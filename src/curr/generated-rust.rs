// Module  is generated from:

//  xdr/curr/Stellar-SCP.x

//  xdr/curr/Stellar-contract-config-setting.x

//  xdr/curr/Stellar-contract-env-meta.x

//  xdr/curr/Stellar-contract-meta.x

//  xdr/curr/Stellar-contract-spec.x

//  xdr/curr/Stellar-contract.x

//  xdr/curr/Stellar-exporter.x

//  xdr/curr/Stellar-internal.x

//  xdr/curr/Stellar-ledger-entries.x

//  xdr/curr/Stellar-ledger.x

//  xdr/curr/Stellar-overlay.x

//  xdr/curr/Stellar-transaction.x

//  xdr/curr/Stellar-types.x

#![allow(clippy::missing_errors_doc, clippy::unreadable_literal)]

/// `XDR_FILES_SHA256` is a list of pairs of source files and their SHA256 hashes.
pub const XDR_FILES_SHA256: [(&str, &str); 13] = [
    (
        "xdr/curr/Stellar-SCP.x",
        "6aed428fb6c2d000f5bc1eef0ba685d6108f3faa96208ffa588c0e2990813939",
    ),
    (
        "xdr/curr/Stellar-contract-config-setting.x",
        "26c2c761d5e175c8b2f373611c942ef4484a6cd33f142f69638b2df82be85313",
    ),
    (
        "xdr/curr/Stellar-contract-env-meta.x",
        "75a271414d852096fea3283c63b7f2a702f2905f78fc28eb60ec7d7bd366a780",
    ),
    (
        "xdr/curr/Stellar-contract-meta.x",
        "f01532c11ca044e19d9f9f16fe373e9af64835da473be556b9a807ee3319ae0d",
    ),
    (
        "xdr/curr/Stellar-contract-spec.x",
        "7d99679155f6ce029f4f2bd8e1bf09524ef2f3e4ca8973265085cfcfdbdae987",
    ),
    (
        "xdr/curr/Stellar-contract.x",
        "dce61df115c93fef5bb352beac1b504a518cb11dcb8ee029b1bb1b5f8fe52982",
    ),
    (
        "xdr/curr/Stellar-exporter.x",
        "a00c83d02e8c8382e06f79a191f1fb5abd097a4bbcab8481c67467e3270e0529",
    ),
    (
        "xdr/curr/Stellar-internal.x",
        "227835866c1b2122d1eaf28839ba85ea7289d1cb681dda4ca619c2da3d71fe00",
    ),
    (
        "xdr/curr/Stellar-ledger-entries.x",
        "5157cad76b008b3606fe5bc2cfe87596827d8e02d16cbec3cedc297bb571aa54",
    ),
    (
        "xdr/curr/Stellar-ledger.x",
        "cf936606885dd265082e553aa433c2cf47b720b6d58839b154cf71096b885d1e",
    ),
    (
        "xdr/curr/Stellar-overlay.x",
        "8c9b9c13c86fa4672f03d741705b41e7221be0fc48e1ea6eeb1ba07d31ec0723",
    ),
    (
        "xdr/curr/Stellar-transaction.x",
        "7c4c951f233ad7cdabedd740abd9697626ec5bc03ce97bf60cbaeee1481a48d1",
    ),
    (
        "xdr/curr/Stellar-types.x",
        "4d7a1d1f1fa0034ddbff27d8a533e59b6154bef295306c6256066def77a5a999",
    ),
];

use core::{array::TryFromSliceError, fmt, fmt::Debug, marker::Sized, ops::Deref, slice};

#[cfg(feature = "std")]
use core::marker::PhantomData;

// When feature alloc is turned off use static lifetime Box and Vec types.
#[cfg(not(feature = "alloc"))]
mod noalloc {
    pub mod boxed {
        pub type Box<T> = &'static T;
    }
    pub mod vec {
        pub type Vec<T> = &'static [T];
    }
}
#[cfg(not(feature = "alloc"))]
use noalloc::{boxed::Box, vec::Vec};

// When feature std is turned off, but feature alloc is turned on import the
// alloc crate and use its Box and Vec types.
#[cfg(all(not(feature = "std"), feature = "alloc"))]
extern crate alloc;
#[cfg(all(not(feature = "std"), feature = "alloc"))]
use alloc::{
    borrow::ToOwned,
    boxed::Box,
    string::{FromUtf8Error, String},
    vec::Vec,
};
#[cfg(feature = "std")]
use std::string::FromUtf8Error;

#[cfg(feature = "arbitrary")]
use arbitrary::Arbitrary;

#[cfg(all(feature = "schemars", feature = "alloc", not(feature = "std")))]
use alloc::borrow::Cow;
#[cfg(all(feature = "schemars", feature = "alloc", feature = "std"))]
use std::borrow::Cow;

// TODO: Add support for read/write xdr fns when std not available.

#[cfg(feature = "std")]
use std::{
    error, io,
    io::{BufRead, BufReader, Cursor, Read, Write},
};

/// Error contains all errors returned by functions in this crate. It can be
/// compared via `PartialEq`, however any contained IO errors will only be
/// compared on their `ErrorKind`.
#[derive(Debug)]
pub enum Error {
    Invalid,
    Unsupported,
    LengthExceedsMax,
    LengthMismatch,
    NonZeroPadding,
    Utf8Error(core::str::Utf8Error),
    #[cfg(feature = "alloc")]
    InvalidHex,
    #[cfg(feature = "std")]
    Io(io::Error),
    DepthLimitExceeded,
    #[cfg(feature = "serde_json")]
    Json(serde_json::Error),
    LengthLimitExceeded,
    #[cfg(feature = "arbitrary")]
    Arbitrary(arbitrary::Error),
}

impl PartialEq for Error {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::Invalid, Self::Invalid)
            | (Self::Unsupported, Self::Unsupported)
            | (Self::LengthExceedsMax, Self::LengthExceedsMax)
            | (Self::LengthMismatch, Self::LengthMismatch)
            | (Self::NonZeroPadding, Self::NonZeroPadding) => true,

            (Self::Utf8Error(l), Self::Utf8Error(r)) => l == r,

            #[cfg(feature = "alloc")]
            (Self::InvalidHex, Self::InvalidHex) => true,

            // IO errors cannot be compared, but in the absence of any more
            // meaningful way to compare the errors we compare the kind of error
            // and ignore the embedded source error or OS error. The main use
            // case for comparing errors outputted by the XDR library is for
            // error case testing, and a lack of the ability to compare has a
            // detrimental affect on failure testing, so this is a tradeoff.
            #[cfg(feature = "std")]
            (Self::Io(l), Self::Io(r)) => l.kind() == r.kind(),

            (Self::DepthLimitExceeded, Self::DepthLimitExceeded) => true,

            #[cfg(feature = "serde_json")]
            (Self::Json(l), Self::Json(r)) => l.classify() == r.classify(),

            (Self::LengthLimitExceeded, Self::LengthLimitExceeded) => true,

            #[cfg(feature = "arbitrary")]
            (Self::Arbitrary(l), Self::Arbitrary(r)) => l == r,

            _ => false,
        }
    }
}

#[cfg(feature = "std")]
impl error::Error for Error {
    #[must_use]
    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
        match self {
            Error::Invalid
            | Error::Unsupported
            | Error::LengthExceedsMax
            | Error::LengthMismatch
            | Error::NonZeroPadding => None,

            Error::Utf8Error(e) => Some(e),

            Self::InvalidHex => None,

            Self::Io(e) => Some(e),

            Self::DepthLimitExceeded => None,

            #[cfg(feature = "serde_json")]
            Self::Json(e) => Some(e),

            Self::LengthLimitExceeded => None,

            #[cfg(feature = "arbitrary")]
            Self::Arbitrary(e) => Some(e),
        }
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Error::Invalid => write!(f, "xdr value invalid"),
            Error::Unsupported => write!(f, "xdr value unsupported"),
            Error::LengthExceedsMax => write!(f, "xdr value max length exceeded"),
            Error::LengthMismatch => write!(f, "xdr value length does not match"),
            Error::NonZeroPadding => write!(f, "xdr padding contains non-zero bytes"),
            Error::Utf8Error(e) => write!(f, "{e}"),

            #[cfg(feature = "alloc")]
            Error::InvalidHex => write!(f, "hex invalid"),

            #[cfg(feature = "std")]
            Error::Io(e) => write!(f, "{e}"),

            Error::DepthLimitExceeded => write!(f, "depth limit exceeded"),

            #[cfg(feature = "serde_json")]
            Error::Json(e) => write!(f, "{e}"),

            Error::LengthLimitExceeded => write!(f, "length limit exceeded"),

            #[cfg(feature = "arbitrary")]
            Error::Arbitrary(e) => write!(f, "{e}"),
        }
    }
}

impl From<TryFromSliceError> for Error {
    fn from(_: TryFromSliceError) -> Error {
        Error::LengthMismatch
    }
}

impl From<core::str::Utf8Error> for Error {
    #[must_use]
    fn from(e: core::str::Utf8Error) -> Self {
        Error::Utf8Error(e)
    }
}

#[cfg(feature = "alloc")]
impl From<FromUtf8Error> for Error {
    #[must_use]
    fn from(e: FromUtf8Error) -> Self {
        Error::Utf8Error(e.utf8_error())
    }
}

#[cfg(feature = "std")]
impl From<io::Error> for Error {
    #[must_use]
    fn from(e: io::Error) -> Self {
        Error::Io(e)
    }
}

#[cfg(feature = "serde_json")]
impl From<serde_json::Error> for Error {
    #[must_use]
    fn from(e: serde_json::Error) -> Self {
        Error::Json(e)
    }
}

#[cfg(feature = "arbitrary")]
impl From<arbitrary::Error> for Error {
    #[must_use]
    fn from(e: arbitrary::Error) -> Self {
        Error::Arbitrary(e)
    }
}

impl From<Error> for () {
    fn from(_: Error) {}
}

/// Name defines types that assign a static name to their value, such as the
/// name given to an identifier in an XDR enum, or the name given to the case in
/// a union.
pub trait Name {
    fn name(&self) -> &'static str;
}

/// Discriminant defines types that may contain a one-of value determined
/// according to the discriminant, and exposes the value of the discriminant for
/// that type, such as in an XDR union.
pub trait Discriminant<D> {
    fn discriminant(&self) -> D;
}

/// Iter defines types that have variants that can be iterated.
pub trait Variants<V> {
    fn variants() -> slice::Iter<'static, V>
    where
        V: Sized;
}

// Enum defines a type that is represented as an XDR enumeration when encoded.
pub trait Enum: Name + Variants<Self> + Sized {}

// Union defines a type that is represented as an XDR union when encoded.
pub trait Union<D>: Name + Discriminant<D> + Variants<D>
where
    D: Sized,
{
}

/// `Limits` contains the limits that a limited reader or writer will be
/// constrained to.
#[cfg(feature = "std")]
#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub struct Limits {
    /// Defines the maximum depth for recursive calls in `Read/WriteXdr` to
    /// prevent stack overflow.
    ///
    /// The depth limit is akin to limiting stack depth. Its purpose is to
    /// prevent the program from hitting the maximum stack size allowed by Rust,
    /// which would result in an unrecoverable `SIGABRT`.  For more information
    /// about Rust's stack size limit, refer to the [Rust
    /// documentation](https://doc.rust-lang.org/std/thread/#stack-size).
    pub depth: u32,

    /// Defines the maximum number of bytes that will be read or written.
    pub len: usize,
}

#[cfg(feature = "std")]
impl Limits {
    #[must_use]
    pub fn none() -> Self {
        Self {
            depth: u32::MAX,
            len: usize::MAX,
        }
    }

    #[must_use]
    pub fn depth(depth: u32) -> Self {
        Limits {
            depth,
            ..Limits::none()
        }
    }

    #[must_use]
    pub fn len(len: usize) -> Self {
        Limits {
            len,
            ..Limits::none()
        }
    }
}

/// `Limited` wraps an object and provides functions for enforcing limits.
///
/// Intended for use with readers and writers and limiting their reads and
/// writes.
#[cfg(feature = "std")]
pub struct Limited<L> {
    pub inner: L,
    pub(crate) limits: Limits,
}

#[cfg(feature = "std")]
impl<L> Limited<L> {
    /// Constructs a new `Limited`.
    ///
    /// - `inner`: The value being limited.
    /// - `limits`: The limits to enforce.
    pub fn new(inner: L, limits: Limits) -> Self {
        Limited { inner, limits }
    }

    /// Consume the given length from the internal remaining length limit.
    ///
    /// ### Errors
    ///
    /// If the length would consume more length than the remaining length limit
    /// allows.
    pub(crate) fn consume_len(&mut self, len: usize) -> Result<(), Error> {
        if let Some(len) = self.limits.len.checked_sub(len) {
            self.limits.len = len;
            Ok(())
        } else {
            Err(Error::LengthLimitExceeded)
        }
    }

    /// Consumes a single depth for the duration of the given function.
    ///
    /// ### Errors
    ///
    /// If the depth limit is already exhausted.
    pub(crate) fn with_limited_depth<T, F>(&mut self, f: F) -> Result<T, Error>
    where
        F: FnOnce(&mut Self) -> Result<T, Error>,
    {
        if let Some(depth) = self.limits.depth.checked_sub(1) {
            self.limits.depth = depth;
            let res = f(self);
            self.limits.depth = self.limits.depth.saturating_add(1);
            res
        } else {
            Err(Error::DepthLimitExceeded)
        }
    }
}

#[cfg(feature = "std")]
impl<R: Read> Read for Limited<R> {
    /// Forwards the read operation to the wrapped object.
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        self.inner.read(buf)
    }
}

#[cfg(feature = "std")]
impl<R: BufRead> BufRead for Limited<R> {
    /// Forwards the read operation to the wrapped object.
    fn fill_buf(&mut self) -> std::io::Result<&[u8]> {
        self.inner.fill_buf()
    }

    /// Forwards the read operation to the wrapped object.
    fn consume(&mut self, amt: usize) {
        self.inner.consume(amt);
    }
}

#[cfg(feature = "std")]
impl<W: Write> Write for Limited<W> {
    /// Forwards the write operation to the wrapped object.
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        self.inner.write(buf)
    }

    /// Forwards the flush operation to the wrapped object.
    fn flush(&mut self) -> std::io::Result<()> {
        self.inner.flush()
    }
}

#[cfg(feature = "std")]
pub struct ReadXdrIter<R: Read, S: ReadXdr> {
    reader: Limited<BufReader<R>>,
    _s: PhantomData<S>,
}

#[cfg(feature = "std")]
impl<R: Read, S: ReadXdr> ReadXdrIter<R, S> {
    fn new(r: R, limits: Limits) -> Self {
        Self {
            reader: Limited {
                inner: BufReader::new(r),
                limits,
            },
            _s: PhantomData,
        }
    }
}

#[cfg(feature = "std")]
impl<R: Read, S: ReadXdr> Iterator for ReadXdrIter<R, S> {
    type Item = Result<S, Error>;

    // Next reads the internal reader and XDR decodes it into the Self type. If
    // the EOF is reached without reading any new bytes `None` is returned. If
    // EOF is reached after reading some bytes a truncated entry is assumed an
    // an `Error::Io` containing an `UnexpectedEof`. If any other IO error
    // occurs it is returned. Iteration of this iterator stops naturally when
    // `None` is returned, but not when a `Some(Err(...))` is returned. The
    // caller is responsible for checking each Result.
    fn next(&mut self) -> Option<Self::Item> {
        // Try to fill the buffer to see if the EOF has been reached or not.
        // This happens to effectively peek to see if the stream has finished
        // and there are no more items.  It is necessary to do this because the
        // xdr types in this crate heavily use the `std::io::Read::read_exact`
        // method that doesn't distinguish between an EOF at the beginning of a
        // read and an EOF after a partial fill of a read_exact.
        match self.reader.fill_buf() {
            // If the reader has no more data and is unable to fill any new data
            // into its internal buf, then the EOF has been reached.
            Ok([]) => return None,
            // If an error occurs filling the buffer, treat that as an error and stop.
            Err(e) => return Some(Err(Error::Io(e))),
            // If there is data in the buf available for reading, continue.
            Ok([..]) => (),
        };
        // Read the buf into the type.
        let r = self.reader.with_limited_depth(|dlr| S::read_xdr(dlr));
        match r {
            Ok(s) => Some(Ok(s)),
            Err(e) => Some(Err(e)),
        }
    }
}

pub trait ReadXdr
where
    Self: Sized,
{
    /// Read the XDR and construct the type.
    ///
    /// Read bytes from the given read implementation, decoding the bytes as
    /// XDR, and construct the type implementing this interface from those
    /// bytes.
    ///
    /// Just enough bytes are read from the read implementation to construct the
    /// type. Any residual bytes remain in the read implementation.
    ///
    /// All implementations should continue if the read implementation returns
    /// [`ErrorKind::Interrupted`](std::io::ErrorKind::Interrupted).
    ///
    /// Use [`ReadXdR: Read_xdr_to_end`] when the intent is for all bytes in the
    /// read implementation to be consumed by the read.
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error>;

    /// Construct the type from the XDR bytes base64 encoded.
    ///
    /// An error is returned if the bytes are not completely consumed by the
    /// deserialization.
    #[cfg(feature = "base64")]
    fn read_xdr_base64<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(
                SkipWhitespace::new(&mut r.inner),
                &base64::engine::general_purpose::STANDARD,
            ),
            r.limits.clone(),
        );
        let t = Self::read_xdr(&mut dec)?;
        Ok(t)
    }

    /// Read the XDR and construct the type, and consider it an error if the
    /// read does not completely consume the read implementation.
    ///
    /// Read bytes from the given read implementation, decoding the bytes as
    /// XDR, and construct the type implementing this interface from those
    /// bytes.
    ///
    /// Just enough bytes are read from the read implementation to construct the
    /// type, and then confirm that no further bytes remain. To confirm no
    /// further bytes remain additional bytes are attempted to be read from the
    /// read implementation. If it is possible to read any residual bytes from
    /// the read implementation an error is returned. The read implementation
    /// may not be exhaustively read if there are residual bytes, and it is
    /// considered undefined how many residual bytes or how much of the residual
    /// buffer are consumed in this case.
    ///
    /// All implementations should continue if the read implementation returns
    /// [`ErrorKind::Interrupted`](std::io::ErrorKind::Interrupted).
    #[cfg(feature = "std")]
    fn read_xdr_to_end<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        let s = Self::read_xdr(r)?;
        // Check that any further reads, such as this read of one byte, read no
        // data, indicating EOF. If a byte is read the data is invalid.
        if r.read(&mut [0u8; 1])? == 0 {
            Ok(s)
        } else {
            Err(Error::Invalid)
        }
    }

    /// Construct the type from the XDR bytes base64 encoded.
    ///
    /// An error is returned if the bytes are not completely consumed by the
    /// deserialization.
    #[cfg(feature = "base64")]
    fn read_xdr_base64_to_end<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(
                SkipWhitespace::new(&mut r.inner),
                &base64::engine::general_purpose::STANDARD,
            ),
            r.limits.clone(),
        );
        let t = Self::read_xdr_to_end(&mut dec)?;
        Ok(t)
    }

    /// Read the XDR and construct the type.
    ///
    /// Read bytes from the given read implementation, decoding the bytes as
    /// XDR, and construct the type implementing this interface from those
    /// bytes.
    ///
    /// Just enough bytes are read from the read implementation to construct the
    /// type. Any residual bytes remain in the read implementation.
    ///
    /// All implementations should continue if the read implementation returns
    /// [`ErrorKind::Interrupted`](std::io::ErrorKind::Interrupted).
    ///
    /// Use [`ReadXdR: Read_xdr_into_to_end`] when the intent is for all bytes
    /// in the read implementation to be consumed by the read.
    #[cfg(feature = "std")]
    fn read_xdr_into<R: Read>(&mut self, r: &mut Limited<R>) -> Result<(), Error> {
        *self = Self::read_xdr(r)?;
        Ok(())
    }

    /// Read the XDR into the existing value, and consider it an error if the
    /// read does not completely consume the read implementation.
    ///
    /// Read bytes from the given read implementation, decoding the bytes as
    /// XDR, and construct the type implementing this interface from those
    /// bytes.
    ///
    /// Just enough bytes are read from the read implementation to construct the
    /// type, and then confirm that no further bytes remain. To confirm no
    /// further bytes remain additional bytes are attempted to be read from the
    /// read implementation. If it is possible to read any residual bytes from
    /// the read implementation an error is returned. The read implementation
    /// may not be exhaustively read if there are residual bytes, and it is
    /// considered undefined how many residual bytes or how much of the residual
    /// buffer are consumed in this case.
    ///
    /// All implementations should continue if the read implementation returns
    /// [`ErrorKind::Interrupted`](std::io::ErrorKind::Interrupted).
    #[cfg(feature = "std")]
    fn read_xdr_into_to_end<R: Read>(&mut self, r: &mut Limited<R>) -> Result<(), Error> {
        Self::read_xdr_into(self, r)?;
        // Check that any further reads, such as this read of one byte, read no
        // data, indicating EOF. If a byte is read the data is invalid.
        if r.read(&mut [0u8; 1])? == 0 {
            Ok(())
        } else {
            Err(Error::Invalid)
        }
    }

    /// Create an iterator that reads the read implementation as a stream of
    /// values that are read into the implementing type.
    ///
    /// Read bytes from the given read implementation, decoding the bytes as
    /// XDR, and construct the type implementing this interface from those
    /// bytes.
    ///
    /// Just enough bytes are read from the read implementation to construct the
    /// type, and then confirm that no further bytes remain. To confirm no
    /// further bytes remain additional bytes are attempted to be read from the
    /// read implementation. If it is possible to read any residual bytes from
    /// the read implementation an error is returned. The read implementation
    /// may not be exhaustively read if there are residual bytes, and it is
    /// considered undefined how many residual bytes or how much of the residual
    /// buffer are consumed in this case.
    ///
    /// All implementations should continue if the read implementation returns
    /// [`ErrorKind::Interrupted`](std::io::ErrorKind::Interrupted).
    #[cfg(feature = "std")]
    fn read_xdr_iter<R: Read>(r: &mut Limited<R>) -> ReadXdrIter<&mut R, Self> {
        ReadXdrIter::new(&mut r.inner, r.limits.clone())
    }

    /// Create an iterator that reads the read implementation as a stream of
    /// values that are read into the implementing type.
    #[cfg(feature = "base64")]
    fn read_xdr_base64_iter<R: Read>(
        r: &mut Limited<R>,
    ) -> ReadXdrIter<
        base64::read::DecoderReader<
            '_,
            base64::engine::general_purpose::GeneralPurpose,
            SkipWhitespace<&mut R>,
        >,
        Self,
    > {
        let dec = base64::read::DecoderReader::new(
            SkipWhitespace::new(&mut r.inner),
            &base64::engine::general_purpose::STANDARD,
        );
        ReadXdrIter::new(dec, r.limits.clone())
    }

    /// Construct the type from the XDR bytes.
    ///
    /// An error is returned if the bytes are not completely consumed by the
    /// deserialization.
    #[cfg(feature = "std")]
    fn from_xdr(bytes: impl AsRef<[u8]>, limits: Limits) -> Result<Self, Error> {
        let mut cursor = Limited::new(Cursor::new(bytes.as_ref()), limits);
        let t = Self::read_xdr_to_end(&mut cursor)?;
        Ok(t)
    }

    /// Construct the type from the XDR bytes base64 encoded.
    ///
    /// An error is returned if the bytes are not completely consumed by the
    /// deserialization.
    #[cfg(feature = "base64")]
    fn from_xdr_base64(b64: impl AsRef<[u8]>, limits: Limits) -> Result<Self, Error> {
        let b64_reader = Cursor::new(b64);
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(
                SkipWhitespace::new(b64_reader),
                &base64::engine::general_purpose::STANDARD,
            ),
            limits,
        );
        let t = Self::read_xdr_to_end(&mut dec)?;
        Ok(t)
    }
}

pub trait WriteXdr {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error>;

    #[cfg(feature = "std")]
    fn to_xdr(&self, limits: Limits) -> Result<Vec<u8>, Error> {
        let mut cursor = Limited::new(Cursor::new(vec![]), limits);
        self.write_xdr(&mut cursor)?;
        let bytes = cursor.inner.into_inner();
        Ok(bytes)
    }

    #[cfg(feature = "base64")]
    fn to_xdr_base64(&self, limits: Limits) -> Result<String, Error> {
        let mut enc = Limited::new(
            base64::write::EncoderStringWriter::new(&base64::engine::general_purpose::STANDARD),
            limits,
        );
        self.write_xdr(&mut enc)?;
        let b64 = enc.inner.into_inner();
        Ok(b64)
    }
}

/// `Pad_len` returns the number of bytes to pad an XDR value of the given
/// length to make the final serialized size a multiple of 4.
#[cfg(feature = "std")]
fn pad_len(len: usize) -> usize {
    (4 - (len % 4)) % 4
}

impl ReadXdr for i32 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        let mut b = [0u8; 4];
        r.with_limited_depth(|r| {
            r.consume_len(b.len())?;
            r.read_exact(&mut b)?;
            Ok(i32::from_be_bytes(b))
        })
    }
}

impl WriteXdr for i32 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        let b: [u8; 4] = self.to_be_bytes();
        w.with_limited_depth(|w| {
            w.consume_len(b.len())?;
            Ok(w.write_all(&b)?)
        })
    }
}

impl ReadXdr for u32 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        let mut b = [0u8; 4];
        r.with_limited_depth(|r| {
            r.consume_len(b.len())?;
            r.read_exact(&mut b)?;
            Ok(u32::from_be_bytes(b))
        })
    }
}

impl WriteXdr for u32 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        let b: [u8; 4] = self.to_be_bytes();
        w.with_limited_depth(|w| {
            w.consume_len(b.len())?;
            Ok(w.write_all(&b)?)
        })
    }
}

impl ReadXdr for i64 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        let mut b = [0u8; 8];
        r.with_limited_depth(|r| {
            r.consume_len(b.len())?;
            r.read_exact(&mut b)?;
            Ok(i64::from_be_bytes(b))
        })
    }
}

impl WriteXdr for i64 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        let b: [u8; 8] = self.to_be_bytes();
        w.with_limited_depth(|w| {
            w.consume_len(b.len())?;
            Ok(w.write_all(&b)?)
        })
    }
}

impl ReadXdr for u64 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        let mut b = [0u8; 8];
        r.with_limited_depth(|r| {
            r.consume_len(b.len())?;
            r.read_exact(&mut b)?;
            Ok(u64::from_be_bytes(b))
        })
    }
}

impl WriteXdr for u64 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        let b: [u8; 8] = self.to_be_bytes();
        w.with_limited_depth(|w| {
            w.consume_len(b.len())?;
            Ok(w.write_all(&b)?)
        })
    }
}

impl ReadXdr for f32 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(_r: &mut Limited<R>) -> Result<Self, Error> {
        todo!()
    }
}

impl WriteXdr for f32 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, _w: &mut Limited<W>) -> Result<(), Error> {
        todo!()
    }
}

impl ReadXdr for f64 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(_r: &mut Limited<R>) -> Result<Self, Error> {
        todo!()
    }
}

impl WriteXdr for f64 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, _w: &mut Limited<W>) -> Result<(), Error> {
        todo!()
    }
}

impl ReadXdr for bool {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = u32::read_xdr(r)?;
            let b = i == 1;
            Ok(b)
        })
    }
}

impl WriteXdr for bool {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i = u32::from(*self); // true = 1, false = 0
            i.write_xdr(w)
        })
    }
}

impl<T: ReadXdr> ReadXdr for Option<T> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = u32::read_xdr(r)?;
            match i {
                0 => Ok(None),
                1 => {
                    let t = T::read_xdr(r)?;
                    Ok(Some(t))
                }
                _ => Err(Error::Invalid),
            }
        })
    }
}

impl<T: WriteXdr> WriteXdr for Option<T> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            if let Some(t) = self {
                1u32.write_xdr(w)?;
                t.write_xdr(w)?;
            } else {
                0u32.write_xdr(w)?;
            }
            Ok(())
        })
    }
}

impl<T: ReadXdr> ReadXdr for Box<T> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| Ok(Box::new(T::read_xdr(r)?)))
    }
}

impl<T: WriteXdr> WriteXdr for Box<T> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| T::write_xdr(self, w))
    }
}

impl ReadXdr for () {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(_r: &mut Limited<R>) -> Result<Self, Error> {
        Ok(())
    }
}

impl WriteXdr for () {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, _w: &mut Limited<W>) -> Result<(), Error> {
        Ok(())
    }
}

impl<const N: usize> ReadXdr for [u8; N] {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            r.consume_len(N)?;
            let padding = pad_len(N);
            r.consume_len(padding)?;
            let mut arr = [0u8; N];
            r.read_exact(&mut arr)?;
            let pad = &mut [0u8; 3][..padding];
            r.read_exact(pad)?;
            if pad.iter().any(|b| *b != 0) {
                return Err(Error::NonZeroPadding);
            }
            Ok(arr)
        })
    }
}

impl<const N: usize> WriteXdr for [u8; N] {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            w.consume_len(N)?;
            let padding = pad_len(N);
            w.consume_len(padding)?;
            w.write_all(self)?;
            w.write_all(&[0u8; 3][..padding])?;
            Ok(())
        })
    }
}

impl<T: ReadXdr, const N: usize> ReadXdr for [T; N] {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let mut vec = Vec::with_capacity(N);
            for _ in 0..N {
                let t = T::read_xdr(r)?;
                vec.push(t);
            }
            let arr: [T; N] = vec.try_into().unwrap_or_else(|_: Vec<T>| unreachable!());
            Ok(arr)
        })
    }
}

impl<T: WriteXdr, const N: usize> WriteXdr for [T; N] {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            for t in self {
                t.write_xdr(w)?;
            }
            Ok(())
        })
    }
}

// VecM ------------------------------------------------------------------------

#[cfg(feature = "alloc")]
#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    feature = "serde",
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize)
)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct VecM<T, const MAX: u32 = { u32::MAX }>(Vec<T>);

#[cfg(not(feature = "alloc"))]
#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct VecM<T, const MAX: u32 = { u32::MAX }>(Vec<T>)
where
    T: 'static;

impl<T, const MAX: u32> Deref for VecM<T, MAX> {
    type Target = Vec<T>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<T, const MAX: u32> Default for VecM<T, MAX> {
    fn default() -> Self {
        Self(Vec::default())
    }
}

#[cfg(feature = "schemars")]
impl<T: schemars::JsonSchema, const MAX: u32> schemars::JsonSchema for VecM<T, MAX> {
    fn schema_name() -> String {
        format!("VecM<{}, {}>", T::schema_name(), MAX)
    }

    fn is_referenceable() -> bool {
        false
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        let schema = Vec::<T>::json_schema(gen);
        if let schemars::schema::Schema::Object(mut schema) = schema {
            if let Some(array) = schema.array.clone() {
                schema.array = Some(Box::new(schemars::schema::ArrayValidation {
                    max_items: Some(MAX),
                    ..*array
                }));
            }
            schema.into()
        } else {
            schema
        }
    }
}

#[cfg(feature = "schemars")]
impl<T, TA, const MAX: u32> serde_with::schemars_0_8::JsonSchemaAs<VecM<T, MAX>> for VecM<TA, MAX>
where
    TA: serde_with::schemars_0_8::JsonSchemaAs<T>,
{
    fn schema_name() -> String {
        <VecM<serde_with::Schema<T, TA>, MAX> as schemars::JsonSchema>::schema_name()
    }

    fn schema_id() -> Cow<'static, str> {
        <VecM<serde_with::Schema<T, TA>, MAX> as schemars::JsonSchema>::schema_id()
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        <VecM<serde_with::Schema<T, TA>, MAX> as schemars::JsonSchema>::json_schema(gen)
    }

    fn is_referenceable() -> bool {
        <VecM<serde_with::Schema<T, TA>, MAX> as schemars::JsonSchema>::is_referenceable()
    }
}

#[cfg(feature = "serde")]
impl<T, U, const MAX: u32> serde_with::SerializeAs<VecM<T, MAX>> for VecM<U, MAX>
where
    U: serde_with::SerializeAs<T>,
{
    fn serialize_as<S>(source: &VecM<T, MAX>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.collect_seq(
            source
                .iter()
                .map(|item| serde_with::ser::SerializeAsWrap::<T, U>::new(item)),
        )
    }
}

#[cfg(feature = "serde")]
impl<'de, T, U, const MAX: u32> serde_with::DeserializeAs<'de, VecM<T, MAX>> for VecM<U, MAX>
where
    U: serde_with::DeserializeAs<'de, T>,
{
    fn deserialize_as<D>(deserializer: D) -> Result<VecM<T, MAX>, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let vec = <Vec<U> as serde_with::DeserializeAs<Vec<T>>>::deserialize_as(deserializer)?;
        vec.try_into().map_err(serde::de::Error::custom)
    }
}

impl<T, const MAX: u32> VecM<T, MAX> {
    pub const MAX_LEN: usize = { MAX as usize };

    #[must_use]
    #[allow(clippy::unused_self)]
    pub fn max_len(&self) -> usize {
        Self::MAX_LEN
    }

    #[must_use]
    pub fn as_vec(&self) -> &Vec<T> {
        self.as_ref()
    }
}

#[cfg(feature = "alloc")]
impl<T, const MAX: u32> VecM<T, MAX> {
    pub fn iter_mut(&mut self) -> core::slice::IterMut<'_, T> {
        self.0.iter_mut()
    }
}

#[cfg(feature = "alloc")]
impl<'a, T, const MAX: u32> core::iter::IntoIterator for &'a mut VecM<T, MAX> {
    type Item = &'a mut T;
    type IntoIter = core::slice::IterMut<'a, T>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

impl<T: Clone, const MAX: u32> VecM<T, MAX> {
    #[must_use]
    #[cfg(feature = "alloc")]
    pub fn to_vec(&self) -> Vec<T> {
        self.into()
    }

    #[must_use]
    pub fn into_vec(self) -> Vec<T> {
        self.into()
    }
}

impl<const MAX: u32> VecM<u8, MAX> {
    #[cfg(feature = "alloc")]
    pub fn to_string(&self) -> Result<String, Error> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    pub fn into_string(self) -> Result<String, Error> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn to_string_lossy(&self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn into_string_lossy(self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }
}

impl<T: Clone> VecM<T, 1> {
    #[must_use]
    pub fn to_option(&self) -> Option<T> {
        if self.len() > 0 {
            Some(self.0[0].clone())
        } else {
            None
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<T: Clone> From<VecM<T, 1>> for Option<T> {
    #[must_use]
    fn from(v: VecM<T, 1>) -> Self {
        v.to_option()
    }
}

#[cfg(feature = "alloc")]
impl<T> VecM<T, 1> {
    #[must_use]
    pub fn into_option(mut self) -> Option<T> {
        self.0.drain(..).next()
    }
}

#[cfg(feature = "alloc")]
impl<T> From<VecM<T, 1>> for Option<T> {
    #[must_use]
    fn from(v: VecM<T, 1>) -> Self {
        v.into_option()
    }
}

impl<T, const MAX: u32> TryFrom<Vec<T>> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: Vec<T>) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<T, const MAX: u32> From<VecM<T, MAX>> for Vec<T> {
    #[must_use]
    fn from(v: VecM<T, MAX>) -> Self {
        v.0
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const MAX: u32> From<&VecM<T, MAX>> for Vec<T> {
    #[must_use]
    fn from(v: &VecM<T, MAX>) -> Self {
        v.0.clone()
    }
}

impl<T, const MAX: u32> AsRef<Vec<T>> for VecM<T, MAX> {
    #[must_use]
    fn as_ref(&self) -> &Vec<T> {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const MAX: u32> TryFrom<&Vec<T>> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: &Vec<T>) -> Result<Self, Error> {
        v.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const MAX: u32> TryFrom<&[T]> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: &[T]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<T, const MAX: u32> AsRef<[T]> for VecM<T, MAX> {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[T] {
        self.0.as_ref()
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[T] {
        self.0
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const N: usize, const MAX: u32> TryFrom<[T; N]> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: [T; N]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const N: usize, const MAX: u32> TryFrom<VecM<T, MAX>> for [T; N] {
    type Error = VecM<T, MAX>;

    fn try_from(v: VecM<T, MAX>) -> core::result::Result<Self, Self::Error> {
        let s: [T; N] = v.0.try_into().map_err(|v: Vec<T>| VecM::<T, MAX>(v))?;
        Ok(s)
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const N: usize, const MAX: u32> TryFrom<&[T; N]> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: &[T; N]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<T: Clone, const N: usize, const MAX: u32> TryFrom<&'static [T; N]> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: &'static [T; N]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&String> for VecM<u8, MAX> {
    type Error = Error;

    fn try_from(v: &String) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.as_bytes().to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<String> for VecM<u8, MAX> {
    type Error = Error;

    fn try_from(v: String) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<VecM<u8, MAX>> for String {
    type Error = Error;

    fn try_from(v: VecM<u8, MAX>) -> Result<Self, Error> {
        Ok(String::from_utf8(v.0)?)
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&VecM<u8, MAX>> for String {
    type Error = Error;

    fn try_from(v: &VecM<u8, MAX>) -> Result<Self, Error> {
        Ok(core::str::from_utf8(v.as_ref())?.to_owned())
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&str> for VecM<u8, MAX> {
    type Error = Error;

    fn try_from(v: &str) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<const MAX: u32> TryFrom<&'static str> for VecM<u8, MAX> {
    type Error = Error;

    fn try_from(v: &'static str) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.as_bytes()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<'a, const MAX: u32> TryFrom<&'a VecM<u8, MAX>> for &'a str {
    type Error = Error;

    fn try_from(v: &'a VecM<u8, MAX>) -> Result<Self, Error> {
        Ok(core::str::from_utf8(v.as_ref())?)
    }
}

impl<const MAX: u32> ReadXdr for VecM<u8, MAX> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let len: u32 = u32::read_xdr(r)?;
            if len > MAX {
                return Err(Error::LengthExceedsMax);
            }

            r.consume_len(len as usize)?;
            let padding = pad_len(len as usize);
            r.consume_len(padding)?;

            let mut vec = vec![0u8; len as usize];
            r.read_exact(&mut vec)?;

            let pad = &mut [0u8; 3][..padding];
            r.read_exact(pad)?;
            if pad.iter().any(|b| *b != 0) {
                return Err(Error::NonZeroPadding);
            }

            Ok(VecM(vec))
        })
    }
}

impl<const MAX: u32> WriteXdr for VecM<u8, MAX> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let len: u32 = self.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
            len.write_xdr(w)?;

            w.consume_len(self.len())?;
            let padding = pad_len(self.len());
            w.consume_len(padding)?;

            w.write_all(&self.0)?;

            w.write_all(&[0u8; 3][..padding])?;

            Ok(())
        })
    }
}

impl<T: ReadXdr, const MAX: u32> ReadXdr for VecM<T, MAX> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let len = u32::read_xdr(r)?;
            if len > MAX {
                return Err(Error::LengthExceedsMax);
            }

            let mut vec = Vec::new();
            for _ in 0..len {
                let t = T::read_xdr(r)?;
                vec.push(t);
            }

            Ok(VecM(vec))
        })
    }
}

impl<T: WriteXdr, const MAX: u32> WriteXdr for VecM<T, MAX> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let len: u32 = self.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
            len.write_xdr(w)?;

            for t in &self.0 {
                t.write_xdr(w)?;
            }

            Ok(())
        })
    }
}

// BytesM ------------------------------------------------------------------------

#[cfg(feature = "alloc")]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    feature = "serde",
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct BytesM<const MAX: u32 = { u32::MAX }>(Vec<u8>);

#[cfg(not(feature = "alloc"))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct BytesM<const MAX: u32 = { u32::MAX }>(Vec<u8>);

impl<const MAX: u32> core::fmt::Display for BytesM<MAX> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        #[cfg(feature = "alloc")]
        let v = &self.0;
        #[cfg(not(feature = "alloc"))]
        let v = self.0;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        Ok(())
    }
}

impl<const MAX: u32> core::fmt::Debug for BytesM<MAX> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        #[cfg(feature = "alloc")]
        let v = &self.0;
        #[cfg(not(feature = "alloc"))]
        let v = self.0;
        write!(f, "BytesM(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> core::str::FromStr for BytesM<MAX> {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        hex::decode(s).map_err(|_| Error::InvalidHex)?.try_into()
    }
}

impl<const MAX: u32> Deref for BytesM<MAX> {
    type Target = Vec<u8>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

#[cfg(feature = "schemars")]
impl<const MAX: u32> schemars::JsonSchema for BytesM<MAX> {
    fn schema_name() -> String {
        format!("BytesM<{MAX}>")
    }

    fn is_referenceable() -> bool {
        false
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        let schema = String::json_schema(gen);
        if let schemars::schema::Schema::Object(mut schema) = schema {
            schema.extensions.insert(
                "contentEncoding".to_owned(),
                serde_json::Value::String("hex".to_string()),
            );
            schema.extensions.insert(
                "contentMediaType".to_owned(),
                serde_json::Value::String("application/binary".to_string()),
            );
            let string = *schema.string.unwrap_or_default().clone();
            schema.string = Some(Box::new(schemars::schema::StringValidation {
                max_length: MAX.checked_mul(2).map(Some).unwrap_or_default(),
                min_length: None,
                ..string
            }));
            schema.into()
        } else {
            schema
        }
    }
}

impl<const MAX: u32> Default for BytesM<MAX> {
    fn default() -> Self {
        Self(Vec::default())
    }
}

impl<const MAX: u32> BytesM<MAX> {
    pub const MAX_LEN: usize = { MAX as usize };

    #[must_use]
    #[allow(clippy::unused_self)]
    pub fn max_len(&self) -> usize {
        Self::MAX_LEN
    }

    #[must_use]
    pub fn as_vec(&self) -> &Vec<u8> {
        self.as_ref()
    }
}

impl<const MAX: u32> BytesM<MAX> {
    #[must_use]
    #[cfg(feature = "alloc")]
    pub fn to_vec(&self) -> Vec<u8> {
        self.into()
    }

    #[must_use]
    pub fn into_vec(self) -> Vec<u8> {
        self.into()
    }
}

impl<const MAX: u32> BytesM<MAX> {
    #[cfg(feature = "alloc")]
    pub fn to_string(&self) -> Result<String, Error> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    pub fn into_string(self) -> Result<String, Error> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn to_string_lossy(&self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn into_string_lossy(self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }
}

impl<const MAX: u32> TryFrom<Vec<u8>> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: Vec<u8>) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<const MAX: u32> From<BytesM<MAX>> for Vec<u8> {
    #[must_use]
    fn from(v: BytesM<MAX>) -> Self {
        v.0
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> From<&BytesM<MAX>> for Vec<u8> {
    #[must_use]
    fn from(v: &BytesM<MAX>) -> Self {
        v.0.clone()
    }
}

impl<const MAX: u32> AsRef<Vec<u8>> for BytesM<MAX> {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&Vec<u8>> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &Vec<u8>) -> Result<Self, Error> {
        v.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&[u8]> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &[u8]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<const MAX: u32> AsRef<[u8]> for BytesM<MAX> {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0.as_ref()
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<[u8; N]> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: [u8; N]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<BytesM<MAX>> for [u8; N] {
    type Error = BytesM<MAX>;

    fn try_from(v: BytesM<MAX>) -> core::result::Result<Self, Self::Error> {
        let s: [u8; N] = v.0.try_into().map_err(BytesM::<MAX>)?;
        Ok(s)
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<&[u8; N]> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &[u8; N]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<const N: usize, const MAX: u32> TryFrom<&'static [u8; N]> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &'static [u8; N]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&String> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &String) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.as_bytes().to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<String> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: String) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<BytesM<MAX>> for String {
    type Error = Error;

    fn try_from(v: BytesM<MAX>) -> Result<Self, Error> {
        Ok(String::from_utf8(v.0)?)
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&BytesM<MAX>> for String {
    type Error = Error;

    fn try_from(v: &BytesM<MAX>) -> Result<Self, Error> {
        Ok(core::str::from_utf8(v.as_ref())?.to_owned())
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&str> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &str) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<const MAX: u32> TryFrom<&'static str> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &'static str) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.as_bytes()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<'a, const MAX: u32> TryFrom<&'a BytesM<MAX>> for &'a str {
    type Error = Error;

    fn try_from(v: &'a BytesM<MAX>) -> Result<Self, Error> {
        Ok(core::str::from_utf8(v.as_ref())?)
    }
}

impl<const MAX: u32> ReadXdr for BytesM<MAX> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let len: u32 = u32::read_xdr(r)?;
            if len > MAX {
                return Err(Error::LengthExceedsMax);
            }

            r.consume_len(len as usize)?;
            let padding = pad_len(len as usize);
            r.consume_len(padding)?;

            let mut vec = vec![0u8; len as usize];
            r.read_exact(&mut vec)?;

            let pad = &mut [0u8; 3][..padding];
            r.read_exact(pad)?;
            if pad.iter().any(|b| *b != 0) {
                return Err(Error::NonZeroPadding);
            }

            Ok(BytesM(vec))
        })
    }
}

impl<const MAX: u32> WriteXdr for BytesM<MAX> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let len: u32 = self.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
            len.write_xdr(w)?;

            w.consume_len(self.len())?;
            let padding = pad_len(self.len());
            w.consume_len(padding)?;

            w.write_all(&self.0)?;

            w.write_all(&[0u8; 3][..pad_len(len as usize)])?;

            Ok(())
        })
    }
}

// StringM ------------------------------------------------------------------------

/// A string type that contains arbitrary bytes.
///
/// Convertible, fallibly, to/from a Rust UTF-8 String using
/// [`TryFrom`]/[`TryInto`]/[`StringM::to_utf8_string`].
///
/// Convertible, lossyly, to a Rust UTF-8 String using
/// [`StringM::to_utf8_string_lossy`].
///
/// Convertible to/from escaped printable-ASCII using
/// [`Display`]/[`ToString`]/[`FromStr`].

#[cfg(feature = "alloc")]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    feature = "serde",
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct StringM<const MAX: u32 = { u32::MAX }>(Vec<u8>);

#[cfg(not(feature = "alloc"))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct StringM<const MAX: u32 = { u32::MAX }>(Vec<u8>);

impl<const MAX: u32> core::fmt::Display for StringM<MAX> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        #[cfg(feature = "alloc")]
        let v = &self.0;
        #[cfg(not(feature = "alloc"))]
        let v = self.0;
        for b in escape_bytes::Escape::new(v) {
            write!(f, "{}", b as char)?;
        }
        Ok(())
    }
}

impl<const MAX: u32> core::fmt::Debug for StringM<MAX> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        #[cfg(feature = "alloc")]
        let v = &self.0;
        #[cfg(not(feature = "alloc"))]
        let v = self.0;
        write!(f, "StringM(")?;
        for b in escape_bytes::Escape::new(v) {
            write!(f, "{}", b as char)?;
        }
        write!(f, ")")?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> core::str::FromStr for StringM<MAX> {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        let b = escape_bytes::unescape(s.as_bytes()).map_err(|_| Error::Invalid)?;
        Ok(Self(b))
    }
}

impl<const MAX: u32> Deref for StringM<MAX> {
    type Target = Vec<u8>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<const MAX: u32> Default for StringM<MAX> {
    fn default() -> Self {
        Self(Vec::default())
    }
}

#[cfg(feature = "schemars")]
impl<const MAX: u32> schemars::JsonSchema for StringM<MAX> {
    fn schema_name() -> String {
        format!("StringM<{MAX}>")
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        let schema = String::json_schema(gen);
        if let schemars::schema::Schema::Object(mut schema) = schema {
            let string = *schema.string.unwrap_or_default().clone();
            schema.string = Some(Box::new(schemars::schema::StringValidation {
                max_length: Some(MAX),
                ..string
            }));
            schema.into()
        } else {
            schema
        }
    }
}

impl<const MAX: u32> StringM<MAX> {
    pub const MAX_LEN: usize = { MAX as usize };

    #[must_use]
    #[allow(clippy::unused_self)]
    pub fn max_len(&self) -> usize {
        Self::MAX_LEN
    }

    #[must_use]
    pub fn as_vec(&self) -> &Vec<u8> {
        self.as_ref()
    }
}

impl<const MAX: u32> StringM<MAX> {
    #[must_use]
    #[cfg(feature = "alloc")]
    pub fn to_vec(&self) -> Vec<u8> {
        self.into()
    }

    #[must_use]
    pub fn into_vec(self) -> Vec<u8> {
        self.into()
    }
}

impl<const MAX: u32> StringM<MAX> {
    #[cfg(feature = "alloc")]
    pub fn to_utf8_string(&self) -> Result<String, Error> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    pub fn into_utf8_string(self) -> Result<String, Error> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn to_utf8_string_lossy(&self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn into_utf8_string_lossy(self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }
}

impl<const MAX: u32> TryFrom<Vec<u8>> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: Vec<u8>) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<const MAX: u32> From<StringM<MAX>> for Vec<u8> {
    #[must_use]
    fn from(v: StringM<MAX>) -> Self {
        v.0
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> From<&StringM<MAX>> for Vec<u8> {
    #[must_use]
    fn from(v: &StringM<MAX>) -> Self {
        v.0.clone()
    }
}

impl<const MAX: u32> AsRef<Vec<u8>> for StringM<MAX> {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&Vec<u8>> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &Vec<u8>) -> Result<Self, Error> {
        v.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&[u8]> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &[u8]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<const MAX: u32> AsRef<[u8]> for StringM<MAX> {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0.as_ref()
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<[u8; N]> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: [u8; N]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<StringM<MAX>> for [u8; N] {
    type Error = StringM<MAX>;

    fn try_from(v: StringM<MAX>) -> core::result::Result<Self, Self::Error> {
        let s: [u8; N] = v.0.try_into().map_err(StringM::<MAX>)?;
        Ok(s)
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<&[u8; N]> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &[u8; N]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<const N: usize, const MAX: u32> TryFrom<&'static [u8; N]> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &'static [u8; N]) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&String> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &String) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.as_bytes().to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<String> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: String) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<StringM<MAX>> for String {
    type Error = Error;

    fn try_from(v: StringM<MAX>) -> Result<Self, Error> {
        Ok(String::from_utf8(v.0)?)
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&StringM<MAX>> for String {
    type Error = Error;

    fn try_from(v: &StringM<MAX>) -> Result<Self, Error> {
        Ok(core::str::from_utf8(v.as_ref())?.to_owned())
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&str> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &str) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<const MAX: u32> TryFrom<&'static str> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &'static str) -> Result<Self, Error> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.as_bytes()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<'a, const MAX: u32> TryFrom<&'a StringM<MAX>> for &'a str {
    type Error = Error;

    fn try_from(v: &'a StringM<MAX>) -> Result<Self, Error> {
        Ok(core::str::from_utf8(v.as_ref())?)
    }
}

impl<const MAX: u32> ReadXdr for StringM<MAX> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let len: u32 = u32::read_xdr(r)?;
            if len > MAX {
                return Err(Error::LengthExceedsMax);
            }

            r.consume_len(len as usize)?;
            let padding = pad_len(len as usize);
            r.consume_len(padding)?;

            let mut vec = vec![0u8; len as usize];
            r.read_exact(&mut vec)?;

            let pad = &mut [0u8; 3][..padding];
            r.read_exact(pad)?;
            if pad.iter().any(|b| *b != 0) {
                return Err(Error::NonZeroPadding);
            }

            Ok(StringM(vec))
        })
    }
}

impl<const MAX: u32> WriteXdr for StringM<MAX> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let len: u32 = self.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
            len.write_xdr(w)?;

            w.consume_len(self.len())?;
            let padding = pad_len(self.len());
            w.consume_len(padding)?;

            w.write_all(&self.0)?;

            w.write_all(&[0u8; 3][..padding])?;

            Ok(())
        })
    }
}

// Frame ------------------------------------------------------------------------

#[derive(Default, Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Frame<T>(pub T)
where
    T: ReadXdr;

#[cfg(feature = "schemars")]
impl<T: schemars::JsonSchema + ReadXdr> schemars::JsonSchema for Frame<T> {
    fn schema_name() -> String {
        format!("Frame<{}>", T::schema_name())
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        T::json_schema(gen)
    }
}

impl<T> ReadXdr for Frame<T>
where
    T: ReadXdr,
{
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        // Read the frame header value that contains 1 flag-bit and a 33-bit length.
        //  - The 1 flag bit is 0 when there are more frames for the same record.
        //  - The 31-bit length is the length of the bytes within the frame that
        //  follow the frame header.
        let header = u32::read_xdr(r)?;
        // TODO: Use the length and cap the length we'll read from `r`.
        let last_record = header >> 31 == 1;
        if last_record {
            // Read the record in the frame.
            Ok(Self(T::read_xdr(r)?))
        } else {
            // TODO: Support reading those additional frames for the same
            // record.
            Err(Error::Unsupported)
        }
    }
}

/// Forwards read operations to the wrapped object, skipping over any
/// whitespace.
#[cfg(feature = "std")]
pub struct SkipWhitespace<R: Read> {
    pub inner: R,
}

#[cfg(feature = "std")]
impl<R: Read> SkipWhitespace<R> {
    pub fn new(inner: R) -> Self {
        SkipWhitespace { inner }
    }
}

#[cfg(feature = "std")]
impl<R: Read> Read for SkipWhitespace<R> {
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        let n = self.inner.read(buf)?;

        let mut written = 0;
        for read in 0..n {
            if !buf[read].is_ascii_whitespace() {
                buf[written] = buf[read];
                written += 1;
            }
        }

        Ok(written)
    }
}

#[cfg(all(test, feature = "std"))]
mod test_skip_whitespace {
    use super::*;

    #[test]
    fn test() {
        struct Test {
            input: &'static [u8],
            output: &'static [u8],
        }
        let tests = [
            Test {
                input: b"",
                output: b"",
            },
            Test {
                input: b" \n\t\r",
                output: b"",
            },
            Test {
                input: b"a c",
                output: b"ac",
            },
            Test {
                input: b"ab cd",
                output: b"abcd",
            },
            Test {
                input: b" ab \n cd ",
                output: b"abcd",
            },
        ];
        for (i, t) in tests.iter().enumerate() {
            let mut skip = SkipWhitespace::new(t.input);
            let mut output = Vec::new();
            skip.read_to_end(&mut output).unwrap();
            assert_eq!(output, t.output, "#{i}");
        }
    }
}

// NumberOrString ---------------------------------------------------------------

/// NumberOrString is a serde_as serializer/deserializer.
///
/// It deserializers any integer that fits into a 64-bit value into an i64 or u64 field from either
/// a JSON Number or JSON String value.
///
/// It serializes always to a string.
///
/// It has a JsonSchema implementation that only advertises that the allowed format is a String.
/// This is because the type is intended to soften the changing of fields from JSON Number to JSON
/// String by permitting deserialization, but discourage new uses of JSON Number.
#[cfg(feature = "serde")]
struct NumberOrString;

#[cfg(feature = "serde")]
impl<'de> serde_with::DeserializeAs<'de, i64> for NumberOrString {
    fn deserialize_as<D>(deserializer: D) -> Result<i64, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum I64OrString<'a> {
            Str(&'a str),
            String(String),
            I64(i64),
        }
        match I64OrString::deserialize(deserializer)? {
            I64OrString::Str(s) => s.parse().map_err(serde::de::Error::custom),
            I64OrString::String(s) => s.parse().map_err(serde::de::Error::custom),
            I64OrString::I64(v) => Ok(v),
        }
    }
}

#[cfg(feature = "serde")]
impl<'de> serde_with::DeserializeAs<'de, u64> for NumberOrString {
    fn deserialize_as<D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum U64OrString<'a> {
            Str(&'a str),
            String(String),
            U64(u64),
        }
        match U64OrString::deserialize(deserializer)? {
            U64OrString::Str(s) => s.parse().map_err(serde::de::Error::custom),
            U64OrString::String(s) => s.parse().map_err(serde::de::Error::custom),
            U64OrString::U64(v) => Ok(v),
        }
    }
}

#[cfg(feature = "serde")]
impl serde_with::SerializeAs<i64> for NumberOrString {
    fn serialize_as<S>(source: &i64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.collect_str(source)
    }
}

#[cfg(feature = "serde")]
impl serde_with::SerializeAs<u64> for NumberOrString {
    fn serialize_as<S>(source: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.collect_str(source)
    }
}

#[cfg(feature = "schemars")]
impl<T> serde_with::schemars_0_8::JsonSchemaAs<T> for NumberOrString {
    fn schema_name() -> String {
        <String as schemars::JsonSchema>::schema_name()
    }

    fn schema_id() -> std::borrow::Cow<'static, str> {
        <String as schemars::JsonSchema>::schema_id()
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        <String as schemars::JsonSchema>::json_schema(gen)
    }

    fn is_referenceable() -> bool {
        <String as schemars::JsonSchema>::is_referenceable()
    }
}

// Tests ------------------------------------------------------------------------

#[cfg(all(test, feature = "std"))]
mod tests {
    use std::io::Cursor;

    use super::*;

    #[test]
    pub fn vec_u8_read_without_padding() {
        let buf = Cursor::new(vec![0, 0, 0, 4, 2, 2, 2, 2]);
        let v = VecM::<u8, 8>::read_xdr(&mut Limited::new(buf, Limits::none())).unwrap();
        assert_eq!(v.to_vec(), vec![2, 2, 2, 2]);
    }

    #[test]
    pub fn vec_u8_read_with_padding() {
        let buf = Cursor::new(vec![0, 0, 0, 1, 2, 0, 0, 0]);
        let v = VecM::<u8, 8>::read_xdr(&mut Limited::new(buf, Limits::none())).unwrap();
        assert_eq!(v.to_vec(), vec![2]);
    }

    #[test]
    pub fn vec_u8_read_with_insufficient_padding() {
        let buf = Cursor::new(vec![0, 0, 0, 1, 2, 0, 0]);
        let res = VecM::<u8, 8>::read_xdr(&mut Limited::new(buf, Limits::none()));
        match res {
            Err(Error::Io(_)) => (),
            _ => panic!("expected IO error got {res:?}"),
        }
    }

    #[test]
    pub fn vec_u8_read_with_non_zero_padding() {
        let buf = Cursor::new(vec![0, 0, 0, 1, 2, 3, 0, 0]);
        let res = VecM::<u8, 8>::read_xdr(&mut Limited::new(buf, Limits::none()));
        match res {
            Err(Error::NonZeroPadding) => (),
            _ => panic!("expected NonZeroPadding got {res:?}"),
        }
    }

    #[test]
    pub fn vec_u8_write_without_padding() {
        let mut buf = vec![];
        let v: VecM<u8, 8> = vec![2, 2, 2, 2].try_into().unwrap();

        v.write_xdr(&mut Limited::new(Cursor::new(&mut buf), Limits::none()))
            .unwrap();
        assert_eq!(buf, vec![0, 0, 0, 4, 2, 2, 2, 2]);
    }

    #[test]
    pub fn vec_u8_write_with_padding() {
        let mut buf = vec![];
        let v: VecM<u8, 8> = vec![2].try_into().unwrap();
        v.write_xdr(&mut Limited::new(Cursor::new(&mut buf), Limits::none()))
            .unwrap();
        assert_eq!(buf, vec![0, 0, 0, 1, 2, 0, 0, 0]);
    }

    #[test]
    pub fn arr_u8_read_without_padding() {
        let buf = Cursor::new(vec![2, 2, 2, 2]);
        let v = <[u8; 4]>::read_xdr(&mut Limited::new(buf, Limits::none())).unwrap();
        assert_eq!(v, [2, 2, 2, 2]);
    }

    #[test]
    pub fn arr_u8_read_with_padding() {
        let buf = Cursor::new(vec![2, 0, 0, 0]);
        let v = <[u8; 1]>::read_xdr(&mut Limited::new(buf, Limits::none())).unwrap();
        assert_eq!(v, [2]);
    }

    #[test]
    pub fn arr_u8_read_with_insufficient_padding() {
        let buf = Cursor::new(vec![2, 0, 0]);
        let res = <[u8; 1]>::read_xdr(&mut Limited::new(buf, Limits::none()));
        match res {
            Err(Error::Io(_)) => (),
            _ => panic!("expected IO error got {res:?}"),
        }
    }

    #[test]
    pub fn arr_u8_read_with_non_zero_padding() {
        let buf = Cursor::new(vec![2, 3, 0, 0]);
        let res = <[u8; 1]>::read_xdr(&mut Limited::new(buf, Limits::none()));
        match res {
            Err(Error::NonZeroPadding) => (),
            _ => panic!("expected NonZeroPadding got {res:?}"),
        }
    }

    #[test]
    pub fn arr_u8_write_without_padding() {
        let mut buf = vec![];
        [2u8, 2, 2, 2]
            .write_xdr(&mut Limited::new(Cursor::new(&mut buf), Limits::none()))
            .unwrap();
        assert_eq!(buf, vec![2, 2, 2, 2]);
    }

    #[test]
    pub fn arr_u8_write_with_padding() {
        let mut buf = vec![];
        [2u8]
            .write_xdr(&mut Limited::new(Cursor::new(&mut buf), Limits::none()))
            .unwrap();
        assert_eq!(buf, vec![2, 0, 0, 0]);
    }
}

#[cfg(all(test, feature = "std"))]
mod test {
    use super::*;

    #[test]
    fn into_option_none() {
        let v: VecM<u32, 1> = vec![].try_into().unwrap();
        assert_eq!(v.into_option(), None);
    }

    #[test]
    fn into_option_some() {
        let v: VecM<_, 1> = vec![1].try_into().unwrap();
        assert_eq!(v.into_option(), Some(1));
    }

    #[test]
    fn to_option_none() {
        let v: VecM<u32, 1> = vec![].try_into().unwrap();
        assert_eq!(v.to_option(), None);
    }

    #[test]
    fn to_option_some() {
        let v: VecM<_, 1> = vec![1].try_into().unwrap();
        assert_eq!(v.to_option(), Some(1));
    }

    #[test]
    fn depth_limited_read_write_under_the_limit_success() {
        let a: Option<Option<Option<u32>>> = Some(Some(Some(5)));
        let mut buf = Limited::new(Vec::new(), Limits::depth(4));
        a.write_xdr(&mut buf).unwrap();

        let mut dlr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::depth(4));
        let a_back: Option<Option<Option<u32>>> = ReadXdr::read_xdr(&mut dlr).unwrap();
        assert_eq!(a, a_back);
    }

    #[test]
    fn write_over_depth_limit_fail() {
        let a: Option<Option<Option<u32>>> = Some(Some(Some(5)));
        let mut buf = Limited::new(Vec::new(), Limits::depth(3));
        let res = a.write_xdr(&mut buf);
        match res {
            Err(Error::DepthLimitExceeded) => (),
            _ => panic!("expected DepthLimitExceeded got {res:?}"),
        }
    }

    #[test]
    fn read_over_depth_limit_fail() {
        let read_limits = Limits::depth(3);
        let write_limits = Limits::depth(5);
        let a: Option<Option<Option<u32>>> = Some(Some(Some(5)));
        let mut buf = Limited::new(Vec::new(), write_limits);
        a.write_xdr(&mut buf).unwrap();

        let mut dlr = Limited::new(Cursor::new(buf.inner.as_slice()), read_limits);
        let res: Result<Option<Option<Option<u32>>>, _> = ReadXdr::read_xdr(&mut dlr);
        match res {
            Err(Error::DepthLimitExceeded) => (),
            _ => panic!("expected DepthLimitExceeded got {res:?}"),
        }
    }

    #[test]
    fn length_limited_read_write_i32() {
        // Exact limit, success
        let v = 123i32;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(4));
        let v_back: i32 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = 123i32;
        let mut buf = Limited::new(Vec::new(), Limits::len(5));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(5));
        let v_back: i32 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = 123i32;
        let mut buf = Limited::new(Vec::new(), Limits::len(3));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = 123i32;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(3));
        assert_eq!(
            <i32 as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_u32() {
        // Exact limit, success
        let v = 123u32;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(4));
        let v_back: u32 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = 123u32;
        let mut buf = Limited::new(Vec::new(), Limits::len(5));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(5));
        let v_back: u32 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = 123u32;
        let mut buf = Limited::new(Vec::new(), Limits::len(3));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = 123u32;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(3));
        assert_eq!(
            <u32 as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_i64() {
        // Exact limit, success
        let v = 123i64;
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(8));
        let v_back: i64 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = 123i64;
        let mut buf = Limited::new(Vec::new(), Limits::len(9));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(9));
        let v_back: i64 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = 123i64;
        let mut buf = Limited::new(Vec::new(), Limits::len(7));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = 123i64;
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(7));
        assert_eq!(
            <i64 as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_u64() {
        // Exact limit, success
        let v = 123u64;
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(8));
        let v_back: u64 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = 123u64;
        let mut buf = Limited::new(Vec::new(), Limits::len(9));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(9));
        let v_back: u64 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = 123u64;
        let mut buf = Limited::new(Vec::new(), Limits::len(7));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = 123u64;
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(7));
        assert_eq!(
            <u64 as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_bool() {
        // Exact limit, success
        let v = true;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(4));
        let v_back: bool = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = true;
        let mut buf = Limited::new(Vec::new(), Limits::len(5));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(5));
        let v_back: bool = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = true;
        let mut buf = Limited::new(Vec::new(), Limits::len(3));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = true;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(3));
        assert_eq!(
            <bool as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_option() {
        // Exact limit, success
        let v = Some(true);
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(8));
        let v_back: Option<bool> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = Some(true);
        let mut buf = Limited::new(Vec::new(), Limits::len(9));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(9));
        let v_back: Option<bool> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = Some(true);
        let mut buf = Limited::new(Vec::new(), Limits::len(7));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = Some(true);
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(7));
        assert_eq!(
            <Option<bool> as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_array_u8() {
        // Exact limit, success
        let v = [1u8, 2, 3];
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(4));
        let v_back: [u8; 3] = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = [1u8, 2, 3];
        let mut buf = Limited::new(Vec::new(), Limits::len(5));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(5));
        let v_back: [u8; 3] = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = [1u8, 2, 3];
        let mut buf = Limited::new(Vec::new(), Limits::len(3));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = [1u8, 2, 3];
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(3));
        assert_eq!(
            <[u8; 3] as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_array_type() {
        // Exact limit, success
        let v = [true, false, true];
        let mut buf = Limited::new(Vec::new(), Limits::len(12));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(12));
        let v_back: [bool; 3] = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = [true, false, true];
        let mut buf = Limited::new(Vec::new(), Limits::len(13));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(13));
        let v_back: [bool; 3] = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = [true, false, true];
        let mut buf = Limited::new(Vec::new(), Limits::len(11));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = [true, false, true];
        let mut buf = Limited::new(Vec::new(), Limits::len(12));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(11));
        assert_eq!(
            <[bool; 3] as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_vec() {
        // Exact limit, success
        let v = VecM::<i32, 3>::try_from([1i32, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(16));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(16));
        let v_back: VecM<i32, 3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = VecM::<i32, 3>::try_from([1i32, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(17));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(17));
        let v_back: VecM<i32, 3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = VecM::<i32, 3>::try_from([1i32, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(15));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = VecM::<i32, 3>::try_from([1i32, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(16));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(15));
        assert_eq!(
            <VecM<i32, 3> as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_bytes() {
        // Exact limit, success
        let v = BytesM::<3>::try_from([1u8, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(8));
        let v_back: BytesM<3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = BytesM::<3>::try_from([1u8, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(9));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(9));
        let v_back: BytesM<3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = BytesM::<3>::try_from([1u8, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(7));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = BytesM::<3>::try_from([1u8, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(7));
        assert_eq!(
            <BytesM<3> as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_string() {
        // Exact limit, success
        let v = StringM::<3>::try_from("123").unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(8));
        let v_back: StringM<3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = StringM::<3>::try_from("123").unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(9));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(9));
        let v_back: StringM<3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = StringM::<3>::try_from("123").unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(7));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = StringM::<3>::try_from("123").unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(7));
        assert_eq!(
            <StringM<3> as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }
}

#[cfg(all(test, not(feature = "alloc")))]
mod test {
    use super::VecM;

    #[test]
    fn to_option_none() {
        let v: VecM<u32, 1> = (&[]).try_into().unwrap();
        assert_eq!(v.to_option(), None);
    }

    #[test]
    fn to_option_some() {
        let v: VecM<_, 1> = (&[1]).try_into().unwrap();
        assert_eq!(v.to_option(), Some(1));
    }
}

#[cfg(all(test, feature = "serde"))]
mod tests_for_number_or_string {
    use super::*;
    use serde::{Deserialize, Serialize};
    use serde_json;
    use serde_with::serde_as;

    // --- Helper Structs ---
    #[serde_as]
    #[derive(Debug, PartialEq, Deserialize, Serialize)]
    struct TestI64 {
        #[serde_as(as = "NumberOrString")]
        val: i64,
    }

    #[serde_as]
    #[derive(Debug, PartialEq, Deserialize, Serialize)]
    struct TestU64 {
        #[serde_as(as = "NumberOrString")]
        val: u64,
    }

    #[serde_as]
    #[derive(Debug, PartialEq, Deserialize, Serialize)]
    struct TestOptionI64 {
        #[serde_as(as = "Option<NumberOrString>")]
        val: Option<i64>,
    }

    #[serde_as]
    #[derive(Debug, PartialEq, Deserialize, Serialize)]
    struct TestOptionU64 {
        #[serde_as(as = "Option<NumberOrString>")]
        val: Option<u64>,
    }

    #[serde_as]
    #[derive(Debug, PartialEq, Deserialize, Serialize)]
    struct TestVecI64 {
        #[serde_as(as = "Vec<NumberOrString>")]
        val: Vec<i64>,
    }

    #[serde_as]
    #[derive(Debug, PartialEq, Deserialize, Serialize)]
    struct TestVecU64 {
        #[serde_as(as = "Vec<NumberOrString>")]
        val: Vec<u64>,
    }

    // Helper Enum for testing field access within variants
    #[serde_as]
    #[derive(Debug, PartialEq, Deserialize, Serialize)]
    #[serde(rename_all = "camelCase")] // Added to make JSON keys distinct for variants
    enum TestEnum {
        VariantA {
            #[serde(rename = "numVal")]
            #[serde_as(as = "NumberOrString")]
            num_val: i64,
            #[serde(rename = "otherData")]
            other_data: String,
        },
        VariantB {
            #[serde_as(as = "NumberOrString")]
            count: u64,
        },
        SimpleVariant,
    }

    // --- i64 Deserialization Tests ---
    #[test]
    fn deserialize_i64_from_json_reader() {
        let json = r#"{"val": "123"}"#;
        let expected = TestI64 { val: 123 };
        assert_eq!(
            serde_json::from_reader::<_, TestI64>(Cursor::new(json)).unwrap(),
            expected
        );
    }

    #[test]
    fn deserialize_i64_from_json_number_positive() {
        let json = r#"{"val": 123}"#;
        let expected = TestI64 { val: 123 };
        assert_eq!(serde_json::from_str::<TestI64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_number_negative() {
        let json = r#"{"val": -456}"#;
        let expected = TestI64 { val: -456 };
        assert_eq!(serde_json::from_str::<TestI64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_number_zero() {
        let json = r#"{"val": 0}"#;
        let expected = TestI64 { val: 0 };
        assert_eq!(serde_json::from_str::<TestI64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_number_max() {
        let json = format!(r#"{{"val": {}}}"#, i64::MAX);
        let expected = TestI64 { val: i64::MAX };
        assert_eq!(serde_json::from_str::<TestI64>(&json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_number_min() {
        let json = format!(r#"{{"val": {}}}"#, i64::MIN);
        let expected = TestI64 { val: i64::MIN };
        assert_eq!(serde_json::from_str::<TestI64>(&json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_string_positive() {
        let json = r#"{"val": "789"}"#;
        let expected = TestI64 { val: 789 };
        assert_eq!(serde_json::from_str::<TestI64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_string_negative() {
        let json = r#"{"val": "-101"}"#;
        let expected = TestI64 { val: -101 };
        assert_eq!(serde_json::from_str::<TestI64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_string_zero() {
        let json = r#"{"val": "0"}"#;
        let expected = TestI64 { val: 0 };
        assert_eq!(serde_json::from_str::<TestI64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_string_max() {
        let json = format!(r#"{{"val": "{}"}}"#, i64::MAX);
        let expected = TestI64 { val: i64::MAX };
        assert_eq!(serde_json::from_str::<TestI64>(&json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_string_min() {
        let json = format!(r#"{{"val": "{}"}}"#, i64::MIN);
        let expected = TestI64 { val: i64::MIN };
        assert_eq!(serde_json::from_str::<TestI64>(&json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_string_with_plus_prefix() {
        let json = r#"{"val": "+123"}"#;
        let expected = TestI64 { val: 123 };
        assert_eq!(serde_json::from_str::<TestI64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_string_with_plus_zero() {
        let json = r#"{"val": "+0"}"#;
        let expected = TestI64 { val: 0 };
        assert_eq!(serde_json::from_str::<TestI64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_from_json_string_with_minus_zero() {
        let json = r#"{"val": "-0"}"#;
        let expected = TestI64 { val: 0 };
        assert_eq!(serde_json::from_str::<TestI64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_i64_error_from_json_string_with_leading_whitespace() {
        let json = r#"{"val": " 123"}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_json_string_with_trailing_whitespace() {
        let json = r#"{"val": "123 "}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_json_string_with_both_whitespace() {
        let json = r#"{"val": " 123 "}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_json_string_with_invalid_plus_prefix() {
        let json = r#"{"val": "++123"}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_json_string_with_invalid_minus_prefix() {
        let json = r#"{"val": "--123"}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_json_string_with_invalid_mixed_prefix() {
        let json = r#"{"val": "+-123"}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_string_not_a_number() {
        let json = r#"{"val": "abc"}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_string_float() {
        let json = r#"{"val": "123.45"}"#; // Not an integer
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_string_empty() {
        let json = r#"{"val": ""}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_string_overflow() {
        let overflow_val = i128::from(i64::MAX) + 1;
        let json = format!(r#"{{"val": "{overflow_val}"}}"#);
        assert!(serde_json::from_str::<TestI64>(&json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_string_underflow() {
        let underflow_val = i128::from(i64::MIN) - 1;
        let json = format!(r#"{{"val": "{underflow_val}"}}"#);
        assert!(serde_json::from_str::<TestI64>(&json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_json_float_number() {
        let json = r#"{"val": 123.45}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_json_bool_true() {
        let json = r#"{"val": true}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_json_array() {
        let json = r#"{"val": []}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_json_object() {
        let json = r#"{"val": {}}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    #[test]
    fn deserialize_i64_error_from_json_null() {
        let json = r#"{"val": null}"#;
        assert!(serde_json::from_str::<TestI64>(json).is_err());
    }

    // -- Additional i64 String Format Tests --
    #[test]
    fn deserialize_i64_error_from_hex_string() {
        let json = r#"{"val": "0x1A"}"#; // Hex "26"
                                         // std::primitive::i64.from_str() does not support "0x"
        assert!(
            serde_json::from_str::<TestI64>(json).is_err(),
            "Hex string should fail parsing to i64"
        );
    }

    #[test]
    fn deserialize_i64_error_from_octal_string() {
        let json = r#"{"val": "0o77"}"#; // Octal "63"
                                         // std::primitive::i64.from_str() does not support "0o"
        assert!(
            serde_json::from_str::<TestI64>(json).is_err(),
            "Octal string should fail parsing to i64"
        );
    }

    #[test]
    fn deserialize_i64_error_from_scientific_notation_string() {
        let json = r#"{"val": "1e3"}"#; // "1000" in scientific
                                        // std::primitive::i64.from_str() does not support scientific notation
        assert!(
            serde_json::from_str::<TestI64>(json).is_err(),
            "Scientific notation string should fail parsing to i64"
        );
    }

    #[test]
    fn deserialize_i64_error_from_invalid_scientific_notation_string() {
        let json = r#"{"val": "1e"}"#;
        assert!(
            serde_json::from_str::<TestI64>(json).is_err(),
            "Invalid scientific notation string should fail"
        );
    }

    #[test]
    fn deserialize_i64_error_from_string_with_underscores() {
        let json = r#"{"val": "1_000_000"}"#;
        // std::primitive::i64.from_str() does not support underscores
        assert!(
            serde_json::from_str::<TestI64>(json).is_err(),
            "String with underscores should fail parsing to i64"
        );
    }

    #[test]
    fn deserialize_i64_from_string_with_leading_zeros() {
        let json = r#"{"val": "000123"}"#;
        let expected = TestI64 { val: 123 };
        // std::primitive::i64.from_str() supports leading zeros
        assert_eq!(
            serde_json::from_str::<TestI64>(json).unwrap(),
            expected,
            "String with leading zeros should parse"
        );
    }

    #[test]
    fn deserialize_i64_from_string_with_leading_zeros_negative() {
        let json = r#"{"val": "-000123"}"#;
        let expected = TestI64 { val: -123 };
        assert_eq!(
            serde_json::from_str::<TestI64>(json).unwrap(),
            expected,
            "Negative string with leading zeros should parse"
        );
    }

    #[test]
    fn deserialize_i64_error_from_string_with_decimal_zeros() {
        let json = r#"{"val": "123.000"}"#;
        // std::primitive::i64.from_str() does not support decimals
        assert!(
            serde_json::from_str::<TestI64>(json).is_err(),
            "String with decimal part should fail parsing to i64"
        );
    }

    #[test]
    fn deserialize_i64_error_from_string_with_internal_decimal() {
        let json = r#"{"val": "12.345"}"#;
        assert!(
            serde_json::from_str::<TestI64>(json).is_err(),
            "String with internal decimal point should fail"
        );
    }

    #[test]
    fn deserialize_i64_error_from_localized_string_commas() {
        let json = r#"{"val": "1,234"}"#;
        // std::primitive::i64.from_str() does not support commas
        assert!(
            serde_json::from_str::<TestI64>(json).is_err(),
            "Localized string with commas should fail parsing to i64"
        );
    }

    // --- u64 Deserialization Tests ---
    #[test]
    fn deserialize_u64_from_json_reader() {
        let json = r#"{"val": "123"}"#;
        let expected = TestU64 { val: 123 };
        assert_eq!(
            serde_json::from_reader::<_, TestU64>(Cursor::new(json)).unwrap(),
            expected
        );
    }

    #[test]
    fn deserialize_u64_from_json_number() {
        let json = r#"{"val": 123}"#;
        let expected = TestU64 { val: 123 };
        assert_eq!(serde_json::from_str::<TestU64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_u64_from_json_number_zero() {
        let json = r#"{"val": 0}"#;
        let expected = TestU64 { val: 0 };
        assert_eq!(serde_json::from_str::<TestU64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_u64_from_json_number_max() {
        let json = format!(r#"{{"val": {}}}"#, u64::MAX);
        let expected = TestU64 { val: u64::MAX };
        assert_eq!(serde_json::from_str::<TestU64>(&json).unwrap(), expected);
    }

    #[test]
    fn deserialize_u64_from_json_string() {
        let json = r#"{"val": "789"}"#;
        let expected = TestU64 { val: 789 };
        assert_eq!(serde_json::from_str::<TestU64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_u64_from_json_string_zero() {
        let json = r#"{"val": "0"}"#;
        let expected = TestU64 { val: 0 };
        assert_eq!(serde_json::from_str::<TestU64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_u64_from_json_string_max() {
        let json = format!(r#"{{"val": "{}"}}"#, u64::MAX);
        let expected = TestU64 { val: u64::MAX };
        assert_eq!(serde_json::from_str::<TestU64>(&json).unwrap(), expected);
    }

    #[test]
    fn deserialize_u64_from_json_string_with_plus_prefix() {
        let json = r#"{"val": "+123"}"#;
        let expected = TestU64 { val: 123 };
        assert_eq!(serde_json::from_str::<TestU64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_u64_from_json_string_with_plus_zero() {
        let json = r#"{"val": "+0"}"#;
        let expected = TestU64 { val: 0 };
        assert_eq!(serde_json::from_str::<TestU64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_u64_error_from_json_string_with_leading_whitespace() {
        let json = r#"{"val": " 123"}"#;
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_json_string_with_trailing_whitespace() {
        let json = r#"{"val": "123 "}"#;
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_json_string_with_invalid_plus_prefix() {
        let json = r#"{"val": "++123"}"#;
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_string_negative() {
        let json = r#"{"val": "-123"}"#; // Negative not allowed for u64 string parse
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_json_number_negative() {
        let json = r#"{"val": -1}"#; // Negative not allowed for u64
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_string_not_a_number() {
        let json = r#"{"val": "abc"}"#;
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_string_float() {
        let json = r#"{"val": "123.45"}"#;
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_string_empty() {
        let json = r#"{"val": ""}"#;
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_string_overflow() {
        let overflow_val = u128::from(u64::MAX) + 1;
        let json = format!(r#"{{"val": "{overflow_val}"}}"#);
        assert!(serde_json::from_str::<TestU64>(&json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_json_float_number() {
        let json = r#"{"val": 123.45}"#;
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_json_bool_true() {
        let json = r#"{"val": true}"#;
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_json_array() {
        let json = r#"{"val": []}"#;
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_json_object() {
        let json = r#"{"val": {}}"#;
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    #[test]
    fn deserialize_u64_error_from_json_null() {
        let json = r#"{"val": null}"#;
        assert!(serde_json::from_str::<TestU64>(json).is_err());
    }

    // -- Additional u64 String Format Tests --
    #[test]
    fn deserialize_u64_error_from_hex_string() {
        let json = r#"{"val": "0x1A"}"#; // Hex "26"
        assert!(
            serde_json::from_str::<TestU64>(json).is_err(),
            "Hex string should fail parsing to u64"
        );
    }

    #[test]
    fn deserialize_u64_error_from_octal_string() {
        let json = r#"{"val": "0o77"}"#; // Octal "63"
        assert!(
            serde_json::from_str::<TestU64>(json).is_err(),
            "Octal string should fail parsing to u64"
        );
    }

    #[test]
    fn deserialize_u64_error_from_scientific_notation_string() {
        let json = r#"{"val": "1e3"}"#;
        assert!(
            serde_json::from_str::<TestU64>(json).is_err(),
            "Scientific notation string should fail parsing to u64"
        );
    }

    #[test]
    fn deserialize_u64_error_from_string_with_underscores() {
        let json = r#"{"val": "1_000_000"}"#;
        assert!(
            serde_json::from_str::<TestU64>(json).is_err(),
            "String with underscores should fail parsing to u64"
        );
    }

    #[test]
    fn deserialize_u64_from_string_with_leading_zeros() {
        let json = r#"{"val": "000123"}"#;
        let expected = TestU64 { val: 123 };
        assert_eq!(
            serde_json::from_str::<TestU64>(json).unwrap(),
            expected,
            "String with leading zeros should parse to u64"
        );
    }

    #[test]
    fn deserialize_u64_error_from_string_with_decimal_zeros() {
        let json = r#"{"val": "123.000"}"#;
        assert!(
            serde_json::from_str::<TestU64>(json).is_err(),
            "String with decimal part should fail parsing to u64"
        );
    }

    #[test]
    fn deserialize_u64_error_from_localized_string_commas() {
        let json = r#"{"val": "1,234"}"#;
        assert!(
            serde_json::from_str::<TestU64>(json).is_err(),
            "Localized string with commas should fail parsing to u64"
        );
    }

    // --- i64 Serialization Tests ---
    #[test]
    fn serialize_i64_positive() {
        let data = TestI64 { val: 123 };
        let expected_json = r#"{"val":"123"}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    #[test]
    fn serialize_i64_negative() {
        let data = TestI64 { val: -456 };
        let expected_json = r#"{"val":"-456"}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    #[test]
    fn serialize_i64_zero() {
        let data = TestI64 { val: 0 };
        let expected_json = r#"{"val":"0"}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    #[test]
    fn serialize_i64_max() {
        let data = TestI64 { val: i64::MAX };
        let expected_json = format!(r#"{{"val":"{}"}}"#, i64::MAX);
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    #[test]
    fn serialize_i64_min() {
        let data = TestI64 { val: i64::MIN };
        let expected_json = format!(r#"{{"val":"{}"}}"#, i64::MIN);
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    // --- u64 Serialization Tests ---
    #[test]
    fn serialize_u64_positive() {
        let data = TestU64 { val: 789 };
        let expected_json = r#"{"val":"789"}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    #[test]
    fn serialize_u64_zero() {
        let data = TestU64 { val: 0 };
        let expected_json = r#"{"val":"0"}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    #[test]
    fn serialize_u64_max() {
        let data = TestU64 { val: u64::MAX };
        let expected_json = format!(r#"{{"val":"{}"}}"#, u64::MAX);
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    // --- Option<i64> Tests ---
    #[test]
    fn deserialize_option_i64_some_from_json_number() {
        let json = r#"{"val": 123}"#;
        let expected = TestOptionI64 { val: Some(123) };
        assert_eq!(
            serde_json::from_str::<TestOptionI64>(json).unwrap(),
            expected
        );
    }

    #[test]
    fn deserialize_option_i64_some_from_json_string() {
        let json = r#"{"val": "456"}"#;
        let expected = TestOptionI64 { val: Some(456) };
        assert_eq!(
            serde_json::from_str::<TestOptionI64>(json).unwrap(),
            expected
        );
    }

    #[test]
    fn deserialize_option_i64_none_from_json_null() {
        let json = r#"{"val": null}"#;
        let expected = TestOptionI64 { val: None };
        assert_eq!(
            serde_json::from_str::<TestOptionI64>(json).unwrap(),
            expected
        );
    }

    #[test]
    fn deserialize_option_i64_error_from_invalid_string() {
        let json = r#"{"val": "abc"}"#;
        assert!(serde_json::from_str::<TestOptionI64>(json).is_err());
    }

    #[test]
    fn deserialize_option_i64_error_from_invalid_type() {
        let json = r#"{"val": true}"#;
        assert!(serde_json::from_str::<TestOptionI64>(json).is_err());
    }

    #[test]
    fn serialize_option_i64_some() {
        let data = TestOptionI64 { val: Some(123) };
        let expected_json = r#"{"val":"123"}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    #[test]
    fn serialize_option_i64_none() {
        let data = TestOptionI64 { val: None };
        let expected_json = r#"{"val":null}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    // --- Option<u64> Tests ---
    #[test]
    fn deserialize_option_u64_some_from_json_number() {
        let json = r#"{"val": 123}"#;
        let expected = TestOptionU64 { val: Some(123) };
        assert_eq!(
            serde_json::from_str::<TestOptionU64>(json).unwrap(),
            expected
        );
    }

    #[test]
    fn deserialize_option_u64_some_from_json_string() {
        let json = r#"{"val": "456"}"#;
        let expected = TestOptionU64 { val: Some(456) };
        assert_eq!(
            serde_json::from_str::<TestOptionU64>(json).unwrap(),
            expected
        );
    }

    #[test]
    fn deserialize_option_u64_none_from_json_null() {
        let json = r#"{"val": null}"#;
        let expected = TestOptionU64 { val: None };
        assert_eq!(
            serde_json::from_str::<TestOptionU64>(json).unwrap(),
            expected
        );
    }

    #[test]
    fn deserialize_option_u64_error_from_invalid_string() {
        let json = r#"{"val": "abc"}"#;
        assert!(serde_json::from_str::<TestOptionU64>(json).is_err());
    }

    #[test]
    fn deserialize_option_u64_error_from_negative_string() {
        let json = r#"{"val": "-1"}"#; // Invalid for u64
        assert!(serde_json::from_str::<TestOptionU64>(json).is_err());
    }

    #[test]
    fn serialize_option_u64_some() {
        let data = TestOptionU64 { val: Some(123) };
        let expected_json = r#"{"val":"123"}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    #[test]
    fn serialize_option_u64_none() {
        let data = TestOptionU64 { val: None };
        let expected_json = r#"{"val":null}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    // --- Vec<i64> Tests ---
    #[test]
    fn deserialize_vec_i64_empty() {
        let json = r#"{"val": []}"#;
        let expected = TestVecI64 { val: vec![] };
        assert_eq!(serde_json::from_str::<TestVecI64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_vec_i64_from_numbers_and_strings() {
        let json = r#"{"val": [1, "2", -3, "-4"]}"#;
        let expected = TestVecI64 {
            val: vec![1, 2, -3, -4],
        };
        assert_eq!(serde_json::from_str::<TestVecI64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_vec_i64_error_if_item_is_invalid_string() {
        let json = r#"{"val": [1, "abc", 3]}"#;
        let err = serde_json::from_str::<TestVecI64>(json).unwrap_err();
        // The error will point to the specific failing element
        assert!(err.to_string().contains("invalid digit found in string")); // From parse error
    }

    #[test]
    fn deserialize_vec_i64_error_if_item_is_invalid_type() {
        let json = r#"{"val": [1, true, 3]}"#;
        assert!(serde_json::from_str::<TestVecI64>(json).is_err());
    }

    #[test]
    fn serialize_vec_i64_empty() {
        let data = TestVecI64 { val: vec![] };
        let expected_json = r#"{"val":[]}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    #[test]
    fn serialize_vec_i64_with_values() {
        let data = TestVecI64 {
            val: vec![1, -2, 0],
        };
        let expected_json = r#"{"val":["1","-2","0"]}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    // --- Vec<u64> Tests ---
    #[test]
    fn deserialize_vec_u64_empty() {
        let json = r#"{"val": []}"#;
        let expected = TestVecU64 { val: vec![] };
        assert_eq!(serde_json::from_str::<TestVecU64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_vec_u64_from_numbers_and_strings() {
        let json = r#"{"val": [1, "2", 3, "4"]}"#;
        let expected = TestVecU64 {
            val: vec![1, 2, 3, 4],
        };
        assert_eq!(serde_json::from_str::<TestVecU64>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_vec_u64_error_if_item_is_invalid_string() {
        let json = r#"{"val": [1, "abc", 3]}"#;
        let err = serde_json::from_str::<TestVecU64>(json).unwrap_err();
        assert!(err.to_string().contains("invalid digit found in string"));
    }

    #[test]
    fn deserialize_vec_u64_error_if_item_is_negative_string() {
        let json = r#"{"val": [1, "-2", 3]}"#;
        let err = serde_json::from_str::<TestVecU64>(json).unwrap_err();
        assert!(err.to_string().contains("invalid digit found in string")); // u64 parse error
    }

    #[test]
    fn deserialize_vec_u64_error_if_item_is_negative_number() {
        let json = r#"{"val": [1, -2, 3]}"#;
        assert!(serde_json::from_str::<TestVecU64>(json).is_err());
    }

    #[test]
    fn serialize_vec_u64_empty() {
        let data = TestVecU64 { val: vec![] };
        let expected_json = r#"{"val":[]}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    #[test]
    fn serialize_vec_u64_with_values() {
        let data = TestVecU64 { val: vec![1, 2, 0] };
        let expected_json = r#"{"val":["1","2","0"]}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    // --- Enum with NumberOrString field Tests ---
    #[test]
    fn deserialize_enum_variant_a_with_number() {
        let json = r#"{"variantA": {"numVal": 123, "otherData": "test"}}"#;
        let expected = TestEnum::VariantA {
            num_val: 123,
            other_data: "test".to_string(),
        };
        assert_eq!(serde_json::from_str::<TestEnum>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_enum_variant_a_with_string_number() {
        let json = r#"{"variantA": {"numVal": "-45", "otherData": "data"}}"#;
        let expected = TestEnum::VariantA {
            num_val: -45,
            other_data: "data".to_string(),
        };
        assert_eq!(serde_json::from_str::<TestEnum>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_enum_variant_b_with_number() {
        let json = r#"{"variantB": {"count": 7890}}"#;
        let expected = TestEnum::VariantB { count: 7890 };
        assert_eq!(serde_json::from_str::<TestEnum>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_enum_variant_b_with_string_number() {
        let json = r#"{"variantB": {"count": "1234567890"}}"#;
        let expected = TestEnum::VariantB { count: 1234567890 };
        assert_eq!(serde_json::from_str::<TestEnum>(json).unwrap(), expected);
    }

    #[test]
    fn deserialize_enum_variant_a_error_invalid_num_string() {
        let json = r#"{"variantA": {"numVal": "abc", "otherData": "test"}}"#;
        assert!(serde_json::from_str::<TestEnum>(json).is_err());
    }

    #[test]
    fn serialize_enum_variant_a() {
        let data = TestEnum::VariantA {
            num_val: 123,
            other_data: "test".to_string(),
        };
        // Note: num_val will be serialized as a string by NumberOrString
        let expected_json = r#"{"variantA":{"numVal":"123","otherData":"test"}}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }

    #[test]
    fn serialize_enum_variant_b() {
        let data = TestEnum::VariantB { count: 7890 };
        let expected_json = r#"{"variantB":{"count":"7890"}}"#;
        assert_eq!(serde_json::to_string(&data).unwrap(), expected_json);
    }
}

/// ScpStatementPrepare
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScpStatementPrepare {
    pub quorum_set_hash: Hash,

    pub ballot: ScpBallot,

    pub prepared: Option<ScpBallot>,

    pub prepared_prime: Option<ScpBallot>,

    pub n_c: u32,

    pub n_h: u32,
}

impl ReadXdr for ScpStatementPrepare {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                quorum_set_hash: Hash::read_xdr(r)?,

                ballot: ScpBallot::read_xdr(r)?,

                prepared: Option::<ScpBallot>::read_xdr(r)?,

                prepared_prime: Option::<ScpBallot>::read_xdr(r)?,

                n_c: u32::read_xdr(r)?,

                n_h: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpStatementPrepare {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.quorum_set_hash.write_xdr(w)?;

            self.ballot.write_xdr(w)?;

            self.prepared.write_xdr(w)?;

            self.prepared_prime.write_xdr(w)?;

            self.n_c.write_xdr(w)?;

            self.n_h.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScpStatementConfirm
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScpStatementConfirm {
    pub ballot: ScpBallot,

    pub n_prepared: u32,

    pub n_commit: u32,

    pub n_h: u32,

    pub quorum_set_hash: Hash,
}

impl ReadXdr for ScpStatementConfirm {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ballot: ScpBallot::read_xdr(r)?,

                n_prepared: u32::read_xdr(r)?,

                n_commit: u32::read_xdr(r)?,

                n_h: u32::read_xdr(r)?,

                quorum_set_hash: Hash::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpStatementConfirm {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ballot.write_xdr(w)?;

            self.n_prepared.write_xdr(w)?;

            self.n_commit.write_xdr(w)?;

            self.n_h.write_xdr(w)?;

            self.quorum_set_hash.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScpStatementExternalize
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScpStatementExternalize {
    pub commit: ScpBallot,

    pub n_h: u32,

    pub commit_quorum_set_hash: Hash,
}

impl ReadXdr for ScpStatementExternalize {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                commit: ScpBallot::read_xdr(r)?,

                n_h: u32::read_xdr(r)?,

                commit_quorum_set_hash: Hash::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpStatementExternalize {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.commit.write_xdr(w)?;

            self.n_h.write_xdr(w)?;

            self.commit_quorum_set_hash.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScpStatementPledges
// union with discriminant ScpStatementType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ScpStatementPledges {
    ScpStPrepare(ScpStatementPrepare),

    ScpStConfirm(ScpStatementConfirm),

    ScpStExternalize(ScpStatementExternalize),

    ScpStNominate(ScpNomination),
}

#[cfg(feature = "alloc")]
impl Default for ScpStatementPledges {
    fn default() -> Self {
        Self::ScpStPrepare(ScpStatementPrepare::default())
    }
}

impl ScpStatementPledges {
    pub const VARIANTS: [ScpStatementType; 4] = [
        ScpStatementType::ScpStPrepare,
        ScpStatementType::ScpStConfirm,
        ScpStatementType::ScpStExternalize,
        ScpStatementType::ScpStNominate,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "ScpStPrepare",
        "ScpStConfirm",
        "ScpStExternalize",
        "ScpStNominate",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScpStPrepare(_) => "ScpStPrepare",

            Self::ScpStConfirm(_) => "ScpStConfirm",

            Self::ScpStExternalize(_) => "ScpStExternalize",

            Self::ScpStNominate(_) => "ScpStNominate",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScpStatementType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ScpStPrepare(_) => ScpStatementType::ScpStPrepare,

            Self::ScpStConfirm(_) => ScpStatementType::ScpStConfirm,

            Self::ScpStExternalize(_) => ScpStatementType::ScpStExternalize,

            Self::ScpStNominate(_) => ScpStatementType::ScpStNominate,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScpStatementType; 4] {
        Self::VARIANTS
    }
}

impl Name for ScpStatementPledges {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScpStatementType> for ScpStatementPledges {
    #[must_use]
    fn discriminant(&self) -> ScpStatementType {
        Self::discriminant(self)
    }
}

impl Variants<ScpStatementType> for ScpStatementPledges {
    fn variants() -> slice::Iter<'static, ScpStatementType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScpStatementType> for ScpStatementPledges {}

impl ReadXdr for ScpStatementPledges {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ScpStatementType = <ScpStatementType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScpStatementType::ScpStPrepare => {
                    Self::ScpStPrepare(ScpStatementPrepare::read_xdr(r)?)
                }

                ScpStatementType::ScpStConfirm => {
                    Self::ScpStConfirm(ScpStatementConfirm::read_xdr(r)?)
                }

                ScpStatementType::ScpStExternalize => {
                    Self::ScpStExternalize(ScpStatementExternalize::read_xdr(r)?)
                }

                ScpStatementType::ScpStNominate => Self::ScpStNominate(ScpNomination::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScpStatementPledges {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ScpStPrepare(v) => v.write_xdr(w)?,

                Self::ScpStConfirm(v) => v.write_xdr(w)?,

                Self::ScpStExternalize(v) => v.write_xdr(w)?,

                Self::ScpStNominate(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScEnvMetaEntryInterfaceVersion
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScEnvMetaEntryInterfaceVersion {
    pub protocol: u32,

    pub pre_release: u32,
}

impl ReadXdr for ScEnvMetaEntryInterfaceVersion {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                protocol: u32::read_xdr(r)?,

                pre_release: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScEnvMetaEntryInterfaceVersion {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.protocol.write_xdr(w)?;

            self.pre_release.write_xdr(w)?;

            Ok(())
        })
    }
}

/// AccountEntryExtensionV2Ext
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum AccountEntryExtensionV2Ext {
    V0,

    V3(AccountEntryExtensionV3),
}

#[cfg(feature = "alloc")]
impl Default for AccountEntryExtensionV2Ext {
    fn default() -> Self {
        Self::V0
    }
}

impl AccountEntryExtensionV2Ext {
    pub const VARIANTS: [i32; 2] = [0, 3];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V3"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V3(_) => "V3",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V3(_) => 3,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for AccountEntryExtensionV2Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for AccountEntryExtensionV2Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for AccountEntryExtensionV2Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for AccountEntryExtensionV2Ext {}

impl ReadXdr for AccountEntryExtensionV2Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                3 => Self::V3(AccountEntryExtensionV3::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AccountEntryExtensionV2Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V3(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AccountEntryExtensionV1Ext
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum AccountEntryExtensionV1Ext {
    V0,

    V2(AccountEntryExtensionV2),
}

#[cfg(feature = "alloc")]
impl Default for AccountEntryExtensionV1Ext {
    fn default() -> Self {
        Self::V0
    }
}

impl AccountEntryExtensionV1Ext {
    pub const VARIANTS: [i32; 2] = [0, 2];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V2"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V2(_) => "V2",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V2(_) => 2,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for AccountEntryExtensionV1Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for AccountEntryExtensionV1Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for AccountEntryExtensionV1Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for AccountEntryExtensionV1Ext {}

impl ReadXdr for AccountEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                2 => Self::V2(AccountEntryExtensionV2::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AccountEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V2(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AccountEntryExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum AccountEntryExt {
    V0,

    V1(AccountEntryExtensionV1),
}

#[cfg(feature = "alloc")]
impl Default for AccountEntryExt {
    fn default() -> Self {
        Self::V0
    }
}

impl AccountEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for AccountEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for AccountEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for AccountEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for AccountEntryExt {}

impl ReadXdr for AccountEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(AccountEntryExtensionV1::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AccountEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TrustLineEntryExtensionV2Ext
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TrustLineEntryExtensionV2Ext {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for TrustLineEntryExtensionV2Ext {
    fn default() -> Self {
        Self::V0
    }
}

impl TrustLineEntryExtensionV2Ext {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for TrustLineEntryExtensionV2Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TrustLineEntryExtensionV2Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TrustLineEntryExtensionV2Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TrustLineEntryExtensionV2Ext {}

impl ReadXdr for TrustLineEntryExtensionV2Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TrustLineEntryExtensionV2Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TrustLineEntryV1Ext
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TrustLineEntryV1Ext {
    V0,

    V2(TrustLineEntryExtensionV2),
}

#[cfg(feature = "alloc")]
impl Default for TrustLineEntryV1Ext {
    fn default() -> Self {
        Self::V0
    }
}

impl TrustLineEntryV1Ext {
    pub const VARIANTS: [i32; 2] = [0, 2];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V2"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V2(_) => "V2",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V2(_) => 2,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for TrustLineEntryV1Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TrustLineEntryV1Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TrustLineEntryV1Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TrustLineEntryV1Ext {}

impl ReadXdr for TrustLineEntryV1Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                2 => Self::V2(TrustLineEntryExtensionV2::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TrustLineEntryV1Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V2(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TrustLineEntryV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TrustLineEntryV1 {
    pub liabilities: Liabilities,

    pub ext: TrustLineEntryV1Ext,
}

impl ReadXdr for TrustLineEntryV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liabilities: Liabilities::read_xdr(r)?,

                ext: TrustLineEntryV1Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TrustLineEntryV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.liabilities.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TrustLineEntryExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TrustLineEntryExt {
    V0,

    V1(TrustLineEntryV1),
}

#[cfg(feature = "alloc")]
impl Default for TrustLineEntryExt {
    fn default() -> Self {
        Self::V0
    }
}

impl TrustLineEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for TrustLineEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TrustLineEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TrustLineEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TrustLineEntryExt {}

impl ReadXdr for TrustLineEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(TrustLineEntryV1::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TrustLineEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// OfferEntryExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum OfferEntryExt {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for OfferEntryExt {
    fn default() -> Self {
        Self::V0
    }
}

impl OfferEntryExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for OfferEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for OfferEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for OfferEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for OfferEntryExt {}

impl ReadXdr for OfferEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for OfferEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// DataEntryExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum DataEntryExt {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for DataEntryExt {
    fn default() -> Self {
        Self::V0
    }
}

impl DataEntryExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for DataEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for DataEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for DataEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for DataEntryExt {}

impl ReadXdr for DataEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for DataEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClaimantV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ClaimantV0 {
    pub destination: AccountId,

    pub predicate: ClaimPredicate,
}

impl ReadXdr for ClaimantV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                destination: AccountId::read_xdr(r)?,

                predicate: ClaimPredicate::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimantV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.destination.write_xdr(w)?;

            self.predicate.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ClaimableBalanceEntryExtensionV1Ext
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ClaimableBalanceEntryExtensionV1Ext {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for ClaimableBalanceEntryExtensionV1Ext {
    fn default() -> Self {
        Self::V0
    }
}

impl ClaimableBalanceEntryExtensionV1Ext {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for ClaimableBalanceEntryExtensionV1Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ClaimableBalanceEntryExtensionV1Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ClaimableBalanceEntryExtensionV1Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ClaimableBalanceEntryExtensionV1Ext {}

impl ReadXdr for ClaimableBalanceEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimableBalanceEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClaimableBalanceEntryExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ClaimableBalanceEntryExt {
    V0,

    V1(ClaimableBalanceEntryExtensionV1),
}

#[cfg(feature = "alloc")]
impl Default for ClaimableBalanceEntryExt {
    fn default() -> Self {
        Self::V0
    }
}

impl ClaimableBalanceEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for ClaimableBalanceEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ClaimableBalanceEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ClaimableBalanceEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ClaimableBalanceEntryExt {}

impl ReadXdr for ClaimableBalanceEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(ClaimableBalanceEntryExtensionV1::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimableBalanceEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LiquidityPoolEntryConstantProduct
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LiquidityPoolEntryConstantProduct {
    pub params: LiquidityPoolConstantProductParameters,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub reserve_a: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub reserve_b: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub total_pool_shares: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub pool_shares_trust_line_count: i64,
}

impl ReadXdr for LiquidityPoolEntryConstantProduct {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                params: LiquidityPoolConstantProductParameters::read_xdr(r)?,

                reserve_a: i64::read_xdr(r)?,

                reserve_b: i64::read_xdr(r)?,

                total_pool_shares: i64::read_xdr(r)?,

                pool_shares_trust_line_count: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LiquidityPoolEntryConstantProduct {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.params.write_xdr(w)?;

            self.reserve_a.write_xdr(w)?;

            self.reserve_b.write_xdr(w)?;

            self.total_pool_shares.write_xdr(w)?;

            self.pool_shares_trust_line_count.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LiquidityPoolEntryBody
// union with discriminant LiquidityPoolType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LiquidityPoolEntryBody {
    LiquidityPoolConstantProduct(LiquidityPoolEntryConstantProduct),
}

#[cfg(feature = "alloc")]
impl Default for LiquidityPoolEntryBody {
    fn default() -> Self {
        Self::LiquidityPoolConstantProduct(LiquidityPoolEntryConstantProduct::default())
    }
}

impl LiquidityPoolEntryBody {
    pub const VARIANTS: [LiquidityPoolType; 1] = [LiquidityPoolType::LiquidityPoolConstantProduct];
    pub const VARIANTS_STR: [&'static str; 1] = ["LiquidityPoolConstantProduct"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LiquidityPoolConstantProduct(_) => "LiquidityPoolConstantProduct",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LiquidityPoolType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::LiquidityPoolConstantProduct(_) => {
                LiquidityPoolType::LiquidityPoolConstantProduct
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolType; 1] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolEntryBody {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LiquidityPoolType> for LiquidityPoolEntryBody {
    #[must_use]
    fn discriminant(&self) -> LiquidityPoolType {
        Self::discriminant(self)
    }
}

impl Variants<LiquidityPoolType> for LiquidityPoolEntryBody {
    fn variants() -> slice::Iter<'static, LiquidityPoolType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LiquidityPoolType> for LiquidityPoolEntryBody {}

impl ReadXdr for LiquidityPoolEntryBody {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: LiquidityPoolType = <LiquidityPoolType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LiquidityPoolType::LiquidityPoolConstantProduct => {
                    Self::LiquidityPoolConstantProduct(LiquidityPoolEntryConstantProduct::read_xdr(
                        r,
                    )?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolEntryBody {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::LiquidityPoolConstantProduct(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ContractCodeEntryV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ContractCodeEntryV1 {
    pub ext: ExtensionPoint,

    pub cost_inputs: ContractCodeCostInputs,
}

impl ReadXdr for ContractCodeEntryV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                cost_inputs: ContractCodeCostInputs::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractCodeEntryV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.cost_inputs.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ContractCodeEntryExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ContractCodeEntryExt {
    V0,

    V1(ContractCodeEntryV1),
}

#[cfg(feature = "alloc")]
impl Default for ContractCodeEntryExt {
    fn default() -> Self {
        Self::V0
    }
}

impl ContractCodeEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractCodeEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ContractCodeEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ContractCodeEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ContractCodeEntryExt {}

impl ReadXdr for ContractCodeEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(ContractCodeEntryV1::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ContractCodeEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerEntryExtensionV1Ext
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LedgerEntryExtensionV1Ext {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for LedgerEntryExtensionV1Ext {
    fn default() -> Self {
        Self::V0
    }
}

impl LedgerEntryExtensionV1Ext {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryExtensionV1Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerEntryExtensionV1Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerEntryExtensionV1Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerEntryExtensionV1Ext {}

impl ReadXdr for LedgerEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerEntryData
// union with discriminant LedgerEntryType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LedgerEntryData {
    Account(AccountEntry),

    Trustline(TrustLineEntry),

    Offer(OfferEntry),

    Data(DataEntry),

    ClaimableBalance(ClaimableBalanceEntry),

    LiquidityPool(LiquidityPoolEntry),

    ContractData(ContractDataEntry),

    ContractCode(ContractCodeEntry),

    ConfigSetting(ConfigSettingEntry),

    Ttl(TtlEntry),
}

#[cfg(feature = "alloc")]
impl Default for LedgerEntryData {
    fn default() -> Self {
        Self::Account(AccountEntry::default())
    }
}

impl LedgerEntryData {
    pub const VARIANTS: [LedgerEntryType; 10] = [
        LedgerEntryType::Account,
        LedgerEntryType::Trustline,
        LedgerEntryType::Offer,
        LedgerEntryType::Data,
        LedgerEntryType::ClaimableBalance,
        LedgerEntryType::LiquidityPool,
        LedgerEntryType::ContractData,
        LedgerEntryType::ContractCode,
        LedgerEntryType::ConfigSetting,
        LedgerEntryType::Ttl,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "Account",
        "Trustline",
        "Offer",
        "Data",
        "ClaimableBalance",
        "LiquidityPool",
        "ContractData",
        "ContractCode",
        "ConfigSetting",
        "Ttl",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Account(_) => "Account",

            Self::Trustline(_) => "Trustline",

            Self::Offer(_) => "Offer",

            Self::Data(_) => "Data",

            Self::ClaimableBalance(_) => "ClaimableBalance",

            Self::LiquidityPool(_) => "LiquidityPool",

            Self::ContractData(_) => "ContractData",

            Self::ContractCode(_) => "ContractCode",

            Self::ConfigSetting(_) => "ConfigSetting",

            Self::Ttl(_) => "Ttl",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LedgerEntryType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Account(_) => LedgerEntryType::Account,

            Self::Trustline(_) => LedgerEntryType::Trustline,

            Self::Offer(_) => LedgerEntryType::Offer,

            Self::Data(_) => LedgerEntryType::Data,

            Self::ClaimableBalance(_) => LedgerEntryType::ClaimableBalance,

            Self::LiquidityPool(_) => LedgerEntryType::LiquidityPool,

            Self::ContractData(_) => LedgerEntryType::ContractData,

            Self::ContractCode(_) => LedgerEntryType::ContractCode,

            Self::ConfigSetting(_) => LedgerEntryType::ConfigSetting,

            Self::Ttl(_) => LedgerEntryType::Ttl,
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerEntryType; 10] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryData {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LedgerEntryType> for LedgerEntryData {
    #[must_use]
    fn discriminant(&self) -> LedgerEntryType {
        Self::discriminant(self)
    }
}

impl Variants<LedgerEntryType> for LedgerEntryData {
    fn variants() -> slice::Iter<'static, LedgerEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LedgerEntryType> for LedgerEntryData {}

impl ReadXdr for LedgerEntryData {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: LedgerEntryType = <LedgerEntryType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LedgerEntryType::Account => Self::Account(AccountEntry::read_xdr(r)?),

                LedgerEntryType::Trustline => Self::Trustline(TrustLineEntry::read_xdr(r)?),

                LedgerEntryType::Offer => Self::Offer(OfferEntry::read_xdr(r)?),

                LedgerEntryType::Data => Self::Data(DataEntry::read_xdr(r)?),

                LedgerEntryType::ClaimableBalance => {
                    Self::ClaimableBalance(ClaimableBalanceEntry::read_xdr(r)?)
                }

                LedgerEntryType::LiquidityPool => {
                    Self::LiquidityPool(LiquidityPoolEntry::read_xdr(r)?)
                }

                LedgerEntryType::ContractData => {
                    Self::ContractData(ContractDataEntry::read_xdr(r)?)
                }

                LedgerEntryType::ContractCode => {
                    Self::ContractCode(ContractCodeEntry::read_xdr(r)?)
                }

                LedgerEntryType::ConfigSetting => {
                    Self::ConfigSetting(ConfigSettingEntry::read_xdr(r)?)
                }

                LedgerEntryType::Ttl => Self::Ttl(TtlEntry::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryData {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Account(v) => v.write_xdr(w)?,

                Self::Trustline(v) => v.write_xdr(w)?,

                Self::Offer(v) => v.write_xdr(w)?,

                Self::Data(v) => v.write_xdr(w)?,

                Self::ClaimableBalance(v) => v.write_xdr(w)?,

                Self::LiquidityPool(v) => v.write_xdr(w)?,

                Self::ContractData(v) => v.write_xdr(w)?,

                Self::ContractCode(v) => v.write_xdr(w)?,

                Self::ConfigSetting(v) => v.write_xdr(w)?,

                Self::Ttl(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerEntryExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LedgerEntryExt {
    V0,

    V1(LedgerEntryExtensionV1),
}

#[cfg(feature = "alloc")]
impl Default for LedgerEntryExt {
    fn default() -> Self {
        Self::V0
    }
}

impl LedgerEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerEntryExt {}

impl ReadXdr for LedgerEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(LedgerEntryExtensionV1::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerKeyAccount
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerKeyAccount {
    pub account_id: AccountId,
}

impl ReadXdr for LedgerKeyAccount {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyAccount {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerKeyTrustLine
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerKeyTrustLine {
    pub account_id: AccountId,

    pub asset: TrustLineAsset,
}

impl ReadXdr for LedgerKeyTrustLine {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,

                asset: TrustLineAsset::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyTrustLine {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;

            self.asset.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerKeyOffer
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerKeyOffer {
    pub seller_id: AccountId,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub offer_id: i64,
}

impl ReadXdr for LedgerKeyOffer {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                seller_id: AccountId::read_xdr(r)?,

                offer_id: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyOffer {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.seller_id.write_xdr(w)?;

            self.offer_id.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerKeyData
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerKeyData {
    pub account_id: AccountId,

    pub data_name: String64,
}

impl ReadXdr for LedgerKeyData {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,

                data_name: String64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyData {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;

            self.data_name.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerKeyClaimableBalance
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerKeyClaimableBalance {
    pub balance_id: ClaimableBalanceId,
}

impl ReadXdr for LedgerKeyClaimableBalance {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                balance_id: ClaimableBalanceId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyClaimableBalance {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.balance_id.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerKeyLiquidityPool
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerKeyLiquidityPool {
    pub liquidity_pool_id: PoolId,
}

impl ReadXdr for LedgerKeyLiquidityPool {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_id: PoolId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyLiquidityPool {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_id.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerKeyContractData
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerKeyContractData {
    pub contract: ScAddress,

    pub key: ScVal,

    pub durability: ContractDataDurability,
}

impl ReadXdr for LedgerKeyContractData {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                contract: ScAddress::read_xdr(r)?,

                key: ScVal::read_xdr(r)?,

                durability: ContractDataDurability::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyContractData {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.contract.write_xdr(w)?;

            self.key.write_xdr(w)?;

            self.durability.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerKeyContractCode
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerKeyContractCode {
    pub hash: Hash,
}

impl ReadXdr for LedgerKeyContractCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hash: Hash::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyContractCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.hash.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerKeyConfigSetting
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerKeyConfigSetting {
    pub config_setting_id: ConfigSettingId,
}

impl ReadXdr for LedgerKeyConfigSetting {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                config_setting_id: ConfigSettingId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyConfigSetting {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.config_setting_id.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerKeyTtl
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerKeyTtl {
    pub key_hash: Hash,
}

impl ReadXdr for LedgerKeyTtl {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key_hash: Hash::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyTtl {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.key_hash.write_xdr(w)?;

            Ok(())
        })
    }
}

/// BucketMetadataExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum BucketMetadataExt {
    V0,

    V1(BucketListType),
}

#[cfg(feature = "alloc")]
impl Default for BucketMetadataExt {
    fn default() -> Self {
        Self::V0
    }
}

impl BucketMetadataExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for BucketMetadataExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for BucketMetadataExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for BucketMetadataExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for BucketMetadataExt {}

impl ReadXdr for BucketMetadataExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(BucketListType::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for BucketMetadataExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// StellarValueExt
// union with discriminant StellarValueType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum StellarValueExt {
    StellarValueBasic,

    StellarValueSigned(LedgerCloseValueSignature),
}

#[cfg(feature = "alloc")]
impl Default for StellarValueExt {
    fn default() -> Self {
        Self::StellarValueBasic
    }
}

impl StellarValueExt {
    pub const VARIANTS: [StellarValueType; 2] = [
        StellarValueType::StellarValueBasic,
        StellarValueType::StellarValueSigned,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["StellarValueBasic", "StellarValueSigned"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::StellarValueBasic => "StellarValueBasic",

            Self::StellarValueSigned(_) => "StellarValueSigned",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> StellarValueType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::StellarValueBasic => StellarValueType::StellarValueBasic,

            Self::StellarValueSigned(_) => StellarValueType::StellarValueSigned,
        }
    }

    #[must_use]
    pub const fn variants() -> [StellarValueType; 2] {
        Self::VARIANTS
    }
}

impl Name for StellarValueExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<StellarValueType> for StellarValueExt {
    #[must_use]
    fn discriminant(&self) -> StellarValueType {
        Self::discriminant(self)
    }
}

impl Variants<StellarValueType> for StellarValueExt {
    fn variants() -> slice::Iter<'static, StellarValueType> {
        Self::VARIANTS.iter()
    }
}

impl Union<StellarValueType> for StellarValueExt {}

impl ReadXdr for StellarValueExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: StellarValueType = <StellarValueType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                StellarValueType::StellarValueBasic => Self::StellarValueBasic,

                StellarValueType::StellarValueSigned => {
                    Self::StellarValueSigned(LedgerCloseValueSignature::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for StellarValueExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::StellarValueBasic => ().write_xdr(w)?,

                Self::StellarValueSigned(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerHeaderExtensionV1Ext
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LedgerHeaderExtensionV1Ext {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for LedgerHeaderExtensionV1Ext {
    fn default() -> Self {
        Self::V0
    }
}

impl LedgerHeaderExtensionV1Ext {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for LedgerHeaderExtensionV1Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerHeaderExtensionV1Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerHeaderExtensionV1Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerHeaderExtensionV1Ext {}

impl ReadXdr for LedgerHeaderExtensionV1Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerHeaderExtensionV1Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerHeaderExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LedgerHeaderExt {
    V0,

    V1(LedgerHeaderExtensionV1),
}

#[cfg(feature = "alloc")]
impl Default for LedgerHeaderExt {
    fn default() -> Self {
        Self::V0
    }
}

impl LedgerHeaderExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for LedgerHeaderExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerHeaderExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerHeaderExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerHeaderExt {}

impl ReadXdr for LedgerHeaderExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(LedgerHeaderExtensionV1::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerHeaderExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TxSetComponentTxsMaybeDiscountedFee
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TxSetComponentTxsMaybeDiscountedFee {
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "Option<NumberOrString>")
    )]
    pub base_fee: Option<i64>,

    pub txs: VecM<TransactionEnvelope>,
}

impl ReadXdr for TxSetComponentTxsMaybeDiscountedFee {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                base_fee: Option::<i64>::read_xdr(r)?,

                txs: VecM::<TransactionEnvelope>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TxSetComponentTxsMaybeDiscountedFee {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.base_fee.write_xdr(w)?;

            self.txs.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionHistoryEntryExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TransactionHistoryEntryExt {
    V0,

    V1(GeneralizedTransactionSet),
}

#[cfg(feature = "alloc")]
impl Default for TransactionHistoryEntryExt {
    fn default() -> Self {
        Self::V0
    }
}

impl TransactionHistoryEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for TransactionHistoryEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionHistoryEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionHistoryEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionHistoryEntryExt {}

impl ReadXdr for TransactionHistoryEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(GeneralizedTransactionSet::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionHistoryEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionHistoryResultEntryExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TransactionHistoryResultEntryExt {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for TransactionHistoryResultEntryExt {
    fn default() -> Self {
        Self::V0
    }
}

impl TransactionHistoryResultEntryExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for TransactionHistoryResultEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionHistoryResultEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionHistoryResultEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionHistoryResultEntryExt {}

impl ReadXdr for TransactionHistoryResultEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionHistoryResultEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerHeaderHistoryEntryExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LedgerHeaderHistoryEntryExt {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for LedgerHeaderHistoryEntryExt {
    fn default() -> Self {
        Self::V0
    }
}

impl LedgerHeaderHistoryEntryExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for LedgerHeaderHistoryEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerHeaderHistoryEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerHeaderHistoryEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerHeaderHistoryEntryExt {}

impl ReadXdr for LedgerHeaderHistoryEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerHeaderHistoryEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ContractEventV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ContractEventV0 {
    pub topics: VecM<ScVal>,

    pub data: ScVal,
}

impl ReadXdr for ContractEventV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                topics: VecM::<ScVal>::read_xdr(r)?,

                data: ScVal::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractEventV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.topics.write_xdr(w)?;

            self.data.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ContractEventBody
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ContractEventBody {
    V0(ContractEventV0),
}

#[cfg(feature = "alloc")]
impl Default for ContractEventBody {
    fn default() -> Self {
        Self::V0(ContractEventV0::default())
    }
}

impl ContractEventBody {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for ContractEventBody {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ContractEventBody {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ContractEventBody {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ContractEventBody {}

impl ReadXdr for ContractEventBody {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(ContractEventV0::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ContractEventBody {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// PeerAddressIp
// union with discriminant IpAddrType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum PeerAddressIp {
    IPv4([u8; 4]),

    IPv6([u8; 16]),
}

#[cfg(feature = "alloc")]
impl Default for PeerAddressIp {
    fn default() -> Self {
        Self::IPv4(<[u8; 4]>::default())
    }
}

impl PeerAddressIp {
    pub const VARIANTS: [IpAddrType; 2] = [IpAddrType::IPv4, IpAddrType::IPv6];
    pub const VARIANTS_STR: [&'static str; 2] = ["IPv4", "IPv6"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::IPv4(_) => "IPv4",

            Self::IPv6(_) => "IPv6",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> IpAddrType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::IPv4(_) => IpAddrType::IPv4,

            Self::IPv6(_) => IpAddrType::IPv6,
        }
    }

    #[must_use]
    pub const fn variants() -> [IpAddrType; 2] {
        Self::VARIANTS
    }
}

impl Name for PeerAddressIp {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<IpAddrType> for PeerAddressIp {
    #[must_use]
    fn discriminant(&self) -> IpAddrType {
        Self::discriminant(self)
    }
}

impl Variants<IpAddrType> for PeerAddressIp {
    fn variants() -> slice::Iter<'static, IpAddrType> {
        Self::VARIANTS.iter()
    }
}

impl Union<IpAddrType> for PeerAddressIp {}

impl ReadXdr for PeerAddressIp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: IpAddrType = <IpAddrType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                IpAddrType::IPv4 => Self::IPv4(<[u8; 4]>::read_xdr(r)?),

                IpAddrType::IPv6 => Self::IPv6(<[u8; 16]>::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PeerAddressIp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::IPv4(v) => v.write_xdr(w)?,

                Self::IPv6(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AuthenticatedMessageV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct AuthenticatedMessageV0 {
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub sequence: u64,

    pub message: StellarMessage,

    pub mac: HmacSha256Mac,
}

impl ReadXdr for AuthenticatedMessageV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                sequence: u64::read_xdr(r)?,

                message: StellarMessage::read_xdr(r)?,

                mac: HmacSha256Mac::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AuthenticatedMessageV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.sequence.write_xdr(w)?;

            self.message.write_xdr(w)?;

            self.mac.write_xdr(w)?;

            Ok(())
        })
    }
}

/// MuxedAccountMed25519
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay)
)]

pub struct MuxedAccountMed25519 {
    pub id: u64,

    pub ed25519: Uint256,
}

impl ReadXdr for MuxedAccountMed25519 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                id: u64::read_xdr(r)?,

                ed25519: Uint256::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for MuxedAccountMed25519 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.id.write_xdr(w)?;

            self.ed25519.write_xdr(w)?;

            Ok(())
        })
    }
}

#[cfg(all(feature = "serde", feature = "alloc"))]
impl<'de> serde::Deserialize<'de> for MuxedAccountMed25519 {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        #[derive(Deserialize)]
        struct MuxedAccountMed25519 {
            id: u64,
            ed25519: Uint256,
        }
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum MuxedAccountMed25519OrString<'a> {
            Str(&'a str),
            String(String),
            MuxedAccountMed25519(MuxedAccountMed25519),
        }
        match MuxedAccountMed25519OrString::deserialize(deserializer)? {
            MuxedAccountMed25519OrString::Str(s) => s.parse().map_err(serde::de::Error::custom),
            MuxedAccountMed25519OrString::String(s) => s.parse().map_err(serde::de::Error::custom),
            MuxedAccountMed25519OrString::MuxedAccountMed25519(MuxedAccountMed25519 {
                id,
                ed25519,
            }) => Ok(self::MuxedAccountMed25519 { id, ed25519 }),
        }
    }
}

/// RevokeSponsorshipOpSigner
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct RevokeSponsorshipOpSigner {
    pub account_id: AccountId,

    pub signer_key: SignerKey,
}

impl ReadXdr for RevokeSponsorshipOpSigner {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,

                signer_key: SignerKey::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for RevokeSponsorshipOpSigner {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;

            self.signer_key.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ContractIdPreimageFromAddress
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ContractIdPreimageFromAddress {
    pub address: ScAddress,

    pub salt: Uint256,
}

impl ReadXdr for ContractIdPreimageFromAddress {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                address: ScAddress::read_xdr(r)?,

                salt: Uint256::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractIdPreimageFromAddress {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.address.write_xdr(w)?;

            self.salt.write_xdr(w)?;

            Ok(())
        })
    }
}

/// OperationBody
// union with discriminant OperationType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum OperationBody {
    CreateAccount(CreateAccountOp),

    Payment(PaymentOp),

    PathPaymentStrictReceive(PathPaymentStrictReceiveOp),

    ManageSellOffer(ManageSellOfferOp),

    CreatePassiveSellOffer(CreatePassiveSellOfferOp),

    SetOptions(SetOptionsOp),

    ChangeTrust(ChangeTrustOp),

    AllowTrust(AllowTrustOp),

    AccountMerge(MuxedAccount),

    Inflation,

    ManageData(ManageDataOp),

    BumpSequence(BumpSequenceOp),

    ManageBuyOffer(ManageBuyOfferOp),

    PathPaymentStrictSend(PathPaymentStrictSendOp),

    CreateClaimableBalance(CreateClaimableBalanceOp),

    ClaimClaimableBalance(ClaimClaimableBalanceOp),

    BeginSponsoringFutureReserves(BeginSponsoringFutureReservesOp),

    EndSponsoringFutureReserves,

    RevokeSponsorship(RevokeSponsorshipOp),

    Clawback(ClawbackOp),

    ClawbackClaimableBalance(ClawbackClaimableBalanceOp),

    SetTrustLineFlags(SetTrustLineFlagsOp),

    LiquidityPoolDeposit(LiquidityPoolDepositOp),

    LiquidityPoolWithdraw(LiquidityPoolWithdrawOp),

    InvokeHostFunction(InvokeHostFunctionOp),

    ExtendFootprintTtl(ExtendFootprintTtlOp),

    RestoreFootprint(RestoreFootprintOp),
}

#[cfg(feature = "alloc")]
impl Default for OperationBody {
    fn default() -> Self {
        Self::CreateAccount(CreateAccountOp::default())
    }
}

impl OperationBody {
    pub const VARIANTS: [OperationType; 27] = [
        OperationType::CreateAccount,
        OperationType::Payment,
        OperationType::PathPaymentStrictReceive,
        OperationType::ManageSellOffer,
        OperationType::CreatePassiveSellOffer,
        OperationType::SetOptions,
        OperationType::ChangeTrust,
        OperationType::AllowTrust,
        OperationType::AccountMerge,
        OperationType::Inflation,
        OperationType::ManageData,
        OperationType::BumpSequence,
        OperationType::ManageBuyOffer,
        OperationType::PathPaymentStrictSend,
        OperationType::CreateClaimableBalance,
        OperationType::ClaimClaimableBalance,
        OperationType::BeginSponsoringFutureReserves,
        OperationType::EndSponsoringFutureReserves,
        OperationType::RevokeSponsorship,
        OperationType::Clawback,
        OperationType::ClawbackClaimableBalance,
        OperationType::SetTrustLineFlags,
        OperationType::LiquidityPoolDeposit,
        OperationType::LiquidityPoolWithdraw,
        OperationType::InvokeHostFunction,
        OperationType::ExtendFootprintTtl,
        OperationType::RestoreFootprint,
    ];
    pub const VARIANTS_STR: [&'static str; 27] = [
        "CreateAccount",
        "Payment",
        "PathPaymentStrictReceive",
        "ManageSellOffer",
        "CreatePassiveSellOffer",
        "SetOptions",
        "ChangeTrust",
        "AllowTrust",
        "AccountMerge",
        "Inflation",
        "ManageData",
        "BumpSequence",
        "ManageBuyOffer",
        "PathPaymentStrictSend",
        "CreateClaimableBalance",
        "ClaimClaimableBalance",
        "BeginSponsoringFutureReserves",
        "EndSponsoringFutureReserves",
        "RevokeSponsorship",
        "Clawback",
        "ClawbackClaimableBalance",
        "SetTrustLineFlags",
        "LiquidityPoolDeposit",
        "LiquidityPoolWithdraw",
        "InvokeHostFunction",
        "ExtendFootprintTtl",
        "RestoreFootprint",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::CreateAccount(_) => "CreateAccount",

            Self::Payment(_) => "Payment",

            Self::PathPaymentStrictReceive(_) => "PathPaymentStrictReceive",

            Self::ManageSellOffer(_) => "ManageSellOffer",

            Self::CreatePassiveSellOffer(_) => "CreatePassiveSellOffer",

            Self::SetOptions(_) => "SetOptions",

            Self::ChangeTrust(_) => "ChangeTrust",

            Self::AllowTrust(_) => "AllowTrust",

            Self::AccountMerge(_) => "AccountMerge",

            Self::Inflation => "Inflation",

            Self::ManageData(_) => "ManageData",

            Self::BumpSequence(_) => "BumpSequence",

            Self::ManageBuyOffer(_) => "ManageBuyOffer",

            Self::PathPaymentStrictSend(_) => "PathPaymentStrictSend",

            Self::CreateClaimableBalance(_) => "CreateClaimableBalance",

            Self::ClaimClaimableBalance(_) => "ClaimClaimableBalance",

            Self::BeginSponsoringFutureReserves(_) => "BeginSponsoringFutureReserves",

            Self::EndSponsoringFutureReserves => "EndSponsoringFutureReserves",

            Self::RevokeSponsorship(_) => "RevokeSponsorship",

            Self::Clawback(_) => "Clawback",

            Self::ClawbackClaimableBalance(_) => "ClawbackClaimableBalance",

            Self::SetTrustLineFlags(_) => "SetTrustLineFlags",

            Self::LiquidityPoolDeposit(_) => "LiquidityPoolDeposit",

            Self::LiquidityPoolWithdraw(_) => "LiquidityPoolWithdraw",

            Self::InvokeHostFunction(_) => "InvokeHostFunction",

            Self::ExtendFootprintTtl(_) => "ExtendFootprintTtl",

            Self::RestoreFootprint(_) => "RestoreFootprint",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> OperationType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::CreateAccount(_) => OperationType::CreateAccount,

            Self::Payment(_) => OperationType::Payment,

            Self::PathPaymentStrictReceive(_) => OperationType::PathPaymentStrictReceive,

            Self::ManageSellOffer(_) => OperationType::ManageSellOffer,

            Self::CreatePassiveSellOffer(_) => OperationType::CreatePassiveSellOffer,

            Self::SetOptions(_) => OperationType::SetOptions,

            Self::ChangeTrust(_) => OperationType::ChangeTrust,

            Self::AllowTrust(_) => OperationType::AllowTrust,

            Self::AccountMerge(_) => OperationType::AccountMerge,

            Self::Inflation => OperationType::Inflation,

            Self::ManageData(_) => OperationType::ManageData,

            Self::BumpSequence(_) => OperationType::BumpSequence,

            Self::ManageBuyOffer(_) => OperationType::ManageBuyOffer,

            Self::PathPaymentStrictSend(_) => OperationType::PathPaymentStrictSend,

            Self::CreateClaimableBalance(_) => OperationType::CreateClaimableBalance,

            Self::ClaimClaimableBalance(_) => OperationType::ClaimClaimableBalance,

            Self::BeginSponsoringFutureReserves(_) => OperationType::BeginSponsoringFutureReserves,

            Self::EndSponsoringFutureReserves => OperationType::EndSponsoringFutureReserves,

            Self::RevokeSponsorship(_) => OperationType::RevokeSponsorship,

            Self::Clawback(_) => OperationType::Clawback,

            Self::ClawbackClaimableBalance(_) => OperationType::ClawbackClaimableBalance,

            Self::SetTrustLineFlags(_) => OperationType::SetTrustLineFlags,

            Self::LiquidityPoolDeposit(_) => OperationType::LiquidityPoolDeposit,

            Self::LiquidityPoolWithdraw(_) => OperationType::LiquidityPoolWithdraw,

            Self::InvokeHostFunction(_) => OperationType::InvokeHostFunction,

            Self::ExtendFootprintTtl(_) => OperationType::ExtendFootprintTtl,

            Self::RestoreFootprint(_) => OperationType::RestoreFootprint,
        }
    }

    #[must_use]
    pub const fn variants() -> [OperationType; 27] {
        Self::VARIANTS
    }
}

impl Name for OperationBody {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<OperationType> for OperationBody {
    #[must_use]
    fn discriminant(&self) -> OperationType {
        Self::discriminant(self)
    }
}

impl Variants<OperationType> for OperationBody {
    fn variants() -> slice::Iter<'static, OperationType> {
        Self::VARIANTS.iter()
    }
}

impl Union<OperationType> for OperationBody {}

impl ReadXdr for OperationBody {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: OperationType = <OperationType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                OperationType::CreateAccount => Self::CreateAccount(CreateAccountOp::read_xdr(r)?),

                OperationType::Payment => Self::Payment(PaymentOp::read_xdr(r)?),

                OperationType::PathPaymentStrictReceive => {
                    Self::PathPaymentStrictReceive(PathPaymentStrictReceiveOp::read_xdr(r)?)
                }

                OperationType::ManageSellOffer => {
                    Self::ManageSellOffer(ManageSellOfferOp::read_xdr(r)?)
                }

                OperationType::CreatePassiveSellOffer => {
                    Self::CreatePassiveSellOffer(CreatePassiveSellOfferOp::read_xdr(r)?)
                }

                OperationType::SetOptions => Self::SetOptions(SetOptionsOp::read_xdr(r)?),

                OperationType::ChangeTrust => Self::ChangeTrust(ChangeTrustOp::read_xdr(r)?),

                OperationType::AllowTrust => Self::AllowTrust(AllowTrustOp::read_xdr(r)?),

                OperationType::AccountMerge => Self::AccountMerge(MuxedAccount::read_xdr(r)?),

                OperationType::Inflation => Self::Inflation,

                OperationType::ManageData => Self::ManageData(ManageDataOp::read_xdr(r)?),

                OperationType::BumpSequence => Self::BumpSequence(BumpSequenceOp::read_xdr(r)?),

                OperationType::ManageBuyOffer => {
                    Self::ManageBuyOffer(ManageBuyOfferOp::read_xdr(r)?)
                }

                OperationType::PathPaymentStrictSend => {
                    Self::PathPaymentStrictSend(PathPaymentStrictSendOp::read_xdr(r)?)
                }

                OperationType::CreateClaimableBalance => {
                    Self::CreateClaimableBalance(CreateClaimableBalanceOp::read_xdr(r)?)
                }

                OperationType::ClaimClaimableBalance => {
                    Self::ClaimClaimableBalance(ClaimClaimableBalanceOp::read_xdr(r)?)
                }

                OperationType::BeginSponsoringFutureReserves => {
                    Self::BeginSponsoringFutureReserves(BeginSponsoringFutureReservesOp::read_xdr(
                        r,
                    )?)
                }

                OperationType::EndSponsoringFutureReserves => Self::EndSponsoringFutureReserves,

                OperationType::RevokeSponsorship => {
                    Self::RevokeSponsorship(RevokeSponsorshipOp::read_xdr(r)?)
                }

                OperationType::Clawback => Self::Clawback(ClawbackOp::read_xdr(r)?),

                OperationType::ClawbackClaimableBalance => {
                    Self::ClawbackClaimableBalance(ClawbackClaimableBalanceOp::read_xdr(r)?)
                }

                OperationType::SetTrustLineFlags => {
                    Self::SetTrustLineFlags(SetTrustLineFlagsOp::read_xdr(r)?)
                }

                OperationType::LiquidityPoolDeposit => {
                    Self::LiquidityPoolDeposit(LiquidityPoolDepositOp::read_xdr(r)?)
                }

                OperationType::LiquidityPoolWithdraw => {
                    Self::LiquidityPoolWithdraw(LiquidityPoolWithdrawOp::read_xdr(r)?)
                }

                OperationType::InvokeHostFunction => {
                    Self::InvokeHostFunction(InvokeHostFunctionOp::read_xdr(r)?)
                }

                OperationType::ExtendFootprintTtl => {
                    Self::ExtendFootprintTtl(ExtendFootprintTtlOp::read_xdr(r)?)
                }

                OperationType::RestoreFootprint => {
                    Self::RestoreFootprint(RestoreFootprintOp::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for OperationBody {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::CreateAccount(v) => v.write_xdr(w)?,

                Self::Payment(v) => v.write_xdr(w)?,

                Self::PathPaymentStrictReceive(v) => v.write_xdr(w)?,

                Self::ManageSellOffer(v) => v.write_xdr(w)?,

                Self::CreatePassiveSellOffer(v) => v.write_xdr(w)?,

                Self::SetOptions(v) => v.write_xdr(w)?,

                Self::ChangeTrust(v) => v.write_xdr(w)?,

                Self::AllowTrust(v) => v.write_xdr(w)?,

                Self::AccountMerge(v) => v.write_xdr(w)?,

                Self::Inflation => ().write_xdr(w)?,

                Self::ManageData(v) => v.write_xdr(w)?,

                Self::BumpSequence(v) => v.write_xdr(w)?,

                Self::ManageBuyOffer(v) => v.write_xdr(w)?,

                Self::PathPaymentStrictSend(v) => v.write_xdr(w)?,

                Self::CreateClaimableBalance(v) => v.write_xdr(w)?,

                Self::ClaimClaimableBalance(v) => v.write_xdr(w)?,

                Self::BeginSponsoringFutureReserves(v) => v.write_xdr(w)?,

                Self::EndSponsoringFutureReserves => ().write_xdr(w)?,

                Self::RevokeSponsorship(v) => v.write_xdr(w)?,

                Self::Clawback(v) => v.write_xdr(w)?,

                Self::ClawbackClaimableBalance(v) => v.write_xdr(w)?,

                Self::SetTrustLineFlags(v) => v.write_xdr(w)?,

                Self::LiquidityPoolDeposit(v) => v.write_xdr(w)?,

                Self::LiquidityPoolWithdraw(v) => v.write_xdr(w)?,

                Self::InvokeHostFunction(v) => v.write_xdr(w)?,

                Self::ExtendFootprintTtl(v) => v.write_xdr(w)?,

                Self::RestoreFootprint(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// HashIdPreimageOperationId
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct HashIdPreimageOperationId {
    pub source_account: AccountId,

    pub seq_num: SequenceNumber,

    pub op_num: u32,
}

impl ReadXdr for HashIdPreimageOperationId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                source_account: AccountId::read_xdr(r)?,

                seq_num: SequenceNumber::read_xdr(r)?,

                op_num: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HashIdPreimageOperationId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.source_account.write_xdr(w)?;

            self.seq_num.write_xdr(w)?;

            self.op_num.write_xdr(w)?;

            Ok(())
        })
    }
}

/// HashIdPreimageRevokeId
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct HashIdPreimageRevokeId {
    pub source_account: AccountId,

    pub seq_num: SequenceNumber,

    pub op_num: u32,

    pub liquidity_pool_id: PoolId,

    pub asset: Asset,
}

impl ReadXdr for HashIdPreimageRevokeId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                source_account: AccountId::read_xdr(r)?,

                seq_num: SequenceNumber::read_xdr(r)?,

                op_num: u32::read_xdr(r)?,

                liquidity_pool_id: PoolId::read_xdr(r)?,

                asset: Asset::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HashIdPreimageRevokeId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.source_account.write_xdr(w)?;

            self.seq_num.write_xdr(w)?;

            self.op_num.write_xdr(w)?;

            self.liquidity_pool_id.write_xdr(w)?;

            self.asset.write_xdr(w)?;

            Ok(())
        })
    }
}

/// HashIdPreimageContractId
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct HashIdPreimageContractId {
    pub network_id: Hash,

    pub contract_id_preimage: ContractIdPreimage,
}

impl ReadXdr for HashIdPreimageContractId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                network_id: Hash::read_xdr(r)?,

                contract_id_preimage: ContractIdPreimage::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HashIdPreimageContractId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.network_id.write_xdr(w)?;

            self.contract_id_preimage.write_xdr(w)?;

            Ok(())
        })
    }
}

/// HashIdPreimageSorobanAuthorization
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct HashIdPreimageSorobanAuthorization {
    pub network_id: Hash,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub nonce: i64,

    pub signature_expiration_ledger: u32,

    pub invocation: SorobanAuthorizedInvocation,
}

impl ReadXdr for HashIdPreimageSorobanAuthorization {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                network_id: Hash::read_xdr(r)?,

                nonce: i64::read_xdr(r)?,

                signature_expiration_ledger: u32::read_xdr(r)?,

                invocation: SorobanAuthorizedInvocation::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HashIdPreimageSorobanAuthorization {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.network_id.write_xdr(w)?;

            self.nonce.write_xdr(w)?;

            self.signature_expiration_ledger.write_xdr(w)?;

            self.invocation.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SorobanTransactionDataExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum SorobanTransactionDataExt {
    V0,

    V1(SorobanResourcesExtV0),
}

#[cfg(feature = "alloc")]
impl Default for SorobanTransactionDataExt {
    fn default() -> Self {
        Self::V0
    }
}

impl SorobanTransactionDataExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for SorobanTransactionDataExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for SorobanTransactionDataExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for SorobanTransactionDataExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for SorobanTransactionDataExt {}

impl ReadXdr for SorobanTransactionDataExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(SorobanResourcesExtV0::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanTransactionDataExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionV0Ext
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TransactionV0Ext {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for TransactionV0Ext {
    fn default() -> Self {
        Self::V0
    }
}

impl TransactionV0Ext {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for TransactionV0Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionV0Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionV0Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionV0Ext {}

impl ReadXdr for TransactionV0Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionV0Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TransactionExt {
    V0,

    V1(SorobanTransactionData),
}

#[cfg(feature = "alloc")]
impl Default for TransactionExt {
    fn default() -> Self {
        Self::V0
    }
}

impl TransactionExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for TransactionExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionExt {}

impl ReadXdr for TransactionExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(SorobanTransactionData::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// FeeBumpTransactionInnerTx
// union with discriminant EnvelopeType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum FeeBumpTransactionInnerTx {
    EnvelopeTypeTx(TransactionV1Envelope),
}

#[cfg(feature = "alloc")]
impl Default for FeeBumpTransactionInnerTx {
    fn default() -> Self {
        Self::EnvelopeTypeTx(TransactionV1Envelope::default())
    }
}

impl FeeBumpTransactionInnerTx {
    pub const VARIANTS: [EnvelopeType; 1] = [EnvelopeType::EnvelopeTypeTx];
    pub const VARIANTS_STR: [&'static str; 1] = ["EnvelopeTypeTx"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::EnvelopeTypeTx(_) => "EnvelopeTypeTx",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> EnvelopeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::EnvelopeTypeTx(_) => EnvelopeType::EnvelopeTypeTx,
        }
    }

    #[must_use]
    pub const fn variants() -> [EnvelopeType; 1] {
        Self::VARIANTS
    }
}

impl Name for FeeBumpTransactionInnerTx {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<EnvelopeType> for FeeBumpTransactionInnerTx {
    #[must_use]
    fn discriminant(&self) -> EnvelopeType {
        Self::discriminant(self)
    }
}

impl Variants<EnvelopeType> for FeeBumpTransactionInnerTx {
    fn variants() -> slice::Iter<'static, EnvelopeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<EnvelopeType> for FeeBumpTransactionInnerTx {}

impl ReadXdr for FeeBumpTransactionInnerTx {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: EnvelopeType = <EnvelopeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                EnvelopeType::EnvelopeTypeTx => {
                    Self::EnvelopeTypeTx(TransactionV1Envelope::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for FeeBumpTransactionInnerTx {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::EnvelopeTypeTx(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// FeeBumpTransactionExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum FeeBumpTransactionExt {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for FeeBumpTransactionExt {
    fn default() -> Self {
        Self::V0
    }
}

impl FeeBumpTransactionExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for FeeBumpTransactionExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for FeeBumpTransactionExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for FeeBumpTransactionExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for FeeBumpTransactionExt {}

impl ReadXdr for FeeBumpTransactionExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for FeeBumpTransactionExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionSignaturePayloadTaggedTransaction
// union with discriminant EnvelopeType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TransactionSignaturePayloadTaggedTransaction {
    EnvelopeTypeTx(Transaction),

    EnvelopeTypeTxFeeBump(FeeBumpTransaction),
}

#[cfg(feature = "alloc")]
impl Default for TransactionSignaturePayloadTaggedTransaction {
    fn default() -> Self {
        Self::EnvelopeTypeTx(Transaction::default())
    }
}

impl TransactionSignaturePayloadTaggedTransaction {
    pub const VARIANTS: [EnvelopeType; 2] = [
        EnvelopeType::EnvelopeTypeTx,
        EnvelopeType::EnvelopeTypeTxFeeBump,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["EnvelopeTypeTx", "EnvelopeTypeTxFeeBump"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::EnvelopeTypeTx(_) => "EnvelopeTypeTx",

            Self::EnvelopeTypeTxFeeBump(_) => "EnvelopeTypeTxFeeBump",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> EnvelopeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::EnvelopeTypeTx(_) => EnvelopeType::EnvelopeTypeTx,

            Self::EnvelopeTypeTxFeeBump(_) => EnvelopeType::EnvelopeTypeTxFeeBump,
        }
    }

    #[must_use]
    pub const fn variants() -> [EnvelopeType; 2] {
        Self::VARIANTS
    }
}

impl Name for TransactionSignaturePayloadTaggedTransaction {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<EnvelopeType> for TransactionSignaturePayloadTaggedTransaction {
    #[must_use]
    fn discriminant(&self) -> EnvelopeType {
        Self::discriminant(self)
    }
}

impl Variants<EnvelopeType> for TransactionSignaturePayloadTaggedTransaction {
    fn variants() -> slice::Iter<'static, EnvelopeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<EnvelopeType> for TransactionSignaturePayloadTaggedTransaction {}

impl ReadXdr for TransactionSignaturePayloadTaggedTransaction {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: EnvelopeType = <EnvelopeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                EnvelopeType::EnvelopeTypeTx => Self::EnvelopeTypeTx(Transaction::read_xdr(r)?),

                EnvelopeType::EnvelopeTypeTxFeeBump => {
                    Self::EnvelopeTypeTxFeeBump(FeeBumpTransaction::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionSignaturePayloadTaggedTransaction {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::EnvelopeTypeTx(v) => v.write_xdr(w)?,

                Self::EnvelopeTypeTxFeeBump(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// PathPaymentStrictReceiveResultSuccess
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct PathPaymentStrictReceiveResultSuccess {
    pub offers: VecM<ClaimAtom>,

    pub last: SimplePaymentResult,
}

impl ReadXdr for PathPaymentStrictReceiveResultSuccess {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                offers: VecM::<ClaimAtom>::read_xdr(r)?,

                last: SimplePaymentResult::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PathPaymentStrictReceiveResultSuccess {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.offers.write_xdr(w)?;

            self.last.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PathPaymentStrictSendResultSuccess
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct PathPaymentStrictSendResultSuccess {
    pub offers: VecM<ClaimAtom>,

    pub last: SimplePaymentResult,
}

impl ReadXdr for PathPaymentStrictSendResultSuccess {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                offers: VecM::<ClaimAtom>::read_xdr(r)?,

                last: SimplePaymentResult::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PathPaymentStrictSendResultSuccess {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.offers.write_xdr(w)?;

            self.last.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ManageOfferSuccessResultOffer
// union with discriminant ManageOfferEffect
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ManageOfferSuccessResultOffer {
    ManageOfferCreated(OfferEntry),

    ManageOfferUpdated(OfferEntry),

    ManageOfferDeleted,
}

#[cfg(feature = "alloc")]
impl Default for ManageOfferSuccessResultOffer {
    fn default() -> Self {
        Self::ManageOfferCreated(OfferEntry::default())
    }
}

impl ManageOfferSuccessResultOffer {
    pub const VARIANTS: [ManageOfferEffect; 3] = [
        ManageOfferEffect::ManageOfferCreated,
        ManageOfferEffect::ManageOfferUpdated,
        ManageOfferEffect::ManageOfferDeleted,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "ManageOfferCreated",
        "ManageOfferUpdated",
        "ManageOfferDeleted",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ManageOfferCreated(_) => "ManageOfferCreated",

            Self::ManageOfferUpdated(_) => "ManageOfferUpdated",

            Self::ManageOfferDeleted => "ManageOfferDeleted",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ManageOfferEffect {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ManageOfferCreated(_) => ManageOfferEffect::ManageOfferCreated,

            Self::ManageOfferUpdated(_) => ManageOfferEffect::ManageOfferUpdated,

            Self::ManageOfferDeleted => ManageOfferEffect::ManageOfferDeleted,
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageOfferEffect; 3] {
        Self::VARIANTS
    }
}

impl Name for ManageOfferSuccessResultOffer {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ManageOfferEffect> for ManageOfferSuccessResultOffer {
    #[must_use]
    fn discriminant(&self) -> ManageOfferEffect {
        Self::discriminant(self)
    }
}

impl Variants<ManageOfferEffect> for ManageOfferSuccessResultOffer {
    fn variants() -> slice::Iter<'static, ManageOfferEffect> {
        Self::VARIANTS.iter()
    }
}

impl Union<ManageOfferEffect> for ManageOfferSuccessResultOffer {}

impl ReadXdr for ManageOfferSuccessResultOffer {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ManageOfferEffect = <ManageOfferEffect as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ManageOfferEffect::ManageOfferCreated => {
                    Self::ManageOfferCreated(OfferEntry::read_xdr(r)?)
                }

                ManageOfferEffect::ManageOfferUpdated => {
                    Self::ManageOfferUpdated(OfferEntry::read_xdr(r)?)
                }

                ManageOfferEffect::ManageOfferDeleted => Self::ManageOfferDeleted,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ManageOfferSuccessResultOffer {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ManageOfferCreated(v) => v.write_xdr(w)?,

                Self::ManageOfferUpdated(v) => v.write_xdr(w)?,

                Self::ManageOfferDeleted => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// OperationResultTr
// union with discriminant OperationType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum OperationResultTr {
    CreateAccount(CreateAccountResult),

    Payment(PaymentResult),

    PathPaymentStrictReceive(PathPaymentStrictReceiveResult),

    ManageSellOffer(ManageSellOfferResult),

    CreatePassiveSellOffer(ManageSellOfferResult),

    SetOptions(SetOptionsResult),

    ChangeTrust(ChangeTrustResult),

    AllowTrust(AllowTrustResult),

    AccountMerge(AccountMergeResult),

    Inflation(InflationResult),

    ManageData(ManageDataResult),

    BumpSequence(BumpSequenceResult),

    ManageBuyOffer(ManageBuyOfferResult),

    PathPaymentStrictSend(PathPaymentStrictSendResult),

    CreateClaimableBalance(CreateClaimableBalanceResult),

    ClaimClaimableBalance(ClaimClaimableBalanceResult),

    BeginSponsoringFutureReserves(BeginSponsoringFutureReservesResult),

    EndSponsoringFutureReserves(EndSponsoringFutureReservesResult),

    RevokeSponsorship(RevokeSponsorshipResult),

    Clawback(ClawbackResult),

    ClawbackClaimableBalance(ClawbackClaimableBalanceResult),

    SetTrustLineFlags(SetTrustLineFlagsResult),

    LiquidityPoolDeposit(LiquidityPoolDepositResult),

    LiquidityPoolWithdraw(LiquidityPoolWithdrawResult),

    InvokeHostFunction(InvokeHostFunctionResult),

    ExtendFootprintTtl(ExtendFootprintTtlResult),

    RestoreFootprint(RestoreFootprintResult),
}

#[cfg(feature = "alloc")]
impl Default for OperationResultTr {
    fn default() -> Self {
        Self::CreateAccount(CreateAccountResult::default())
    }
}

impl OperationResultTr {
    pub const VARIANTS: [OperationType; 27] = [
        OperationType::CreateAccount,
        OperationType::Payment,
        OperationType::PathPaymentStrictReceive,
        OperationType::ManageSellOffer,
        OperationType::CreatePassiveSellOffer,
        OperationType::SetOptions,
        OperationType::ChangeTrust,
        OperationType::AllowTrust,
        OperationType::AccountMerge,
        OperationType::Inflation,
        OperationType::ManageData,
        OperationType::BumpSequence,
        OperationType::ManageBuyOffer,
        OperationType::PathPaymentStrictSend,
        OperationType::CreateClaimableBalance,
        OperationType::ClaimClaimableBalance,
        OperationType::BeginSponsoringFutureReserves,
        OperationType::EndSponsoringFutureReserves,
        OperationType::RevokeSponsorship,
        OperationType::Clawback,
        OperationType::ClawbackClaimableBalance,
        OperationType::SetTrustLineFlags,
        OperationType::LiquidityPoolDeposit,
        OperationType::LiquidityPoolWithdraw,
        OperationType::InvokeHostFunction,
        OperationType::ExtendFootprintTtl,
        OperationType::RestoreFootprint,
    ];
    pub const VARIANTS_STR: [&'static str; 27] = [
        "CreateAccount",
        "Payment",
        "PathPaymentStrictReceive",
        "ManageSellOffer",
        "CreatePassiveSellOffer",
        "SetOptions",
        "ChangeTrust",
        "AllowTrust",
        "AccountMerge",
        "Inflation",
        "ManageData",
        "BumpSequence",
        "ManageBuyOffer",
        "PathPaymentStrictSend",
        "CreateClaimableBalance",
        "ClaimClaimableBalance",
        "BeginSponsoringFutureReserves",
        "EndSponsoringFutureReserves",
        "RevokeSponsorship",
        "Clawback",
        "ClawbackClaimableBalance",
        "SetTrustLineFlags",
        "LiquidityPoolDeposit",
        "LiquidityPoolWithdraw",
        "InvokeHostFunction",
        "ExtendFootprintTtl",
        "RestoreFootprint",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::CreateAccount(_) => "CreateAccount",

            Self::Payment(_) => "Payment",

            Self::PathPaymentStrictReceive(_) => "PathPaymentStrictReceive",

            Self::ManageSellOffer(_) => "ManageSellOffer",

            Self::CreatePassiveSellOffer(_) => "CreatePassiveSellOffer",

            Self::SetOptions(_) => "SetOptions",

            Self::ChangeTrust(_) => "ChangeTrust",

            Self::AllowTrust(_) => "AllowTrust",

            Self::AccountMerge(_) => "AccountMerge",

            Self::Inflation(_) => "Inflation",

            Self::ManageData(_) => "ManageData",

            Self::BumpSequence(_) => "BumpSequence",

            Self::ManageBuyOffer(_) => "ManageBuyOffer",

            Self::PathPaymentStrictSend(_) => "PathPaymentStrictSend",

            Self::CreateClaimableBalance(_) => "CreateClaimableBalance",

            Self::ClaimClaimableBalance(_) => "ClaimClaimableBalance",

            Self::BeginSponsoringFutureReserves(_) => "BeginSponsoringFutureReserves",

            Self::EndSponsoringFutureReserves(_) => "EndSponsoringFutureReserves",

            Self::RevokeSponsorship(_) => "RevokeSponsorship",

            Self::Clawback(_) => "Clawback",

            Self::ClawbackClaimableBalance(_) => "ClawbackClaimableBalance",

            Self::SetTrustLineFlags(_) => "SetTrustLineFlags",

            Self::LiquidityPoolDeposit(_) => "LiquidityPoolDeposit",

            Self::LiquidityPoolWithdraw(_) => "LiquidityPoolWithdraw",

            Self::InvokeHostFunction(_) => "InvokeHostFunction",

            Self::ExtendFootprintTtl(_) => "ExtendFootprintTtl",

            Self::RestoreFootprint(_) => "RestoreFootprint",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> OperationType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::CreateAccount(_) => OperationType::CreateAccount,

            Self::Payment(_) => OperationType::Payment,

            Self::PathPaymentStrictReceive(_) => OperationType::PathPaymentStrictReceive,

            Self::ManageSellOffer(_) => OperationType::ManageSellOffer,

            Self::CreatePassiveSellOffer(_) => OperationType::CreatePassiveSellOffer,

            Self::SetOptions(_) => OperationType::SetOptions,

            Self::ChangeTrust(_) => OperationType::ChangeTrust,

            Self::AllowTrust(_) => OperationType::AllowTrust,

            Self::AccountMerge(_) => OperationType::AccountMerge,

            Self::Inflation(_) => OperationType::Inflation,

            Self::ManageData(_) => OperationType::ManageData,

            Self::BumpSequence(_) => OperationType::BumpSequence,

            Self::ManageBuyOffer(_) => OperationType::ManageBuyOffer,

            Self::PathPaymentStrictSend(_) => OperationType::PathPaymentStrictSend,

            Self::CreateClaimableBalance(_) => OperationType::CreateClaimableBalance,

            Self::ClaimClaimableBalance(_) => OperationType::ClaimClaimableBalance,

            Self::BeginSponsoringFutureReserves(_) => OperationType::BeginSponsoringFutureReserves,

            Self::EndSponsoringFutureReserves(_) => OperationType::EndSponsoringFutureReserves,

            Self::RevokeSponsorship(_) => OperationType::RevokeSponsorship,

            Self::Clawback(_) => OperationType::Clawback,

            Self::ClawbackClaimableBalance(_) => OperationType::ClawbackClaimableBalance,

            Self::SetTrustLineFlags(_) => OperationType::SetTrustLineFlags,

            Self::LiquidityPoolDeposit(_) => OperationType::LiquidityPoolDeposit,

            Self::LiquidityPoolWithdraw(_) => OperationType::LiquidityPoolWithdraw,

            Self::InvokeHostFunction(_) => OperationType::InvokeHostFunction,

            Self::ExtendFootprintTtl(_) => OperationType::ExtendFootprintTtl,

            Self::RestoreFootprint(_) => OperationType::RestoreFootprint,
        }
    }

    #[must_use]
    pub const fn variants() -> [OperationType; 27] {
        Self::VARIANTS
    }
}

impl Name for OperationResultTr {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<OperationType> for OperationResultTr {
    #[must_use]
    fn discriminant(&self) -> OperationType {
        Self::discriminant(self)
    }
}

impl Variants<OperationType> for OperationResultTr {
    fn variants() -> slice::Iter<'static, OperationType> {
        Self::VARIANTS.iter()
    }
}

impl Union<OperationType> for OperationResultTr {}

impl ReadXdr for OperationResultTr {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: OperationType = <OperationType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                OperationType::CreateAccount => {
                    Self::CreateAccount(CreateAccountResult::read_xdr(r)?)
                }

                OperationType::Payment => Self::Payment(PaymentResult::read_xdr(r)?),

                OperationType::PathPaymentStrictReceive => {
                    Self::PathPaymentStrictReceive(PathPaymentStrictReceiveResult::read_xdr(r)?)
                }

                OperationType::ManageSellOffer => {
                    Self::ManageSellOffer(ManageSellOfferResult::read_xdr(r)?)
                }

                OperationType::CreatePassiveSellOffer => {
                    Self::CreatePassiveSellOffer(ManageSellOfferResult::read_xdr(r)?)
                }

                OperationType::SetOptions => Self::SetOptions(SetOptionsResult::read_xdr(r)?),

                OperationType::ChangeTrust => Self::ChangeTrust(ChangeTrustResult::read_xdr(r)?),

                OperationType::AllowTrust => Self::AllowTrust(AllowTrustResult::read_xdr(r)?),

                OperationType::AccountMerge => Self::AccountMerge(AccountMergeResult::read_xdr(r)?),

                OperationType::Inflation => Self::Inflation(InflationResult::read_xdr(r)?),

                OperationType::ManageData => Self::ManageData(ManageDataResult::read_xdr(r)?),

                OperationType::BumpSequence => Self::BumpSequence(BumpSequenceResult::read_xdr(r)?),

                OperationType::ManageBuyOffer => {
                    Self::ManageBuyOffer(ManageBuyOfferResult::read_xdr(r)?)
                }

                OperationType::PathPaymentStrictSend => {
                    Self::PathPaymentStrictSend(PathPaymentStrictSendResult::read_xdr(r)?)
                }

                OperationType::CreateClaimableBalance => {
                    Self::CreateClaimableBalance(CreateClaimableBalanceResult::read_xdr(r)?)
                }

                OperationType::ClaimClaimableBalance => {
                    Self::ClaimClaimableBalance(ClaimClaimableBalanceResult::read_xdr(r)?)
                }

                OperationType::BeginSponsoringFutureReserves => {
                    Self::BeginSponsoringFutureReserves(
                        BeginSponsoringFutureReservesResult::read_xdr(r)?,
                    )
                }

                OperationType::EndSponsoringFutureReserves => Self::EndSponsoringFutureReserves(
                    EndSponsoringFutureReservesResult::read_xdr(r)?,
                ),

                OperationType::RevokeSponsorship => {
                    Self::RevokeSponsorship(RevokeSponsorshipResult::read_xdr(r)?)
                }

                OperationType::Clawback => Self::Clawback(ClawbackResult::read_xdr(r)?),

                OperationType::ClawbackClaimableBalance => {
                    Self::ClawbackClaimableBalance(ClawbackClaimableBalanceResult::read_xdr(r)?)
                }

                OperationType::SetTrustLineFlags => {
                    Self::SetTrustLineFlags(SetTrustLineFlagsResult::read_xdr(r)?)
                }

                OperationType::LiquidityPoolDeposit => {
                    Self::LiquidityPoolDeposit(LiquidityPoolDepositResult::read_xdr(r)?)
                }

                OperationType::LiquidityPoolWithdraw => {
                    Self::LiquidityPoolWithdraw(LiquidityPoolWithdrawResult::read_xdr(r)?)
                }

                OperationType::InvokeHostFunction => {
                    Self::InvokeHostFunction(InvokeHostFunctionResult::read_xdr(r)?)
                }

                OperationType::ExtendFootprintTtl => {
                    Self::ExtendFootprintTtl(ExtendFootprintTtlResult::read_xdr(r)?)
                }

                OperationType::RestoreFootprint => {
                    Self::RestoreFootprint(RestoreFootprintResult::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for OperationResultTr {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::CreateAccount(v) => v.write_xdr(w)?,

                Self::Payment(v) => v.write_xdr(w)?,

                Self::PathPaymentStrictReceive(v) => v.write_xdr(w)?,

                Self::ManageSellOffer(v) => v.write_xdr(w)?,

                Self::CreatePassiveSellOffer(v) => v.write_xdr(w)?,

                Self::SetOptions(v) => v.write_xdr(w)?,

                Self::ChangeTrust(v) => v.write_xdr(w)?,

                Self::AllowTrust(v) => v.write_xdr(w)?,

                Self::AccountMerge(v) => v.write_xdr(w)?,

                Self::Inflation(v) => v.write_xdr(w)?,

                Self::ManageData(v) => v.write_xdr(w)?,

                Self::BumpSequence(v) => v.write_xdr(w)?,

                Self::ManageBuyOffer(v) => v.write_xdr(w)?,

                Self::PathPaymentStrictSend(v) => v.write_xdr(w)?,

                Self::CreateClaimableBalance(v) => v.write_xdr(w)?,

                Self::ClaimClaimableBalance(v) => v.write_xdr(w)?,

                Self::BeginSponsoringFutureReserves(v) => v.write_xdr(w)?,

                Self::EndSponsoringFutureReserves(v) => v.write_xdr(w)?,

                Self::RevokeSponsorship(v) => v.write_xdr(w)?,

                Self::Clawback(v) => v.write_xdr(w)?,

                Self::ClawbackClaimableBalance(v) => v.write_xdr(w)?,

                Self::SetTrustLineFlags(v) => v.write_xdr(w)?,

                Self::LiquidityPoolDeposit(v) => v.write_xdr(w)?,

                Self::LiquidityPoolWithdraw(v) => v.write_xdr(w)?,

                Self::InvokeHostFunction(v) => v.write_xdr(w)?,

                Self::ExtendFootprintTtl(v) => v.write_xdr(w)?,

                Self::RestoreFootprint(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// InnerTransactionResultResult
// union with discriminant TransactionResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum InnerTransactionResultResult {
    TxSuccess(VecM<OperationResult>),

    TxFailed(VecM<OperationResult>),

    TxTooEarly,

    TxTooLate,

    TxMissingOperation,

    TxBadSeq,

    TxBadAuth,

    TxInsufficientBalance,

    TxNoAccount,

    TxInsufficientFee,

    TxBadAuthExtra,

    TxInternalError,

    TxNotSupported,

    TxBadSponsorship,

    TxBadMinSeqAgeOrGap,

    TxMalformed,

    TxSorobanInvalid,
}

#[cfg(feature = "alloc")]
impl Default for InnerTransactionResultResult {
    fn default() -> Self {
        Self::TxSuccess(VecM::<OperationResult>::default())
    }
}

impl InnerTransactionResultResult {
    pub const VARIANTS: [TransactionResultCode; 17] = [
        TransactionResultCode::TxSuccess,
        TransactionResultCode::TxFailed,
        TransactionResultCode::TxTooEarly,
        TransactionResultCode::TxTooLate,
        TransactionResultCode::TxMissingOperation,
        TransactionResultCode::TxBadSeq,
        TransactionResultCode::TxBadAuth,
        TransactionResultCode::TxInsufficientBalance,
        TransactionResultCode::TxNoAccount,
        TransactionResultCode::TxInsufficientFee,
        TransactionResultCode::TxBadAuthExtra,
        TransactionResultCode::TxInternalError,
        TransactionResultCode::TxNotSupported,
        TransactionResultCode::TxBadSponsorship,
        TransactionResultCode::TxBadMinSeqAgeOrGap,
        TransactionResultCode::TxMalformed,
        TransactionResultCode::TxSorobanInvalid,
    ];
    pub const VARIANTS_STR: [&'static str; 17] = [
        "TxSuccess",
        "TxFailed",
        "TxTooEarly",
        "TxTooLate",
        "TxMissingOperation",
        "TxBadSeq",
        "TxBadAuth",
        "TxInsufficientBalance",
        "TxNoAccount",
        "TxInsufficientFee",
        "TxBadAuthExtra",
        "TxInternalError",
        "TxNotSupported",
        "TxBadSponsorship",
        "TxBadMinSeqAgeOrGap",
        "TxMalformed",
        "TxSorobanInvalid",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxSuccess(_) => "TxSuccess",

            Self::TxFailed(_) => "TxFailed",

            Self::TxTooEarly => "TxTooEarly",

            Self::TxTooLate => "TxTooLate",

            Self::TxMissingOperation => "TxMissingOperation",

            Self::TxBadSeq => "TxBadSeq",

            Self::TxBadAuth => "TxBadAuth",

            Self::TxInsufficientBalance => "TxInsufficientBalance",

            Self::TxNoAccount => "TxNoAccount",

            Self::TxInsufficientFee => "TxInsufficientFee",

            Self::TxBadAuthExtra => "TxBadAuthExtra",

            Self::TxInternalError => "TxInternalError",

            Self::TxNotSupported => "TxNotSupported",

            Self::TxBadSponsorship => "TxBadSponsorship",

            Self::TxBadMinSeqAgeOrGap => "TxBadMinSeqAgeOrGap",

            Self::TxMalformed => "TxMalformed",

            Self::TxSorobanInvalid => "TxSorobanInvalid",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> TransactionResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::TxSuccess(_) => TransactionResultCode::TxSuccess,

            Self::TxFailed(_) => TransactionResultCode::TxFailed,

            Self::TxTooEarly => TransactionResultCode::TxTooEarly,

            Self::TxTooLate => TransactionResultCode::TxTooLate,

            Self::TxMissingOperation => TransactionResultCode::TxMissingOperation,

            Self::TxBadSeq => TransactionResultCode::TxBadSeq,

            Self::TxBadAuth => TransactionResultCode::TxBadAuth,

            Self::TxInsufficientBalance => TransactionResultCode::TxInsufficientBalance,

            Self::TxNoAccount => TransactionResultCode::TxNoAccount,

            Self::TxInsufficientFee => TransactionResultCode::TxInsufficientFee,

            Self::TxBadAuthExtra => TransactionResultCode::TxBadAuthExtra,

            Self::TxInternalError => TransactionResultCode::TxInternalError,

            Self::TxNotSupported => TransactionResultCode::TxNotSupported,

            Self::TxBadSponsorship => TransactionResultCode::TxBadSponsorship,

            Self::TxBadMinSeqAgeOrGap => TransactionResultCode::TxBadMinSeqAgeOrGap,

            Self::TxMalformed => TransactionResultCode::TxMalformed,

            Self::TxSorobanInvalid => TransactionResultCode::TxSorobanInvalid,
        }
    }

    #[must_use]
    pub const fn variants() -> [TransactionResultCode; 17] {
        Self::VARIANTS
    }
}

impl Name for InnerTransactionResultResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<TransactionResultCode> for InnerTransactionResultResult {
    #[must_use]
    fn discriminant(&self) -> TransactionResultCode {
        Self::discriminant(self)
    }
}

impl Variants<TransactionResultCode> for InnerTransactionResultResult {
    fn variants() -> slice::Iter<'static, TransactionResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<TransactionResultCode> for InnerTransactionResultResult {}

impl ReadXdr for InnerTransactionResultResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: TransactionResultCode = <TransactionResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                TransactionResultCode::TxSuccess => {
                    Self::TxSuccess(VecM::<OperationResult>::read_xdr(r)?)
                }

                TransactionResultCode::TxFailed => {
                    Self::TxFailed(VecM::<OperationResult>::read_xdr(r)?)
                }

                TransactionResultCode::TxTooEarly => Self::TxTooEarly,

                TransactionResultCode::TxTooLate => Self::TxTooLate,

                TransactionResultCode::TxMissingOperation => Self::TxMissingOperation,

                TransactionResultCode::TxBadSeq => Self::TxBadSeq,

                TransactionResultCode::TxBadAuth => Self::TxBadAuth,

                TransactionResultCode::TxInsufficientBalance => Self::TxInsufficientBalance,

                TransactionResultCode::TxNoAccount => Self::TxNoAccount,

                TransactionResultCode::TxInsufficientFee => Self::TxInsufficientFee,

                TransactionResultCode::TxBadAuthExtra => Self::TxBadAuthExtra,

                TransactionResultCode::TxInternalError => Self::TxInternalError,

                TransactionResultCode::TxNotSupported => Self::TxNotSupported,

                TransactionResultCode::TxBadSponsorship => Self::TxBadSponsorship,

                TransactionResultCode::TxBadMinSeqAgeOrGap => Self::TxBadMinSeqAgeOrGap,

                TransactionResultCode::TxMalformed => Self::TxMalformed,

                TransactionResultCode::TxSorobanInvalid => Self::TxSorobanInvalid,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for InnerTransactionResultResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::TxSuccess(v) => v.write_xdr(w)?,

                Self::TxFailed(v) => v.write_xdr(w)?,

                Self::TxTooEarly => ().write_xdr(w)?,

                Self::TxTooLate => ().write_xdr(w)?,

                Self::TxMissingOperation => ().write_xdr(w)?,

                Self::TxBadSeq => ().write_xdr(w)?,

                Self::TxBadAuth => ().write_xdr(w)?,

                Self::TxInsufficientBalance => ().write_xdr(w)?,

                Self::TxNoAccount => ().write_xdr(w)?,

                Self::TxInsufficientFee => ().write_xdr(w)?,

                Self::TxBadAuthExtra => ().write_xdr(w)?,

                Self::TxInternalError => ().write_xdr(w)?,

                Self::TxNotSupported => ().write_xdr(w)?,

                Self::TxBadSponsorship => ().write_xdr(w)?,

                Self::TxBadMinSeqAgeOrGap => ().write_xdr(w)?,

                Self::TxMalformed => ().write_xdr(w)?,

                Self::TxSorobanInvalid => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// InnerTransactionResultExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum InnerTransactionResultExt {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for InnerTransactionResultExt {
    fn default() -> Self {
        Self::V0
    }
}

impl InnerTransactionResultExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for InnerTransactionResultExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for InnerTransactionResultExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for InnerTransactionResultExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for InnerTransactionResultExt {}

impl ReadXdr for InnerTransactionResultExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for InnerTransactionResultExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionResultResult
// union with discriminant TransactionResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TransactionResultResult {
    TxFeeBumpInnerSuccess(InnerTransactionResultPair),

    TxFeeBumpInnerFailed(InnerTransactionResultPair),

    TxSuccess(VecM<OperationResult>),

    TxFailed(VecM<OperationResult>),

    TxTooEarly,

    TxTooLate,

    TxMissingOperation,

    TxBadSeq,

    TxBadAuth,

    TxInsufficientBalance,

    TxNoAccount,

    TxInsufficientFee,

    TxBadAuthExtra,

    TxInternalError,

    TxNotSupported,

    TxBadSponsorship,

    TxBadMinSeqAgeOrGap,

    TxMalformed,

    TxSorobanInvalid,
}

#[cfg(feature = "alloc")]
impl Default for TransactionResultResult {
    fn default() -> Self {
        Self::TxFeeBumpInnerSuccess(InnerTransactionResultPair::default())
    }
}

impl TransactionResultResult {
    pub const VARIANTS: [TransactionResultCode; 19] = [
        TransactionResultCode::TxFeeBumpInnerSuccess,
        TransactionResultCode::TxFeeBumpInnerFailed,
        TransactionResultCode::TxSuccess,
        TransactionResultCode::TxFailed,
        TransactionResultCode::TxTooEarly,
        TransactionResultCode::TxTooLate,
        TransactionResultCode::TxMissingOperation,
        TransactionResultCode::TxBadSeq,
        TransactionResultCode::TxBadAuth,
        TransactionResultCode::TxInsufficientBalance,
        TransactionResultCode::TxNoAccount,
        TransactionResultCode::TxInsufficientFee,
        TransactionResultCode::TxBadAuthExtra,
        TransactionResultCode::TxInternalError,
        TransactionResultCode::TxNotSupported,
        TransactionResultCode::TxBadSponsorship,
        TransactionResultCode::TxBadMinSeqAgeOrGap,
        TransactionResultCode::TxMalformed,
        TransactionResultCode::TxSorobanInvalid,
    ];
    pub const VARIANTS_STR: [&'static str; 19] = [
        "TxFeeBumpInnerSuccess",
        "TxFeeBumpInnerFailed",
        "TxSuccess",
        "TxFailed",
        "TxTooEarly",
        "TxTooLate",
        "TxMissingOperation",
        "TxBadSeq",
        "TxBadAuth",
        "TxInsufficientBalance",
        "TxNoAccount",
        "TxInsufficientFee",
        "TxBadAuthExtra",
        "TxInternalError",
        "TxNotSupported",
        "TxBadSponsorship",
        "TxBadMinSeqAgeOrGap",
        "TxMalformed",
        "TxSorobanInvalid",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxFeeBumpInnerSuccess(_) => "TxFeeBumpInnerSuccess",

            Self::TxFeeBumpInnerFailed(_) => "TxFeeBumpInnerFailed",

            Self::TxSuccess(_) => "TxSuccess",

            Self::TxFailed(_) => "TxFailed",

            Self::TxTooEarly => "TxTooEarly",

            Self::TxTooLate => "TxTooLate",

            Self::TxMissingOperation => "TxMissingOperation",

            Self::TxBadSeq => "TxBadSeq",

            Self::TxBadAuth => "TxBadAuth",

            Self::TxInsufficientBalance => "TxInsufficientBalance",

            Self::TxNoAccount => "TxNoAccount",

            Self::TxInsufficientFee => "TxInsufficientFee",

            Self::TxBadAuthExtra => "TxBadAuthExtra",

            Self::TxInternalError => "TxInternalError",

            Self::TxNotSupported => "TxNotSupported",

            Self::TxBadSponsorship => "TxBadSponsorship",

            Self::TxBadMinSeqAgeOrGap => "TxBadMinSeqAgeOrGap",

            Self::TxMalformed => "TxMalformed",

            Self::TxSorobanInvalid => "TxSorobanInvalid",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> TransactionResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::TxFeeBumpInnerSuccess(_) => TransactionResultCode::TxFeeBumpInnerSuccess,

            Self::TxFeeBumpInnerFailed(_) => TransactionResultCode::TxFeeBumpInnerFailed,

            Self::TxSuccess(_) => TransactionResultCode::TxSuccess,

            Self::TxFailed(_) => TransactionResultCode::TxFailed,

            Self::TxTooEarly => TransactionResultCode::TxTooEarly,

            Self::TxTooLate => TransactionResultCode::TxTooLate,

            Self::TxMissingOperation => TransactionResultCode::TxMissingOperation,

            Self::TxBadSeq => TransactionResultCode::TxBadSeq,

            Self::TxBadAuth => TransactionResultCode::TxBadAuth,

            Self::TxInsufficientBalance => TransactionResultCode::TxInsufficientBalance,

            Self::TxNoAccount => TransactionResultCode::TxNoAccount,

            Self::TxInsufficientFee => TransactionResultCode::TxInsufficientFee,

            Self::TxBadAuthExtra => TransactionResultCode::TxBadAuthExtra,

            Self::TxInternalError => TransactionResultCode::TxInternalError,

            Self::TxNotSupported => TransactionResultCode::TxNotSupported,

            Self::TxBadSponsorship => TransactionResultCode::TxBadSponsorship,

            Self::TxBadMinSeqAgeOrGap => TransactionResultCode::TxBadMinSeqAgeOrGap,

            Self::TxMalformed => TransactionResultCode::TxMalformed,

            Self::TxSorobanInvalid => TransactionResultCode::TxSorobanInvalid,
        }
    }

    #[must_use]
    pub const fn variants() -> [TransactionResultCode; 19] {
        Self::VARIANTS
    }
}

impl Name for TransactionResultResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<TransactionResultCode> for TransactionResultResult {
    #[must_use]
    fn discriminant(&self) -> TransactionResultCode {
        Self::discriminant(self)
    }
}

impl Variants<TransactionResultCode> for TransactionResultResult {
    fn variants() -> slice::Iter<'static, TransactionResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<TransactionResultCode> for TransactionResultResult {}

impl ReadXdr for TransactionResultResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: TransactionResultCode = <TransactionResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                TransactionResultCode::TxFeeBumpInnerSuccess => {
                    Self::TxFeeBumpInnerSuccess(InnerTransactionResultPair::read_xdr(r)?)
                }

                TransactionResultCode::TxFeeBumpInnerFailed => {
                    Self::TxFeeBumpInnerFailed(InnerTransactionResultPair::read_xdr(r)?)
                }

                TransactionResultCode::TxSuccess => {
                    Self::TxSuccess(VecM::<OperationResult>::read_xdr(r)?)
                }

                TransactionResultCode::TxFailed => {
                    Self::TxFailed(VecM::<OperationResult>::read_xdr(r)?)
                }

                TransactionResultCode::TxTooEarly => Self::TxTooEarly,

                TransactionResultCode::TxTooLate => Self::TxTooLate,

                TransactionResultCode::TxMissingOperation => Self::TxMissingOperation,

                TransactionResultCode::TxBadSeq => Self::TxBadSeq,

                TransactionResultCode::TxBadAuth => Self::TxBadAuth,

                TransactionResultCode::TxInsufficientBalance => Self::TxInsufficientBalance,

                TransactionResultCode::TxNoAccount => Self::TxNoAccount,

                TransactionResultCode::TxInsufficientFee => Self::TxInsufficientFee,

                TransactionResultCode::TxBadAuthExtra => Self::TxBadAuthExtra,

                TransactionResultCode::TxInternalError => Self::TxInternalError,

                TransactionResultCode::TxNotSupported => Self::TxNotSupported,

                TransactionResultCode::TxBadSponsorship => Self::TxBadSponsorship,

                TransactionResultCode::TxBadMinSeqAgeOrGap => Self::TxBadMinSeqAgeOrGap,

                TransactionResultCode::TxMalformed => Self::TxMalformed,

                TransactionResultCode::TxSorobanInvalid => Self::TxSorobanInvalid,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionResultResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::TxFeeBumpInnerSuccess(v) => v.write_xdr(w)?,

                Self::TxFeeBumpInnerFailed(v) => v.write_xdr(w)?,

                Self::TxSuccess(v) => v.write_xdr(w)?,

                Self::TxFailed(v) => v.write_xdr(w)?,

                Self::TxTooEarly => ().write_xdr(w)?,

                Self::TxTooLate => ().write_xdr(w)?,

                Self::TxMissingOperation => ().write_xdr(w)?,

                Self::TxBadSeq => ().write_xdr(w)?,

                Self::TxBadAuth => ().write_xdr(w)?,

                Self::TxInsufficientBalance => ().write_xdr(w)?,

                Self::TxNoAccount => ().write_xdr(w)?,

                Self::TxInsufficientFee => ().write_xdr(w)?,

                Self::TxBadAuthExtra => ().write_xdr(w)?,

                Self::TxInternalError => ().write_xdr(w)?,

                Self::TxNotSupported => ().write_xdr(w)?,

                Self::TxBadSponsorship => ().write_xdr(w)?,

                Self::TxBadMinSeqAgeOrGap => ().write_xdr(w)?,

                Self::TxMalformed => ().write_xdr(w)?,

                Self::TxSorobanInvalid => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionResultExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TransactionResultExt {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for TransactionResultExt {
    fn default() -> Self {
        Self::V0
    }
}

impl TransactionResultExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for TransactionResultExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionResultExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionResultExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionResultExt {}

impl ReadXdr for TransactionResultExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionResultExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SignerKeyEd25519SignedPayload
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay)
)]

pub struct SignerKeyEd25519SignedPayload {
    pub ed25519: Uint256,

    pub payload: BytesM<64>,
}

impl ReadXdr for SignerKeyEd25519SignedPayload {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ed25519: Uint256::read_xdr(r)?,

                payload: BytesM::<64>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SignerKeyEd25519SignedPayload {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ed25519.write_xdr(w)?;

            self.payload.write_xdr(w)?;

            Ok(())
        })
    }
}

#[cfg(all(feature = "serde", feature = "alloc"))]
impl<'de> serde::Deserialize<'de> for SignerKeyEd25519SignedPayload {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        #[derive(Deserialize)]
        struct SignerKeyEd25519SignedPayload {
            ed25519: Uint256,
            payload: BytesM<64>,
        }
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum SignerKeyEd25519SignedPayloadOrString<'a> {
            Str(&'a str),
            String(String),
            SignerKeyEd25519SignedPayload(SignerKeyEd25519SignedPayload),
        }
        match SignerKeyEd25519SignedPayloadOrString::deserialize(deserializer)? {
            SignerKeyEd25519SignedPayloadOrString::Str(s) => {
                s.parse().map_err(serde::de::Error::custom)
            }
            SignerKeyEd25519SignedPayloadOrString::String(s) => {
                s.parse().map_err(serde::de::Error::custom)
            }
            SignerKeyEd25519SignedPayloadOrString::SignerKeyEd25519SignedPayload(
                SignerKeyEd25519SignedPayload { ed25519, payload },
            ) => Ok(self::SignerKeyEd25519SignedPayload { ed25519, payload }),
        }
    }
}

/// Value
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Value(pub BytesM);

impl From<Value> for BytesM {
    #[must_use]
    fn from(x: Value) -> Self {
        x.0
    }
}

impl From<BytesM> for Value {
    #[must_use]
    fn from(x: BytesM) -> Self {
        Value(x)
    }
}

impl AsRef<BytesM> for Value {
    #[must_use]
    fn as_ref(&self) -> &BytesM {
        &self.0
    }
}

impl ReadXdr for Value {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = BytesM::read_xdr(r)?;
            let v = Value(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Value {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for Value {
    type Target = BytesM;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<Value> for Vec<u8> {
    #[must_use]
    fn from(x: Value) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for Value {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        Ok(Value(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for Value {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        Ok(Value(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for Value {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for Value {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// ScpBallot
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScpBallot {
    pub counter: u32,

    pub value: Value,
}

impl ReadXdr for ScpBallot {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                counter: u32::read_xdr(r)?,

                value: Value::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpBallot {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.counter.write_xdr(w)?;

            self.value.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScpStatementType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScpStatementType {
    #[cfg_attr(feature = "alloc", default)]
    ScpStPrepare = 0,

    ScpStConfirm = 1,

    ScpStExternalize = 2,

    ScpStNominate = 3,
}

impl ScpStatementType {
    pub const VARIANTS: [ScpStatementType; 4] = [
        ScpStatementType::ScpStPrepare,
        ScpStatementType::ScpStConfirm,
        ScpStatementType::ScpStExternalize,
        ScpStatementType::ScpStNominate,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "ScpStPrepare",
        "ScpStConfirm",
        "ScpStExternalize",
        "ScpStNominate",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScpStPrepare => "ScpStPrepare",

            Self::ScpStConfirm => "ScpStConfirm",

            Self::ScpStExternalize => "ScpStExternalize",

            Self::ScpStNominate => "ScpStNominate",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScpStatementType; 4] {
        Self::VARIANTS
    }
}

impl Name for ScpStatementType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScpStatementType> for ScpStatementType {
    fn variants() -> slice::Iter<'static, ScpStatementType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScpStatementType {}

impl fmt::Display for ScpStatementType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScpStatementType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScpStatementType::ScpStPrepare,

            1 => ScpStatementType::ScpStConfirm,

            2 => ScpStatementType::ScpStExternalize,

            3 => ScpStatementType::ScpStNominate,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScpStatementType> for i32 {
    #[must_use]
    fn from(e: ScpStatementType) -> Self {
        e as Self
    }
}

impl ReadXdr for ScpStatementType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScpStatementType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScpNomination
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScpNomination {
    pub quorum_set_hash: Hash,

    pub votes: VecM<Value>,

    pub accepted: VecM<Value>,
}

impl ReadXdr for ScpNomination {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                quorum_set_hash: Hash::read_xdr(r)?,

                votes: VecM::<Value>::read_xdr(r)?,

                accepted: VecM::<Value>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpNomination {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.quorum_set_hash.write_xdr(w)?;

            self.votes.write_xdr(w)?;

            self.accepted.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScpStatement
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScpStatement {
    pub node_id: NodeId,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub slot_index: u64,

    pub pledges: ScpStatementPledges,
}

impl ReadXdr for ScpStatement {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                node_id: NodeId::read_xdr(r)?,

                slot_index: u64::read_xdr(r)?,

                pledges: ScpStatementPledges::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpStatement {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.node_id.write_xdr(w)?;

            self.slot_index.write_xdr(w)?;

            self.pledges.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScpEnvelope
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScpEnvelope {
    pub statement: ScpStatement,

    pub signature: Signature,
}

impl ReadXdr for ScpEnvelope {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                statement: ScpStatement::read_xdr(r)?,

                signature: Signature::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpEnvelope {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.statement.write_xdr(w)?;

            self.signature.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScpQuorumSet
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScpQuorumSet {
    pub threshold: u32,

    pub validators: VecM<NodeId>,

    pub inner_sets: VecM<ScpQuorumSet>,
}

impl ReadXdr for ScpQuorumSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                threshold: u32::read_xdr(r)?,

                validators: VecM::<NodeId>::read_xdr(r)?,

                inner_sets: VecM::<ScpQuorumSet>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpQuorumSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.threshold.write_xdr(w)?;

            self.validators.write_xdr(w)?;

            self.inner_sets.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ConfigSettingContractExecutionLanesV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ConfigSettingContractExecutionLanesV0 {
    pub ledger_max_tx_count: u32,
}

impl ReadXdr for ConfigSettingContractExecutionLanesV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_max_tx_count: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractExecutionLanesV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_max_tx_count.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ConfigSettingContractComputeV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ConfigSettingContractComputeV0 {
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub ledger_max_instructions: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub tx_max_instructions: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee_rate_per_instructions_increment: i64,

    pub tx_memory_limit: u32,
}

impl ReadXdr for ConfigSettingContractComputeV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_max_instructions: i64::read_xdr(r)?,

                tx_max_instructions: i64::read_xdr(r)?,

                fee_rate_per_instructions_increment: i64::read_xdr(r)?,

                tx_memory_limit: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractComputeV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_max_instructions.write_xdr(w)?;

            self.tx_max_instructions.write_xdr(w)?;

            self.fee_rate_per_instructions_increment.write_xdr(w)?;

            self.tx_memory_limit.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ConfigSettingContractParallelComputeV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ConfigSettingContractParallelComputeV0 {
    pub ledger_max_dependent_tx_clusters: u32,
}

impl ReadXdr for ConfigSettingContractParallelComputeV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_max_dependent_tx_clusters: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractParallelComputeV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_max_dependent_tx_clusters.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ConfigSettingContractLedgerCostV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ConfigSettingContractLedgerCostV0 {
    pub ledger_max_disk_read_entries: u32,

    pub ledger_max_disk_read_bytes: u32,

    pub ledger_max_write_ledger_entries: u32,

    pub ledger_max_write_bytes: u32,

    pub tx_max_disk_read_entries: u32,

    pub tx_max_disk_read_bytes: u32,

    pub tx_max_write_ledger_entries: u32,

    pub tx_max_write_bytes: u32,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee_disk_read_ledger_entry: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee_write_ledger_entry: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee_disk_read1_kb: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub soroban_state_target_size_bytes: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub rent_fee1_kb_soroban_state_size_low: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub rent_fee1_kb_soroban_state_size_high: i64,

    pub soroban_state_rent_fee_growth_factor: u32,
}

impl ReadXdr for ConfigSettingContractLedgerCostV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_max_disk_read_entries: u32::read_xdr(r)?,

                ledger_max_disk_read_bytes: u32::read_xdr(r)?,

                ledger_max_write_ledger_entries: u32::read_xdr(r)?,

                ledger_max_write_bytes: u32::read_xdr(r)?,

                tx_max_disk_read_entries: u32::read_xdr(r)?,

                tx_max_disk_read_bytes: u32::read_xdr(r)?,

                tx_max_write_ledger_entries: u32::read_xdr(r)?,

                tx_max_write_bytes: u32::read_xdr(r)?,

                fee_disk_read_ledger_entry: i64::read_xdr(r)?,

                fee_write_ledger_entry: i64::read_xdr(r)?,

                fee_disk_read1_kb: i64::read_xdr(r)?,

                soroban_state_target_size_bytes: i64::read_xdr(r)?,

                rent_fee1_kb_soroban_state_size_low: i64::read_xdr(r)?,

                rent_fee1_kb_soroban_state_size_high: i64::read_xdr(r)?,

                soroban_state_rent_fee_growth_factor: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractLedgerCostV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_max_disk_read_entries.write_xdr(w)?;

            self.ledger_max_disk_read_bytes.write_xdr(w)?;

            self.ledger_max_write_ledger_entries.write_xdr(w)?;

            self.ledger_max_write_bytes.write_xdr(w)?;

            self.tx_max_disk_read_entries.write_xdr(w)?;

            self.tx_max_disk_read_bytes.write_xdr(w)?;

            self.tx_max_write_ledger_entries.write_xdr(w)?;

            self.tx_max_write_bytes.write_xdr(w)?;

            self.fee_disk_read_ledger_entry.write_xdr(w)?;

            self.fee_write_ledger_entry.write_xdr(w)?;

            self.fee_disk_read1_kb.write_xdr(w)?;

            self.soroban_state_target_size_bytes.write_xdr(w)?;

            self.rent_fee1_kb_soroban_state_size_low.write_xdr(w)?;

            self.rent_fee1_kb_soroban_state_size_high.write_xdr(w)?;

            self.soroban_state_rent_fee_growth_factor.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ConfigSettingContractLedgerCostExtV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ConfigSettingContractLedgerCostExtV0 {
    pub tx_max_footprint_entries: u32,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee_write1_kb: i64,
}

impl ReadXdr for ConfigSettingContractLedgerCostExtV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_max_footprint_entries: u32::read_xdr(r)?,

                fee_write1_kb: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractLedgerCostExtV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.tx_max_footprint_entries.write_xdr(w)?;

            self.fee_write1_kb.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ConfigSettingContractHistoricalDataV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ConfigSettingContractHistoricalDataV0 {
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee_historical1_kb: i64,
}

impl ReadXdr for ConfigSettingContractHistoricalDataV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                fee_historical1_kb: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractHistoricalDataV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.fee_historical1_kb.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ConfigSettingContractEventsV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ConfigSettingContractEventsV0 {
    pub tx_max_contract_events_size_bytes: u32,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee_contract_events1_kb: i64,
}

impl ReadXdr for ConfigSettingContractEventsV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_max_contract_events_size_bytes: u32::read_xdr(r)?,

                fee_contract_events1_kb: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractEventsV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.tx_max_contract_events_size_bytes.write_xdr(w)?;

            self.fee_contract_events1_kb.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ConfigSettingContractBandwidthV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ConfigSettingContractBandwidthV0 {
    pub ledger_max_txs_size_bytes: u32,

    pub tx_max_size_bytes: u32,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee_tx_size1_kb: i64,
}

impl ReadXdr for ConfigSettingContractBandwidthV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_max_txs_size_bytes: u32::read_xdr(r)?,

                tx_max_size_bytes: u32::read_xdr(r)?,

                fee_tx_size1_kb: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractBandwidthV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_max_txs_size_bytes.write_xdr(w)?;

            self.tx_max_size_bytes.write_xdr(w)?;

            self.fee_tx_size1_kb.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ContractCostType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ContractCostType {
    #[cfg_attr(feature = "alloc", default)]
    WasmInsnExec = 0,

    MemAlloc = 1,

    MemCpy = 2,

    MemCmp = 3,

    DispatchHostFunction = 4,

    VisitObject = 5,

    ValSer = 6,

    ValDeser = 7,

    ComputeSha256Hash = 8,

    ComputeEd25519PubKey = 9,

    VerifyEd25519Sig = 10,

    VmInstantiation = 11,

    VmCachedInstantiation = 12,

    InvokeVmFunction = 13,

    ComputeKeccak256Hash = 14,

    DecodeEcdsaCurve256Sig = 15,

    RecoverEcdsaSecp256k1Key = 16,

    Int256AddSub = 17,

    Int256Mul = 18,

    Int256Div = 19,

    Int256Pow = 20,

    Int256Shift = 21,

    ChaCha20DrawBytes = 22,

    ParseWasmInstructions = 23,

    ParseWasmFunctions = 24,

    ParseWasmGlobals = 25,

    ParseWasmTableEntries = 26,

    ParseWasmTypes = 27,

    ParseWasmDataSegments = 28,

    ParseWasmElemSegments = 29,

    ParseWasmImports = 30,

    ParseWasmExports = 31,

    ParseWasmDataSegmentBytes = 32,

    InstantiateWasmInstructions = 33,

    InstantiateWasmFunctions = 34,

    InstantiateWasmGlobals = 35,

    InstantiateWasmTableEntries = 36,

    InstantiateWasmTypes = 37,

    InstantiateWasmDataSegments = 38,

    InstantiateWasmElemSegments = 39,

    InstantiateWasmImports = 40,

    InstantiateWasmExports = 41,

    InstantiateWasmDataSegmentBytes = 42,

    Sec1DecodePointUncompressed = 43,

    VerifyEcdsaSecp256r1Sig = 44,

    Bls12381EncodeFp = 45,

    Bls12381DecodeFp = 46,

    Bls12381G1CheckPointOnCurve = 47,

    Bls12381G1CheckPointInSubgroup = 48,

    Bls12381G2CheckPointOnCurve = 49,

    Bls12381G2CheckPointInSubgroup = 50,

    Bls12381G1ProjectiveToAffine = 51,

    Bls12381G2ProjectiveToAffine = 52,

    Bls12381G1Add = 53,

    Bls12381G1Mul = 54,

    Bls12381G1Msm = 55,

    Bls12381MapFpToG1 = 56,

    Bls12381HashToG1 = 57,

    Bls12381G2Add = 58,

    Bls12381G2Mul = 59,

    Bls12381G2Msm = 60,

    Bls12381MapFp2ToG2 = 61,

    Bls12381HashToG2 = 62,

    Bls12381Pairing = 63,

    Bls12381FrFromU256 = 64,

    Bls12381FrToU256 = 65,

    Bls12381FrAddSub = 66,

    Bls12381FrMul = 67,

    Bls12381FrPow = 68,

    Bls12381FrInv = 69,

    Bn254EncodeFp = 70,

    Bn254DecodeFp = 71,

    Bn254G1CheckPointOnCurve = 72,

    Bn254G2CheckPointOnCurve = 73,

    Bn254G2CheckPointInSubgroup = 74,

    Bn254G1ProjectiveToAffine = 75,

    Bn254G1Add = 76,

    Bn254G1Mul = 77,

    Bn254Pairing = 78,

    Bn254FrFromU256 = 79,

    Bn254FrToU256 = 80,

    Bn254FrAddSub = 81,

    Bn254FrMul = 82,

    Bn254FrPow = 83,

    Bn254FrInv = 84,
}

impl ContractCostType {
    pub const VARIANTS: [ContractCostType; 85] = [
        ContractCostType::WasmInsnExec,
        ContractCostType::MemAlloc,
        ContractCostType::MemCpy,
        ContractCostType::MemCmp,
        ContractCostType::DispatchHostFunction,
        ContractCostType::VisitObject,
        ContractCostType::ValSer,
        ContractCostType::ValDeser,
        ContractCostType::ComputeSha256Hash,
        ContractCostType::ComputeEd25519PubKey,
        ContractCostType::VerifyEd25519Sig,
        ContractCostType::VmInstantiation,
        ContractCostType::VmCachedInstantiation,
        ContractCostType::InvokeVmFunction,
        ContractCostType::ComputeKeccak256Hash,
        ContractCostType::DecodeEcdsaCurve256Sig,
        ContractCostType::RecoverEcdsaSecp256k1Key,
        ContractCostType::Int256AddSub,
        ContractCostType::Int256Mul,
        ContractCostType::Int256Div,
        ContractCostType::Int256Pow,
        ContractCostType::Int256Shift,
        ContractCostType::ChaCha20DrawBytes,
        ContractCostType::ParseWasmInstructions,
        ContractCostType::ParseWasmFunctions,
        ContractCostType::ParseWasmGlobals,
        ContractCostType::ParseWasmTableEntries,
        ContractCostType::ParseWasmTypes,
        ContractCostType::ParseWasmDataSegments,
        ContractCostType::ParseWasmElemSegments,
        ContractCostType::ParseWasmImports,
        ContractCostType::ParseWasmExports,
        ContractCostType::ParseWasmDataSegmentBytes,
        ContractCostType::InstantiateWasmInstructions,
        ContractCostType::InstantiateWasmFunctions,
        ContractCostType::InstantiateWasmGlobals,
        ContractCostType::InstantiateWasmTableEntries,
        ContractCostType::InstantiateWasmTypes,
        ContractCostType::InstantiateWasmDataSegments,
        ContractCostType::InstantiateWasmElemSegments,
        ContractCostType::InstantiateWasmImports,
        ContractCostType::InstantiateWasmExports,
        ContractCostType::InstantiateWasmDataSegmentBytes,
        ContractCostType::Sec1DecodePointUncompressed,
        ContractCostType::VerifyEcdsaSecp256r1Sig,
        ContractCostType::Bls12381EncodeFp,
        ContractCostType::Bls12381DecodeFp,
        ContractCostType::Bls12381G1CheckPointOnCurve,
        ContractCostType::Bls12381G1CheckPointInSubgroup,
        ContractCostType::Bls12381G2CheckPointOnCurve,
        ContractCostType::Bls12381G2CheckPointInSubgroup,
        ContractCostType::Bls12381G1ProjectiveToAffine,
        ContractCostType::Bls12381G2ProjectiveToAffine,
        ContractCostType::Bls12381G1Add,
        ContractCostType::Bls12381G1Mul,
        ContractCostType::Bls12381G1Msm,
        ContractCostType::Bls12381MapFpToG1,
        ContractCostType::Bls12381HashToG1,
        ContractCostType::Bls12381G2Add,
        ContractCostType::Bls12381G2Mul,
        ContractCostType::Bls12381G2Msm,
        ContractCostType::Bls12381MapFp2ToG2,
        ContractCostType::Bls12381HashToG2,
        ContractCostType::Bls12381Pairing,
        ContractCostType::Bls12381FrFromU256,
        ContractCostType::Bls12381FrToU256,
        ContractCostType::Bls12381FrAddSub,
        ContractCostType::Bls12381FrMul,
        ContractCostType::Bls12381FrPow,
        ContractCostType::Bls12381FrInv,
        ContractCostType::Bn254EncodeFp,
        ContractCostType::Bn254DecodeFp,
        ContractCostType::Bn254G1CheckPointOnCurve,
        ContractCostType::Bn254G2CheckPointOnCurve,
        ContractCostType::Bn254G2CheckPointInSubgroup,
        ContractCostType::Bn254G1ProjectiveToAffine,
        ContractCostType::Bn254G1Add,
        ContractCostType::Bn254G1Mul,
        ContractCostType::Bn254Pairing,
        ContractCostType::Bn254FrFromU256,
        ContractCostType::Bn254FrToU256,
        ContractCostType::Bn254FrAddSub,
        ContractCostType::Bn254FrMul,
        ContractCostType::Bn254FrPow,
        ContractCostType::Bn254FrInv,
    ];
    pub const VARIANTS_STR: [&'static str; 85] = [
        "WasmInsnExec",
        "MemAlloc",
        "MemCpy",
        "MemCmp",
        "DispatchHostFunction",
        "VisitObject",
        "ValSer",
        "ValDeser",
        "ComputeSha256Hash",
        "ComputeEd25519PubKey",
        "VerifyEd25519Sig",
        "VmInstantiation",
        "VmCachedInstantiation",
        "InvokeVmFunction",
        "ComputeKeccak256Hash",
        "DecodeEcdsaCurve256Sig",
        "RecoverEcdsaSecp256k1Key",
        "Int256AddSub",
        "Int256Mul",
        "Int256Div",
        "Int256Pow",
        "Int256Shift",
        "ChaCha20DrawBytes",
        "ParseWasmInstructions",
        "ParseWasmFunctions",
        "ParseWasmGlobals",
        "ParseWasmTableEntries",
        "ParseWasmTypes",
        "ParseWasmDataSegments",
        "ParseWasmElemSegments",
        "ParseWasmImports",
        "ParseWasmExports",
        "ParseWasmDataSegmentBytes",
        "InstantiateWasmInstructions",
        "InstantiateWasmFunctions",
        "InstantiateWasmGlobals",
        "InstantiateWasmTableEntries",
        "InstantiateWasmTypes",
        "InstantiateWasmDataSegments",
        "InstantiateWasmElemSegments",
        "InstantiateWasmImports",
        "InstantiateWasmExports",
        "InstantiateWasmDataSegmentBytes",
        "Sec1DecodePointUncompressed",
        "VerifyEcdsaSecp256r1Sig",
        "Bls12381EncodeFp",
        "Bls12381DecodeFp",
        "Bls12381G1CheckPointOnCurve",
        "Bls12381G1CheckPointInSubgroup",
        "Bls12381G2CheckPointOnCurve",
        "Bls12381G2CheckPointInSubgroup",
        "Bls12381G1ProjectiveToAffine",
        "Bls12381G2ProjectiveToAffine",
        "Bls12381G1Add",
        "Bls12381G1Mul",
        "Bls12381G1Msm",
        "Bls12381MapFpToG1",
        "Bls12381HashToG1",
        "Bls12381G2Add",
        "Bls12381G2Mul",
        "Bls12381G2Msm",
        "Bls12381MapFp2ToG2",
        "Bls12381HashToG2",
        "Bls12381Pairing",
        "Bls12381FrFromU256",
        "Bls12381FrToU256",
        "Bls12381FrAddSub",
        "Bls12381FrMul",
        "Bls12381FrPow",
        "Bls12381FrInv",
        "Bn254EncodeFp",
        "Bn254DecodeFp",
        "Bn254G1CheckPointOnCurve",
        "Bn254G2CheckPointOnCurve",
        "Bn254G2CheckPointInSubgroup",
        "Bn254G1ProjectiveToAffine",
        "Bn254G1Add",
        "Bn254G1Mul",
        "Bn254Pairing",
        "Bn254FrFromU256",
        "Bn254FrToU256",
        "Bn254FrAddSub",
        "Bn254FrMul",
        "Bn254FrPow",
        "Bn254FrInv",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::WasmInsnExec => "WasmInsnExec",

            Self::MemAlloc => "MemAlloc",

            Self::MemCpy => "MemCpy",

            Self::MemCmp => "MemCmp",

            Self::DispatchHostFunction => "DispatchHostFunction",

            Self::VisitObject => "VisitObject",

            Self::ValSer => "ValSer",

            Self::ValDeser => "ValDeser",

            Self::ComputeSha256Hash => "ComputeSha256Hash",

            Self::ComputeEd25519PubKey => "ComputeEd25519PubKey",

            Self::VerifyEd25519Sig => "VerifyEd25519Sig",

            Self::VmInstantiation => "VmInstantiation",

            Self::VmCachedInstantiation => "VmCachedInstantiation",

            Self::InvokeVmFunction => "InvokeVmFunction",

            Self::ComputeKeccak256Hash => "ComputeKeccak256Hash",

            Self::DecodeEcdsaCurve256Sig => "DecodeEcdsaCurve256Sig",

            Self::RecoverEcdsaSecp256k1Key => "RecoverEcdsaSecp256k1Key",

            Self::Int256AddSub => "Int256AddSub",

            Self::Int256Mul => "Int256Mul",

            Self::Int256Div => "Int256Div",

            Self::Int256Pow => "Int256Pow",

            Self::Int256Shift => "Int256Shift",

            Self::ChaCha20DrawBytes => "ChaCha20DrawBytes",

            Self::ParseWasmInstructions => "ParseWasmInstructions",

            Self::ParseWasmFunctions => "ParseWasmFunctions",

            Self::ParseWasmGlobals => "ParseWasmGlobals",

            Self::ParseWasmTableEntries => "ParseWasmTableEntries",

            Self::ParseWasmTypes => "ParseWasmTypes",

            Self::ParseWasmDataSegments => "ParseWasmDataSegments",

            Self::ParseWasmElemSegments => "ParseWasmElemSegments",

            Self::ParseWasmImports => "ParseWasmImports",

            Self::ParseWasmExports => "ParseWasmExports",

            Self::ParseWasmDataSegmentBytes => "ParseWasmDataSegmentBytes",

            Self::InstantiateWasmInstructions => "InstantiateWasmInstructions",

            Self::InstantiateWasmFunctions => "InstantiateWasmFunctions",

            Self::InstantiateWasmGlobals => "InstantiateWasmGlobals",

            Self::InstantiateWasmTableEntries => "InstantiateWasmTableEntries",

            Self::InstantiateWasmTypes => "InstantiateWasmTypes",

            Self::InstantiateWasmDataSegments => "InstantiateWasmDataSegments",

            Self::InstantiateWasmElemSegments => "InstantiateWasmElemSegments",

            Self::InstantiateWasmImports => "InstantiateWasmImports",

            Self::InstantiateWasmExports => "InstantiateWasmExports",

            Self::InstantiateWasmDataSegmentBytes => "InstantiateWasmDataSegmentBytes",

            Self::Sec1DecodePointUncompressed => "Sec1DecodePointUncompressed",

            Self::VerifyEcdsaSecp256r1Sig => "VerifyEcdsaSecp256r1Sig",

            Self::Bls12381EncodeFp => "Bls12381EncodeFp",

            Self::Bls12381DecodeFp => "Bls12381DecodeFp",

            Self::Bls12381G1CheckPointOnCurve => "Bls12381G1CheckPointOnCurve",

            Self::Bls12381G1CheckPointInSubgroup => "Bls12381G1CheckPointInSubgroup",

            Self::Bls12381G2CheckPointOnCurve => "Bls12381G2CheckPointOnCurve",

            Self::Bls12381G2CheckPointInSubgroup => "Bls12381G2CheckPointInSubgroup",

            Self::Bls12381G1ProjectiveToAffine => "Bls12381G1ProjectiveToAffine",

            Self::Bls12381G2ProjectiveToAffine => "Bls12381G2ProjectiveToAffine",

            Self::Bls12381G1Add => "Bls12381G1Add",

            Self::Bls12381G1Mul => "Bls12381G1Mul",

            Self::Bls12381G1Msm => "Bls12381G1Msm",

            Self::Bls12381MapFpToG1 => "Bls12381MapFpToG1",

            Self::Bls12381HashToG1 => "Bls12381HashToG1",

            Self::Bls12381G2Add => "Bls12381G2Add",

            Self::Bls12381G2Mul => "Bls12381G2Mul",

            Self::Bls12381G2Msm => "Bls12381G2Msm",

            Self::Bls12381MapFp2ToG2 => "Bls12381MapFp2ToG2",

            Self::Bls12381HashToG2 => "Bls12381HashToG2",

            Self::Bls12381Pairing => "Bls12381Pairing",

            Self::Bls12381FrFromU256 => "Bls12381FrFromU256",

            Self::Bls12381FrToU256 => "Bls12381FrToU256",

            Self::Bls12381FrAddSub => "Bls12381FrAddSub",

            Self::Bls12381FrMul => "Bls12381FrMul",

            Self::Bls12381FrPow => "Bls12381FrPow",

            Self::Bls12381FrInv => "Bls12381FrInv",

            Self::Bn254EncodeFp => "Bn254EncodeFp",

            Self::Bn254DecodeFp => "Bn254DecodeFp",

            Self::Bn254G1CheckPointOnCurve => "Bn254G1CheckPointOnCurve",

            Self::Bn254G2CheckPointOnCurve => "Bn254G2CheckPointOnCurve",

            Self::Bn254G2CheckPointInSubgroup => "Bn254G2CheckPointInSubgroup",

            Self::Bn254G1ProjectiveToAffine => "Bn254G1ProjectiveToAffine",

            Self::Bn254G1Add => "Bn254G1Add",

            Self::Bn254G1Mul => "Bn254G1Mul",

            Self::Bn254Pairing => "Bn254Pairing",

            Self::Bn254FrFromU256 => "Bn254FrFromU256",

            Self::Bn254FrToU256 => "Bn254FrToU256",

            Self::Bn254FrAddSub => "Bn254FrAddSub",

            Self::Bn254FrMul => "Bn254FrMul",

            Self::Bn254FrPow => "Bn254FrPow",

            Self::Bn254FrInv => "Bn254FrInv",
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractCostType; 85] {
        Self::VARIANTS
    }
}

impl Name for ContractCostType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ContractCostType> for ContractCostType {
    fn variants() -> slice::Iter<'static, ContractCostType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ContractCostType {}

impl fmt::Display for ContractCostType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ContractCostType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ContractCostType::WasmInsnExec,

            1 => ContractCostType::MemAlloc,

            2 => ContractCostType::MemCpy,

            3 => ContractCostType::MemCmp,

            4 => ContractCostType::DispatchHostFunction,

            5 => ContractCostType::VisitObject,

            6 => ContractCostType::ValSer,

            7 => ContractCostType::ValDeser,

            8 => ContractCostType::ComputeSha256Hash,

            9 => ContractCostType::ComputeEd25519PubKey,

            10 => ContractCostType::VerifyEd25519Sig,

            11 => ContractCostType::VmInstantiation,

            12 => ContractCostType::VmCachedInstantiation,

            13 => ContractCostType::InvokeVmFunction,

            14 => ContractCostType::ComputeKeccak256Hash,

            15 => ContractCostType::DecodeEcdsaCurve256Sig,

            16 => ContractCostType::RecoverEcdsaSecp256k1Key,

            17 => ContractCostType::Int256AddSub,

            18 => ContractCostType::Int256Mul,

            19 => ContractCostType::Int256Div,

            20 => ContractCostType::Int256Pow,

            21 => ContractCostType::Int256Shift,

            22 => ContractCostType::ChaCha20DrawBytes,

            23 => ContractCostType::ParseWasmInstructions,

            24 => ContractCostType::ParseWasmFunctions,

            25 => ContractCostType::ParseWasmGlobals,

            26 => ContractCostType::ParseWasmTableEntries,

            27 => ContractCostType::ParseWasmTypes,

            28 => ContractCostType::ParseWasmDataSegments,

            29 => ContractCostType::ParseWasmElemSegments,

            30 => ContractCostType::ParseWasmImports,

            31 => ContractCostType::ParseWasmExports,

            32 => ContractCostType::ParseWasmDataSegmentBytes,

            33 => ContractCostType::InstantiateWasmInstructions,

            34 => ContractCostType::InstantiateWasmFunctions,

            35 => ContractCostType::InstantiateWasmGlobals,

            36 => ContractCostType::InstantiateWasmTableEntries,

            37 => ContractCostType::InstantiateWasmTypes,

            38 => ContractCostType::InstantiateWasmDataSegments,

            39 => ContractCostType::InstantiateWasmElemSegments,

            40 => ContractCostType::InstantiateWasmImports,

            41 => ContractCostType::InstantiateWasmExports,

            42 => ContractCostType::InstantiateWasmDataSegmentBytes,

            43 => ContractCostType::Sec1DecodePointUncompressed,

            44 => ContractCostType::VerifyEcdsaSecp256r1Sig,

            45 => ContractCostType::Bls12381EncodeFp,

            46 => ContractCostType::Bls12381DecodeFp,

            47 => ContractCostType::Bls12381G1CheckPointOnCurve,

            48 => ContractCostType::Bls12381G1CheckPointInSubgroup,

            49 => ContractCostType::Bls12381G2CheckPointOnCurve,

            50 => ContractCostType::Bls12381G2CheckPointInSubgroup,

            51 => ContractCostType::Bls12381G1ProjectiveToAffine,

            52 => ContractCostType::Bls12381G2ProjectiveToAffine,

            53 => ContractCostType::Bls12381G1Add,

            54 => ContractCostType::Bls12381G1Mul,

            55 => ContractCostType::Bls12381G1Msm,

            56 => ContractCostType::Bls12381MapFpToG1,

            57 => ContractCostType::Bls12381HashToG1,

            58 => ContractCostType::Bls12381G2Add,

            59 => ContractCostType::Bls12381G2Mul,

            60 => ContractCostType::Bls12381G2Msm,

            61 => ContractCostType::Bls12381MapFp2ToG2,

            62 => ContractCostType::Bls12381HashToG2,

            63 => ContractCostType::Bls12381Pairing,

            64 => ContractCostType::Bls12381FrFromU256,

            65 => ContractCostType::Bls12381FrToU256,

            66 => ContractCostType::Bls12381FrAddSub,

            67 => ContractCostType::Bls12381FrMul,

            68 => ContractCostType::Bls12381FrPow,

            69 => ContractCostType::Bls12381FrInv,

            70 => ContractCostType::Bn254EncodeFp,

            71 => ContractCostType::Bn254DecodeFp,

            72 => ContractCostType::Bn254G1CheckPointOnCurve,

            73 => ContractCostType::Bn254G2CheckPointOnCurve,

            74 => ContractCostType::Bn254G2CheckPointInSubgroup,

            75 => ContractCostType::Bn254G1ProjectiveToAffine,

            76 => ContractCostType::Bn254G1Add,

            77 => ContractCostType::Bn254G1Mul,

            78 => ContractCostType::Bn254Pairing,

            79 => ContractCostType::Bn254FrFromU256,

            80 => ContractCostType::Bn254FrToU256,

            81 => ContractCostType::Bn254FrAddSub,

            82 => ContractCostType::Bn254FrMul,

            83 => ContractCostType::Bn254FrPow,

            84 => ContractCostType::Bn254FrInv,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ContractCostType> for i32 {
    #[must_use]
    fn from(e: ContractCostType) -> Self {
        e as Self
    }
}

impl ReadXdr for ContractCostType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ContractCostType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractCostParamEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ContractCostParamEntry {
    pub ext: ExtensionPoint,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub const_term: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub linear_term: i64,
}

impl ReadXdr for ContractCostParamEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                const_term: i64::read_xdr(r)?,

                linear_term: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractCostParamEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.const_term.write_xdr(w)?;

            self.linear_term.write_xdr(w)?;

            Ok(())
        })
    }
}

/// StateArchivalSettings
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct StateArchivalSettings {
    pub max_entry_ttl: u32,

    pub min_temporary_ttl: u32,

    pub min_persistent_ttl: u32,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub persistent_rent_rate_denominator: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub temp_rent_rate_denominator: i64,

    pub max_entries_to_archive: u32,

    pub live_soroban_state_size_window_sample_size: u32,

    pub live_soroban_state_size_window_sample_period: u32,

    pub eviction_scan_size: u32,

    pub starting_eviction_scan_level: u32,
}

impl ReadXdr for StateArchivalSettings {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                max_entry_ttl: u32::read_xdr(r)?,

                min_temporary_ttl: u32::read_xdr(r)?,

                min_persistent_ttl: u32::read_xdr(r)?,

                persistent_rent_rate_denominator: i64::read_xdr(r)?,

                temp_rent_rate_denominator: i64::read_xdr(r)?,

                max_entries_to_archive: u32::read_xdr(r)?,

                live_soroban_state_size_window_sample_size: u32::read_xdr(r)?,

                live_soroban_state_size_window_sample_period: u32::read_xdr(r)?,

                eviction_scan_size: u32::read_xdr(r)?,

                starting_eviction_scan_level: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for StateArchivalSettings {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.max_entry_ttl.write_xdr(w)?;

            self.min_temporary_ttl.write_xdr(w)?;

            self.min_persistent_ttl.write_xdr(w)?;

            self.persistent_rent_rate_denominator.write_xdr(w)?;

            self.temp_rent_rate_denominator.write_xdr(w)?;

            self.max_entries_to_archive.write_xdr(w)?;

            self.live_soroban_state_size_window_sample_size
                .write_xdr(w)?;

            self.live_soroban_state_size_window_sample_period
                .write_xdr(w)?;

            self.eviction_scan_size.write_xdr(w)?;

            self.starting_eviction_scan_level.write_xdr(w)?;

            Ok(())
        })
    }
}

/// EvictionIterator
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct EvictionIterator {
    pub bucket_list_level: u32,

    pub is_curr_bucket: bool,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub bucket_file_offset: u64,
}

impl ReadXdr for EvictionIterator {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                bucket_list_level: u32::read_xdr(r)?,

                is_curr_bucket: bool::read_xdr(r)?,

                bucket_file_offset: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for EvictionIterator {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.bucket_list_level.write_xdr(w)?;

            self.is_curr_bucket.write_xdr(w)?;

            self.bucket_file_offset.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ConfigSettingScpTiming
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ConfigSettingScpTiming {
    pub ledger_target_close_time_milliseconds: u32,

    pub nomination_timeout_initial_milliseconds: u32,

    pub nomination_timeout_increment_milliseconds: u32,

    pub ballot_timeout_initial_milliseconds: u32,

    pub ballot_timeout_increment_milliseconds: u32,
}

impl ReadXdr for ConfigSettingScpTiming {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_target_close_time_milliseconds: u32::read_xdr(r)?,

                nomination_timeout_initial_milliseconds: u32::read_xdr(r)?,

                nomination_timeout_increment_milliseconds: u32::read_xdr(r)?,

                ballot_timeout_initial_milliseconds: u32::read_xdr(r)?,

                ballot_timeout_increment_milliseconds: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingScpTiming {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_target_close_time_milliseconds.write_xdr(w)?;

            self.nomination_timeout_initial_milliseconds.write_xdr(w)?;

            self.nomination_timeout_increment_milliseconds
                .write_xdr(w)?;

            self.ballot_timeout_initial_milliseconds.write_xdr(w)?;

            self.ballot_timeout_increment_milliseconds.write_xdr(w)?;

            Ok(())
        })
    }
}

pub const CONTRACT_COST_COUNT_LIMIT: u64 = 1024;

/// ContractCostParams
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ContractCostParams(pub VecM<ContractCostParamEntry, ContractCostCountLimit>);

impl From<ContractCostParams> for VecM<ContractCostParamEntry, ContractCostCountLimit> {
    #[must_use]
    fn from(x: ContractCostParams) -> Self {
        x.0
    }
}

impl From<VecM<ContractCostParamEntry, ContractCostCountLimit>> for ContractCostParams {
    #[must_use]
    fn from(x: VecM<ContractCostParamEntry, ContractCostCountLimit>) -> Self {
        ContractCostParams(x)
    }
}

impl AsRef<VecM<ContractCostParamEntry, ContractCostCountLimit>> for ContractCostParams {
    #[must_use]
    fn as_ref(&self) -> &VecM<ContractCostParamEntry, ContractCostCountLimit> {
        &self.0
    }
}

impl ReadXdr for ContractCostParams {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = VecM::<ContractCostParamEntry, ContractCostCountLimit>::read_xdr(r)?;
            let v = ContractCostParams(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ContractCostParams {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ContractCostParams {
    type Target = VecM<ContractCostParamEntry, ContractCostCountLimit>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ContractCostParams> for Vec<ContractCostParamEntry> {
    #[must_use]
    fn from(x: ContractCostParams) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<ContractCostParamEntry>> for ContractCostParams {
    type Error = Error;
    fn try_from(x: Vec<ContractCostParamEntry>) -> Result<Self, Error> {
        Ok(ContractCostParams(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<ContractCostParamEntry>> for ContractCostParams {
    type Error = Error;
    fn try_from(x: &Vec<ContractCostParamEntry>) -> Result<Self, Error> {
        Ok(ContractCostParams(x.try_into()?))
    }
}

impl AsRef<Vec<ContractCostParamEntry>> for ContractCostParams {
    #[must_use]
    fn as_ref(&self) -> &Vec<ContractCostParamEntry> {
        &self.0 .0
    }
}

impl AsRef<[ContractCostParamEntry]> for ContractCostParams {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[ContractCostParamEntry] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[ContractCostParamEntry] {
        self.0 .0
    }
}

/// ConfigSettingId
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ConfigSettingId {
    #[cfg_attr(feature = "alloc", default)]
    ConfigSettingContractMaxSizeBytes = 0,

    ConfigSettingContractComputeV0 = 1,

    ConfigSettingContractLedgerCostV0 = 2,

    ConfigSettingContractHistoricalDataV0 = 3,

    ConfigSettingContractEventsV0 = 4,

    ConfigSettingContractBandwidthV0 = 5,

    ConfigSettingContractCostParamsCpuInstructions = 6,

    ConfigSettingContractCostParamsMemoryBytes = 7,

    ConfigSettingContractDataKeySizeBytes = 8,

    ConfigSettingContractDataEntrySizeBytes = 9,

    ConfigSettingStateArchival = 10,

    ConfigSettingContractExecutionLanes = 11,

    ConfigSettingLiveSorobanStateSizeWindow = 12,

    ConfigSettingEvictionIterator = 13,

    ConfigSettingContractParallelComputeV0 = 14,

    ConfigSettingContractLedgerCostExtV0 = 15,

    ConfigSettingScpTiming = 16,
}

impl ConfigSettingId {
    pub const VARIANTS: [ConfigSettingId; 17] = [
        ConfigSettingId::ConfigSettingContractMaxSizeBytes,
        ConfigSettingId::ConfigSettingContractComputeV0,
        ConfigSettingId::ConfigSettingContractLedgerCostV0,
        ConfigSettingId::ConfigSettingContractHistoricalDataV0,
        ConfigSettingId::ConfigSettingContractEventsV0,
        ConfigSettingId::ConfigSettingContractBandwidthV0,
        ConfigSettingId::ConfigSettingContractCostParamsCpuInstructions,
        ConfigSettingId::ConfigSettingContractCostParamsMemoryBytes,
        ConfigSettingId::ConfigSettingContractDataKeySizeBytes,
        ConfigSettingId::ConfigSettingContractDataEntrySizeBytes,
        ConfigSettingId::ConfigSettingStateArchival,
        ConfigSettingId::ConfigSettingContractExecutionLanes,
        ConfigSettingId::ConfigSettingLiveSorobanStateSizeWindow,
        ConfigSettingId::ConfigSettingEvictionIterator,
        ConfigSettingId::ConfigSettingContractParallelComputeV0,
        ConfigSettingId::ConfigSettingContractLedgerCostExtV0,
        ConfigSettingId::ConfigSettingScpTiming,
    ];
    pub const VARIANTS_STR: [&'static str; 17] = [
        "ConfigSettingContractMaxSizeBytes",
        "ConfigSettingContractComputeV0",
        "ConfigSettingContractLedgerCostV0",
        "ConfigSettingContractHistoricalDataV0",
        "ConfigSettingContractEventsV0",
        "ConfigSettingContractBandwidthV0",
        "ConfigSettingContractCostParamsCpuInstructions",
        "ConfigSettingContractCostParamsMemoryBytes",
        "ConfigSettingContractDataKeySizeBytes",
        "ConfigSettingContractDataEntrySizeBytes",
        "ConfigSettingStateArchival",
        "ConfigSettingContractExecutionLanes",
        "ConfigSettingLiveSorobanStateSizeWindow",
        "ConfigSettingEvictionIterator",
        "ConfigSettingContractParallelComputeV0",
        "ConfigSettingContractLedgerCostExtV0",
        "ConfigSettingScpTiming",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ConfigSettingContractMaxSizeBytes => "ConfigSettingContractMaxSizeBytes",

            Self::ConfigSettingContractComputeV0 => "ConfigSettingContractComputeV0",

            Self::ConfigSettingContractLedgerCostV0 => "ConfigSettingContractLedgerCostV0",

            Self::ConfigSettingContractHistoricalDataV0 => "ConfigSettingContractHistoricalDataV0",

            Self::ConfigSettingContractEventsV0 => "ConfigSettingContractEventsV0",

            Self::ConfigSettingContractBandwidthV0 => "ConfigSettingContractBandwidthV0",

            Self::ConfigSettingContractCostParamsCpuInstructions => {
                "ConfigSettingContractCostParamsCpuInstructions"
            }

            Self::ConfigSettingContractCostParamsMemoryBytes => {
                "ConfigSettingContractCostParamsMemoryBytes"
            }

            Self::ConfigSettingContractDataKeySizeBytes => "ConfigSettingContractDataKeySizeBytes",

            Self::ConfigSettingContractDataEntrySizeBytes => {
                "ConfigSettingContractDataEntrySizeBytes"
            }

            Self::ConfigSettingStateArchival => "ConfigSettingStateArchival",

            Self::ConfigSettingContractExecutionLanes => "ConfigSettingContractExecutionLanes",

            Self::ConfigSettingLiveSorobanStateSizeWindow => {
                "ConfigSettingLiveSorobanStateSizeWindow"
            }

            Self::ConfigSettingEvictionIterator => "ConfigSettingEvictionIterator",

            Self::ConfigSettingContractParallelComputeV0 => {
                "ConfigSettingContractParallelComputeV0"
            }

            Self::ConfigSettingContractLedgerCostExtV0 => "ConfigSettingContractLedgerCostExtV0",

            Self::ConfigSettingScpTiming => "ConfigSettingScpTiming",
        }
    }

    #[must_use]
    pub const fn variants() -> [ConfigSettingId; 17] {
        Self::VARIANTS
    }
}

impl Name for ConfigSettingId {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ConfigSettingId> for ConfigSettingId {
    fn variants() -> slice::Iter<'static, ConfigSettingId> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ConfigSettingId {}

impl fmt::Display for ConfigSettingId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ConfigSettingId {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ConfigSettingId::ConfigSettingContractMaxSizeBytes,

            1 => ConfigSettingId::ConfigSettingContractComputeV0,

            2 => ConfigSettingId::ConfigSettingContractLedgerCostV0,

            3 => ConfigSettingId::ConfigSettingContractHistoricalDataV0,

            4 => ConfigSettingId::ConfigSettingContractEventsV0,

            5 => ConfigSettingId::ConfigSettingContractBandwidthV0,

            6 => ConfigSettingId::ConfigSettingContractCostParamsCpuInstructions,

            7 => ConfigSettingId::ConfigSettingContractCostParamsMemoryBytes,

            8 => ConfigSettingId::ConfigSettingContractDataKeySizeBytes,

            9 => ConfigSettingId::ConfigSettingContractDataEntrySizeBytes,

            10 => ConfigSettingId::ConfigSettingStateArchival,

            11 => ConfigSettingId::ConfigSettingContractExecutionLanes,

            12 => ConfigSettingId::ConfigSettingLiveSorobanStateSizeWindow,

            13 => ConfigSettingId::ConfigSettingEvictionIterator,

            14 => ConfigSettingId::ConfigSettingContractParallelComputeV0,

            15 => ConfigSettingId::ConfigSettingContractLedgerCostExtV0,

            16 => ConfigSettingId::ConfigSettingScpTiming,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ConfigSettingId> for i32 {
    #[must_use]
    fn from(e: ConfigSettingId) -> Self {
        e as Self
    }
}

impl ReadXdr for ConfigSettingId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ConfigSettingId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ConfigSettingEntry
// union with discriminant ConfigSettingId
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ConfigSettingEntry {
    ConfigSettingContractMaxSizeBytes(u32),

    ConfigSettingContractComputeV0(ConfigSettingContractComputeV0),

    ConfigSettingContractLedgerCostV0(ConfigSettingContractLedgerCostV0),

    ConfigSettingContractHistoricalDataV0(ConfigSettingContractHistoricalDataV0),

    ConfigSettingContractEventsV0(ConfigSettingContractEventsV0),

    ConfigSettingContractBandwidthV0(ConfigSettingContractBandwidthV0),

    ConfigSettingContractCostParamsCpuInstructions(ContractCostParams),

    ConfigSettingContractCostParamsMemoryBytes(ContractCostParams),

    ConfigSettingContractDataKeySizeBytes(u32),

    ConfigSettingContractDataEntrySizeBytes(u32),

    ConfigSettingStateArchival(StateArchivalSettings),

    ConfigSettingContractExecutionLanes(ConfigSettingContractExecutionLanesV0),

    ConfigSettingLiveSorobanStateSizeWindow(VecM<u64>),

    ConfigSettingEvictionIterator(EvictionIterator),

    ConfigSettingContractParallelComputeV0(ConfigSettingContractParallelComputeV0),

    ConfigSettingContractLedgerCostExtV0(ConfigSettingContractLedgerCostExtV0),

    ConfigSettingScpTiming(ConfigSettingScpTiming),
}

#[cfg(feature = "alloc")]
impl Default for ConfigSettingEntry {
    fn default() -> Self {
        Self::ConfigSettingContractMaxSizeBytes(u32::default())
    }
}

impl ConfigSettingEntry {
    pub const VARIANTS: [ConfigSettingId; 17] = [
        ConfigSettingId::ConfigSettingContractMaxSizeBytes,
        ConfigSettingId::ConfigSettingContractComputeV0,
        ConfigSettingId::ConfigSettingContractLedgerCostV0,
        ConfigSettingId::ConfigSettingContractHistoricalDataV0,
        ConfigSettingId::ConfigSettingContractEventsV0,
        ConfigSettingId::ConfigSettingContractBandwidthV0,
        ConfigSettingId::ConfigSettingContractCostParamsCpuInstructions,
        ConfigSettingId::ConfigSettingContractCostParamsMemoryBytes,
        ConfigSettingId::ConfigSettingContractDataKeySizeBytes,
        ConfigSettingId::ConfigSettingContractDataEntrySizeBytes,
        ConfigSettingId::ConfigSettingStateArchival,
        ConfigSettingId::ConfigSettingContractExecutionLanes,
        ConfigSettingId::ConfigSettingLiveSorobanStateSizeWindow,
        ConfigSettingId::ConfigSettingEvictionIterator,
        ConfigSettingId::ConfigSettingContractParallelComputeV0,
        ConfigSettingId::ConfigSettingContractLedgerCostExtV0,
        ConfigSettingId::ConfigSettingScpTiming,
    ];
    pub const VARIANTS_STR: [&'static str; 17] = [
        "ConfigSettingContractMaxSizeBytes",
        "ConfigSettingContractComputeV0",
        "ConfigSettingContractLedgerCostV0",
        "ConfigSettingContractHistoricalDataV0",
        "ConfigSettingContractEventsV0",
        "ConfigSettingContractBandwidthV0",
        "ConfigSettingContractCostParamsCpuInstructions",
        "ConfigSettingContractCostParamsMemoryBytes",
        "ConfigSettingContractDataKeySizeBytes",
        "ConfigSettingContractDataEntrySizeBytes",
        "ConfigSettingStateArchival",
        "ConfigSettingContractExecutionLanes",
        "ConfigSettingLiveSorobanStateSizeWindow",
        "ConfigSettingEvictionIterator",
        "ConfigSettingContractParallelComputeV0",
        "ConfigSettingContractLedgerCostExtV0",
        "ConfigSettingScpTiming",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ConfigSettingContractMaxSizeBytes(_) => "ConfigSettingContractMaxSizeBytes",

            Self::ConfigSettingContractComputeV0(_) => "ConfigSettingContractComputeV0",

            Self::ConfigSettingContractLedgerCostV0(_) => "ConfigSettingContractLedgerCostV0",

            Self::ConfigSettingContractHistoricalDataV0(_) => {
                "ConfigSettingContractHistoricalDataV0"
            }

            Self::ConfigSettingContractEventsV0(_) => "ConfigSettingContractEventsV0",

            Self::ConfigSettingContractBandwidthV0(_) => "ConfigSettingContractBandwidthV0",

            Self::ConfigSettingContractCostParamsCpuInstructions(_) => {
                "ConfigSettingContractCostParamsCpuInstructions"
            }

            Self::ConfigSettingContractCostParamsMemoryBytes(_) => {
                "ConfigSettingContractCostParamsMemoryBytes"
            }

            Self::ConfigSettingContractDataKeySizeBytes(_) => {
                "ConfigSettingContractDataKeySizeBytes"
            }

            Self::ConfigSettingContractDataEntrySizeBytes(_) => {
                "ConfigSettingContractDataEntrySizeBytes"
            }

            Self::ConfigSettingStateArchival(_) => "ConfigSettingStateArchival",

            Self::ConfigSettingContractExecutionLanes(_) => "ConfigSettingContractExecutionLanes",

            Self::ConfigSettingLiveSorobanStateSizeWindow(_) => {
                "ConfigSettingLiveSorobanStateSizeWindow"
            }

            Self::ConfigSettingEvictionIterator(_) => "ConfigSettingEvictionIterator",

            Self::ConfigSettingContractParallelComputeV0(_) => {
                "ConfigSettingContractParallelComputeV0"
            }

            Self::ConfigSettingContractLedgerCostExtV0(_) => "ConfigSettingContractLedgerCostExtV0",

            Self::ConfigSettingScpTiming(_) => "ConfigSettingScpTiming",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ConfigSettingId {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ConfigSettingContractMaxSizeBytes(_) => {
                ConfigSettingId::ConfigSettingContractMaxSizeBytes
            }

            Self::ConfigSettingContractComputeV0(_) => {
                ConfigSettingId::ConfigSettingContractComputeV0
            }

            Self::ConfigSettingContractLedgerCostV0(_) => {
                ConfigSettingId::ConfigSettingContractLedgerCostV0
            }

            Self::ConfigSettingContractHistoricalDataV0(_) => {
                ConfigSettingId::ConfigSettingContractHistoricalDataV0
            }

            Self::ConfigSettingContractEventsV0(_) => {
                ConfigSettingId::ConfigSettingContractEventsV0
            }

            Self::ConfigSettingContractBandwidthV0(_) => {
                ConfigSettingId::ConfigSettingContractBandwidthV0
            }

            Self::ConfigSettingContractCostParamsCpuInstructions(_) => {
                ConfigSettingId::ConfigSettingContractCostParamsCpuInstructions
            }

            Self::ConfigSettingContractCostParamsMemoryBytes(_) => {
                ConfigSettingId::ConfigSettingContractCostParamsMemoryBytes
            }

            Self::ConfigSettingContractDataKeySizeBytes(_) => {
                ConfigSettingId::ConfigSettingContractDataKeySizeBytes
            }

            Self::ConfigSettingContractDataEntrySizeBytes(_) => {
                ConfigSettingId::ConfigSettingContractDataEntrySizeBytes
            }

            Self::ConfigSettingStateArchival(_) => ConfigSettingId::ConfigSettingStateArchival,

            Self::ConfigSettingContractExecutionLanes(_) => {
                ConfigSettingId::ConfigSettingContractExecutionLanes
            }

            Self::ConfigSettingLiveSorobanStateSizeWindow(_) => {
                ConfigSettingId::ConfigSettingLiveSorobanStateSizeWindow
            }

            Self::ConfigSettingEvictionIterator(_) => {
                ConfigSettingId::ConfigSettingEvictionIterator
            }

            Self::ConfigSettingContractParallelComputeV0(_) => {
                ConfigSettingId::ConfigSettingContractParallelComputeV0
            }

            Self::ConfigSettingContractLedgerCostExtV0(_) => {
                ConfigSettingId::ConfigSettingContractLedgerCostExtV0
            }

            Self::ConfigSettingScpTiming(_) => ConfigSettingId::ConfigSettingScpTiming,
        }
    }

    #[must_use]
    pub const fn variants() -> [ConfigSettingId; 17] {
        Self::VARIANTS
    }
}

impl Name for ConfigSettingEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ConfigSettingId> for ConfigSettingEntry {
    #[must_use]
    fn discriminant(&self) -> ConfigSettingId {
        Self::discriminant(self)
    }
}

impl Variants<ConfigSettingId> for ConfigSettingEntry {
    fn variants() -> slice::Iter<'static, ConfigSettingId> {
        Self::VARIANTS.iter()
    }
}

impl Union<ConfigSettingId> for ConfigSettingEntry {}

impl ReadXdr for ConfigSettingEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ConfigSettingId = <ConfigSettingId as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ConfigSettingId::ConfigSettingContractMaxSizeBytes => {
                    Self::ConfigSettingContractMaxSizeBytes(u32::read_xdr(r)?)
                }

                ConfigSettingId::ConfigSettingContractComputeV0 => {
                    Self::ConfigSettingContractComputeV0(ConfigSettingContractComputeV0::read_xdr(
                        r,
                    )?)
                }

                ConfigSettingId::ConfigSettingContractLedgerCostV0 => {
                    Self::ConfigSettingContractLedgerCostV0(
                        ConfigSettingContractLedgerCostV0::read_xdr(r)?,
                    )
                }

                ConfigSettingId::ConfigSettingContractHistoricalDataV0 => {
                    Self::ConfigSettingContractHistoricalDataV0(
                        ConfigSettingContractHistoricalDataV0::read_xdr(r)?,
                    )
                }

                ConfigSettingId::ConfigSettingContractEventsV0 => {
                    Self::ConfigSettingContractEventsV0(ConfigSettingContractEventsV0::read_xdr(r)?)
                }

                ConfigSettingId::ConfigSettingContractBandwidthV0 => {
                    Self::ConfigSettingContractBandwidthV0(
                        ConfigSettingContractBandwidthV0::read_xdr(r)?,
                    )
                }

                ConfigSettingId::ConfigSettingContractCostParamsCpuInstructions => {
                    Self::ConfigSettingContractCostParamsCpuInstructions(
                        ContractCostParams::read_xdr(r)?,
                    )
                }

                ConfigSettingId::ConfigSettingContractCostParamsMemoryBytes => {
                    Self::ConfigSettingContractCostParamsMemoryBytes(ContractCostParams::read_xdr(
                        r,
                    )?)
                }

                ConfigSettingId::ConfigSettingContractDataKeySizeBytes => {
                    Self::ConfigSettingContractDataKeySizeBytes(u32::read_xdr(r)?)
                }

                ConfigSettingId::ConfigSettingContractDataEntrySizeBytes => {
                    Self::ConfigSettingContractDataEntrySizeBytes(u32::read_xdr(r)?)
                }

                ConfigSettingId::ConfigSettingStateArchival => {
                    Self::ConfigSettingStateArchival(StateArchivalSettings::read_xdr(r)?)
                }

                ConfigSettingId::ConfigSettingContractExecutionLanes => {
                    Self::ConfigSettingContractExecutionLanes(
                        ConfigSettingContractExecutionLanesV0::read_xdr(r)?,
                    )
                }

                ConfigSettingId::ConfigSettingLiveSorobanStateSizeWindow => {
                    Self::ConfigSettingLiveSorobanStateSizeWindow(VecM::<u64>::read_xdr(r)?)
                }

                ConfigSettingId::ConfigSettingEvictionIterator => {
                    Self::ConfigSettingEvictionIterator(EvictionIterator::read_xdr(r)?)
                }

                ConfigSettingId::ConfigSettingContractParallelComputeV0 => {
                    Self::ConfigSettingContractParallelComputeV0(
                        ConfigSettingContractParallelComputeV0::read_xdr(r)?,
                    )
                }

                ConfigSettingId::ConfigSettingContractLedgerCostExtV0 => {
                    Self::ConfigSettingContractLedgerCostExtV0(
                        ConfigSettingContractLedgerCostExtV0::read_xdr(r)?,
                    )
                }

                ConfigSettingId::ConfigSettingScpTiming => {
                    Self::ConfigSettingScpTiming(ConfigSettingScpTiming::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ConfigSettingEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ConfigSettingContractMaxSizeBytes(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractComputeV0(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractLedgerCostV0(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractHistoricalDataV0(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractEventsV0(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractBandwidthV0(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractCostParamsCpuInstructions(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractCostParamsMemoryBytes(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractDataKeySizeBytes(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractDataEntrySizeBytes(v) => v.write_xdr(w)?,

                Self::ConfigSettingStateArchival(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractExecutionLanes(v) => v.write_xdr(w)?,

                Self::ConfigSettingLiveSorobanStateSizeWindow(v) => v.write_xdr(w)?,

                Self::ConfigSettingEvictionIterator(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractParallelComputeV0(v) => v.write_xdr(w)?,

                Self::ConfigSettingContractLedgerCostExtV0(v) => v.write_xdr(w)?,

                Self::ConfigSettingScpTiming(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScEnvMetaKind
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScEnvMetaKind {
    #[cfg_attr(feature = "alloc", default)]
    ScEnvMetaKindInterfaceVersion = 0,
}

impl ScEnvMetaKind {
    pub const VARIANTS: [ScEnvMetaKind; 1] = [ScEnvMetaKind::ScEnvMetaKindInterfaceVersion];
    pub const VARIANTS_STR: [&'static str; 1] = ["ScEnvMetaKindInterfaceVersion"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScEnvMetaKindInterfaceVersion => "ScEnvMetaKindInterfaceVersion",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScEnvMetaKind; 1] {
        Self::VARIANTS
    }
}

impl Name for ScEnvMetaKind {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScEnvMetaKind> for ScEnvMetaKind {
    fn variants() -> slice::Iter<'static, ScEnvMetaKind> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScEnvMetaKind {}

impl fmt::Display for ScEnvMetaKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScEnvMetaKind {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScEnvMetaKind::ScEnvMetaKindInterfaceVersion,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScEnvMetaKind> for i32 {
    #[must_use]
    fn from(e: ScEnvMetaKind) -> Self {
        e as Self
    }
}

impl ReadXdr for ScEnvMetaKind {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScEnvMetaKind {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScEnvMetaEntry
// union with discriminant ScEnvMetaKind
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ScEnvMetaEntry {
    ScEnvMetaKindInterfaceVersion(ScEnvMetaEntryInterfaceVersion),
}

#[cfg(feature = "alloc")]
impl Default for ScEnvMetaEntry {
    fn default() -> Self {
        Self::ScEnvMetaKindInterfaceVersion(ScEnvMetaEntryInterfaceVersion::default())
    }
}

impl ScEnvMetaEntry {
    pub const VARIANTS: [ScEnvMetaKind; 1] = [ScEnvMetaKind::ScEnvMetaKindInterfaceVersion];
    pub const VARIANTS_STR: [&'static str; 1] = ["ScEnvMetaKindInterfaceVersion"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScEnvMetaKindInterfaceVersion(_) => "ScEnvMetaKindInterfaceVersion",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScEnvMetaKind {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ScEnvMetaKindInterfaceVersion(_) => ScEnvMetaKind::ScEnvMetaKindInterfaceVersion,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScEnvMetaKind; 1] {
        Self::VARIANTS
    }
}

impl Name for ScEnvMetaEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScEnvMetaKind> for ScEnvMetaEntry {
    #[must_use]
    fn discriminant(&self) -> ScEnvMetaKind {
        Self::discriminant(self)
    }
}

impl Variants<ScEnvMetaKind> for ScEnvMetaEntry {
    fn variants() -> slice::Iter<'static, ScEnvMetaKind> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScEnvMetaKind> for ScEnvMetaEntry {}

impl ReadXdr for ScEnvMetaEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ScEnvMetaKind = <ScEnvMetaKind as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScEnvMetaKind::ScEnvMetaKindInterfaceVersion => {
                    Self::ScEnvMetaKindInterfaceVersion(ScEnvMetaEntryInterfaceVersion::read_xdr(
                        r,
                    )?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScEnvMetaEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ScEnvMetaKindInterfaceVersion(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScMetaV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScMetaV0 {
    pub key: StringM,

    pub val: StringM,
}

impl ReadXdr for ScMetaV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: StringM::read_xdr(r)?,

                val: StringM::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScMetaV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;

            self.val.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScMetaKind
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScMetaKind {
    #[cfg_attr(feature = "alloc", default)]
    ScMetaV0 = 0,
}

impl ScMetaKind {
    pub const VARIANTS: [ScMetaKind; 1] = [ScMetaKind::ScMetaV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ScMetaV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScMetaV0 => "ScMetaV0",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScMetaKind; 1] {
        Self::VARIANTS
    }
}

impl Name for ScMetaKind {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScMetaKind> for ScMetaKind {
    fn variants() -> slice::Iter<'static, ScMetaKind> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScMetaKind {}

impl fmt::Display for ScMetaKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScMetaKind {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScMetaKind::ScMetaV0,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScMetaKind> for i32 {
    #[must_use]
    fn from(e: ScMetaKind) -> Self {
        e as Self
    }
}

impl ReadXdr for ScMetaKind {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScMetaKind {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScMetaEntry
// union with discriminant ScMetaKind
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ScMetaEntry {
    ScMetaV0(ScMetaV0),
}

#[cfg(feature = "alloc")]
impl Default for ScMetaEntry {
    fn default() -> Self {
        Self::ScMetaV0(ScMetaV0::default())
    }
}

impl ScMetaEntry {
    pub const VARIANTS: [ScMetaKind; 1] = [ScMetaKind::ScMetaV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ScMetaV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScMetaV0(_) => "ScMetaV0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScMetaKind {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ScMetaV0(_) => ScMetaKind::ScMetaV0,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScMetaKind; 1] {
        Self::VARIANTS
    }
}

impl Name for ScMetaEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScMetaKind> for ScMetaEntry {
    #[must_use]
    fn discriminant(&self) -> ScMetaKind {
        Self::discriminant(self)
    }
}

impl Variants<ScMetaKind> for ScMetaEntry {
    fn variants() -> slice::Iter<'static, ScMetaKind> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScMetaKind> for ScMetaEntry {}

impl ReadXdr for ScMetaEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ScMetaKind = <ScMetaKind as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScMetaKind::ScMetaV0 => Self::ScMetaV0(ScMetaV0::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScMetaEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ScMetaV0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

pub const SC_SPEC_DOC_LIMIT: u64 = 1024;

/// ScSpecType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScSpecType {
    #[cfg_attr(feature = "alloc", default)]
    ScSpecTypeVal = 0,

    ScSpecTypeBool = 1,

    ScSpecTypeVoid = 2,

    ScSpecTypeError = 3,

    ScSpecTypeU32 = 4,

    ScSpecTypeI32 = 5,

    ScSpecTypeU64 = 6,

    ScSpecTypeI64 = 7,

    ScSpecTypeTimepoint = 8,

    ScSpecTypeDuration = 9,

    ScSpecTypeU128 = 10,

    ScSpecTypeI128 = 11,

    ScSpecTypeU256 = 12,

    ScSpecTypeI256 = 13,

    ScSpecTypeBytes = 14,

    ScSpecTypeString = 16,

    ScSpecTypeSymbol = 17,

    ScSpecTypeAddress = 19,

    ScSpecTypeMuxedAddress = 20,

    ScSpecTypeOption = 1000,

    ScSpecTypeResult = 1001,

    ScSpecTypeVec = 1002,

    ScSpecTypeMap = 1004,

    ScSpecTypeTuple = 1005,

    ScSpecTypeBytesN = 1006,

    ScSpecTypeUdt = 2000,
}

impl ScSpecType {
    pub const VARIANTS: [ScSpecType; 26] = [
        ScSpecType::ScSpecTypeVal,
        ScSpecType::ScSpecTypeBool,
        ScSpecType::ScSpecTypeVoid,
        ScSpecType::ScSpecTypeError,
        ScSpecType::ScSpecTypeU32,
        ScSpecType::ScSpecTypeI32,
        ScSpecType::ScSpecTypeU64,
        ScSpecType::ScSpecTypeI64,
        ScSpecType::ScSpecTypeTimepoint,
        ScSpecType::ScSpecTypeDuration,
        ScSpecType::ScSpecTypeU128,
        ScSpecType::ScSpecTypeI128,
        ScSpecType::ScSpecTypeU256,
        ScSpecType::ScSpecTypeI256,
        ScSpecType::ScSpecTypeBytes,
        ScSpecType::ScSpecTypeString,
        ScSpecType::ScSpecTypeSymbol,
        ScSpecType::ScSpecTypeAddress,
        ScSpecType::ScSpecTypeMuxedAddress,
        ScSpecType::ScSpecTypeOption,
        ScSpecType::ScSpecTypeResult,
        ScSpecType::ScSpecTypeVec,
        ScSpecType::ScSpecTypeMap,
        ScSpecType::ScSpecTypeTuple,
        ScSpecType::ScSpecTypeBytesN,
        ScSpecType::ScSpecTypeUdt,
    ];
    pub const VARIANTS_STR: [&'static str; 26] = [
        "ScSpecTypeVal",
        "ScSpecTypeBool",
        "ScSpecTypeVoid",
        "ScSpecTypeError",
        "ScSpecTypeU32",
        "ScSpecTypeI32",
        "ScSpecTypeU64",
        "ScSpecTypeI64",
        "ScSpecTypeTimepoint",
        "ScSpecTypeDuration",
        "ScSpecTypeU128",
        "ScSpecTypeI128",
        "ScSpecTypeU256",
        "ScSpecTypeI256",
        "ScSpecTypeBytes",
        "ScSpecTypeString",
        "ScSpecTypeSymbol",
        "ScSpecTypeAddress",
        "ScSpecTypeMuxedAddress",
        "ScSpecTypeOption",
        "ScSpecTypeResult",
        "ScSpecTypeVec",
        "ScSpecTypeMap",
        "ScSpecTypeTuple",
        "ScSpecTypeBytesN",
        "ScSpecTypeUdt",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScSpecTypeVal => "ScSpecTypeVal",

            Self::ScSpecTypeBool => "ScSpecTypeBool",

            Self::ScSpecTypeVoid => "ScSpecTypeVoid",

            Self::ScSpecTypeError => "ScSpecTypeError",

            Self::ScSpecTypeU32 => "ScSpecTypeU32",

            Self::ScSpecTypeI32 => "ScSpecTypeI32",

            Self::ScSpecTypeU64 => "ScSpecTypeU64",

            Self::ScSpecTypeI64 => "ScSpecTypeI64",

            Self::ScSpecTypeTimepoint => "ScSpecTypeTimepoint",

            Self::ScSpecTypeDuration => "ScSpecTypeDuration",

            Self::ScSpecTypeU128 => "ScSpecTypeU128",

            Self::ScSpecTypeI128 => "ScSpecTypeI128",

            Self::ScSpecTypeU256 => "ScSpecTypeU256",

            Self::ScSpecTypeI256 => "ScSpecTypeI256",

            Self::ScSpecTypeBytes => "ScSpecTypeBytes",

            Self::ScSpecTypeString => "ScSpecTypeString",

            Self::ScSpecTypeSymbol => "ScSpecTypeSymbol",

            Self::ScSpecTypeAddress => "ScSpecTypeAddress",

            Self::ScSpecTypeMuxedAddress => "ScSpecTypeMuxedAddress",

            Self::ScSpecTypeOption => "ScSpecTypeOption",

            Self::ScSpecTypeResult => "ScSpecTypeResult",

            Self::ScSpecTypeVec => "ScSpecTypeVec",

            Self::ScSpecTypeMap => "ScSpecTypeMap",

            Self::ScSpecTypeTuple => "ScSpecTypeTuple",

            Self::ScSpecTypeBytesN => "ScSpecTypeBytesN",

            Self::ScSpecTypeUdt => "ScSpecTypeUdt",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecType; 26] {
        Self::VARIANTS
    }
}

impl Name for ScSpecType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScSpecType> for ScSpecType {
    fn variants() -> slice::Iter<'static, ScSpecType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScSpecType {}

impl fmt::Display for ScSpecType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScSpecType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScSpecType::ScSpecTypeVal,

            1 => ScSpecType::ScSpecTypeBool,

            2 => ScSpecType::ScSpecTypeVoid,

            3 => ScSpecType::ScSpecTypeError,

            4 => ScSpecType::ScSpecTypeU32,

            5 => ScSpecType::ScSpecTypeI32,

            6 => ScSpecType::ScSpecTypeU64,

            7 => ScSpecType::ScSpecTypeI64,

            8 => ScSpecType::ScSpecTypeTimepoint,

            9 => ScSpecType::ScSpecTypeDuration,

            10 => ScSpecType::ScSpecTypeU128,

            11 => ScSpecType::ScSpecTypeI128,

            12 => ScSpecType::ScSpecTypeU256,

            13 => ScSpecType::ScSpecTypeI256,

            14 => ScSpecType::ScSpecTypeBytes,

            16 => ScSpecType::ScSpecTypeString,

            17 => ScSpecType::ScSpecTypeSymbol,

            19 => ScSpecType::ScSpecTypeAddress,

            20 => ScSpecType::ScSpecTypeMuxedAddress,

            1000 => ScSpecType::ScSpecTypeOption,

            1001 => ScSpecType::ScSpecTypeResult,

            1002 => ScSpecType::ScSpecTypeVec,

            1004 => ScSpecType::ScSpecTypeMap,

            1005 => ScSpecType::ScSpecTypeTuple,

            1006 => ScSpecType::ScSpecTypeBytesN,

            2000 => ScSpecType::ScSpecTypeUdt,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScSpecType> for i32 {
    #[must_use]
    fn from(e: ScSpecType) -> Self {
        e as Self
    }
}

impl ReadXdr for ScSpecType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScSpecTypeOption
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecTypeOption {
    pub value_type: Box<ScSpecTypeDef>,
}

impl ReadXdr for ScSpecTypeOption {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                value_type: Box::<ScSpecTypeDef>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeOption {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.value_type.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecTypeResult
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecTypeResult {
    pub ok_type: Box<ScSpecTypeDef>,

    pub error_type: Box<ScSpecTypeDef>,
}

impl ReadXdr for ScSpecTypeResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ok_type: Box::<ScSpecTypeDef>::read_xdr(r)?,

                error_type: Box::<ScSpecTypeDef>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ok_type.write_xdr(w)?;

            self.error_type.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecTypeVec
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecTypeVec {
    pub element_type: Box<ScSpecTypeDef>,
}

impl ReadXdr for ScSpecTypeVec {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                element_type: Box::<ScSpecTypeDef>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeVec {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.element_type.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecTypeMap
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecTypeMap {
    pub key_type: Box<ScSpecTypeDef>,

    pub value_type: Box<ScSpecTypeDef>,
}

impl ReadXdr for ScSpecTypeMap {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key_type: Box::<ScSpecTypeDef>::read_xdr(r)?,

                value_type: Box::<ScSpecTypeDef>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeMap {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.key_type.write_xdr(w)?;

            self.value_type.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecTypeTuple
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecTypeTuple {
    pub value_types: VecM<ScSpecTypeDef, 12>,
}

impl ReadXdr for ScSpecTypeTuple {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                value_types: VecM::<ScSpecTypeDef, 12>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeTuple {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.value_types.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecTypeBytesN
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecTypeBytesN {
    pub n: u32,
}

impl ReadXdr for ScSpecTypeBytesN {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                n: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeBytesN {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.n.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecTypeUdt
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecTypeUdt {
    pub name: StringM<60>,
}

impl ReadXdr for ScSpecTypeUdt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                name: StringM::<60>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeUdt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.name.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecTypeDef
// union with discriminant ScSpecType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ScSpecTypeDef {
    ScSpecTypeVal,

    ScSpecTypeBool,

    ScSpecTypeVoid,

    ScSpecTypeError,

    ScSpecTypeU32,

    ScSpecTypeI32,

    ScSpecTypeU64,

    ScSpecTypeI64,

    ScSpecTypeTimepoint,

    ScSpecTypeDuration,

    ScSpecTypeU128,

    ScSpecTypeI128,

    ScSpecTypeU256,

    ScSpecTypeI256,

    ScSpecTypeBytes,

    ScSpecTypeString,

    ScSpecTypeSymbol,

    ScSpecTypeAddress,

    ScSpecTypeMuxedAddress,

    ScSpecTypeOption(Box<ScSpecTypeOption>),

    ScSpecTypeResult(Box<ScSpecTypeResult>),

    ScSpecTypeVec(Box<ScSpecTypeVec>),

    ScSpecTypeMap(Box<ScSpecTypeMap>),

    ScSpecTypeTuple(Box<ScSpecTypeTuple>),

    ScSpecTypeBytesN(ScSpecTypeBytesN),

    ScSpecTypeUdt(ScSpecTypeUdt),
}

#[cfg(feature = "alloc")]
impl Default for ScSpecTypeDef {
    fn default() -> Self {
        Self::ScSpecTypeVal
    }
}

impl ScSpecTypeDef {
    pub const VARIANTS: [ScSpecType; 26] = [
        ScSpecType::ScSpecTypeVal,
        ScSpecType::ScSpecTypeBool,
        ScSpecType::ScSpecTypeVoid,
        ScSpecType::ScSpecTypeError,
        ScSpecType::ScSpecTypeU32,
        ScSpecType::ScSpecTypeI32,
        ScSpecType::ScSpecTypeU64,
        ScSpecType::ScSpecTypeI64,
        ScSpecType::ScSpecTypeTimepoint,
        ScSpecType::ScSpecTypeDuration,
        ScSpecType::ScSpecTypeU128,
        ScSpecType::ScSpecTypeI128,
        ScSpecType::ScSpecTypeU256,
        ScSpecType::ScSpecTypeI256,
        ScSpecType::ScSpecTypeBytes,
        ScSpecType::ScSpecTypeString,
        ScSpecType::ScSpecTypeSymbol,
        ScSpecType::ScSpecTypeAddress,
        ScSpecType::ScSpecTypeMuxedAddress,
        ScSpecType::ScSpecTypeOption,
        ScSpecType::ScSpecTypeResult,
        ScSpecType::ScSpecTypeVec,
        ScSpecType::ScSpecTypeMap,
        ScSpecType::ScSpecTypeTuple,
        ScSpecType::ScSpecTypeBytesN,
        ScSpecType::ScSpecTypeUdt,
    ];
    pub const VARIANTS_STR: [&'static str; 26] = [
        "ScSpecTypeVal",
        "ScSpecTypeBool",
        "ScSpecTypeVoid",
        "ScSpecTypeError",
        "ScSpecTypeU32",
        "ScSpecTypeI32",
        "ScSpecTypeU64",
        "ScSpecTypeI64",
        "ScSpecTypeTimepoint",
        "ScSpecTypeDuration",
        "ScSpecTypeU128",
        "ScSpecTypeI128",
        "ScSpecTypeU256",
        "ScSpecTypeI256",
        "ScSpecTypeBytes",
        "ScSpecTypeString",
        "ScSpecTypeSymbol",
        "ScSpecTypeAddress",
        "ScSpecTypeMuxedAddress",
        "ScSpecTypeOption",
        "ScSpecTypeResult",
        "ScSpecTypeVec",
        "ScSpecTypeMap",
        "ScSpecTypeTuple",
        "ScSpecTypeBytesN",
        "ScSpecTypeUdt",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScSpecTypeVal => "ScSpecTypeVal",

            Self::ScSpecTypeBool => "ScSpecTypeBool",

            Self::ScSpecTypeVoid => "ScSpecTypeVoid",

            Self::ScSpecTypeError => "ScSpecTypeError",

            Self::ScSpecTypeU32 => "ScSpecTypeU32",

            Self::ScSpecTypeI32 => "ScSpecTypeI32",

            Self::ScSpecTypeU64 => "ScSpecTypeU64",

            Self::ScSpecTypeI64 => "ScSpecTypeI64",

            Self::ScSpecTypeTimepoint => "ScSpecTypeTimepoint",

            Self::ScSpecTypeDuration => "ScSpecTypeDuration",

            Self::ScSpecTypeU128 => "ScSpecTypeU128",

            Self::ScSpecTypeI128 => "ScSpecTypeI128",

            Self::ScSpecTypeU256 => "ScSpecTypeU256",

            Self::ScSpecTypeI256 => "ScSpecTypeI256",

            Self::ScSpecTypeBytes => "ScSpecTypeBytes",

            Self::ScSpecTypeString => "ScSpecTypeString",

            Self::ScSpecTypeSymbol => "ScSpecTypeSymbol",

            Self::ScSpecTypeAddress => "ScSpecTypeAddress",

            Self::ScSpecTypeMuxedAddress => "ScSpecTypeMuxedAddress",

            Self::ScSpecTypeOption(_) => "ScSpecTypeOption",

            Self::ScSpecTypeResult(_) => "ScSpecTypeResult",

            Self::ScSpecTypeVec(_) => "ScSpecTypeVec",

            Self::ScSpecTypeMap(_) => "ScSpecTypeMap",

            Self::ScSpecTypeTuple(_) => "ScSpecTypeTuple",

            Self::ScSpecTypeBytesN(_) => "ScSpecTypeBytesN",

            Self::ScSpecTypeUdt(_) => "ScSpecTypeUdt",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScSpecType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ScSpecTypeVal => ScSpecType::ScSpecTypeVal,

            Self::ScSpecTypeBool => ScSpecType::ScSpecTypeBool,

            Self::ScSpecTypeVoid => ScSpecType::ScSpecTypeVoid,

            Self::ScSpecTypeError => ScSpecType::ScSpecTypeError,

            Self::ScSpecTypeU32 => ScSpecType::ScSpecTypeU32,

            Self::ScSpecTypeI32 => ScSpecType::ScSpecTypeI32,

            Self::ScSpecTypeU64 => ScSpecType::ScSpecTypeU64,

            Self::ScSpecTypeI64 => ScSpecType::ScSpecTypeI64,

            Self::ScSpecTypeTimepoint => ScSpecType::ScSpecTypeTimepoint,

            Self::ScSpecTypeDuration => ScSpecType::ScSpecTypeDuration,

            Self::ScSpecTypeU128 => ScSpecType::ScSpecTypeU128,

            Self::ScSpecTypeI128 => ScSpecType::ScSpecTypeI128,

            Self::ScSpecTypeU256 => ScSpecType::ScSpecTypeU256,

            Self::ScSpecTypeI256 => ScSpecType::ScSpecTypeI256,

            Self::ScSpecTypeBytes => ScSpecType::ScSpecTypeBytes,

            Self::ScSpecTypeString => ScSpecType::ScSpecTypeString,

            Self::ScSpecTypeSymbol => ScSpecType::ScSpecTypeSymbol,

            Self::ScSpecTypeAddress => ScSpecType::ScSpecTypeAddress,

            Self::ScSpecTypeMuxedAddress => ScSpecType::ScSpecTypeMuxedAddress,

            Self::ScSpecTypeOption(_) => ScSpecType::ScSpecTypeOption,

            Self::ScSpecTypeResult(_) => ScSpecType::ScSpecTypeResult,

            Self::ScSpecTypeVec(_) => ScSpecType::ScSpecTypeVec,

            Self::ScSpecTypeMap(_) => ScSpecType::ScSpecTypeMap,

            Self::ScSpecTypeTuple(_) => ScSpecType::ScSpecTypeTuple,

            Self::ScSpecTypeBytesN(_) => ScSpecType::ScSpecTypeBytesN,

            Self::ScSpecTypeUdt(_) => ScSpecType::ScSpecTypeUdt,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecType; 26] {
        Self::VARIANTS
    }
}

impl Name for ScSpecTypeDef {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScSpecType> for ScSpecTypeDef {
    #[must_use]
    fn discriminant(&self) -> ScSpecType {
        Self::discriminant(self)
    }
}

impl Variants<ScSpecType> for ScSpecTypeDef {
    fn variants() -> slice::Iter<'static, ScSpecType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScSpecType> for ScSpecTypeDef {}

impl ReadXdr for ScSpecTypeDef {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ScSpecType = <ScSpecType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScSpecType::ScSpecTypeVal => Self::ScSpecTypeVal,

                ScSpecType::ScSpecTypeBool => Self::ScSpecTypeBool,

                ScSpecType::ScSpecTypeVoid => Self::ScSpecTypeVoid,

                ScSpecType::ScSpecTypeError => Self::ScSpecTypeError,

                ScSpecType::ScSpecTypeU32 => Self::ScSpecTypeU32,

                ScSpecType::ScSpecTypeI32 => Self::ScSpecTypeI32,

                ScSpecType::ScSpecTypeU64 => Self::ScSpecTypeU64,

                ScSpecType::ScSpecTypeI64 => Self::ScSpecTypeI64,

                ScSpecType::ScSpecTypeTimepoint => Self::ScSpecTypeTimepoint,

                ScSpecType::ScSpecTypeDuration => Self::ScSpecTypeDuration,

                ScSpecType::ScSpecTypeU128 => Self::ScSpecTypeU128,

                ScSpecType::ScSpecTypeI128 => Self::ScSpecTypeI128,

                ScSpecType::ScSpecTypeU256 => Self::ScSpecTypeU256,

                ScSpecType::ScSpecTypeI256 => Self::ScSpecTypeI256,

                ScSpecType::ScSpecTypeBytes => Self::ScSpecTypeBytes,

                ScSpecType::ScSpecTypeString => Self::ScSpecTypeString,

                ScSpecType::ScSpecTypeSymbol => Self::ScSpecTypeSymbol,

                ScSpecType::ScSpecTypeAddress => Self::ScSpecTypeAddress,

                ScSpecType::ScSpecTypeMuxedAddress => Self::ScSpecTypeMuxedAddress,

                ScSpecType::ScSpecTypeOption => {
                    Self::ScSpecTypeOption(Box::<ScSpecTypeOption>::read_xdr(r)?)
                }

                ScSpecType::ScSpecTypeResult => {
                    Self::ScSpecTypeResult(Box::<ScSpecTypeResult>::read_xdr(r)?)
                }

                ScSpecType::ScSpecTypeVec => {
                    Self::ScSpecTypeVec(Box::<ScSpecTypeVec>::read_xdr(r)?)
                }

                ScSpecType::ScSpecTypeMap => {
                    Self::ScSpecTypeMap(Box::<ScSpecTypeMap>::read_xdr(r)?)
                }

                ScSpecType::ScSpecTypeTuple => {
                    Self::ScSpecTypeTuple(Box::<ScSpecTypeTuple>::read_xdr(r)?)
                }

                ScSpecType::ScSpecTypeBytesN => {
                    Self::ScSpecTypeBytesN(ScSpecTypeBytesN::read_xdr(r)?)
                }

                ScSpecType::ScSpecTypeUdt => Self::ScSpecTypeUdt(ScSpecTypeUdt::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecTypeDef {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ScSpecTypeVal => ().write_xdr(w)?,

                Self::ScSpecTypeBool => ().write_xdr(w)?,

                Self::ScSpecTypeVoid => ().write_xdr(w)?,

                Self::ScSpecTypeError => ().write_xdr(w)?,

                Self::ScSpecTypeU32 => ().write_xdr(w)?,

                Self::ScSpecTypeI32 => ().write_xdr(w)?,

                Self::ScSpecTypeU64 => ().write_xdr(w)?,

                Self::ScSpecTypeI64 => ().write_xdr(w)?,

                Self::ScSpecTypeTimepoint => ().write_xdr(w)?,

                Self::ScSpecTypeDuration => ().write_xdr(w)?,

                Self::ScSpecTypeU128 => ().write_xdr(w)?,

                Self::ScSpecTypeI128 => ().write_xdr(w)?,

                Self::ScSpecTypeU256 => ().write_xdr(w)?,

                Self::ScSpecTypeI256 => ().write_xdr(w)?,

                Self::ScSpecTypeBytes => ().write_xdr(w)?,

                Self::ScSpecTypeString => ().write_xdr(w)?,

                Self::ScSpecTypeSymbol => ().write_xdr(w)?,

                Self::ScSpecTypeAddress => ().write_xdr(w)?,

                Self::ScSpecTypeMuxedAddress => ().write_xdr(w)?,

                Self::ScSpecTypeOption(v) => v.write_xdr(w)?,

                Self::ScSpecTypeResult(v) => v.write_xdr(w)?,

                Self::ScSpecTypeVec(v) => v.write_xdr(w)?,

                Self::ScSpecTypeMap(v) => v.write_xdr(w)?,

                Self::ScSpecTypeTuple(v) => v.write_xdr(w)?,

                Self::ScSpecTypeBytesN(v) => v.write_xdr(w)?,

                Self::ScSpecTypeUdt(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScSpecUdtStructFieldV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecUdtStructFieldV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub name: StringM<30>,

    pub type_: ScSpecTypeDef,
}

impl ReadXdr for ScSpecUdtStructFieldV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                name: StringM::<30>::read_xdr(r)?,

                type_: ScSpecTypeDef::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtStructFieldV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.type_.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecUdtStructV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecUdtStructV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub lib: StringM<80>,

    pub name: StringM<60>,

    pub fields: VecM<ScSpecUdtStructFieldV0>,
}

impl ReadXdr for ScSpecUdtStructV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                lib: StringM::<80>::read_xdr(r)?,

                name: StringM::<60>::read_xdr(r)?,

                fields: VecM::<ScSpecUdtStructFieldV0>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtStructV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.lib.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.fields.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecUdtUnionCaseVoidV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecUdtUnionCaseVoidV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub name: StringM<60>,
}

impl ReadXdr for ScSpecUdtUnionCaseVoidV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                name: StringM::<60>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtUnionCaseVoidV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.name.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecUdtUnionCaseTupleV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecUdtUnionCaseTupleV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub name: StringM<60>,

    pub type_: VecM<ScSpecTypeDef>,
}

impl ReadXdr for ScSpecUdtUnionCaseTupleV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                name: StringM::<60>::read_xdr(r)?,

                type_: VecM::<ScSpecTypeDef>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtUnionCaseTupleV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.type_.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecUdtUnionCaseV0Kind
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScSpecUdtUnionCaseV0Kind {
    #[cfg_attr(feature = "alloc", default)]
    ScSpecUdtUnionCaseVoidV0 = 0,

    ScSpecUdtUnionCaseTupleV0 = 1,
}

impl ScSpecUdtUnionCaseV0Kind {
    pub const VARIANTS: [ScSpecUdtUnionCaseV0Kind; 2] = [
        ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseVoidV0,
        ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseTupleV0,
    ];
    pub const VARIANTS_STR: [&'static str; 2] =
        ["ScSpecUdtUnionCaseVoidV0", "ScSpecUdtUnionCaseTupleV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScSpecUdtUnionCaseVoidV0 => "ScSpecUdtUnionCaseVoidV0",

            Self::ScSpecUdtUnionCaseTupleV0 => "ScSpecUdtUnionCaseTupleV0",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecUdtUnionCaseV0Kind; 2] {
        Self::VARIANTS
    }
}

impl Name for ScSpecUdtUnionCaseV0Kind {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScSpecUdtUnionCaseV0Kind> for ScSpecUdtUnionCaseV0Kind {
    fn variants() -> slice::Iter<'static, ScSpecUdtUnionCaseV0Kind> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScSpecUdtUnionCaseV0Kind {}

impl fmt::Display for ScSpecUdtUnionCaseV0Kind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScSpecUdtUnionCaseV0Kind {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseVoidV0,

            1 => ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseTupleV0,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScSpecUdtUnionCaseV0Kind> for i32 {
    #[must_use]
    fn from(e: ScSpecUdtUnionCaseV0Kind) -> Self {
        e as Self
    }
}

impl ReadXdr for ScSpecUdtUnionCaseV0Kind {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecUdtUnionCaseV0Kind {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScSpecUdtUnionCaseV0
// union with discriminant ScSpecUdtUnionCaseV0Kind
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ScSpecUdtUnionCaseV0 {
    ScSpecUdtUnionCaseVoidV0(ScSpecUdtUnionCaseVoidV0),

    ScSpecUdtUnionCaseTupleV0(ScSpecUdtUnionCaseTupleV0),
}

#[cfg(feature = "alloc")]
impl Default for ScSpecUdtUnionCaseV0 {
    fn default() -> Self {
        Self::ScSpecUdtUnionCaseVoidV0(ScSpecUdtUnionCaseVoidV0::default())
    }
}

impl ScSpecUdtUnionCaseV0 {
    pub const VARIANTS: [ScSpecUdtUnionCaseV0Kind; 2] = [
        ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseVoidV0,
        ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseTupleV0,
    ];
    pub const VARIANTS_STR: [&'static str; 2] =
        ["ScSpecUdtUnionCaseVoidV0", "ScSpecUdtUnionCaseTupleV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScSpecUdtUnionCaseVoidV0(_) => "ScSpecUdtUnionCaseVoidV0",

            Self::ScSpecUdtUnionCaseTupleV0(_) => "ScSpecUdtUnionCaseTupleV0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScSpecUdtUnionCaseV0Kind {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ScSpecUdtUnionCaseVoidV0(_) => ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseVoidV0,

            Self::ScSpecUdtUnionCaseTupleV0(_) => {
                ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseTupleV0
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecUdtUnionCaseV0Kind; 2] {
        Self::VARIANTS
    }
}

impl Name for ScSpecUdtUnionCaseV0 {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScSpecUdtUnionCaseV0Kind> for ScSpecUdtUnionCaseV0 {
    #[must_use]
    fn discriminant(&self) -> ScSpecUdtUnionCaseV0Kind {
        Self::discriminant(self)
    }
}

impl Variants<ScSpecUdtUnionCaseV0Kind> for ScSpecUdtUnionCaseV0 {
    fn variants() -> slice::Iter<'static, ScSpecUdtUnionCaseV0Kind> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScSpecUdtUnionCaseV0Kind> for ScSpecUdtUnionCaseV0 {}

impl ReadXdr for ScSpecUdtUnionCaseV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ScSpecUdtUnionCaseV0Kind = <ScSpecUdtUnionCaseV0Kind as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseVoidV0 => {
                    Self::ScSpecUdtUnionCaseVoidV0(ScSpecUdtUnionCaseVoidV0::read_xdr(r)?)
                }

                ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseTupleV0 => {
                    Self::ScSpecUdtUnionCaseTupleV0(ScSpecUdtUnionCaseTupleV0::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecUdtUnionCaseV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ScSpecUdtUnionCaseVoidV0(v) => v.write_xdr(w)?,

                Self::ScSpecUdtUnionCaseTupleV0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScSpecUdtUnionV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecUdtUnionV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub lib: StringM<80>,

    pub name: StringM<60>,

    pub cases: VecM<ScSpecUdtUnionCaseV0>,
}

impl ReadXdr for ScSpecUdtUnionV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                lib: StringM::<80>::read_xdr(r)?,

                name: StringM::<60>::read_xdr(r)?,

                cases: VecM::<ScSpecUdtUnionCaseV0>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtUnionV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.lib.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.cases.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecUdtEnumCaseV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecUdtEnumCaseV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub name: StringM<60>,

    pub value: u32,
}

impl ReadXdr for ScSpecUdtEnumCaseV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                name: StringM::<60>::read_xdr(r)?,

                value: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtEnumCaseV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.value.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecUdtEnumV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecUdtEnumV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub lib: StringM<80>,

    pub name: StringM<60>,

    pub cases: VecM<ScSpecUdtEnumCaseV0>,
}

impl ReadXdr for ScSpecUdtEnumV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                lib: StringM::<80>::read_xdr(r)?,

                name: StringM::<60>::read_xdr(r)?,

                cases: VecM::<ScSpecUdtEnumCaseV0>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtEnumV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.lib.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.cases.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecUdtErrorEnumCaseV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecUdtErrorEnumCaseV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub name: StringM<60>,

    pub value: u32,
}

impl ReadXdr for ScSpecUdtErrorEnumCaseV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                name: StringM::<60>::read_xdr(r)?,

                value: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtErrorEnumCaseV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.value.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecUdtErrorEnumV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecUdtErrorEnumV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub lib: StringM<80>,

    pub name: StringM<60>,

    pub cases: VecM<ScSpecUdtErrorEnumCaseV0>,
}

impl ReadXdr for ScSpecUdtErrorEnumV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                lib: StringM::<80>::read_xdr(r)?,

                name: StringM::<60>::read_xdr(r)?,

                cases: VecM::<ScSpecUdtErrorEnumCaseV0>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtErrorEnumV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.lib.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.cases.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecFunctionInputV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecFunctionInputV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub name: StringM<30>,

    pub type_: ScSpecTypeDef,
}

impl ReadXdr for ScSpecFunctionInputV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                name: StringM::<30>::read_xdr(r)?,

                type_: ScSpecTypeDef::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecFunctionInputV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.type_.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecFunctionV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecFunctionV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub name: ScSymbol,

    pub inputs: VecM<ScSpecFunctionInputV0>,

    pub outputs: VecM<ScSpecTypeDef, 1>,
}

impl ReadXdr for ScSpecFunctionV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                name: ScSymbol::read_xdr(r)?,

                inputs: VecM::<ScSpecFunctionInputV0>::read_xdr(r)?,

                outputs: VecM::<ScSpecTypeDef, 1>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecFunctionV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.inputs.write_xdr(w)?;

            self.outputs.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecEventParamLocationV0
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScSpecEventParamLocationV0 {
    #[cfg_attr(feature = "alloc", default)]
    ScSpecEventParamLocationData = 0,

    ScSpecEventParamLocationTopicList = 1,
}

impl ScSpecEventParamLocationV0 {
    pub const VARIANTS: [ScSpecEventParamLocationV0; 2] = [
        ScSpecEventParamLocationV0::ScSpecEventParamLocationData,
        ScSpecEventParamLocationV0::ScSpecEventParamLocationTopicList,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = [
        "ScSpecEventParamLocationData",
        "ScSpecEventParamLocationTopicList",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScSpecEventParamLocationData => "ScSpecEventParamLocationData",

            Self::ScSpecEventParamLocationTopicList => "ScSpecEventParamLocationTopicList",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecEventParamLocationV0; 2] {
        Self::VARIANTS
    }
}

impl Name for ScSpecEventParamLocationV0 {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScSpecEventParamLocationV0> for ScSpecEventParamLocationV0 {
    fn variants() -> slice::Iter<'static, ScSpecEventParamLocationV0> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScSpecEventParamLocationV0 {}

impl fmt::Display for ScSpecEventParamLocationV0 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScSpecEventParamLocationV0 {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScSpecEventParamLocationV0::ScSpecEventParamLocationData,

            1 => ScSpecEventParamLocationV0::ScSpecEventParamLocationTopicList,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScSpecEventParamLocationV0> for i32 {
    #[must_use]
    fn from(e: ScSpecEventParamLocationV0) -> Self {
        e as Self
    }
}

impl ReadXdr for ScSpecEventParamLocationV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecEventParamLocationV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScSpecEventParamV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecEventParamV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub name: StringM<30>,

    pub type_: ScSpecTypeDef,

    pub location: ScSpecEventParamLocationV0,
}

impl ReadXdr for ScSpecEventParamV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                name: StringM::<30>::read_xdr(r)?,

                type_: ScSpecTypeDef::read_xdr(r)?,

                location: ScSpecEventParamLocationV0::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecEventParamV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.type_.write_xdr(w)?;

            self.location.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecEventDataFormat
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScSpecEventDataFormat {
    #[cfg_attr(feature = "alloc", default)]
    ScSpecEventDataFormatSingleValue = 0,

    ScSpecEventDataFormatVec = 1,

    ScSpecEventDataFormatMap = 2,
}

impl ScSpecEventDataFormat {
    pub const VARIANTS: [ScSpecEventDataFormat; 3] = [
        ScSpecEventDataFormat::ScSpecEventDataFormatSingleValue,
        ScSpecEventDataFormat::ScSpecEventDataFormatVec,
        ScSpecEventDataFormat::ScSpecEventDataFormatMap,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "ScSpecEventDataFormatSingleValue",
        "ScSpecEventDataFormatVec",
        "ScSpecEventDataFormatMap",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScSpecEventDataFormatSingleValue => "ScSpecEventDataFormatSingleValue",

            Self::ScSpecEventDataFormatVec => "ScSpecEventDataFormatVec",

            Self::ScSpecEventDataFormatMap => "ScSpecEventDataFormatMap",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecEventDataFormat; 3] {
        Self::VARIANTS
    }
}

impl Name for ScSpecEventDataFormat {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScSpecEventDataFormat> for ScSpecEventDataFormat {
    fn variants() -> slice::Iter<'static, ScSpecEventDataFormat> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScSpecEventDataFormat {}

impl fmt::Display for ScSpecEventDataFormat {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScSpecEventDataFormat {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScSpecEventDataFormat::ScSpecEventDataFormatSingleValue,

            1 => ScSpecEventDataFormat::ScSpecEventDataFormatVec,

            2 => ScSpecEventDataFormat::ScSpecEventDataFormatMap,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScSpecEventDataFormat> for i32 {
    #[must_use]
    fn from(e: ScSpecEventDataFormat) -> Self {
        e as Self
    }
}

impl ReadXdr for ScSpecEventDataFormat {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecEventDataFormat {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScSpecEventV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSpecEventV0 {
    pub doc: StringM<ScSpecDocLimit>,

    pub lib: StringM<80>,

    pub name: ScSymbol,

    pub prefix_topics: VecM<ScSymbol, 2>,

    pub params: VecM<ScSpecEventParamV0>,

    pub data_format: ScSpecEventDataFormat,
}

impl ReadXdr for ScSpecEventV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<ScSpecDocLimit>::read_xdr(r)?,

                lib: StringM::<80>::read_xdr(r)?,

                name: ScSymbol::read_xdr(r)?,

                prefix_topics: VecM::<ScSymbol, 2>::read_xdr(r)?,

                params: VecM::<ScSpecEventParamV0>::read_xdr(r)?,

                data_format: ScSpecEventDataFormat::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecEventV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;

            self.lib.write_xdr(w)?;

            self.name.write_xdr(w)?;

            self.prefix_topics.write_xdr(w)?;

            self.params.write_xdr(w)?;

            self.data_format.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScSpecEntryKind
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScSpecEntryKind {
    #[cfg_attr(feature = "alloc", default)]
    ScSpecEntryFunctionV0 = 0,

    ScSpecEntryUdtStructV0 = 1,

    ScSpecEntryUdtUnionV0 = 2,

    ScSpecEntryUdtEnumV0 = 3,

    ScSpecEntryUdtErrorEnumV0 = 4,

    ScSpecEntryEventV0 = 5,
}

impl ScSpecEntryKind {
    pub const VARIANTS: [ScSpecEntryKind; 6] = [
        ScSpecEntryKind::ScSpecEntryFunctionV0,
        ScSpecEntryKind::ScSpecEntryUdtStructV0,
        ScSpecEntryKind::ScSpecEntryUdtUnionV0,
        ScSpecEntryKind::ScSpecEntryUdtEnumV0,
        ScSpecEntryKind::ScSpecEntryUdtErrorEnumV0,
        ScSpecEntryKind::ScSpecEntryEventV0,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "ScSpecEntryFunctionV0",
        "ScSpecEntryUdtStructV0",
        "ScSpecEntryUdtUnionV0",
        "ScSpecEntryUdtEnumV0",
        "ScSpecEntryUdtErrorEnumV0",
        "ScSpecEntryEventV0",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScSpecEntryFunctionV0 => "ScSpecEntryFunctionV0",

            Self::ScSpecEntryUdtStructV0 => "ScSpecEntryUdtStructV0",

            Self::ScSpecEntryUdtUnionV0 => "ScSpecEntryUdtUnionV0",

            Self::ScSpecEntryUdtEnumV0 => "ScSpecEntryUdtEnumV0",

            Self::ScSpecEntryUdtErrorEnumV0 => "ScSpecEntryUdtErrorEnumV0",

            Self::ScSpecEntryEventV0 => "ScSpecEntryEventV0",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecEntryKind; 6] {
        Self::VARIANTS
    }
}

impl Name for ScSpecEntryKind {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScSpecEntryKind> for ScSpecEntryKind {
    fn variants() -> slice::Iter<'static, ScSpecEntryKind> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScSpecEntryKind {}

impl fmt::Display for ScSpecEntryKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScSpecEntryKind {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScSpecEntryKind::ScSpecEntryFunctionV0,

            1 => ScSpecEntryKind::ScSpecEntryUdtStructV0,

            2 => ScSpecEntryKind::ScSpecEntryUdtUnionV0,

            3 => ScSpecEntryKind::ScSpecEntryUdtEnumV0,

            4 => ScSpecEntryKind::ScSpecEntryUdtErrorEnumV0,

            5 => ScSpecEntryKind::ScSpecEntryEventV0,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScSpecEntryKind> for i32 {
    #[must_use]
    fn from(e: ScSpecEntryKind) -> Self {
        e as Self
    }
}

impl ReadXdr for ScSpecEntryKind {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecEntryKind {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScSpecEntry
// union with discriminant ScSpecEntryKind
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ScSpecEntry {
    ScSpecEntryFunctionV0(ScSpecFunctionV0),

    ScSpecEntryUdtStructV0(ScSpecUdtStructV0),

    ScSpecEntryUdtUnionV0(ScSpecUdtUnionV0),

    ScSpecEntryUdtEnumV0(ScSpecUdtEnumV0),

    ScSpecEntryUdtErrorEnumV0(ScSpecUdtErrorEnumV0),

    ScSpecEntryEventV0(ScSpecEventV0),
}

#[cfg(feature = "alloc")]
impl Default for ScSpecEntry {
    fn default() -> Self {
        Self::ScSpecEntryFunctionV0(ScSpecFunctionV0::default())
    }
}

impl ScSpecEntry {
    pub const VARIANTS: [ScSpecEntryKind; 6] = [
        ScSpecEntryKind::ScSpecEntryFunctionV0,
        ScSpecEntryKind::ScSpecEntryUdtStructV0,
        ScSpecEntryKind::ScSpecEntryUdtUnionV0,
        ScSpecEntryKind::ScSpecEntryUdtEnumV0,
        ScSpecEntryKind::ScSpecEntryUdtErrorEnumV0,
        ScSpecEntryKind::ScSpecEntryEventV0,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "ScSpecEntryFunctionV0",
        "ScSpecEntryUdtStructV0",
        "ScSpecEntryUdtUnionV0",
        "ScSpecEntryUdtEnumV0",
        "ScSpecEntryUdtErrorEnumV0",
        "ScSpecEntryEventV0",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScSpecEntryFunctionV0(_) => "ScSpecEntryFunctionV0",

            Self::ScSpecEntryUdtStructV0(_) => "ScSpecEntryUdtStructV0",

            Self::ScSpecEntryUdtUnionV0(_) => "ScSpecEntryUdtUnionV0",

            Self::ScSpecEntryUdtEnumV0(_) => "ScSpecEntryUdtEnumV0",

            Self::ScSpecEntryUdtErrorEnumV0(_) => "ScSpecEntryUdtErrorEnumV0",

            Self::ScSpecEntryEventV0(_) => "ScSpecEntryEventV0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScSpecEntryKind {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ScSpecEntryFunctionV0(_) => ScSpecEntryKind::ScSpecEntryFunctionV0,

            Self::ScSpecEntryUdtStructV0(_) => ScSpecEntryKind::ScSpecEntryUdtStructV0,

            Self::ScSpecEntryUdtUnionV0(_) => ScSpecEntryKind::ScSpecEntryUdtUnionV0,

            Self::ScSpecEntryUdtEnumV0(_) => ScSpecEntryKind::ScSpecEntryUdtEnumV0,

            Self::ScSpecEntryUdtErrorEnumV0(_) => ScSpecEntryKind::ScSpecEntryUdtErrorEnumV0,

            Self::ScSpecEntryEventV0(_) => ScSpecEntryKind::ScSpecEntryEventV0,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecEntryKind; 6] {
        Self::VARIANTS
    }
}

impl Name for ScSpecEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScSpecEntryKind> for ScSpecEntry {
    #[must_use]
    fn discriminant(&self) -> ScSpecEntryKind {
        Self::discriminant(self)
    }
}

impl Variants<ScSpecEntryKind> for ScSpecEntry {
    fn variants() -> slice::Iter<'static, ScSpecEntryKind> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScSpecEntryKind> for ScSpecEntry {}

impl ReadXdr for ScSpecEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ScSpecEntryKind = <ScSpecEntryKind as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScSpecEntryKind::ScSpecEntryFunctionV0 => {
                    Self::ScSpecEntryFunctionV0(ScSpecFunctionV0::read_xdr(r)?)
                }

                ScSpecEntryKind::ScSpecEntryUdtStructV0 => {
                    Self::ScSpecEntryUdtStructV0(ScSpecUdtStructV0::read_xdr(r)?)
                }

                ScSpecEntryKind::ScSpecEntryUdtUnionV0 => {
                    Self::ScSpecEntryUdtUnionV0(ScSpecUdtUnionV0::read_xdr(r)?)
                }

                ScSpecEntryKind::ScSpecEntryUdtEnumV0 => {
                    Self::ScSpecEntryUdtEnumV0(ScSpecUdtEnumV0::read_xdr(r)?)
                }

                ScSpecEntryKind::ScSpecEntryUdtErrorEnumV0 => {
                    Self::ScSpecEntryUdtErrorEnumV0(ScSpecUdtErrorEnumV0::read_xdr(r)?)
                }

                ScSpecEntryKind::ScSpecEntryEventV0 => {
                    Self::ScSpecEntryEventV0(ScSpecEventV0::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ScSpecEntryFunctionV0(v) => v.write_xdr(w)?,

                Self::ScSpecEntryUdtStructV0(v) => v.write_xdr(w)?,

                Self::ScSpecEntryUdtUnionV0(v) => v.write_xdr(w)?,

                Self::ScSpecEntryUdtEnumV0(v) => v.write_xdr(w)?,

                Self::ScSpecEntryUdtErrorEnumV0(v) => v.write_xdr(w)?,

                Self::ScSpecEntryEventV0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScValType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScValType {
    #[cfg_attr(feature = "alloc", default)]
    ScvBool = 0,

    ScvVoid = 1,

    ScvError = 2,

    ScvU32 = 3,

    ScvI32 = 4,

    ScvU64 = 5,

    ScvI64 = 6,

    ScvTimepoint = 7,

    ScvDuration = 8,

    ScvU128 = 9,

    ScvI128 = 10,

    ScvU256 = 11,

    ScvI256 = 12,

    ScvBytes = 13,

    ScvString = 14,

    ScvSymbol = 15,

    ScvVec = 16,

    ScvMap = 17,

    ScvAddress = 18,

    ScvContractInstance = 19,

    ScvLedgerKeyContractInstance = 20,

    ScvLedgerKeyNonce = 21,
}

impl ScValType {
    pub const VARIANTS: [ScValType; 22] = [
        ScValType::ScvBool,
        ScValType::ScvVoid,
        ScValType::ScvError,
        ScValType::ScvU32,
        ScValType::ScvI32,
        ScValType::ScvU64,
        ScValType::ScvI64,
        ScValType::ScvTimepoint,
        ScValType::ScvDuration,
        ScValType::ScvU128,
        ScValType::ScvI128,
        ScValType::ScvU256,
        ScValType::ScvI256,
        ScValType::ScvBytes,
        ScValType::ScvString,
        ScValType::ScvSymbol,
        ScValType::ScvVec,
        ScValType::ScvMap,
        ScValType::ScvAddress,
        ScValType::ScvContractInstance,
        ScValType::ScvLedgerKeyContractInstance,
        ScValType::ScvLedgerKeyNonce,
    ];
    pub const VARIANTS_STR: [&'static str; 22] = [
        "ScvBool",
        "ScvVoid",
        "ScvError",
        "ScvU32",
        "ScvI32",
        "ScvU64",
        "ScvI64",
        "ScvTimepoint",
        "ScvDuration",
        "ScvU128",
        "ScvI128",
        "ScvU256",
        "ScvI256",
        "ScvBytes",
        "ScvString",
        "ScvSymbol",
        "ScvVec",
        "ScvMap",
        "ScvAddress",
        "ScvContractInstance",
        "ScvLedgerKeyContractInstance",
        "ScvLedgerKeyNonce",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScvBool => "ScvBool",

            Self::ScvVoid => "ScvVoid",

            Self::ScvError => "ScvError",

            Self::ScvU32 => "ScvU32",

            Self::ScvI32 => "ScvI32",

            Self::ScvU64 => "ScvU64",

            Self::ScvI64 => "ScvI64",

            Self::ScvTimepoint => "ScvTimepoint",

            Self::ScvDuration => "ScvDuration",

            Self::ScvU128 => "ScvU128",

            Self::ScvI128 => "ScvI128",

            Self::ScvU256 => "ScvU256",

            Self::ScvI256 => "ScvI256",

            Self::ScvBytes => "ScvBytes",

            Self::ScvString => "ScvString",

            Self::ScvSymbol => "ScvSymbol",

            Self::ScvVec => "ScvVec",

            Self::ScvMap => "ScvMap",

            Self::ScvAddress => "ScvAddress",

            Self::ScvContractInstance => "ScvContractInstance",

            Self::ScvLedgerKeyContractInstance => "ScvLedgerKeyContractInstance",

            Self::ScvLedgerKeyNonce => "ScvLedgerKeyNonce",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScValType; 22] {
        Self::VARIANTS
    }
}

impl Name for ScValType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScValType> for ScValType {
    fn variants() -> slice::Iter<'static, ScValType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScValType {}

impl fmt::Display for ScValType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScValType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScValType::ScvBool,

            1 => ScValType::ScvVoid,

            2 => ScValType::ScvError,

            3 => ScValType::ScvU32,

            4 => ScValType::ScvI32,

            5 => ScValType::ScvU64,

            6 => ScValType::ScvI64,

            7 => ScValType::ScvTimepoint,

            8 => ScValType::ScvDuration,

            9 => ScValType::ScvU128,

            10 => ScValType::ScvI128,

            11 => ScValType::ScvU256,

            12 => ScValType::ScvI256,

            13 => ScValType::ScvBytes,

            14 => ScValType::ScvString,

            15 => ScValType::ScvSymbol,

            16 => ScValType::ScvVec,

            17 => ScValType::ScvMap,

            18 => ScValType::ScvAddress,

            19 => ScValType::ScvContractInstance,

            20 => ScValType::ScvLedgerKeyContractInstance,

            21 => ScValType::ScvLedgerKeyNonce,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScValType> for i32 {
    #[must_use]
    fn from(e: ScValType) -> Self {
        e as Self
    }
}

impl ReadXdr for ScValType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScValType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScErrorType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScErrorType {
    #[cfg_attr(feature = "alloc", default)]
    SceContract = 0,

    SceWasmVm = 1,

    SceContext = 2,

    SceStorage = 3,

    SceObject = 4,

    SceCrypto = 5,

    SceEvents = 6,

    SceBudget = 7,

    SceValue = 8,

    SceAuth = 9,
}

impl ScErrorType {
    pub const VARIANTS: [ScErrorType; 10] = [
        ScErrorType::SceContract,
        ScErrorType::SceWasmVm,
        ScErrorType::SceContext,
        ScErrorType::SceStorage,
        ScErrorType::SceObject,
        ScErrorType::SceCrypto,
        ScErrorType::SceEvents,
        ScErrorType::SceBudget,
        ScErrorType::SceValue,
        ScErrorType::SceAuth,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "SceContract",
        "SceWasmVm",
        "SceContext",
        "SceStorage",
        "SceObject",
        "SceCrypto",
        "SceEvents",
        "SceBudget",
        "SceValue",
        "SceAuth",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SceContract => "SceContract",

            Self::SceWasmVm => "SceWasmVm",

            Self::SceContext => "SceContext",

            Self::SceStorage => "SceStorage",

            Self::SceObject => "SceObject",

            Self::SceCrypto => "SceCrypto",

            Self::SceEvents => "SceEvents",

            Self::SceBudget => "SceBudget",

            Self::SceValue => "SceValue",

            Self::SceAuth => "SceAuth",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScErrorType; 10] {
        Self::VARIANTS
    }
}

impl Name for ScErrorType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScErrorType> for ScErrorType {
    fn variants() -> slice::Iter<'static, ScErrorType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScErrorType {}

impl fmt::Display for ScErrorType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScErrorType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScErrorType::SceContract,

            1 => ScErrorType::SceWasmVm,

            2 => ScErrorType::SceContext,

            3 => ScErrorType::SceStorage,

            4 => ScErrorType::SceObject,

            5 => ScErrorType::SceCrypto,

            6 => ScErrorType::SceEvents,

            7 => ScErrorType::SceBudget,

            8 => ScErrorType::SceValue,

            9 => ScErrorType::SceAuth,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScErrorType> for i32 {
    #[must_use]
    fn from(e: ScErrorType) -> Self {
        e as Self
    }
}

impl ReadXdr for ScErrorType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScErrorType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScErrorCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScErrorCode {
    #[cfg_attr(feature = "alloc", default)]
    ScecArithDomain = 0,

    ScecIndexBounds = 1,

    ScecInvalidInput = 2,

    ScecMissingValue = 3,

    ScecExistingValue = 4,

    ScecExceededLimit = 5,

    ScecInvalidAction = 6,

    ScecInternalError = 7,

    ScecUnexpectedType = 8,

    ScecUnexpectedSize = 9,
}

impl ScErrorCode {
    pub const VARIANTS: [ScErrorCode; 10] = [
        ScErrorCode::ScecArithDomain,
        ScErrorCode::ScecIndexBounds,
        ScErrorCode::ScecInvalidInput,
        ScErrorCode::ScecMissingValue,
        ScErrorCode::ScecExistingValue,
        ScErrorCode::ScecExceededLimit,
        ScErrorCode::ScecInvalidAction,
        ScErrorCode::ScecInternalError,
        ScErrorCode::ScecUnexpectedType,
        ScErrorCode::ScecUnexpectedSize,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "ScecArithDomain",
        "ScecIndexBounds",
        "ScecInvalidInput",
        "ScecMissingValue",
        "ScecExistingValue",
        "ScecExceededLimit",
        "ScecInvalidAction",
        "ScecInternalError",
        "ScecUnexpectedType",
        "ScecUnexpectedSize",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScecArithDomain => "ScecArithDomain",

            Self::ScecIndexBounds => "ScecIndexBounds",

            Self::ScecInvalidInput => "ScecInvalidInput",

            Self::ScecMissingValue => "ScecMissingValue",

            Self::ScecExistingValue => "ScecExistingValue",

            Self::ScecExceededLimit => "ScecExceededLimit",

            Self::ScecInvalidAction => "ScecInvalidAction",

            Self::ScecInternalError => "ScecInternalError",

            Self::ScecUnexpectedType => "ScecUnexpectedType",

            Self::ScecUnexpectedSize => "ScecUnexpectedSize",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScErrorCode; 10] {
        Self::VARIANTS
    }
}

impl Name for ScErrorCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScErrorCode> for ScErrorCode {
    fn variants() -> slice::Iter<'static, ScErrorCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScErrorCode {}

impl fmt::Display for ScErrorCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScErrorCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScErrorCode::ScecArithDomain,

            1 => ScErrorCode::ScecIndexBounds,

            2 => ScErrorCode::ScecInvalidInput,

            3 => ScErrorCode::ScecMissingValue,

            4 => ScErrorCode::ScecExistingValue,

            5 => ScErrorCode::ScecExceededLimit,

            6 => ScErrorCode::ScecInvalidAction,

            7 => ScErrorCode::ScecInternalError,

            8 => ScErrorCode::ScecUnexpectedType,

            9 => ScErrorCode::ScecUnexpectedSize,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScErrorCode> for i32 {
    #[must_use]
    fn from(e: ScErrorCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ScErrorCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScErrorCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScError
// union with discriminant ScErrorType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ScError {
    SceContract(u32),

    SceWasmVm(ScErrorCode),

    SceContext(ScErrorCode),

    SceStorage(ScErrorCode),

    SceObject(ScErrorCode),

    SceCrypto(ScErrorCode),

    SceEvents(ScErrorCode),

    SceBudget(ScErrorCode),

    SceValue(ScErrorCode),

    SceAuth(ScErrorCode),
}

#[cfg(feature = "alloc")]
impl Default for ScError {
    fn default() -> Self {
        Self::SceContract(u32::default())
    }
}

impl ScError {
    pub const VARIANTS: [ScErrorType; 10] = [
        ScErrorType::SceContract,
        ScErrorType::SceWasmVm,
        ScErrorType::SceContext,
        ScErrorType::SceStorage,
        ScErrorType::SceObject,
        ScErrorType::SceCrypto,
        ScErrorType::SceEvents,
        ScErrorType::SceBudget,
        ScErrorType::SceValue,
        ScErrorType::SceAuth,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "SceContract",
        "SceWasmVm",
        "SceContext",
        "SceStorage",
        "SceObject",
        "SceCrypto",
        "SceEvents",
        "SceBudget",
        "SceValue",
        "SceAuth",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SceContract(_) => "SceContract",

            Self::SceWasmVm(_) => "SceWasmVm",

            Self::SceContext(_) => "SceContext",

            Self::SceStorage(_) => "SceStorage",

            Self::SceObject(_) => "SceObject",

            Self::SceCrypto(_) => "SceCrypto",

            Self::SceEvents(_) => "SceEvents",

            Self::SceBudget(_) => "SceBudget",

            Self::SceValue(_) => "SceValue",

            Self::SceAuth(_) => "SceAuth",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScErrorType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::SceContract(_) => ScErrorType::SceContract,

            Self::SceWasmVm(_) => ScErrorType::SceWasmVm,

            Self::SceContext(_) => ScErrorType::SceContext,

            Self::SceStorage(_) => ScErrorType::SceStorage,

            Self::SceObject(_) => ScErrorType::SceObject,

            Self::SceCrypto(_) => ScErrorType::SceCrypto,

            Self::SceEvents(_) => ScErrorType::SceEvents,

            Self::SceBudget(_) => ScErrorType::SceBudget,

            Self::SceValue(_) => ScErrorType::SceValue,

            Self::SceAuth(_) => ScErrorType::SceAuth,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScErrorType; 10] {
        Self::VARIANTS
    }
}

impl Name for ScError {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScErrorType> for ScError {
    #[must_use]
    fn discriminant(&self) -> ScErrorType {
        Self::discriminant(self)
    }
}

impl Variants<ScErrorType> for ScError {
    fn variants() -> slice::Iter<'static, ScErrorType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScErrorType> for ScError {}

impl ReadXdr for ScError {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ScErrorType = <ScErrorType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScErrorType::SceContract => Self::SceContract(u32::read_xdr(r)?),

                ScErrorType::SceWasmVm => Self::SceWasmVm(ScErrorCode::read_xdr(r)?),

                ScErrorType::SceContext => Self::SceContext(ScErrorCode::read_xdr(r)?),

                ScErrorType::SceStorage => Self::SceStorage(ScErrorCode::read_xdr(r)?),

                ScErrorType::SceObject => Self::SceObject(ScErrorCode::read_xdr(r)?),

                ScErrorType::SceCrypto => Self::SceCrypto(ScErrorCode::read_xdr(r)?),

                ScErrorType::SceEvents => Self::SceEvents(ScErrorCode::read_xdr(r)?),

                ScErrorType::SceBudget => Self::SceBudget(ScErrorCode::read_xdr(r)?),

                ScErrorType::SceValue => Self::SceValue(ScErrorCode::read_xdr(r)?),

                ScErrorType::SceAuth => Self::SceAuth(ScErrorCode::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScError {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::SceContract(v) => v.write_xdr(w)?,

                Self::SceWasmVm(v) => v.write_xdr(w)?,

                Self::SceContext(v) => v.write_xdr(w)?,

                Self::SceStorage(v) => v.write_xdr(w)?,

                Self::SceObject(v) => v.write_xdr(w)?,

                Self::SceCrypto(v) => v.write_xdr(w)?,

                Self::SceEvents(v) => v.write_xdr(w)?,

                Self::SceBudget(v) => v.write_xdr(w)?,

                Self::SceValue(v) => v.write_xdr(w)?,

                Self::SceAuth(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// UInt128Parts
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay)
)]

pub struct UInt128Parts {
    pub hi: u64,

    pub lo: u64,
}

impl ReadXdr for UInt128Parts {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hi: u64::read_xdr(r)?,

                lo: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for UInt128Parts {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.hi.write_xdr(w)?;

            self.lo.write_xdr(w)?;

            Ok(())
        })
    }
}

#[cfg(all(feature = "serde", feature = "alloc"))]
impl<'de> serde::Deserialize<'de> for UInt128Parts {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        #[derive(Deserialize)]
        struct UInt128Parts {
            hi: u64,
            lo: u64,
        }
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum UInt128PartsOrString<'a> {
            Str(&'a str),
            String(String),
            UInt128Parts(UInt128Parts),
        }
        match UInt128PartsOrString::deserialize(deserializer)? {
            UInt128PartsOrString::Str(s) => s.parse().map_err(serde::de::Error::custom),
            UInt128PartsOrString::String(s) => s.parse().map_err(serde::de::Error::custom),
            UInt128PartsOrString::UInt128Parts(UInt128Parts { hi, lo }) => {
                Ok(self::UInt128Parts { hi, lo })
            }
        }
    }
}

/// Int128Parts
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay)
)]

pub struct Int128Parts {
    pub hi: i64,

    pub lo: u64,
}

impl ReadXdr for Int128Parts {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hi: i64::read_xdr(r)?,

                lo: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Int128Parts {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.hi.write_xdr(w)?;

            self.lo.write_xdr(w)?;

            Ok(())
        })
    }
}

#[cfg(all(feature = "serde", feature = "alloc"))]
impl<'de> serde::Deserialize<'de> for Int128Parts {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        #[derive(Deserialize)]
        struct Int128Parts {
            hi: i64,
            lo: u64,
        }
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum Int128PartsOrString<'a> {
            Str(&'a str),
            String(String),
            Int128Parts(Int128Parts),
        }
        match Int128PartsOrString::deserialize(deserializer)? {
            Int128PartsOrString::Str(s) => s.parse().map_err(serde::de::Error::custom),
            Int128PartsOrString::String(s) => s.parse().map_err(serde::de::Error::custom),
            Int128PartsOrString::Int128Parts(Int128Parts { hi, lo }) => {
                Ok(self::Int128Parts { hi, lo })
            }
        }
    }
}

/// UInt256Parts
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay)
)]

pub struct UInt256Parts {
    pub hi_hi: u64,

    pub hi_lo: u64,

    pub lo_hi: u64,

    pub lo_lo: u64,
}

impl ReadXdr for UInt256Parts {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hi_hi: u64::read_xdr(r)?,

                hi_lo: u64::read_xdr(r)?,

                lo_hi: u64::read_xdr(r)?,

                lo_lo: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for UInt256Parts {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.hi_hi.write_xdr(w)?;

            self.hi_lo.write_xdr(w)?;

            self.lo_hi.write_xdr(w)?;

            self.lo_lo.write_xdr(w)?;

            Ok(())
        })
    }
}

#[cfg(all(feature = "serde", feature = "alloc"))]
impl<'de> serde::Deserialize<'de> for UInt256Parts {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        #[derive(Deserialize)]
        struct UInt256Parts {
            hi_hi: u64,
            hi_lo: u64,
            lo_hi: u64,
            lo_lo: u64,
        }
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum UInt256PartsOrString<'a> {
            Str(&'a str),
            String(String),
            UInt256Parts(UInt256Parts),
        }
        match UInt256PartsOrString::deserialize(deserializer)? {
            UInt256PartsOrString::Str(s) => s.parse().map_err(serde::de::Error::custom),
            UInt256PartsOrString::String(s) => s.parse().map_err(serde::de::Error::custom),
            UInt256PartsOrString::UInt256Parts(UInt256Parts {
                hi_hi,
                hi_lo,
                lo_hi,
                lo_lo,
            }) => Ok(self::UInt256Parts {
                hi_hi,
                hi_lo,
                lo_hi,
                lo_lo,
            }),
        }
    }
}

/// Int256Parts
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay)
)]

pub struct Int256Parts {
    pub hi_hi: i64,

    pub hi_lo: u64,

    pub lo_hi: u64,

    pub lo_lo: u64,
}

impl ReadXdr for Int256Parts {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hi_hi: i64::read_xdr(r)?,

                hi_lo: u64::read_xdr(r)?,

                lo_hi: u64::read_xdr(r)?,

                lo_lo: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Int256Parts {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.hi_hi.write_xdr(w)?;

            self.hi_lo.write_xdr(w)?;

            self.lo_hi.write_xdr(w)?;

            self.lo_lo.write_xdr(w)?;

            Ok(())
        })
    }
}

#[cfg(all(feature = "serde", feature = "alloc"))]
impl<'de> serde::Deserialize<'de> for Int256Parts {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        #[derive(Deserialize)]
        struct Int256Parts {
            hi_hi: i64,
            hi_lo: u64,
            lo_hi: u64,
            lo_lo: u64,
        }
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum Int256PartsOrString<'a> {
            Str(&'a str),
            String(String),
            Int256Parts(Int256Parts),
        }
        match Int256PartsOrString::deserialize(deserializer)? {
            Int256PartsOrString::Str(s) => s.parse().map_err(serde::de::Error::custom),
            Int256PartsOrString::String(s) => s.parse().map_err(serde::de::Error::custom),
            Int256PartsOrString::Int256Parts(Int256Parts {
                hi_hi,
                hi_lo,
                lo_hi,
                lo_lo,
            }) => Ok(self::Int256Parts {
                hi_hi,
                hi_lo,
                lo_hi,
                lo_lo,
            }),
        }
    }
}

/// ContractExecutableType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ContractExecutableType {
    #[cfg_attr(feature = "alloc", default)]
    ContractExecutableWasm = 0,

    ContractExecutableStellarAsset = 1,
}

impl ContractExecutableType {
    pub const VARIANTS: [ContractExecutableType; 2] = [
        ContractExecutableType::ContractExecutableWasm,
        ContractExecutableType::ContractExecutableStellarAsset,
    ];
    pub const VARIANTS_STR: [&'static str; 2] =
        ["ContractExecutableWasm", "ContractExecutableStellarAsset"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ContractExecutableWasm => "ContractExecutableWasm",

            Self::ContractExecutableStellarAsset => "ContractExecutableStellarAsset",
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractExecutableType; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractExecutableType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ContractExecutableType> for ContractExecutableType {
    fn variants() -> slice::Iter<'static, ContractExecutableType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ContractExecutableType {}

impl fmt::Display for ContractExecutableType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ContractExecutableType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ContractExecutableType::ContractExecutableWasm,

            1 => ContractExecutableType::ContractExecutableStellarAsset,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ContractExecutableType> for i32 {
    #[must_use]
    fn from(e: ContractExecutableType) -> Self {
        e as Self
    }
}

impl ReadXdr for ContractExecutableType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ContractExecutableType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractExecutable
// union with discriminant ContractExecutableType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ContractExecutable {
    ContractExecutableWasm(Hash),

    ContractExecutableStellarAsset,
}

#[cfg(feature = "alloc")]
impl Default for ContractExecutable {
    fn default() -> Self {
        Self::ContractExecutableWasm(Hash::default())
    }
}

impl ContractExecutable {
    pub const VARIANTS: [ContractExecutableType; 2] = [
        ContractExecutableType::ContractExecutableWasm,
        ContractExecutableType::ContractExecutableStellarAsset,
    ];
    pub const VARIANTS_STR: [&'static str; 2] =
        ["ContractExecutableWasm", "ContractExecutableStellarAsset"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ContractExecutableWasm(_) => "ContractExecutableWasm",

            Self::ContractExecutableStellarAsset => "ContractExecutableStellarAsset",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ContractExecutableType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ContractExecutableWasm(_) => ContractExecutableType::ContractExecutableWasm,

            Self::ContractExecutableStellarAsset => {
                ContractExecutableType::ContractExecutableStellarAsset
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractExecutableType; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractExecutable {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ContractExecutableType> for ContractExecutable {
    #[must_use]
    fn discriminant(&self) -> ContractExecutableType {
        Self::discriminant(self)
    }
}

impl Variants<ContractExecutableType> for ContractExecutable {
    fn variants() -> slice::Iter<'static, ContractExecutableType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ContractExecutableType> for ContractExecutable {}

impl ReadXdr for ContractExecutable {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ContractExecutableType = <ContractExecutableType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ContractExecutableType::ContractExecutableWasm => {
                    Self::ContractExecutableWasm(Hash::read_xdr(r)?)
                }

                ContractExecutableType::ContractExecutableStellarAsset => {
                    Self::ContractExecutableStellarAsset
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ContractExecutable {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ContractExecutableWasm(v) => v.write_xdr(w)?,

                Self::ContractExecutableStellarAsset => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScAddressType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ScAddressType {
    #[cfg_attr(feature = "alloc", default)]
    ScAddressTypeAccount = 0,

    ScAddressTypeContract = 1,

    ScAddressTypeMuxedAccount = 2,

    ScAddressTypeClaimableBalance = 3,

    ScAddressTypeLiquidityPool = 4,
}

impl ScAddressType {
    pub const VARIANTS: [ScAddressType; 5] = [
        ScAddressType::ScAddressTypeAccount,
        ScAddressType::ScAddressTypeContract,
        ScAddressType::ScAddressTypeMuxedAccount,
        ScAddressType::ScAddressTypeClaimableBalance,
        ScAddressType::ScAddressTypeLiquidityPool,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "ScAddressTypeAccount",
        "ScAddressTypeContract",
        "ScAddressTypeMuxedAccount",
        "ScAddressTypeClaimableBalance",
        "ScAddressTypeLiquidityPool",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScAddressTypeAccount => "ScAddressTypeAccount",

            Self::ScAddressTypeContract => "ScAddressTypeContract",

            Self::ScAddressTypeMuxedAccount => "ScAddressTypeMuxedAccount",

            Self::ScAddressTypeClaimableBalance => "ScAddressTypeClaimableBalance",

            Self::ScAddressTypeLiquidityPool => "ScAddressTypeLiquidityPool",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScAddressType; 5] {
        Self::VARIANTS
    }
}

impl Name for ScAddressType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScAddressType> for ScAddressType {
    fn variants() -> slice::Iter<'static, ScAddressType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScAddressType {}

impl fmt::Display for ScAddressType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScAddressType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ScAddressType::ScAddressTypeAccount,

            1 => ScAddressType::ScAddressTypeContract,

            2 => ScAddressType::ScAddressTypeMuxedAccount,

            3 => ScAddressType::ScAddressTypeClaimableBalance,

            4 => ScAddressType::ScAddressTypeLiquidityPool,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScAddressType> for i32 {
    #[must_use]
    fn from(e: ScAddressType) -> Self {
        e as Self
    }
}

impl ReadXdr for ScAddressType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScAddressType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// MuxedEd25519Account
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay)
)]

pub struct MuxedEd25519Account {
    pub id: u64,

    pub ed25519: Uint256,
}

impl ReadXdr for MuxedEd25519Account {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                id: u64::read_xdr(r)?,

                ed25519: Uint256::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for MuxedEd25519Account {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.id.write_xdr(w)?;

            self.ed25519.write_xdr(w)?;

            Ok(())
        })
    }
}

#[cfg(all(feature = "serde", feature = "alloc"))]
impl<'de> serde::Deserialize<'de> for MuxedEd25519Account {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        #[derive(Deserialize)]
        struct MuxedEd25519Account {
            id: u64,
            ed25519: Uint256,
        }
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum MuxedEd25519AccountOrString<'a> {
            Str(&'a str),
            String(String),
            MuxedEd25519Account(MuxedEd25519Account),
        }
        match MuxedEd25519AccountOrString::deserialize(deserializer)? {
            MuxedEd25519AccountOrString::Str(s) => s.parse().map_err(serde::de::Error::custom),
            MuxedEd25519AccountOrString::String(s) => s.parse().map_err(serde::de::Error::custom),
            MuxedEd25519AccountOrString::MuxedEd25519Account(MuxedEd25519Account {
                id,
                ed25519,
            }) => Ok(self::MuxedEd25519Account { id, ed25519 }),
        }
    }
}

/// ScAddress
// union with discriminant ScAddressType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[allow(clippy::large_enum_variant)]
pub enum ScAddress {
    ScAddressTypeAccount(AccountId),

    ScAddressTypeContract(ContractId),

    ScAddressTypeMuxedAccount(MuxedEd25519Account),

    ScAddressTypeClaimableBalance(ClaimableBalanceId),

    ScAddressTypeLiquidityPool(PoolId),
}

#[cfg(feature = "alloc")]
impl Default for ScAddress {
    fn default() -> Self {
        Self::ScAddressTypeAccount(AccountId::default())
    }
}

impl ScAddress {
    pub const VARIANTS: [ScAddressType; 5] = [
        ScAddressType::ScAddressTypeAccount,
        ScAddressType::ScAddressTypeContract,
        ScAddressType::ScAddressTypeMuxedAccount,
        ScAddressType::ScAddressTypeClaimableBalance,
        ScAddressType::ScAddressTypeLiquidityPool,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "ScAddressTypeAccount",
        "ScAddressTypeContract",
        "ScAddressTypeMuxedAccount",
        "ScAddressTypeClaimableBalance",
        "ScAddressTypeLiquidityPool",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScAddressTypeAccount(_) => "ScAddressTypeAccount",

            Self::ScAddressTypeContract(_) => "ScAddressTypeContract",

            Self::ScAddressTypeMuxedAccount(_) => "ScAddressTypeMuxedAccount",

            Self::ScAddressTypeClaimableBalance(_) => "ScAddressTypeClaimableBalance",

            Self::ScAddressTypeLiquidityPool(_) => "ScAddressTypeLiquidityPool",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScAddressType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ScAddressTypeAccount(_) => ScAddressType::ScAddressTypeAccount,

            Self::ScAddressTypeContract(_) => ScAddressType::ScAddressTypeContract,

            Self::ScAddressTypeMuxedAccount(_) => ScAddressType::ScAddressTypeMuxedAccount,

            Self::ScAddressTypeClaimableBalance(_) => ScAddressType::ScAddressTypeClaimableBalance,

            Self::ScAddressTypeLiquidityPool(_) => ScAddressType::ScAddressTypeLiquidityPool,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScAddressType; 5] {
        Self::VARIANTS
    }
}

impl Name for ScAddress {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScAddressType> for ScAddress {
    #[must_use]
    fn discriminant(&self) -> ScAddressType {
        Self::discriminant(self)
    }
}

impl Variants<ScAddressType> for ScAddress {
    fn variants() -> slice::Iter<'static, ScAddressType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScAddressType> for ScAddress {}

impl ReadXdr for ScAddress {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ScAddressType = <ScAddressType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScAddressType::ScAddressTypeAccount => {
                    Self::ScAddressTypeAccount(AccountId::read_xdr(r)?)
                }

                ScAddressType::ScAddressTypeContract => {
                    Self::ScAddressTypeContract(ContractId::read_xdr(r)?)
                }

                ScAddressType::ScAddressTypeMuxedAccount => {
                    Self::ScAddressTypeMuxedAccount(MuxedEd25519Account::read_xdr(r)?)
                }

                ScAddressType::ScAddressTypeClaimableBalance => {
                    Self::ScAddressTypeClaimableBalance(ClaimableBalanceId::read_xdr(r)?)
                }

                ScAddressType::ScAddressTypeLiquidityPool => {
                    Self::ScAddressTypeLiquidityPool(PoolId::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScAddress {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ScAddressTypeAccount(v) => v.write_xdr(w)?,

                Self::ScAddressTypeContract(v) => v.write_xdr(w)?,

                Self::ScAddressTypeMuxedAccount(v) => v.write_xdr(w)?,

                Self::ScAddressTypeClaimableBalance(v) => v.write_xdr(w)?,

                Self::ScAddressTypeLiquidityPool(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

pub const SCSYMBOL_LIMIT: u64 = 32;

/// ScVec
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScVec(pub VecM<ScVal>);

impl From<ScVec> for VecM<ScVal> {
    #[must_use]
    fn from(x: ScVec) -> Self {
        x.0
    }
}

impl From<VecM<ScVal>> for ScVec {
    #[must_use]
    fn from(x: VecM<ScVal>) -> Self {
        ScVec(x)
    }
}

impl AsRef<VecM<ScVal>> for ScVec {
    #[must_use]
    fn as_ref(&self) -> &VecM<ScVal> {
        &self.0
    }
}

impl ReadXdr for ScVec {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = VecM::<ScVal>::read_xdr(r)?;
            let v = ScVec(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ScVec {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ScVec {
    type Target = VecM<ScVal>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ScVec> for Vec<ScVal> {
    #[must_use]
    fn from(x: ScVec) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<ScVal>> for ScVec {
    type Error = Error;
    fn try_from(x: Vec<ScVal>) -> Result<Self, Error> {
        Ok(ScVec(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<ScVal>> for ScVec {
    type Error = Error;
    fn try_from(x: &Vec<ScVal>) -> Result<Self, Error> {
        Ok(ScVec(x.try_into()?))
    }
}

impl AsRef<Vec<ScVal>> for ScVec {
    #[must_use]
    fn as_ref(&self) -> &Vec<ScVal> {
        &self.0 .0
    }
}

impl AsRef<[ScVal]> for ScVec {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[ScVal] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[ScVal] {
        self.0 .0
    }
}

/// ScMap
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScMap(pub VecM<ScMapEntry>);

impl From<ScMap> for VecM<ScMapEntry> {
    #[must_use]
    fn from(x: ScMap) -> Self {
        x.0
    }
}

impl From<VecM<ScMapEntry>> for ScMap {
    #[must_use]
    fn from(x: VecM<ScMapEntry>) -> Self {
        ScMap(x)
    }
}

impl AsRef<VecM<ScMapEntry>> for ScMap {
    #[must_use]
    fn as_ref(&self) -> &VecM<ScMapEntry> {
        &self.0
    }
}

impl ReadXdr for ScMap {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = VecM::<ScMapEntry>::read_xdr(r)?;
            let v = ScMap(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ScMap {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ScMap {
    type Target = VecM<ScMapEntry>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ScMap> for Vec<ScMapEntry> {
    #[must_use]
    fn from(x: ScMap) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<ScMapEntry>> for ScMap {
    type Error = Error;
    fn try_from(x: Vec<ScMapEntry>) -> Result<Self, Error> {
        Ok(ScMap(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<ScMapEntry>> for ScMap {
    type Error = Error;
    fn try_from(x: &Vec<ScMapEntry>) -> Result<Self, Error> {
        Ok(ScMap(x.try_into()?))
    }
}

impl AsRef<Vec<ScMapEntry>> for ScMap {
    #[must_use]
    fn as_ref(&self) -> &Vec<ScMapEntry> {
        &self.0 .0
    }
}

impl AsRef<[ScMapEntry]> for ScMap {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[ScMapEntry] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[ScMapEntry] {
        self.0 .0
    }
}

/// ScBytes
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScBytes(pub BytesM);

impl From<ScBytes> for BytesM {
    #[must_use]
    fn from(x: ScBytes) -> Self {
        x.0
    }
}

impl From<BytesM> for ScBytes {
    #[must_use]
    fn from(x: BytesM) -> Self {
        ScBytes(x)
    }
}

impl AsRef<BytesM> for ScBytes {
    #[must_use]
    fn as_ref(&self) -> &BytesM {
        &self.0
    }
}

impl ReadXdr for ScBytes {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = BytesM::read_xdr(r)?;
            let v = ScBytes(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ScBytes {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ScBytes {
    type Target = BytesM;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ScBytes> for Vec<u8> {
    #[must_use]
    fn from(x: ScBytes) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for ScBytes {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        Ok(ScBytes(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for ScBytes {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        Ok(ScBytes(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for ScBytes {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for ScBytes {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// ScString
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScString(pub StringM);

impl From<ScString> for StringM {
    #[must_use]
    fn from(x: ScString) -> Self {
        x.0
    }
}

impl From<StringM> for ScString {
    #[must_use]
    fn from(x: StringM) -> Self {
        ScString(x)
    }
}

impl AsRef<StringM> for ScString {
    #[must_use]
    fn as_ref(&self) -> &StringM {
        &self.0
    }
}

impl ReadXdr for ScString {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = StringM::read_xdr(r)?;
            let v = ScString(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ScString {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ScString {
    type Target = StringM;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ScString> for Vec<u8> {
    #[must_use]
    fn from(x: ScString) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for ScString {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        Ok(ScString(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for ScString {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        Ok(ScString(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for ScString {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for ScString {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// ScSymbol
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScSymbol(pub StringM<ScsymbolLimit>);

impl From<ScSymbol> for StringM<ScsymbolLimit> {
    #[must_use]
    fn from(x: ScSymbol) -> Self {
        x.0
    }
}

impl From<StringM<ScsymbolLimit>> for ScSymbol {
    #[must_use]
    fn from(x: StringM<ScsymbolLimit>) -> Self {
        ScSymbol(x)
    }
}

impl AsRef<StringM<ScsymbolLimit>> for ScSymbol {
    #[must_use]
    fn as_ref(&self) -> &StringM<ScsymbolLimit> {
        &self.0
    }
}

impl ReadXdr for ScSymbol {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = StringM::<ScsymbolLimit>::read_xdr(r)?;
            let v = ScSymbol(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ScSymbol {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ScSymbol {
    type Target = StringM<ScsymbolLimit>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ScSymbol> for Vec<u8> {
    #[must_use]
    fn from(x: ScSymbol) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for ScSymbol {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        Ok(ScSymbol(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for ScSymbol {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        Ok(ScSymbol(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for ScSymbol {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for ScSymbol {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// ScNonceKey
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScNonceKey {
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub nonce: i64,
}

impl ReadXdr for ScNonceKey {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                nonce: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScNonceKey {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.nonce.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScContractInstance
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScContractInstance {
    pub executable: ContractExecutable,

    pub storage: Option<Box<ScMap>>,
}

impl ReadXdr for ScContractInstance {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                executable: ContractExecutable::read_xdr(r)?,

                storage: Option::<Box<ScMap>>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScContractInstance {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.executable.write_xdr(w)?;

            self.storage.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScVal
// union with discriminant ScValType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ScVal {
    ScvBool(bool),

    ScvVoid,

    ScvError(ScError),

    ScvU32(u32),

    ScvI32(i32),

    ScvU64(u64),

    ScvI64(i64),

    ScvTimepoint(TimePoint),

    ScvDuration(Duration),

    ScvU128(UInt128Parts),

    ScvI128(Int128Parts),

    ScvU256(UInt256Parts),

    ScvI256(Int256Parts),

    ScvBytes(ScBytes),

    ScvString(ScString),

    ScvSymbol(ScSymbol),

    ScvVec(Option<Box<ScVec>>),

    ScvMap(Option<Box<ScMap>>),

    ScvAddress(ScAddress),

    ScvContractInstance(Box<ScContractInstance>),

    ScvLedgerKeyContractInstance,

    ScvLedgerKeyNonce(ScNonceKey),
}

#[cfg(feature = "alloc")]
impl Default for ScVal {
    fn default() -> Self {
        Self::ScvBool(bool::default())
    }
}

impl ScVal {
    pub const VARIANTS: [ScValType; 22] = [
        ScValType::ScvBool,
        ScValType::ScvVoid,
        ScValType::ScvError,
        ScValType::ScvU32,
        ScValType::ScvI32,
        ScValType::ScvU64,
        ScValType::ScvI64,
        ScValType::ScvTimepoint,
        ScValType::ScvDuration,
        ScValType::ScvU128,
        ScValType::ScvI128,
        ScValType::ScvU256,
        ScValType::ScvI256,
        ScValType::ScvBytes,
        ScValType::ScvString,
        ScValType::ScvSymbol,
        ScValType::ScvVec,
        ScValType::ScvMap,
        ScValType::ScvAddress,
        ScValType::ScvContractInstance,
        ScValType::ScvLedgerKeyContractInstance,
        ScValType::ScvLedgerKeyNonce,
    ];
    pub const VARIANTS_STR: [&'static str; 22] = [
        "ScvBool",
        "ScvVoid",
        "ScvError",
        "ScvU32",
        "ScvI32",
        "ScvU64",
        "ScvI64",
        "ScvTimepoint",
        "ScvDuration",
        "ScvU128",
        "ScvI128",
        "ScvU256",
        "ScvI256",
        "ScvBytes",
        "ScvString",
        "ScvSymbol",
        "ScvVec",
        "ScvMap",
        "ScvAddress",
        "ScvContractInstance",
        "ScvLedgerKeyContractInstance",
        "ScvLedgerKeyNonce",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScvBool(_) => "ScvBool",

            Self::ScvVoid => "ScvVoid",

            Self::ScvError(_) => "ScvError",

            Self::ScvU32(_) => "ScvU32",

            Self::ScvI32(_) => "ScvI32",

            Self::ScvU64(_) => "ScvU64",

            Self::ScvI64(_) => "ScvI64",

            Self::ScvTimepoint(_) => "ScvTimepoint",

            Self::ScvDuration(_) => "ScvDuration",

            Self::ScvU128(_) => "ScvU128",

            Self::ScvI128(_) => "ScvI128",

            Self::ScvU256(_) => "ScvU256",

            Self::ScvI256(_) => "ScvI256",

            Self::ScvBytes(_) => "ScvBytes",

            Self::ScvString(_) => "ScvString",

            Self::ScvSymbol(_) => "ScvSymbol",

            Self::ScvVec(_) => "ScvVec",

            Self::ScvMap(_) => "ScvMap",

            Self::ScvAddress(_) => "ScvAddress",

            Self::ScvContractInstance(_) => "ScvContractInstance",

            Self::ScvLedgerKeyContractInstance => "ScvLedgerKeyContractInstance",

            Self::ScvLedgerKeyNonce(_) => "ScvLedgerKeyNonce",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScValType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ScvBool(_) => ScValType::ScvBool,

            Self::ScvVoid => ScValType::ScvVoid,

            Self::ScvError(_) => ScValType::ScvError,

            Self::ScvU32(_) => ScValType::ScvU32,

            Self::ScvI32(_) => ScValType::ScvI32,

            Self::ScvU64(_) => ScValType::ScvU64,

            Self::ScvI64(_) => ScValType::ScvI64,

            Self::ScvTimepoint(_) => ScValType::ScvTimepoint,

            Self::ScvDuration(_) => ScValType::ScvDuration,

            Self::ScvU128(_) => ScValType::ScvU128,

            Self::ScvI128(_) => ScValType::ScvI128,

            Self::ScvU256(_) => ScValType::ScvU256,

            Self::ScvI256(_) => ScValType::ScvI256,

            Self::ScvBytes(_) => ScValType::ScvBytes,

            Self::ScvString(_) => ScValType::ScvString,

            Self::ScvSymbol(_) => ScValType::ScvSymbol,

            Self::ScvVec(_) => ScValType::ScvVec,

            Self::ScvMap(_) => ScValType::ScvMap,

            Self::ScvAddress(_) => ScValType::ScvAddress,

            Self::ScvContractInstance(_) => ScValType::ScvContractInstance,

            Self::ScvLedgerKeyContractInstance => ScValType::ScvLedgerKeyContractInstance,

            Self::ScvLedgerKeyNonce(_) => ScValType::ScvLedgerKeyNonce,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScValType; 22] {
        Self::VARIANTS
    }
}

impl Name for ScVal {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScValType> for ScVal {
    #[must_use]
    fn discriminant(&self) -> ScValType {
        Self::discriminant(self)
    }
}

impl Variants<ScValType> for ScVal {
    fn variants() -> slice::Iter<'static, ScValType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScValType> for ScVal {}

impl ReadXdr for ScVal {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ScValType = <ScValType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScValType::ScvBool => Self::ScvBool(bool::read_xdr(r)?),

                ScValType::ScvVoid => Self::ScvVoid,

                ScValType::ScvError => Self::ScvError(ScError::read_xdr(r)?),

                ScValType::ScvU32 => Self::ScvU32(u32::read_xdr(r)?),

                ScValType::ScvI32 => Self::ScvI32(i32::read_xdr(r)?),

                ScValType::ScvU64 => Self::ScvU64(u64::read_xdr(r)?),

                ScValType::ScvI64 => Self::ScvI64(i64::read_xdr(r)?),

                ScValType::ScvTimepoint => Self::ScvTimepoint(TimePoint::read_xdr(r)?),

                ScValType::ScvDuration => Self::ScvDuration(Duration::read_xdr(r)?),

                ScValType::ScvU128 => Self::ScvU128(UInt128Parts::read_xdr(r)?),

                ScValType::ScvI128 => Self::ScvI128(Int128Parts::read_xdr(r)?),

                ScValType::ScvU256 => Self::ScvU256(UInt256Parts::read_xdr(r)?),

                ScValType::ScvI256 => Self::ScvI256(Int256Parts::read_xdr(r)?),

                ScValType::ScvBytes => Self::ScvBytes(ScBytes::read_xdr(r)?),

                ScValType::ScvString => Self::ScvString(ScString::read_xdr(r)?),

                ScValType::ScvSymbol => Self::ScvSymbol(ScSymbol::read_xdr(r)?),

                ScValType::ScvVec => Self::ScvVec(Option::<Box<ScVec>>::read_xdr(r)?),

                ScValType::ScvMap => Self::ScvMap(Option::<Box<ScMap>>::read_xdr(r)?),

                ScValType::ScvAddress => Self::ScvAddress(ScAddress::read_xdr(r)?),

                ScValType::ScvContractInstance => {
                    Self::ScvContractInstance(Box::<ScContractInstance>::read_xdr(r)?)
                }

                ScValType::ScvLedgerKeyContractInstance => Self::ScvLedgerKeyContractInstance,

                ScValType::ScvLedgerKeyNonce => Self::ScvLedgerKeyNonce(ScNonceKey::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScVal {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ScvBool(v) => v.write_xdr(w)?,

                Self::ScvVoid => ().write_xdr(w)?,

                Self::ScvError(v) => v.write_xdr(w)?,

                Self::ScvU32(v) => v.write_xdr(w)?,

                Self::ScvI32(v) => v.write_xdr(w)?,

                Self::ScvU64(v) => v.write_xdr(w)?,

                Self::ScvI64(v) => v.write_xdr(w)?,

                Self::ScvTimepoint(v) => v.write_xdr(w)?,

                Self::ScvDuration(v) => v.write_xdr(w)?,

                Self::ScvU128(v) => v.write_xdr(w)?,

                Self::ScvI128(v) => v.write_xdr(w)?,

                Self::ScvU256(v) => v.write_xdr(w)?,

                Self::ScvI256(v) => v.write_xdr(w)?,

                Self::ScvBytes(v) => v.write_xdr(w)?,

                Self::ScvString(v) => v.write_xdr(w)?,

                Self::ScvSymbol(v) => v.write_xdr(w)?,

                Self::ScvVec(v) => v.write_xdr(w)?,

                Self::ScvMap(v) => v.write_xdr(w)?,

                Self::ScvAddress(v) => v.write_xdr(w)?,

                Self::ScvContractInstance(v) => v.write_xdr(w)?,

                Self::ScvLedgerKeyContractInstance => ().write_xdr(w)?,

                Self::ScvLedgerKeyNonce(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScMapEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScMapEntry {
    pub key: Box<ScVal>,

    pub val: Box<ScVal>,
}

impl ReadXdr for ScMapEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: Box::<ScVal>::read_xdr(r)?,

                val: Box::<ScVal>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScMapEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;

            self.val.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerCloseMetaBatch
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerCloseMetaBatch {
    pub start_sequence: u32,

    pub end_sequence: u32,

    pub ledger_close_metas: VecM<LedgerCloseMeta>,
}

impl ReadXdr for LedgerCloseMetaBatch {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                start_sequence: u32::read_xdr(r)?,

                end_sequence: u32::read_xdr(r)?,

                ledger_close_metas: VecM::<LedgerCloseMeta>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerCloseMetaBatch {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.start_sequence.write_xdr(w)?;

            self.end_sequence.write_xdr(w)?;

            self.ledger_close_metas.write_xdr(w)?;

            Ok(())
        })
    }
}

/// StoredTransactionSet
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum StoredTransactionSet {
    V0(TransactionSet),

    V1(GeneralizedTransactionSet),
}

#[cfg(feature = "alloc")]
impl Default for StoredTransactionSet {
    fn default() -> Self {
        Self::V0(TransactionSet::default())
    }
}

impl StoredTransactionSet {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for StoredTransactionSet {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for StoredTransactionSet {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for StoredTransactionSet {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for StoredTransactionSet {}

impl ReadXdr for StoredTransactionSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(TransactionSet::read_xdr(r)?),

                1 => Self::V1(GeneralizedTransactionSet::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for StoredTransactionSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// StoredDebugTransactionSet
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct StoredDebugTransactionSet {
    pub tx_set: StoredTransactionSet,

    pub ledger_seq: u32,

    pub scp_value: StellarValue,
}

impl ReadXdr for StoredDebugTransactionSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_set: StoredTransactionSet::read_xdr(r)?,

                ledger_seq: u32::read_xdr(r)?,

                scp_value: StellarValue::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for StoredDebugTransactionSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.tx_set.write_xdr(w)?;

            self.ledger_seq.write_xdr(w)?;

            self.scp_value.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PersistedScpStateV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct PersistedScpStateV0 {
    pub scp_envelopes: VecM<ScpEnvelope>,

    pub quorum_sets: VecM<ScpQuorumSet>,

    pub tx_sets: VecM<StoredTransactionSet>,
}

impl ReadXdr for PersistedScpStateV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                scp_envelopes: VecM::<ScpEnvelope>::read_xdr(r)?,

                quorum_sets: VecM::<ScpQuorumSet>::read_xdr(r)?,

                tx_sets: VecM::<StoredTransactionSet>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PersistedScpStateV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.scp_envelopes.write_xdr(w)?;

            self.quorum_sets.write_xdr(w)?;

            self.tx_sets.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PersistedScpStateV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct PersistedScpStateV1 {
    pub scp_envelopes: VecM<ScpEnvelope>,

    pub quorum_sets: VecM<ScpQuorumSet>,
}

impl ReadXdr for PersistedScpStateV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                scp_envelopes: VecM::<ScpEnvelope>::read_xdr(r)?,

                quorum_sets: VecM::<ScpQuorumSet>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PersistedScpStateV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.scp_envelopes.write_xdr(w)?;

            self.quorum_sets.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PersistedScpState
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum PersistedScpState {
    V0(PersistedScpStateV0),

    V1(PersistedScpStateV1),
}

#[cfg(feature = "alloc")]
impl Default for PersistedScpState {
    fn default() -> Self {
        Self::V0(PersistedScpStateV0::default())
    }
}

impl PersistedScpState {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for PersistedScpState {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for PersistedScpState {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for PersistedScpState {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for PersistedScpState {}

impl ReadXdr for PersistedScpState {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(PersistedScpStateV0::read_xdr(r)?),

                1 => Self::V1(PersistedScpStateV1::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PersistedScpState {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// Thresholds
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]

pub struct Thresholds(pub [u8; 4]);

impl core::fmt::Debug for Thresholds {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "Thresholds(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}

impl core::fmt::Display for Thresholds {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl core::str::FromStr for Thresholds {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        hex::decode(s).map_err(|_| Error::InvalidHex)?.try_into()
    }
}

#[cfg(feature = "schemars")]
impl schemars::JsonSchema for Thresholds {
    fn schema_name() -> String {
        "Thresholds".to_string()
    }

    fn is_referenceable() -> bool {
        false
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        let schema = String::json_schema(gen);
        if let schemars::schema::Schema::Object(mut schema) = schema {
            schema.extensions.insert(
                "contentEncoding".to_owned(),
                serde_json::Value::String("hex".to_string()),
            );
            schema.extensions.insert(
                "contentMediaType".to_owned(),
                serde_json::Value::String("application/binary".to_string()),
            );
            let string = *schema.string.unwrap_or_default().clone();
            schema.string = Some(Box::new(schemars::schema::StringValidation {
                max_length: 4_u32.checked_mul(2).map(Some).unwrap_or_default(),
                min_length: 4_u32.checked_mul(2).map(Some).unwrap_or_default(),
                ..string
            }));
            schema.into()
        } else {
            schema
        }
    }
}

impl From<Thresholds> for [u8; 4] {
    #[must_use]
    fn from(x: Thresholds) -> Self {
        x.0
    }
}

impl From<[u8; 4]> for Thresholds {
    #[must_use]
    fn from(x: [u8; 4]) -> Self {
        Thresholds(x)
    }
}

impl AsRef<[u8; 4]> for Thresholds {
    #[must_use]
    fn as_ref(&self) -> &[u8; 4] {
        &self.0
    }
}

impl ReadXdr for Thresholds {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = <[u8; 4]>::read_xdr(r)?;
            let v = Thresholds(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Thresholds {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Thresholds {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for Thresholds {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for Thresholds {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for Thresholds {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self, Error> {
        Ok(Thresholds(x.try_into()?))
    }
}

impl AsRef<[u8]> for Thresholds {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// String32
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct String32(pub StringM<32>);

impl From<String32> for StringM<32> {
    #[must_use]
    fn from(x: String32) -> Self {
        x.0
    }
}

impl From<StringM<32>> for String32 {
    #[must_use]
    fn from(x: StringM<32>) -> Self {
        String32(x)
    }
}

impl AsRef<StringM<32>> for String32 {
    #[must_use]
    fn as_ref(&self) -> &StringM<32> {
        &self.0
    }
}

impl ReadXdr for String32 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = StringM::<32>::read_xdr(r)?;
            let v = String32(i);
            Ok(v)
        })
    }
}

impl WriteXdr for String32 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for String32 {
    type Target = StringM<32>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<String32> for Vec<u8> {
    #[must_use]
    fn from(x: String32) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for String32 {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        Ok(String32(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for String32 {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        Ok(String32(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for String32 {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for String32 {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// String64
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct String64(pub StringM<64>);

impl From<String64> for StringM<64> {
    #[must_use]
    fn from(x: String64) -> Self {
        x.0
    }
}

impl From<StringM<64>> for String64 {
    #[must_use]
    fn from(x: StringM<64>) -> Self {
        String64(x)
    }
}

impl AsRef<StringM<64>> for String64 {
    #[must_use]
    fn as_ref(&self) -> &StringM<64> {
        &self.0
    }
}

impl ReadXdr for String64 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = StringM::<64>::read_xdr(r)?;
            let v = String64(i);
            Ok(v)
        })
    }
}

impl WriteXdr for String64 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for String64 {
    type Target = StringM<64>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<String64> for Vec<u8> {
    #[must_use]
    fn from(x: String64) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for String64 {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        Ok(String64(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for String64 {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        Ok(String64(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for String64 {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for String64 {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// SequenceNumber
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SequenceNumber(
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub i64,
);

impl From<SequenceNumber> for i64 {
    #[must_use]
    fn from(x: SequenceNumber) -> Self {
        x.0
    }
}

impl From<i64> for SequenceNumber {
    #[must_use]
    fn from(x: i64) -> Self {
        SequenceNumber(x)
    }
}

impl AsRef<i64> for SequenceNumber {
    #[must_use]
    fn as_ref(&self) -> &i64 {
        &self.0
    }
}

impl ReadXdr for SequenceNumber {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = i64::read_xdr(r)?;
            let v = SequenceNumber(i);
            Ok(v)
        })
    }
}

impl WriteXdr for SequenceNumber {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// DataValue
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct DataValue(pub BytesM<64>);

impl From<DataValue> for BytesM<64> {
    #[must_use]
    fn from(x: DataValue) -> Self {
        x.0
    }
}

impl From<BytesM<64>> for DataValue {
    #[must_use]
    fn from(x: BytesM<64>) -> Self {
        DataValue(x)
    }
}

impl AsRef<BytesM<64>> for DataValue {
    #[must_use]
    fn as_ref(&self) -> &BytesM<64> {
        &self.0
    }
}

impl ReadXdr for DataValue {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = BytesM::<64>::read_xdr(r)?;
            let v = DataValue(i);
            Ok(v)
        })
    }
}

impl WriteXdr for DataValue {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for DataValue {
    type Target = BytesM<64>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<DataValue> for Vec<u8> {
    #[must_use]
    fn from(x: DataValue) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for DataValue {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        Ok(DataValue(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for DataValue {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        Ok(DataValue(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for DataValue {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for DataValue {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// AssetCode4
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]

pub struct AssetCode4(pub [u8; 4]);

impl core::fmt::Debug for AssetCode4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "AssetCode4(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}

impl From<AssetCode4> for [u8; 4] {
    #[must_use]
    fn from(x: AssetCode4) -> Self {
        x.0
    }
}

impl From<[u8; 4]> for AssetCode4 {
    #[must_use]
    fn from(x: [u8; 4]) -> Self {
        AssetCode4(x)
    }
}

impl AsRef<[u8; 4]> for AssetCode4 {
    #[must_use]
    fn as_ref(&self) -> &[u8; 4] {
        &self.0
    }
}

impl ReadXdr for AssetCode4 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = <[u8; 4]>::read_xdr(r)?;
            let v = AssetCode4(i);
            Ok(v)
        })
    }
}

impl WriteXdr for AssetCode4 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl AssetCode4 {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for AssetCode4 {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for AssetCode4 {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for AssetCode4 {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self, Error> {
        Ok(AssetCode4(x.try_into()?))
    }
}

impl AsRef<[u8]> for AssetCode4 {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// AssetCode12
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]

pub struct AssetCode12(pub [u8; 12]);

impl core::fmt::Debug for AssetCode12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "AssetCode12(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}

impl From<AssetCode12> for [u8; 12] {
    #[must_use]
    fn from(x: AssetCode12) -> Self {
        x.0
    }
}

impl From<[u8; 12]> for AssetCode12 {
    #[must_use]
    fn from(x: [u8; 12]) -> Self {
        AssetCode12(x)
    }
}

impl AsRef<[u8; 12]> for AssetCode12 {
    #[must_use]
    fn as_ref(&self) -> &[u8; 12] {
        &self.0
    }
}

impl ReadXdr for AssetCode12 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = <[u8; 12]>::read_xdr(r)?;
            let v = AssetCode12(i);
            Ok(v)
        })
    }
}

impl WriteXdr for AssetCode12 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl AssetCode12 {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for AssetCode12 {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for AssetCode12 {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for AssetCode12 {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self, Error> {
        Ok(AssetCode12(x.try_into()?))
    }
}

impl AsRef<[u8]> for AssetCode12 {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// AssetType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum AssetType {
    #[cfg_attr(feature = "alloc", default)]
    AssetTypeNative = 0,

    AssetTypeCreditAlphanum4 = 1,

    AssetTypeCreditAlphanum12 = 2,

    AssetTypePoolShare = 3,
}

impl AssetType {
    pub const VARIANTS: [AssetType; 4] = [
        AssetType::AssetTypeNative,
        AssetType::AssetTypeCreditAlphanum4,
        AssetType::AssetTypeCreditAlphanum12,
        AssetType::AssetTypePoolShare,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "AssetTypeNative",
        "AssetTypeCreditAlphanum4",
        "AssetTypeCreditAlphanum12",
        "AssetTypePoolShare",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AssetTypeNative => "AssetTypeNative",

            Self::AssetTypeCreditAlphanum4 => "AssetTypeCreditAlphanum4",

            Self::AssetTypeCreditAlphanum12 => "AssetTypeCreditAlphanum12",

            Self::AssetTypePoolShare => "AssetTypePoolShare",
        }
    }

    #[must_use]
    pub const fn variants() -> [AssetType; 4] {
        Self::VARIANTS
    }
}

impl Name for AssetType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<AssetType> for AssetType {
    fn variants() -> slice::Iter<'static, AssetType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for AssetType {}

impl fmt::Display for AssetType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for AssetType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => AssetType::AssetTypeNative,

            1 => AssetType::AssetTypeCreditAlphanum4,

            2 => AssetType::AssetTypeCreditAlphanum12,

            3 => AssetType::AssetTypePoolShare,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<AssetType> for i32 {
    #[must_use]
    fn from(e: AssetType) -> Self {
        e as Self
    }
}

impl ReadXdr for AssetType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for AssetType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// AssetCode
// union with discriminant AssetType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[allow(clippy::large_enum_variant)]
pub enum AssetCode {
    AssetTypeCreditAlphanum4(AssetCode4),

    AssetTypeCreditAlphanum12(AssetCode12),
}

#[cfg(feature = "alloc")]
impl Default for AssetCode {
    fn default() -> Self {
        Self::AssetTypeCreditAlphanum4(AssetCode4::default())
    }
}

impl AssetCode {
    pub const VARIANTS: [AssetType; 2] = [
        AssetType::AssetTypeCreditAlphanum4,
        AssetType::AssetTypeCreditAlphanum12,
    ];
    pub const VARIANTS_STR: [&'static str; 2] =
        ["AssetTypeCreditAlphanum4", "AssetTypeCreditAlphanum12"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AssetTypeCreditAlphanum4(_) => "AssetTypeCreditAlphanum4",

            Self::AssetTypeCreditAlphanum12(_) => "AssetTypeCreditAlphanum12",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AssetType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::AssetTypeCreditAlphanum4(_) => AssetType::AssetTypeCreditAlphanum4,

            Self::AssetTypeCreditAlphanum12(_) => AssetType::AssetTypeCreditAlphanum12,
        }
    }

    #[must_use]
    pub const fn variants() -> [AssetType; 2] {
        Self::VARIANTS
    }
}

impl Name for AssetCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AssetType> for AssetCode {
    #[must_use]
    fn discriminant(&self) -> AssetType {
        Self::discriminant(self)
    }
}

impl Variants<AssetType> for AssetCode {
    fn variants() -> slice::Iter<'static, AssetType> {
        Self::VARIANTS.iter()
    }
}

impl Union<AssetType> for AssetCode {}

impl ReadXdr for AssetCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: AssetType = <AssetType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AssetType::AssetTypeCreditAlphanum4 => {
                    Self::AssetTypeCreditAlphanum4(AssetCode4::read_xdr(r)?)
                }

                AssetType::AssetTypeCreditAlphanum12 => {
                    Self::AssetTypeCreditAlphanum12(AssetCode12::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AssetCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::AssetTypeCreditAlphanum4(v) => v.write_xdr(w)?,

                Self::AssetTypeCreditAlphanum12(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AlphaNum4
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct AlphaNum4 {
    pub asset_code: AssetCode4,

    pub issuer: AccountId,
}

impl ReadXdr for AlphaNum4 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                asset_code: AssetCode4::read_xdr(r)?,

                issuer: AccountId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AlphaNum4 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.asset_code.write_xdr(w)?;

            self.issuer.write_xdr(w)?;

            Ok(())
        })
    }
}

/// AlphaNum12
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct AlphaNum12 {
    pub asset_code: AssetCode12,

    pub issuer: AccountId,
}

impl ReadXdr for AlphaNum12 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                asset_code: AssetCode12::read_xdr(r)?,

                issuer: AccountId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AlphaNum12 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.asset_code.write_xdr(w)?;

            self.issuer.write_xdr(w)?;

            Ok(())
        })
    }
}

/// Asset
// union with discriminant AssetType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum Asset {
    AssetTypeNative,

    AssetTypeCreditAlphanum4(AlphaNum4),

    AssetTypeCreditAlphanum12(AlphaNum12),
}

#[cfg(feature = "alloc")]
impl Default for Asset {
    fn default() -> Self {
        Self::AssetTypeNative
    }
}

impl Asset {
    pub const VARIANTS: [AssetType; 3] = [
        AssetType::AssetTypeNative,
        AssetType::AssetTypeCreditAlphanum4,
        AssetType::AssetTypeCreditAlphanum12,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "AssetTypeNative",
        "AssetTypeCreditAlphanum4",
        "AssetTypeCreditAlphanum12",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AssetTypeNative => "AssetTypeNative",

            Self::AssetTypeCreditAlphanum4(_) => "AssetTypeCreditAlphanum4",

            Self::AssetTypeCreditAlphanum12(_) => "AssetTypeCreditAlphanum12",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AssetType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::AssetTypeNative => AssetType::AssetTypeNative,

            Self::AssetTypeCreditAlphanum4(_) => AssetType::AssetTypeCreditAlphanum4,

            Self::AssetTypeCreditAlphanum12(_) => AssetType::AssetTypeCreditAlphanum12,
        }
    }

    #[must_use]
    pub const fn variants() -> [AssetType; 3] {
        Self::VARIANTS
    }
}

impl Name for Asset {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AssetType> for Asset {
    #[must_use]
    fn discriminant(&self) -> AssetType {
        Self::discriminant(self)
    }
}

impl Variants<AssetType> for Asset {
    fn variants() -> slice::Iter<'static, AssetType> {
        Self::VARIANTS.iter()
    }
}

impl Union<AssetType> for Asset {}

impl ReadXdr for Asset {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: AssetType = <AssetType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AssetType::AssetTypeNative => Self::AssetTypeNative,

                AssetType::AssetTypeCreditAlphanum4 => {
                    Self::AssetTypeCreditAlphanum4(AlphaNum4::read_xdr(r)?)
                }

                AssetType::AssetTypeCreditAlphanum12 => {
                    Self::AssetTypeCreditAlphanum12(AlphaNum12::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for Asset {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::AssetTypeNative => ().write_xdr(w)?,

                Self::AssetTypeCreditAlphanum4(v) => v.write_xdr(w)?,

                Self::AssetTypeCreditAlphanum12(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// Price
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Price {
    pub n: i32,

    pub d: i32,
}

impl ReadXdr for Price {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                n: i32::read_xdr(r)?,

                d: i32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Price {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.n.write_xdr(w)?;

            self.d.write_xdr(w)?;

            Ok(())
        })
    }
}

/// Liabilities
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Liabilities {
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub buying: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub selling: i64,
}

impl ReadXdr for Liabilities {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                buying: i64::read_xdr(r)?,

                selling: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Liabilities {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.buying.write_xdr(w)?;

            self.selling.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ThresholdIndexes
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ThresholdIndexes {
    #[cfg_attr(feature = "alloc", default)]
    ThresholdMasterWeight = 0,

    ThresholdLow = 1,

    ThresholdMed = 2,

    ThresholdHigh = 3,
}

impl ThresholdIndexes {
    pub const VARIANTS: [ThresholdIndexes; 4] = [
        ThresholdIndexes::ThresholdMasterWeight,
        ThresholdIndexes::ThresholdLow,
        ThresholdIndexes::ThresholdMed,
        ThresholdIndexes::ThresholdHigh,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "ThresholdMasterWeight",
        "ThresholdLow",
        "ThresholdMed",
        "ThresholdHigh",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ThresholdMasterWeight => "ThresholdMasterWeight",

            Self::ThresholdLow => "ThresholdLow",

            Self::ThresholdMed => "ThresholdMed",

            Self::ThresholdHigh => "ThresholdHigh",
        }
    }

    #[must_use]
    pub const fn variants() -> [ThresholdIndexes; 4] {
        Self::VARIANTS
    }
}

impl Name for ThresholdIndexes {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ThresholdIndexes> for ThresholdIndexes {
    fn variants() -> slice::Iter<'static, ThresholdIndexes> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ThresholdIndexes {}

impl fmt::Display for ThresholdIndexes {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ThresholdIndexes {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ThresholdIndexes::ThresholdMasterWeight,

            1 => ThresholdIndexes::ThresholdLow,

            2 => ThresholdIndexes::ThresholdMed,

            3 => ThresholdIndexes::ThresholdHigh,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ThresholdIndexes> for i32 {
    #[must_use]
    fn from(e: ThresholdIndexes) -> Self {
        e as Self
    }
}

impl ReadXdr for ThresholdIndexes {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ThresholdIndexes {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LedgerEntryType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum LedgerEntryType {
    #[cfg_attr(feature = "alloc", default)]
    Account = 0,

    Trustline = 1,

    Offer = 2,

    Data = 3,

    ClaimableBalance = 4,

    LiquidityPool = 5,

    ContractData = 6,

    ContractCode = 7,

    ConfigSetting = 8,

    Ttl = 9,
}

impl LedgerEntryType {
    pub const VARIANTS: [LedgerEntryType; 10] = [
        LedgerEntryType::Account,
        LedgerEntryType::Trustline,
        LedgerEntryType::Offer,
        LedgerEntryType::Data,
        LedgerEntryType::ClaimableBalance,
        LedgerEntryType::LiquidityPool,
        LedgerEntryType::ContractData,
        LedgerEntryType::ContractCode,
        LedgerEntryType::ConfigSetting,
        LedgerEntryType::Ttl,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "Account",
        "Trustline",
        "Offer",
        "Data",
        "ClaimableBalance",
        "LiquidityPool",
        "ContractData",
        "ContractCode",
        "ConfigSetting",
        "Ttl",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Account => "Account",

            Self::Trustline => "Trustline",

            Self::Offer => "Offer",

            Self::Data => "Data",

            Self::ClaimableBalance => "ClaimableBalance",

            Self::LiquidityPool => "LiquidityPool",

            Self::ContractData => "ContractData",

            Self::ContractCode => "ContractCode",

            Self::ConfigSetting => "ConfigSetting",

            Self::Ttl => "Ttl",
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerEntryType; 10] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LedgerEntryType> for LedgerEntryType {
    fn variants() -> slice::Iter<'static, LedgerEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LedgerEntryType {}

impl fmt::Display for LedgerEntryType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LedgerEntryType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => LedgerEntryType::Account,

            1 => LedgerEntryType::Trustline,

            2 => LedgerEntryType::Offer,

            3 => LedgerEntryType::Data,

            4 => LedgerEntryType::ClaimableBalance,

            5 => LedgerEntryType::LiquidityPool,

            6 => LedgerEntryType::ContractData,

            7 => LedgerEntryType::ContractCode,

            8 => LedgerEntryType::ConfigSetting,

            9 => LedgerEntryType::Ttl,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LedgerEntryType> for i32 {
    #[must_use]
    fn from(e: LedgerEntryType) -> Self {
        e as Self
    }
}

impl ReadXdr for LedgerEntryType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// Signer
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Signer {
    pub key: SignerKey,

    pub weight: u32,
}

impl ReadXdr for Signer {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: SignerKey::read_xdr(r)?,

                weight: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Signer {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;

            self.weight.write_xdr(w)?;

            Ok(())
        })
    }
}

/// AccountFlags
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum AccountFlags {
    #[cfg_attr(feature = "alloc", default)]
    AuthRequiredFlag = 1,

    AuthRevocableFlag = 2,

    AuthImmutableFlag = 4,

    AuthClawbackEnabledFlag = 8,
}

impl AccountFlags {
    pub const VARIANTS: [AccountFlags; 4] = [
        AccountFlags::AuthRequiredFlag,
        AccountFlags::AuthRevocableFlag,
        AccountFlags::AuthImmutableFlag,
        AccountFlags::AuthClawbackEnabledFlag,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "AuthRequiredFlag",
        "AuthRevocableFlag",
        "AuthImmutableFlag",
        "AuthClawbackEnabledFlag",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AuthRequiredFlag => "AuthRequiredFlag",

            Self::AuthRevocableFlag => "AuthRevocableFlag",

            Self::AuthImmutableFlag => "AuthImmutableFlag",

            Self::AuthClawbackEnabledFlag => "AuthClawbackEnabledFlag",
        }
    }

    #[must_use]
    pub const fn variants() -> [AccountFlags; 4] {
        Self::VARIANTS
    }
}

impl Name for AccountFlags {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<AccountFlags> for AccountFlags {
    fn variants() -> slice::Iter<'static, AccountFlags> {
        Self::VARIANTS.iter()
    }
}

impl Enum for AccountFlags {}

impl fmt::Display for AccountFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for AccountFlags {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            1 => AccountFlags::AuthRequiredFlag,

            2 => AccountFlags::AuthRevocableFlag,

            4 => AccountFlags::AuthImmutableFlag,

            8 => AccountFlags::AuthClawbackEnabledFlag,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<AccountFlags> for i32 {
    #[must_use]
    fn from(e: AccountFlags) -> Self {
        e as Self
    }
}

impl ReadXdr for AccountFlags {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for AccountFlags {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

pub const MASK_ACCOUNT_FLAGS: u64 = 7;

pub const MASK_ACCOUNT_FLAGS_V17: u64 = 15;

pub const MAX_SIGNERS: u64 = 20;

/// SponsorshipDescriptor
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SponsorshipDescriptor(pub Option<AccountId>);

impl From<SponsorshipDescriptor> for Option<AccountId> {
    #[must_use]
    fn from(x: SponsorshipDescriptor) -> Self {
        x.0
    }
}

impl From<Option<AccountId>> for SponsorshipDescriptor {
    #[must_use]
    fn from(x: Option<AccountId>) -> Self {
        SponsorshipDescriptor(x)
    }
}

impl AsRef<Option<AccountId>> for SponsorshipDescriptor {
    #[must_use]
    fn as_ref(&self) -> &Option<AccountId> {
        &self.0
    }
}

impl ReadXdr for SponsorshipDescriptor {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = Option::<AccountId>::read_xdr(r)?;
            let v = SponsorshipDescriptor(i);
            Ok(v)
        })
    }
}

impl WriteXdr for SponsorshipDescriptor {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// AccountEntryExtensionV3
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct AccountEntryExtensionV3 {
    pub ext: ExtensionPoint,

    pub seq_ledger: u32,

    pub seq_time: TimePoint,
}

impl ReadXdr for AccountEntryExtensionV3 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                seq_ledger: u32::read_xdr(r)?,

                seq_time: TimePoint::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AccountEntryExtensionV3 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.seq_ledger.write_xdr(w)?;

            self.seq_time.write_xdr(w)?;

            Ok(())
        })
    }
}

/// AccountEntryExtensionV2
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct AccountEntryExtensionV2 {
    pub num_sponsored: u32,

    pub num_sponsoring: u32,

    pub signer_sponsoring_i_ds: VecM<SponsorshipDescriptor, MaxSigners>,

    pub ext: AccountEntryExtensionV2Ext,
}

impl ReadXdr for AccountEntryExtensionV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                num_sponsored: u32::read_xdr(r)?,

                num_sponsoring: u32::read_xdr(r)?,

                signer_sponsoring_i_ds: VecM::<SponsorshipDescriptor, MaxSigners>::read_xdr(r)?,

                ext: AccountEntryExtensionV2Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AccountEntryExtensionV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.num_sponsored.write_xdr(w)?;

            self.num_sponsoring.write_xdr(w)?;

            self.signer_sponsoring_i_ds.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// AccountEntryExtensionV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct AccountEntryExtensionV1 {
    pub liabilities: Liabilities,

    pub ext: AccountEntryExtensionV1Ext,
}

impl ReadXdr for AccountEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liabilities: Liabilities::read_xdr(r)?,

                ext: AccountEntryExtensionV1Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AccountEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.liabilities.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// AccountEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct AccountEntry {
    pub account_id: AccountId,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub balance: i64,

    pub seq_num: SequenceNumber,

    pub num_sub_entries: u32,

    pub inflation_dest: Option<AccountId>,

    pub flags: u32,

    pub home_domain: String32,

    pub thresholds: Thresholds,

    pub signers: VecM<Signer, MaxSigners>,

    pub ext: AccountEntryExt,
}

impl ReadXdr for AccountEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,

                balance: i64::read_xdr(r)?,

                seq_num: SequenceNumber::read_xdr(r)?,

                num_sub_entries: u32::read_xdr(r)?,

                inflation_dest: Option::<AccountId>::read_xdr(r)?,

                flags: u32::read_xdr(r)?,

                home_domain: String32::read_xdr(r)?,

                thresholds: Thresholds::read_xdr(r)?,

                signers: VecM::<Signer, MaxSigners>::read_xdr(r)?,

                ext: AccountEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AccountEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;

            self.balance.write_xdr(w)?;

            self.seq_num.write_xdr(w)?;

            self.num_sub_entries.write_xdr(w)?;

            self.inflation_dest.write_xdr(w)?;

            self.flags.write_xdr(w)?;

            self.home_domain.write_xdr(w)?;

            self.thresholds.write_xdr(w)?;

            self.signers.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TrustLineFlags
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum TrustLineFlags {
    #[cfg_attr(feature = "alloc", default)]
    AuthorizedFlag = 1,

    AuthorizedToMaintainLiabilitiesFlag = 2,

    TrustlineClawbackEnabledFlag = 4,
}

impl TrustLineFlags {
    pub const VARIANTS: [TrustLineFlags; 3] = [
        TrustLineFlags::AuthorizedFlag,
        TrustLineFlags::AuthorizedToMaintainLiabilitiesFlag,
        TrustLineFlags::TrustlineClawbackEnabledFlag,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "AuthorizedFlag",
        "AuthorizedToMaintainLiabilitiesFlag",
        "TrustlineClawbackEnabledFlag",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AuthorizedFlag => "AuthorizedFlag",

            Self::AuthorizedToMaintainLiabilitiesFlag => "AuthorizedToMaintainLiabilitiesFlag",

            Self::TrustlineClawbackEnabledFlag => "TrustlineClawbackEnabledFlag",
        }
    }

    #[must_use]
    pub const fn variants() -> [TrustLineFlags; 3] {
        Self::VARIANTS
    }
}

impl Name for TrustLineFlags {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TrustLineFlags> for TrustLineFlags {
    fn variants() -> slice::Iter<'static, TrustLineFlags> {
        Self::VARIANTS.iter()
    }
}

impl Enum for TrustLineFlags {}

impl fmt::Display for TrustLineFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for TrustLineFlags {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            1 => TrustLineFlags::AuthorizedFlag,

            2 => TrustLineFlags::AuthorizedToMaintainLiabilitiesFlag,

            4 => TrustLineFlags::TrustlineClawbackEnabledFlag,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<TrustLineFlags> for i32 {
    #[must_use]
    fn from(e: TrustLineFlags) -> Self {
        e as Self
    }
}

impl ReadXdr for TrustLineFlags {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for TrustLineFlags {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

pub const MASK_TRUSTLINE_FLAGS: u64 = 1;

pub const MASK_TRUSTLINE_FLAGS_V13: u64 = 3;

pub const MASK_TRUSTLINE_FLAGS_V17: u64 = 7;

/// LiquidityPoolType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum LiquidityPoolType {
    #[cfg_attr(feature = "alloc", default)]
    LiquidityPoolConstantProduct = 0,
}

impl LiquidityPoolType {
    pub const VARIANTS: [LiquidityPoolType; 1] = [LiquidityPoolType::LiquidityPoolConstantProduct];
    pub const VARIANTS_STR: [&'static str; 1] = ["LiquidityPoolConstantProduct"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LiquidityPoolConstantProduct => "LiquidityPoolConstantProduct",
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolType; 1] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LiquidityPoolType> for LiquidityPoolType {
    fn variants() -> slice::Iter<'static, LiquidityPoolType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LiquidityPoolType {}

impl fmt::Display for LiquidityPoolType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LiquidityPoolType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => LiquidityPoolType::LiquidityPoolConstantProduct,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LiquidityPoolType> for i32 {
    #[must_use]
    fn from(e: LiquidityPoolType) -> Self {
        e as Self
    }
}

impl ReadXdr for LiquidityPoolType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// TrustLineAsset
// union with discriminant AssetType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TrustLineAsset {
    AssetTypeNative,

    AssetTypeCreditAlphanum4(AlphaNum4),

    AssetTypeCreditAlphanum12(AlphaNum12),

    AssetTypePoolShare(PoolId),
}

#[cfg(feature = "alloc")]
impl Default for TrustLineAsset {
    fn default() -> Self {
        Self::AssetTypeNative
    }
}

impl TrustLineAsset {
    pub const VARIANTS: [AssetType; 4] = [
        AssetType::AssetTypeNative,
        AssetType::AssetTypeCreditAlphanum4,
        AssetType::AssetTypeCreditAlphanum12,
        AssetType::AssetTypePoolShare,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "AssetTypeNative",
        "AssetTypeCreditAlphanum4",
        "AssetTypeCreditAlphanum12",
        "AssetTypePoolShare",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AssetTypeNative => "AssetTypeNative",

            Self::AssetTypeCreditAlphanum4(_) => "AssetTypeCreditAlphanum4",

            Self::AssetTypeCreditAlphanum12(_) => "AssetTypeCreditAlphanum12",

            Self::AssetTypePoolShare(_) => "AssetTypePoolShare",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AssetType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::AssetTypeNative => AssetType::AssetTypeNative,

            Self::AssetTypeCreditAlphanum4(_) => AssetType::AssetTypeCreditAlphanum4,

            Self::AssetTypeCreditAlphanum12(_) => AssetType::AssetTypeCreditAlphanum12,

            Self::AssetTypePoolShare(_) => AssetType::AssetTypePoolShare,
        }
    }

    #[must_use]
    pub const fn variants() -> [AssetType; 4] {
        Self::VARIANTS
    }
}

impl Name for TrustLineAsset {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AssetType> for TrustLineAsset {
    #[must_use]
    fn discriminant(&self) -> AssetType {
        Self::discriminant(self)
    }
}

impl Variants<AssetType> for TrustLineAsset {
    fn variants() -> slice::Iter<'static, AssetType> {
        Self::VARIANTS.iter()
    }
}

impl Union<AssetType> for TrustLineAsset {}

impl ReadXdr for TrustLineAsset {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: AssetType = <AssetType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AssetType::AssetTypeNative => Self::AssetTypeNative,

                AssetType::AssetTypeCreditAlphanum4 => {
                    Self::AssetTypeCreditAlphanum4(AlphaNum4::read_xdr(r)?)
                }

                AssetType::AssetTypeCreditAlphanum12 => {
                    Self::AssetTypeCreditAlphanum12(AlphaNum12::read_xdr(r)?)
                }

                AssetType::AssetTypePoolShare => Self::AssetTypePoolShare(PoolId::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TrustLineAsset {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::AssetTypeNative => ().write_xdr(w)?,

                Self::AssetTypeCreditAlphanum4(v) => v.write_xdr(w)?,

                Self::AssetTypeCreditAlphanum12(v) => v.write_xdr(w)?,

                Self::AssetTypePoolShare(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TrustLineEntryExtensionV2
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TrustLineEntryExtensionV2 {
    pub liquidity_pool_use_count: i32,

    pub ext: TrustLineEntryExtensionV2Ext,
}

impl ReadXdr for TrustLineEntryExtensionV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_use_count: i32::read_xdr(r)?,

                ext: TrustLineEntryExtensionV2Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TrustLineEntryExtensionV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_use_count.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TrustLineEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TrustLineEntry {
    pub account_id: AccountId,

    pub asset: TrustLineAsset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub balance: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub limit: i64,

    pub flags: u32,

    pub ext: TrustLineEntryExt,
}

impl ReadXdr for TrustLineEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,

                asset: TrustLineAsset::read_xdr(r)?,

                balance: i64::read_xdr(r)?,

                limit: i64::read_xdr(r)?,

                flags: u32::read_xdr(r)?,

                ext: TrustLineEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TrustLineEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;

            self.asset.write_xdr(w)?;

            self.balance.write_xdr(w)?;

            self.limit.write_xdr(w)?;

            self.flags.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// OfferEntryFlags
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum OfferEntryFlags {
    #[cfg_attr(feature = "alloc", default)]
    PassiveFlag = 1,
}

impl OfferEntryFlags {
    pub const VARIANTS: [OfferEntryFlags; 1] = [OfferEntryFlags::PassiveFlag];
    pub const VARIANTS_STR: [&'static str; 1] = ["PassiveFlag"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PassiveFlag => "PassiveFlag",
        }
    }

    #[must_use]
    pub const fn variants() -> [OfferEntryFlags; 1] {
        Self::VARIANTS
    }
}

impl Name for OfferEntryFlags {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<OfferEntryFlags> for OfferEntryFlags {
    fn variants() -> slice::Iter<'static, OfferEntryFlags> {
        Self::VARIANTS.iter()
    }
}

impl Enum for OfferEntryFlags {}

impl fmt::Display for OfferEntryFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for OfferEntryFlags {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            1 => OfferEntryFlags::PassiveFlag,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<OfferEntryFlags> for i32 {
    #[must_use]
    fn from(e: OfferEntryFlags) -> Self {
        e as Self
    }
}

impl ReadXdr for OfferEntryFlags {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for OfferEntryFlags {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

pub const MASK_OFFERENTRY_FLAGS: u64 = 1;

/// OfferEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct OfferEntry {
    pub seller_id: AccountId,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub offer_id: i64,

    pub selling: Asset,

    pub buying: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount: i64,

    pub price: Price,

    pub flags: u32,

    pub ext: OfferEntryExt,
}

impl ReadXdr for OfferEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                seller_id: AccountId::read_xdr(r)?,

                offer_id: i64::read_xdr(r)?,

                selling: Asset::read_xdr(r)?,

                buying: Asset::read_xdr(r)?,

                amount: i64::read_xdr(r)?,

                price: Price::read_xdr(r)?,

                flags: u32::read_xdr(r)?,

                ext: OfferEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for OfferEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.seller_id.write_xdr(w)?;

            self.offer_id.write_xdr(w)?;

            self.selling.write_xdr(w)?;

            self.buying.write_xdr(w)?;

            self.amount.write_xdr(w)?;

            self.price.write_xdr(w)?;

            self.flags.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// DataEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct DataEntry {
    pub account_id: AccountId,

    pub data_name: String64,

    pub data_value: DataValue,

    pub ext: DataEntryExt,
}

impl ReadXdr for DataEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,

                data_name: String64::read_xdr(r)?,

                data_value: DataValue::read_xdr(r)?,

                ext: DataEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for DataEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;

            self.data_name.write_xdr(w)?;

            self.data_value.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ClaimPredicateType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ClaimPredicateType {
    #[cfg_attr(feature = "alloc", default)]
    ClaimPredicateUnconditional = 0,

    ClaimPredicateAnd = 1,

    ClaimPredicateOr = 2,

    ClaimPredicateNot = 3,

    ClaimPredicateBeforeAbsoluteTime = 4,

    ClaimPredicateBeforeRelativeTime = 5,
}

impl ClaimPredicateType {
    pub const VARIANTS: [ClaimPredicateType; 6] = [
        ClaimPredicateType::ClaimPredicateUnconditional,
        ClaimPredicateType::ClaimPredicateAnd,
        ClaimPredicateType::ClaimPredicateOr,
        ClaimPredicateType::ClaimPredicateNot,
        ClaimPredicateType::ClaimPredicateBeforeAbsoluteTime,
        ClaimPredicateType::ClaimPredicateBeforeRelativeTime,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "ClaimPredicateUnconditional",
        "ClaimPredicateAnd",
        "ClaimPredicateOr",
        "ClaimPredicateNot",
        "ClaimPredicateBeforeAbsoluteTime",
        "ClaimPredicateBeforeRelativeTime",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimPredicateUnconditional => "ClaimPredicateUnconditional",

            Self::ClaimPredicateAnd => "ClaimPredicateAnd",

            Self::ClaimPredicateOr => "ClaimPredicateOr",

            Self::ClaimPredicateNot => "ClaimPredicateNot",

            Self::ClaimPredicateBeforeAbsoluteTime => "ClaimPredicateBeforeAbsoluteTime",

            Self::ClaimPredicateBeforeRelativeTime => "ClaimPredicateBeforeRelativeTime",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimPredicateType; 6] {
        Self::VARIANTS
    }
}

impl Name for ClaimPredicateType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimPredicateType> for ClaimPredicateType {
    fn variants() -> slice::Iter<'static, ClaimPredicateType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimPredicateType {}

impl fmt::Display for ClaimPredicateType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimPredicateType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ClaimPredicateType::ClaimPredicateUnconditional,

            1 => ClaimPredicateType::ClaimPredicateAnd,

            2 => ClaimPredicateType::ClaimPredicateOr,

            3 => ClaimPredicateType::ClaimPredicateNot,

            4 => ClaimPredicateType::ClaimPredicateBeforeAbsoluteTime,

            5 => ClaimPredicateType::ClaimPredicateBeforeRelativeTime,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimPredicateType> for i32 {
    #[must_use]
    fn from(e: ClaimPredicateType) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimPredicateType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimPredicateType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClaimPredicate
// union with discriminant ClaimPredicateType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ClaimPredicate {
    ClaimPredicateUnconditional,

    ClaimPredicateAnd(VecM<ClaimPredicate, 2>),

    ClaimPredicateOr(VecM<ClaimPredicate, 2>),

    ClaimPredicateNot(Option<Box<ClaimPredicate>>),

    ClaimPredicateBeforeAbsoluteTime(i64),

    ClaimPredicateBeforeRelativeTime(i64),
}

#[cfg(feature = "alloc")]
impl Default for ClaimPredicate {
    fn default() -> Self {
        Self::ClaimPredicateUnconditional
    }
}

impl ClaimPredicate {
    pub const VARIANTS: [ClaimPredicateType; 6] = [
        ClaimPredicateType::ClaimPredicateUnconditional,
        ClaimPredicateType::ClaimPredicateAnd,
        ClaimPredicateType::ClaimPredicateOr,
        ClaimPredicateType::ClaimPredicateNot,
        ClaimPredicateType::ClaimPredicateBeforeAbsoluteTime,
        ClaimPredicateType::ClaimPredicateBeforeRelativeTime,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "ClaimPredicateUnconditional",
        "ClaimPredicateAnd",
        "ClaimPredicateOr",
        "ClaimPredicateNot",
        "ClaimPredicateBeforeAbsoluteTime",
        "ClaimPredicateBeforeRelativeTime",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimPredicateUnconditional => "ClaimPredicateUnconditional",

            Self::ClaimPredicateAnd(_) => "ClaimPredicateAnd",

            Self::ClaimPredicateOr(_) => "ClaimPredicateOr",

            Self::ClaimPredicateNot(_) => "ClaimPredicateNot",

            Self::ClaimPredicateBeforeAbsoluteTime(_) => "ClaimPredicateBeforeAbsoluteTime",

            Self::ClaimPredicateBeforeRelativeTime(_) => "ClaimPredicateBeforeRelativeTime",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClaimPredicateType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ClaimPredicateUnconditional => ClaimPredicateType::ClaimPredicateUnconditional,

            Self::ClaimPredicateAnd(_) => ClaimPredicateType::ClaimPredicateAnd,

            Self::ClaimPredicateOr(_) => ClaimPredicateType::ClaimPredicateOr,

            Self::ClaimPredicateNot(_) => ClaimPredicateType::ClaimPredicateNot,

            Self::ClaimPredicateBeforeAbsoluteTime(_) => {
                ClaimPredicateType::ClaimPredicateBeforeAbsoluteTime
            }

            Self::ClaimPredicateBeforeRelativeTime(_) => {
                ClaimPredicateType::ClaimPredicateBeforeRelativeTime
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimPredicateType; 6] {
        Self::VARIANTS
    }
}

impl Name for ClaimPredicate {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClaimPredicateType> for ClaimPredicate {
    #[must_use]
    fn discriminant(&self) -> ClaimPredicateType {
        Self::discriminant(self)
    }
}

impl Variants<ClaimPredicateType> for ClaimPredicate {
    fn variants() -> slice::Iter<'static, ClaimPredicateType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClaimPredicateType> for ClaimPredicate {}

impl ReadXdr for ClaimPredicate {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ClaimPredicateType = <ClaimPredicateType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClaimPredicateType::ClaimPredicateUnconditional => {
                    Self::ClaimPredicateUnconditional
                }

                ClaimPredicateType::ClaimPredicateAnd => {
                    Self::ClaimPredicateAnd(VecM::<ClaimPredicate, 2>::read_xdr(r)?)
                }

                ClaimPredicateType::ClaimPredicateOr => {
                    Self::ClaimPredicateOr(VecM::<ClaimPredicate, 2>::read_xdr(r)?)
                }

                ClaimPredicateType::ClaimPredicateNot => {
                    Self::ClaimPredicateNot(Option::<Box<ClaimPredicate>>::read_xdr(r)?)
                }

                ClaimPredicateType::ClaimPredicateBeforeAbsoluteTime => {
                    Self::ClaimPredicateBeforeAbsoluteTime(i64::read_xdr(r)?)
                }

                ClaimPredicateType::ClaimPredicateBeforeRelativeTime => {
                    Self::ClaimPredicateBeforeRelativeTime(i64::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimPredicate {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ClaimPredicateUnconditional => ().write_xdr(w)?,

                Self::ClaimPredicateAnd(v) => v.write_xdr(w)?,

                Self::ClaimPredicateOr(v) => v.write_xdr(w)?,

                Self::ClaimPredicateNot(v) => v.write_xdr(w)?,

                Self::ClaimPredicateBeforeAbsoluteTime(v) => v.write_xdr(w)?,

                Self::ClaimPredicateBeforeRelativeTime(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClaimantType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ClaimantType {
    #[cfg_attr(feature = "alloc", default)]
    ClaimantTypeV0 = 0,
}

impl ClaimantType {
    pub const VARIANTS: [ClaimantType; 1] = [ClaimantType::ClaimantTypeV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ClaimantTypeV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimantTypeV0 => "ClaimantTypeV0",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimantType; 1] {
        Self::VARIANTS
    }
}

impl Name for ClaimantType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimantType> for ClaimantType {
    fn variants() -> slice::Iter<'static, ClaimantType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimantType {}

impl fmt::Display for ClaimantType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimantType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ClaimantType::ClaimantTypeV0,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimantType> for i32 {
    #[must_use]
    fn from(e: ClaimantType) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimantType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimantType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// Claimant
// union with discriminant ClaimantType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum Claimant {
    ClaimantTypeV0(ClaimantV0),
}

#[cfg(feature = "alloc")]
impl Default for Claimant {
    fn default() -> Self {
        Self::ClaimantTypeV0(ClaimantV0::default())
    }
}

impl Claimant {
    pub const VARIANTS: [ClaimantType; 1] = [ClaimantType::ClaimantTypeV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ClaimantTypeV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimantTypeV0(_) => "ClaimantTypeV0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClaimantType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ClaimantTypeV0(_) => ClaimantType::ClaimantTypeV0,
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimantType; 1] {
        Self::VARIANTS
    }
}

impl Name for Claimant {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClaimantType> for Claimant {
    #[must_use]
    fn discriminant(&self) -> ClaimantType {
        Self::discriminant(self)
    }
}

impl Variants<ClaimantType> for Claimant {
    fn variants() -> slice::Iter<'static, ClaimantType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClaimantType> for Claimant {}

impl ReadXdr for Claimant {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ClaimantType = <ClaimantType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClaimantType::ClaimantTypeV0 => Self::ClaimantTypeV0(ClaimantV0::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for Claimant {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ClaimantTypeV0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClaimableBalanceFlags
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ClaimableBalanceFlags {
    #[cfg_attr(feature = "alloc", default)]
    ClaimableBalanceClawbackEnabledFlag = 1,
}

impl ClaimableBalanceFlags {
    pub const VARIANTS: [ClaimableBalanceFlags; 1] =
        [ClaimableBalanceFlags::ClaimableBalanceClawbackEnabledFlag];
    pub const VARIANTS_STR: [&'static str; 1] = ["ClaimableBalanceClawbackEnabledFlag"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimableBalanceClawbackEnabledFlag => "ClaimableBalanceClawbackEnabledFlag",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimableBalanceFlags; 1] {
        Self::VARIANTS
    }
}

impl Name for ClaimableBalanceFlags {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimableBalanceFlags> for ClaimableBalanceFlags {
    fn variants() -> slice::Iter<'static, ClaimableBalanceFlags> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimableBalanceFlags {}

impl fmt::Display for ClaimableBalanceFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimableBalanceFlags {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            1 => ClaimableBalanceFlags::ClaimableBalanceClawbackEnabledFlag,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimableBalanceFlags> for i32 {
    #[must_use]
    fn from(e: ClaimableBalanceFlags) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimableBalanceFlags {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimableBalanceFlags {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

pub const MASK_CLAIMABLE_BALANCE_FLAGS: u64 = 1;

/// ClaimableBalanceEntryExtensionV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ClaimableBalanceEntryExtensionV1 {
    pub ext: ClaimableBalanceEntryExtensionV1Ext,

    pub flags: u32,
}

impl ReadXdr for ClaimableBalanceEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ClaimableBalanceEntryExtensionV1Ext::read_xdr(r)?,

                flags: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimableBalanceEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.flags.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ClaimableBalanceEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ClaimableBalanceEntry {
    pub balance_id: ClaimableBalanceId,

    pub claimants: VecM<Claimant, 10>,

    pub asset: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount: i64,

    pub ext: ClaimableBalanceEntryExt,
}

impl ReadXdr for ClaimableBalanceEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                balance_id: ClaimableBalanceId::read_xdr(r)?,

                claimants: VecM::<Claimant, 10>::read_xdr(r)?,

                asset: Asset::read_xdr(r)?,

                amount: i64::read_xdr(r)?,

                ext: ClaimableBalanceEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimableBalanceEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.balance_id.write_xdr(w)?;

            self.claimants.write_xdr(w)?;

            self.asset.write_xdr(w)?;

            self.amount.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LiquidityPoolConstantProductParameters
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LiquidityPoolConstantProductParameters {
    pub asset_a: Asset,

    pub asset_b: Asset,

    pub fee: i32,
}

impl ReadXdr for LiquidityPoolConstantProductParameters {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                asset_a: Asset::read_xdr(r)?,

                asset_b: Asset::read_xdr(r)?,

                fee: i32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LiquidityPoolConstantProductParameters {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.asset_a.write_xdr(w)?;

            self.asset_b.write_xdr(w)?;

            self.fee.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LiquidityPoolEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LiquidityPoolEntry {
    pub liquidity_pool_id: PoolId,

    pub body: LiquidityPoolEntryBody,
}

impl ReadXdr for LiquidityPoolEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_id: PoolId::read_xdr(r)?,

                body: LiquidityPoolEntryBody::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LiquidityPoolEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_id.write_xdr(w)?;

            self.body.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ContractDataDurability
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ContractDataDurability {
    #[cfg_attr(feature = "alloc", default)]
    Temporary = 0,

    Persistent = 1,
}

impl ContractDataDurability {
    pub const VARIANTS: [ContractDataDurability; 2] = [
        ContractDataDurability::Temporary,
        ContractDataDurability::Persistent,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["Temporary", "Persistent"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Temporary => "Temporary",

            Self::Persistent => "Persistent",
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractDataDurability; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractDataDurability {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ContractDataDurability> for ContractDataDurability {
    fn variants() -> slice::Iter<'static, ContractDataDurability> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ContractDataDurability {}

impl fmt::Display for ContractDataDurability {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ContractDataDurability {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ContractDataDurability::Temporary,

            1 => ContractDataDurability::Persistent,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ContractDataDurability> for i32 {
    #[must_use]
    fn from(e: ContractDataDurability) -> Self {
        e as Self
    }
}

impl ReadXdr for ContractDataDurability {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ContractDataDurability {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractDataEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ContractDataEntry {
    pub ext: ExtensionPoint,

    pub contract: ScAddress,

    pub key: ScVal,

    pub durability: ContractDataDurability,

    pub val: ScVal,
}

impl ReadXdr for ContractDataEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                contract: ScAddress::read_xdr(r)?,

                key: ScVal::read_xdr(r)?,

                durability: ContractDataDurability::read_xdr(r)?,

                val: ScVal::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractDataEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.contract.write_xdr(w)?;

            self.key.write_xdr(w)?;

            self.durability.write_xdr(w)?;

            self.val.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ContractCodeCostInputs
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ContractCodeCostInputs {
    pub ext: ExtensionPoint,

    pub n_instructions: u32,

    pub n_functions: u32,

    pub n_globals: u32,

    pub n_table_entries: u32,

    pub n_types: u32,

    pub n_data_segments: u32,

    pub n_elem_segments: u32,

    pub n_imports: u32,

    pub n_exports: u32,

    pub n_data_segment_bytes: u32,
}

impl ReadXdr for ContractCodeCostInputs {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                n_instructions: u32::read_xdr(r)?,

                n_functions: u32::read_xdr(r)?,

                n_globals: u32::read_xdr(r)?,

                n_table_entries: u32::read_xdr(r)?,

                n_types: u32::read_xdr(r)?,

                n_data_segments: u32::read_xdr(r)?,

                n_elem_segments: u32::read_xdr(r)?,

                n_imports: u32::read_xdr(r)?,

                n_exports: u32::read_xdr(r)?,

                n_data_segment_bytes: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractCodeCostInputs {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.n_instructions.write_xdr(w)?;

            self.n_functions.write_xdr(w)?;

            self.n_globals.write_xdr(w)?;

            self.n_table_entries.write_xdr(w)?;

            self.n_types.write_xdr(w)?;

            self.n_data_segments.write_xdr(w)?;

            self.n_elem_segments.write_xdr(w)?;

            self.n_imports.write_xdr(w)?;

            self.n_exports.write_xdr(w)?;

            self.n_data_segment_bytes.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ContractCodeEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ContractCodeEntry {
    pub ext: ContractCodeEntryExt,

    pub hash: Hash,

    pub code: BytesM,
}

impl ReadXdr for ContractCodeEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ContractCodeEntryExt::read_xdr(r)?,

                hash: Hash::read_xdr(r)?,

                code: BytesM::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractCodeEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.hash.write_xdr(w)?;

            self.code.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TtlEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TtlEntry {
    pub key_hash: Hash,

    pub live_until_ledger_seq: u32,
}

impl ReadXdr for TtlEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key_hash: Hash::read_xdr(r)?,

                live_until_ledger_seq: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TtlEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.key_hash.write_xdr(w)?;

            self.live_until_ledger_seq.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerEntryExtensionV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerEntryExtensionV1 {
    pub sponsoring_id: SponsorshipDescriptor,

    pub ext: LedgerEntryExtensionV1Ext,
}

impl ReadXdr for LedgerEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                sponsoring_id: SponsorshipDescriptor::read_xdr(r)?,

                ext: LedgerEntryExtensionV1Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.sponsoring_id.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerEntry {
    pub last_modified_ledger_seq: u32,

    pub data: LedgerEntryData,

    pub ext: LedgerEntryExt,
}

impl ReadXdr for LedgerEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                last_modified_ledger_seq: u32::read_xdr(r)?,

                data: LedgerEntryData::read_xdr(r)?,

                ext: LedgerEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.last_modified_ledger_seq.write_xdr(w)?;

            self.data.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerKey
// union with discriminant LedgerEntryType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LedgerKey {
    Account(LedgerKeyAccount),

    Trustline(LedgerKeyTrustLine),

    Offer(LedgerKeyOffer),

    Data(LedgerKeyData),

    ClaimableBalance(LedgerKeyClaimableBalance),

    LiquidityPool(LedgerKeyLiquidityPool),

    ContractData(LedgerKeyContractData),

    ContractCode(LedgerKeyContractCode),

    ConfigSetting(LedgerKeyConfigSetting),

    Ttl(LedgerKeyTtl),
}

#[cfg(feature = "alloc")]
impl Default for LedgerKey {
    fn default() -> Self {
        Self::Account(LedgerKeyAccount::default())
    }
}

impl LedgerKey {
    pub const VARIANTS: [LedgerEntryType; 10] = [
        LedgerEntryType::Account,
        LedgerEntryType::Trustline,
        LedgerEntryType::Offer,
        LedgerEntryType::Data,
        LedgerEntryType::ClaimableBalance,
        LedgerEntryType::LiquidityPool,
        LedgerEntryType::ContractData,
        LedgerEntryType::ContractCode,
        LedgerEntryType::ConfigSetting,
        LedgerEntryType::Ttl,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "Account",
        "Trustline",
        "Offer",
        "Data",
        "ClaimableBalance",
        "LiquidityPool",
        "ContractData",
        "ContractCode",
        "ConfigSetting",
        "Ttl",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Account(_) => "Account",

            Self::Trustline(_) => "Trustline",

            Self::Offer(_) => "Offer",

            Self::Data(_) => "Data",

            Self::ClaimableBalance(_) => "ClaimableBalance",

            Self::LiquidityPool(_) => "LiquidityPool",

            Self::ContractData(_) => "ContractData",

            Self::ContractCode(_) => "ContractCode",

            Self::ConfigSetting(_) => "ConfigSetting",

            Self::Ttl(_) => "Ttl",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LedgerEntryType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Account(_) => LedgerEntryType::Account,

            Self::Trustline(_) => LedgerEntryType::Trustline,

            Self::Offer(_) => LedgerEntryType::Offer,

            Self::Data(_) => LedgerEntryType::Data,

            Self::ClaimableBalance(_) => LedgerEntryType::ClaimableBalance,

            Self::LiquidityPool(_) => LedgerEntryType::LiquidityPool,

            Self::ContractData(_) => LedgerEntryType::ContractData,

            Self::ContractCode(_) => LedgerEntryType::ContractCode,

            Self::ConfigSetting(_) => LedgerEntryType::ConfigSetting,

            Self::Ttl(_) => LedgerEntryType::Ttl,
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerEntryType; 10] {
        Self::VARIANTS
    }
}

impl Name for LedgerKey {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LedgerEntryType> for LedgerKey {
    #[must_use]
    fn discriminant(&self) -> LedgerEntryType {
        Self::discriminant(self)
    }
}

impl Variants<LedgerEntryType> for LedgerKey {
    fn variants() -> slice::Iter<'static, LedgerEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LedgerEntryType> for LedgerKey {}

impl ReadXdr for LedgerKey {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: LedgerEntryType = <LedgerEntryType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LedgerEntryType::Account => Self::Account(LedgerKeyAccount::read_xdr(r)?),

                LedgerEntryType::Trustline => Self::Trustline(LedgerKeyTrustLine::read_xdr(r)?),

                LedgerEntryType::Offer => Self::Offer(LedgerKeyOffer::read_xdr(r)?),

                LedgerEntryType::Data => Self::Data(LedgerKeyData::read_xdr(r)?),

                LedgerEntryType::ClaimableBalance => {
                    Self::ClaimableBalance(LedgerKeyClaimableBalance::read_xdr(r)?)
                }

                LedgerEntryType::LiquidityPool => {
                    Self::LiquidityPool(LedgerKeyLiquidityPool::read_xdr(r)?)
                }

                LedgerEntryType::ContractData => {
                    Self::ContractData(LedgerKeyContractData::read_xdr(r)?)
                }

                LedgerEntryType::ContractCode => {
                    Self::ContractCode(LedgerKeyContractCode::read_xdr(r)?)
                }

                LedgerEntryType::ConfigSetting => {
                    Self::ConfigSetting(LedgerKeyConfigSetting::read_xdr(r)?)
                }

                LedgerEntryType::Ttl => Self::Ttl(LedgerKeyTtl::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerKey {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Account(v) => v.write_xdr(w)?,

                Self::Trustline(v) => v.write_xdr(w)?,

                Self::Offer(v) => v.write_xdr(w)?,

                Self::Data(v) => v.write_xdr(w)?,

                Self::ClaimableBalance(v) => v.write_xdr(w)?,

                Self::LiquidityPool(v) => v.write_xdr(w)?,

                Self::ContractData(v) => v.write_xdr(w)?,

                Self::ContractCode(v) => v.write_xdr(w)?,

                Self::ConfigSetting(v) => v.write_xdr(w)?,

                Self::Ttl(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// EnvelopeType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum EnvelopeType {
    #[cfg_attr(feature = "alloc", default)]
    EnvelopeTypeTxV0 = 0,

    EnvelopeTypeScp = 1,

    EnvelopeTypeTx = 2,

    EnvelopeTypeAuth = 3,

    EnvelopeTypeScpvalue = 4,

    EnvelopeTypeTxFeeBump = 5,

    EnvelopeTypeOpId = 6,

    EnvelopeTypePoolRevokeOpId = 7,

    EnvelopeTypeContractId = 8,

    EnvelopeTypeSorobanAuthorization = 9,
}

impl EnvelopeType {
    pub const VARIANTS: [EnvelopeType; 10] = [
        EnvelopeType::EnvelopeTypeTxV0,
        EnvelopeType::EnvelopeTypeScp,
        EnvelopeType::EnvelopeTypeTx,
        EnvelopeType::EnvelopeTypeAuth,
        EnvelopeType::EnvelopeTypeScpvalue,
        EnvelopeType::EnvelopeTypeTxFeeBump,
        EnvelopeType::EnvelopeTypeOpId,
        EnvelopeType::EnvelopeTypePoolRevokeOpId,
        EnvelopeType::EnvelopeTypeContractId,
        EnvelopeType::EnvelopeTypeSorobanAuthorization,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "EnvelopeTypeTxV0",
        "EnvelopeTypeScp",
        "EnvelopeTypeTx",
        "EnvelopeTypeAuth",
        "EnvelopeTypeScpvalue",
        "EnvelopeTypeTxFeeBump",
        "EnvelopeTypeOpId",
        "EnvelopeTypePoolRevokeOpId",
        "EnvelopeTypeContractId",
        "EnvelopeTypeSorobanAuthorization",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::EnvelopeTypeTxV0 => "EnvelopeTypeTxV0",

            Self::EnvelopeTypeScp => "EnvelopeTypeScp",

            Self::EnvelopeTypeTx => "EnvelopeTypeTx",

            Self::EnvelopeTypeAuth => "EnvelopeTypeAuth",

            Self::EnvelopeTypeScpvalue => "EnvelopeTypeScpvalue",

            Self::EnvelopeTypeTxFeeBump => "EnvelopeTypeTxFeeBump",

            Self::EnvelopeTypeOpId => "EnvelopeTypeOpId",

            Self::EnvelopeTypePoolRevokeOpId => "EnvelopeTypePoolRevokeOpId",

            Self::EnvelopeTypeContractId => "EnvelopeTypeContractId",

            Self::EnvelopeTypeSorobanAuthorization => "EnvelopeTypeSorobanAuthorization",
        }
    }

    #[must_use]
    pub const fn variants() -> [EnvelopeType; 10] {
        Self::VARIANTS
    }
}

impl Name for EnvelopeType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<EnvelopeType> for EnvelopeType {
    fn variants() -> slice::Iter<'static, EnvelopeType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for EnvelopeType {}

impl fmt::Display for EnvelopeType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for EnvelopeType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => EnvelopeType::EnvelopeTypeTxV0,

            1 => EnvelopeType::EnvelopeTypeScp,

            2 => EnvelopeType::EnvelopeTypeTx,

            3 => EnvelopeType::EnvelopeTypeAuth,

            4 => EnvelopeType::EnvelopeTypeScpvalue,

            5 => EnvelopeType::EnvelopeTypeTxFeeBump,

            6 => EnvelopeType::EnvelopeTypeOpId,

            7 => EnvelopeType::EnvelopeTypePoolRevokeOpId,

            8 => EnvelopeType::EnvelopeTypeContractId,

            9 => EnvelopeType::EnvelopeTypeSorobanAuthorization,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<EnvelopeType> for i32 {
    #[must_use]
    fn from(e: EnvelopeType) -> Self {
        e as Self
    }
}

impl ReadXdr for EnvelopeType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for EnvelopeType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// BucketListType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum BucketListType {
    #[cfg_attr(feature = "alloc", default)]
    Live = 0,

    HotArchive = 1,
}

impl BucketListType {
    pub const VARIANTS: [BucketListType; 2] = [BucketListType::Live, BucketListType::HotArchive];
    pub const VARIANTS_STR: [&'static str; 2] = ["Live", "HotArchive"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Live => "Live",

            Self::HotArchive => "HotArchive",
        }
    }

    #[must_use]
    pub const fn variants() -> [BucketListType; 2] {
        Self::VARIANTS
    }
}

impl Name for BucketListType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<BucketListType> for BucketListType {
    fn variants() -> slice::Iter<'static, BucketListType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for BucketListType {}

impl fmt::Display for BucketListType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for BucketListType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => BucketListType::Live,

            1 => BucketListType::HotArchive,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<BucketListType> for i32 {
    #[must_use]
    fn from(e: BucketListType) -> Self {
        e as Self
    }
}

impl ReadXdr for BucketListType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for BucketListType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// BucketEntryType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum BucketEntryType {
    #[cfg_attr(feature = "alloc", default)]
    Metaentry = -1,

    Liveentry = 0,

    Deadentry = 1,

    Initentry = 2,
}

impl BucketEntryType {
    pub const VARIANTS: [BucketEntryType; 4] = [
        BucketEntryType::Metaentry,
        BucketEntryType::Liveentry,
        BucketEntryType::Deadentry,
        BucketEntryType::Initentry,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Metaentry", "Liveentry", "Deadentry", "Initentry"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Metaentry => "Metaentry",

            Self::Liveentry => "Liveentry",

            Self::Deadentry => "Deadentry",

            Self::Initentry => "Initentry",
        }
    }

    #[must_use]
    pub const fn variants() -> [BucketEntryType; 4] {
        Self::VARIANTS
    }
}

impl Name for BucketEntryType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<BucketEntryType> for BucketEntryType {
    fn variants() -> slice::Iter<'static, BucketEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for BucketEntryType {}

impl fmt::Display for BucketEntryType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for BucketEntryType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            -1 => BucketEntryType::Metaentry,

            0 => BucketEntryType::Liveentry,

            1 => BucketEntryType::Deadentry,

            2 => BucketEntryType::Initentry,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<BucketEntryType> for i32 {
    #[must_use]
    fn from(e: BucketEntryType) -> Self {
        e as Self
    }
}

impl ReadXdr for BucketEntryType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for BucketEntryType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// HotArchiveBucketEntryType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum HotArchiveBucketEntryType {
    #[cfg_attr(feature = "alloc", default)]
    HotArchiveMetaentry = -1,

    HotArchiveArchived = 0,

    HotArchiveLive = 1,
}

impl HotArchiveBucketEntryType {
    pub const VARIANTS: [HotArchiveBucketEntryType; 3] = [
        HotArchiveBucketEntryType::HotArchiveMetaentry,
        HotArchiveBucketEntryType::HotArchiveArchived,
        HotArchiveBucketEntryType::HotArchiveLive,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "HotArchiveMetaentry",
        "HotArchiveArchived",
        "HotArchiveLive",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::HotArchiveMetaentry => "HotArchiveMetaentry",

            Self::HotArchiveArchived => "HotArchiveArchived",

            Self::HotArchiveLive => "HotArchiveLive",
        }
    }

    #[must_use]
    pub const fn variants() -> [HotArchiveBucketEntryType; 3] {
        Self::VARIANTS
    }
}

impl Name for HotArchiveBucketEntryType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<HotArchiveBucketEntryType> for HotArchiveBucketEntryType {
    fn variants() -> slice::Iter<'static, HotArchiveBucketEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for HotArchiveBucketEntryType {}

impl fmt::Display for HotArchiveBucketEntryType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for HotArchiveBucketEntryType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            -1 => HotArchiveBucketEntryType::HotArchiveMetaentry,

            0 => HotArchiveBucketEntryType::HotArchiveArchived,

            1 => HotArchiveBucketEntryType::HotArchiveLive,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<HotArchiveBucketEntryType> for i32 {
    #[must_use]
    fn from(e: HotArchiveBucketEntryType) -> Self {
        e as Self
    }
}

impl ReadXdr for HotArchiveBucketEntryType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for HotArchiveBucketEntryType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// BucketMetadata
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct BucketMetadata {
    pub ledger_version: u32,

    pub ext: BucketMetadataExt,
}

impl ReadXdr for BucketMetadata {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_version: u32::read_xdr(r)?,

                ext: BucketMetadataExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for BucketMetadata {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_version.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// BucketEntry
// union with discriminant BucketEntryType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum BucketEntry {
    Liveentry(LedgerEntry),

    Initentry(LedgerEntry),

    Deadentry(LedgerKey),

    Metaentry(BucketMetadata),
}

#[cfg(feature = "alloc")]
impl Default for BucketEntry {
    fn default() -> Self {
        Self::Liveentry(LedgerEntry::default())
    }
}

impl BucketEntry {
    pub const VARIANTS: [BucketEntryType; 4] = [
        BucketEntryType::Liveentry,
        BucketEntryType::Initentry,
        BucketEntryType::Deadentry,
        BucketEntryType::Metaentry,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Liveentry", "Initentry", "Deadentry", "Metaentry"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Liveentry(_) => "Liveentry",

            Self::Initentry(_) => "Initentry",

            Self::Deadentry(_) => "Deadentry",

            Self::Metaentry(_) => "Metaentry",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> BucketEntryType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Liveentry(_) => BucketEntryType::Liveentry,

            Self::Initentry(_) => BucketEntryType::Initentry,

            Self::Deadentry(_) => BucketEntryType::Deadentry,

            Self::Metaentry(_) => BucketEntryType::Metaentry,
        }
    }

    #[must_use]
    pub const fn variants() -> [BucketEntryType; 4] {
        Self::VARIANTS
    }
}

impl Name for BucketEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<BucketEntryType> for BucketEntry {
    #[must_use]
    fn discriminant(&self) -> BucketEntryType {
        Self::discriminant(self)
    }
}

impl Variants<BucketEntryType> for BucketEntry {
    fn variants() -> slice::Iter<'static, BucketEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Union<BucketEntryType> for BucketEntry {}

impl ReadXdr for BucketEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: BucketEntryType = <BucketEntryType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                BucketEntryType::Liveentry => Self::Liveentry(LedgerEntry::read_xdr(r)?),

                BucketEntryType::Initentry => Self::Initentry(LedgerEntry::read_xdr(r)?),

                BucketEntryType::Deadentry => Self::Deadentry(LedgerKey::read_xdr(r)?),

                BucketEntryType::Metaentry => Self::Metaentry(BucketMetadata::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for BucketEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Liveentry(v) => v.write_xdr(w)?,

                Self::Initentry(v) => v.write_xdr(w)?,

                Self::Deadentry(v) => v.write_xdr(w)?,

                Self::Metaentry(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// HotArchiveBucketEntry
// union with discriminant HotArchiveBucketEntryType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum HotArchiveBucketEntry {
    HotArchiveArchived(LedgerEntry),

    HotArchiveLive(LedgerKey),

    HotArchiveMetaentry(BucketMetadata),
}

#[cfg(feature = "alloc")]
impl Default for HotArchiveBucketEntry {
    fn default() -> Self {
        Self::HotArchiveArchived(LedgerEntry::default())
    }
}

impl HotArchiveBucketEntry {
    pub const VARIANTS: [HotArchiveBucketEntryType; 3] = [
        HotArchiveBucketEntryType::HotArchiveArchived,
        HotArchiveBucketEntryType::HotArchiveLive,
        HotArchiveBucketEntryType::HotArchiveMetaentry,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "HotArchiveArchived",
        "HotArchiveLive",
        "HotArchiveMetaentry",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::HotArchiveArchived(_) => "HotArchiveArchived",

            Self::HotArchiveLive(_) => "HotArchiveLive",

            Self::HotArchiveMetaentry(_) => "HotArchiveMetaentry",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> HotArchiveBucketEntryType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::HotArchiveArchived(_) => HotArchiveBucketEntryType::HotArchiveArchived,

            Self::HotArchiveLive(_) => HotArchiveBucketEntryType::HotArchiveLive,

            Self::HotArchiveMetaentry(_) => HotArchiveBucketEntryType::HotArchiveMetaentry,
        }
    }

    #[must_use]
    pub const fn variants() -> [HotArchiveBucketEntryType; 3] {
        Self::VARIANTS
    }
}

impl Name for HotArchiveBucketEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<HotArchiveBucketEntryType> for HotArchiveBucketEntry {
    #[must_use]
    fn discriminant(&self) -> HotArchiveBucketEntryType {
        Self::discriminant(self)
    }
}

impl Variants<HotArchiveBucketEntryType> for HotArchiveBucketEntry {
    fn variants() -> slice::Iter<'static, HotArchiveBucketEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Union<HotArchiveBucketEntryType> for HotArchiveBucketEntry {}

impl ReadXdr for HotArchiveBucketEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: HotArchiveBucketEntryType =
                <HotArchiveBucketEntryType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                HotArchiveBucketEntryType::HotArchiveArchived => {
                    Self::HotArchiveArchived(LedgerEntry::read_xdr(r)?)
                }

                HotArchiveBucketEntryType::HotArchiveLive => {
                    Self::HotArchiveLive(LedgerKey::read_xdr(r)?)
                }

                HotArchiveBucketEntryType::HotArchiveMetaentry => {
                    Self::HotArchiveMetaentry(BucketMetadata::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for HotArchiveBucketEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::HotArchiveArchived(v) => v.write_xdr(w)?,

                Self::HotArchiveLive(v) => v.write_xdr(w)?,

                Self::HotArchiveMetaentry(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// UpgradeType
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct UpgradeType(pub BytesM<128>);

impl From<UpgradeType> for BytesM<128> {
    #[must_use]
    fn from(x: UpgradeType) -> Self {
        x.0
    }
}

impl From<BytesM<128>> for UpgradeType {
    #[must_use]
    fn from(x: BytesM<128>) -> Self {
        UpgradeType(x)
    }
}

impl AsRef<BytesM<128>> for UpgradeType {
    #[must_use]
    fn as_ref(&self) -> &BytesM<128> {
        &self.0
    }
}

impl ReadXdr for UpgradeType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = BytesM::<128>::read_xdr(r)?;
            let v = UpgradeType(i);
            Ok(v)
        })
    }
}

impl WriteXdr for UpgradeType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for UpgradeType {
    type Target = BytesM<128>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<UpgradeType> for Vec<u8> {
    #[must_use]
    fn from(x: UpgradeType) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for UpgradeType {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        Ok(UpgradeType(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for UpgradeType {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        Ok(UpgradeType(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for UpgradeType {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for UpgradeType {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// StellarValueType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum StellarValueType {
    #[cfg_attr(feature = "alloc", default)]
    StellarValueBasic = 0,

    StellarValueSigned = 1,
}

impl StellarValueType {
    pub const VARIANTS: [StellarValueType; 2] = [
        StellarValueType::StellarValueBasic,
        StellarValueType::StellarValueSigned,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["StellarValueBasic", "StellarValueSigned"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::StellarValueBasic => "StellarValueBasic",

            Self::StellarValueSigned => "StellarValueSigned",
        }
    }

    #[must_use]
    pub const fn variants() -> [StellarValueType; 2] {
        Self::VARIANTS
    }
}

impl Name for StellarValueType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<StellarValueType> for StellarValueType {
    fn variants() -> slice::Iter<'static, StellarValueType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for StellarValueType {}

impl fmt::Display for StellarValueType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for StellarValueType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => StellarValueType::StellarValueBasic,

            1 => StellarValueType::StellarValueSigned,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<StellarValueType> for i32 {
    #[must_use]
    fn from(e: StellarValueType) -> Self {
        e as Self
    }
}

impl ReadXdr for StellarValueType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for StellarValueType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LedgerCloseValueSignature
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerCloseValueSignature {
    pub node_id: NodeId,

    pub signature: Signature,
}

impl ReadXdr for LedgerCloseValueSignature {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                node_id: NodeId::read_xdr(r)?,

                signature: Signature::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerCloseValueSignature {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.node_id.write_xdr(w)?;

            self.signature.write_xdr(w)?;

            Ok(())
        })
    }
}

/// StellarValue
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct StellarValue {
    pub tx_set_hash: Hash,

    pub close_time: TimePoint,

    pub upgrades: VecM<UpgradeType, 6>,

    pub ext: StellarValueExt,
}

impl ReadXdr for StellarValue {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_set_hash: Hash::read_xdr(r)?,

                close_time: TimePoint::read_xdr(r)?,

                upgrades: VecM::<UpgradeType, 6>::read_xdr(r)?,

                ext: StellarValueExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for StellarValue {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.tx_set_hash.write_xdr(w)?;

            self.close_time.write_xdr(w)?;

            self.upgrades.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

pub const MASK_LEDGER_HEADER_FLAGS: u64 = 7;

/// LedgerHeaderFlags
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum LedgerHeaderFlags {
    #[cfg_attr(feature = "alloc", default)]
    DisableLiquidityPoolTradingFlag = 1,

    DisableLiquidityPoolDepositFlag = 2,

    DisableLiquidityPoolWithdrawalFlag = 4,
}

impl LedgerHeaderFlags {
    pub const VARIANTS: [LedgerHeaderFlags; 3] = [
        LedgerHeaderFlags::DisableLiquidityPoolTradingFlag,
        LedgerHeaderFlags::DisableLiquidityPoolDepositFlag,
        LedgerHeaderFlags::DisableLiquidityPoolWithdrawalFlag,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "DisableLiquidityPoolTradingFlag",
        "DisableLiquidityPoolDepositFlag",
        "DisableLiquidityPoolWithdrawalFlag",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::DisableLiquidityPoolTradingFlag => "DisableLiquidityPoolTradingFlag",

            Self::DisableLiquidityPoolDepositFlag => "DisableLiquidityPoolDepositFlag",

            Self::DisableLiquidityPoolWithdrawalFlag => "DisableLiquidityPoolWithdrawalFlag",
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerHeaderFlags; 3] {
        Self::VARIANTS
    }
}

impl Name for LedgerHeaderFlags {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LedgerHeaderFlags> for LedgerHeaderFlags {
    fn variants() -> slice::Iter<'static, LedgerHeaderFlags> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LedgerHeaderFlags {}

impl fmt::Display for LedgerHeaderFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LedgerHeaderFlags {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            1 => LedgerHeaderFlags::DisableLiquidityPoolTradingFlag,

            2 => LedgerHeaderFlags::DisableLiquidityPoolDepositFlag,

            4 => LedgerHeaderFlags::DisableLiquidityPoolWithdrawalFlag,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LedgerHeaderFlags> for i32 {
    #[must_use]
    fn from(e: LedgerHeaderFlags) -> Self {
        e as Self
    }
}

impl ReadXdr for LedgerHeaderFlags {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerHeaderFlags {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LedgerHeaderExtensionV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerHeaderExtensionV1 {
    pub flags: u32,

    pub ext: LedgerHeaderExtensionV1Ext,
}

impl ReadXdr for LedgerHeaderExtensionV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                flags: u32::read_xdr(r)?,

                ext: LedgerHeaderExtensionV1Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerHeaderExtensionV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.flags.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerHeader
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerHeader {
    pub ledger_version: u32,

    pub previous_ledger_hash: Hash,

    pub scp_value: StellarValue,

    pub tx_set_result_hash: Hash,

    pub bucket_list_hash: Hash,

    pub ledger_seq: u32,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub total_coins: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee_pool: i64,

    pub inflation_seq: u32,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub id_pool: u64,

    pub base_fee: u32,

    pub base_reserve: u32,

    pub max_tx_set_size: u32,

    pub skip_list: [Hash; 4],

    pub ext: LedgerHeaderExt,
}

impl ReadXdr for LedgerHeader {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_version: u32::read_xdr(r)?,

                previous_ledger_hash: Hash::read_xdr(r)?,

                scp_value: StellarValue::read_xdr(r)?,

                tx_set_result_hash: Hash::read_xdr(r)?,

                bucket_list_hash: Hash::read_xdr(r)?,

                ledger_seq: u32::read_xdr(r)?,

                total_coins: i64::read_xdr(r)?,

                fee_pool: i64::read_xdr(r)?,

                inflation_seq: u32::read_xdr(r)?,

                id_pool: u64::read_xdr(r)?,

                base_fee: u32::read_xdr(r)?,

                base_reserve: u32::read_xdr(r)?,

                max_tx_set_size: u32::read_xdr(r)?,

                skip_list: <[Hash; 4]>::read_xdr(r)?,

                ext: LedgerHeaderExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerHeader {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_version.write_xdr(w)?;

            self.previous_ledger_hash.write_xdr(w)?;

            self.scp_value.write_xdr(w)?;

            self.tx_set_result_hash.write_xdr(w)?;

            self.bucket_list_hash.write_xdr(w)?;

            self.ledger_seq.write_xdr(w)?;

            self.total_coins.write_xdr(w)?;

            self.fee_pool.write_xdr(w)?;

            self.inflation_seq.write_xdr(w)?;

            self.id_pool.write_xdr(w)?;

            self.base_fee.write_xdr(w)?;

            self.base_reserve.write_xdr(w)?;

            self.max_tx_set_size.write_xdr(w)?;

            self.skip_list.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerUpgradeType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum LedgerUpgradeType {
    #[cfg_attr(feature = "alloc", default)]
    LedgerUpgradeVersion = 1,

    LedgerUpgradeBaseFee = 2,

    LedgerUpgradeMaxTxSetSize = 3,

    LedgerUpgradeBaseReserve = 4,

    LedgerUpgradeFlags = 5,

    LedgerUpgradeConfig = 6,

    LedgerUpgradeMaxSorobanTxSetSize = 7,
}

impl LedgerUpgradeType {
    pub const VARIANTS: [LedgerUpgradeType; 7] = [
        LedgerUpgradeType::LedgerUpgradeVersion,
        LedgerUpgradeType::LedgerUpgradeBaseFee,
        LedgerUpgradeType::LedgerUpgradeMaxTxSetSize,
        LedgerUpgradeType::LedgerUpgradeBaseReserve,
        LedgerUpgradeType::LedgerUpgradeFlags,
        LedgerUpgradeType::LedgerUpgradeConfig,
        LedgerUpgradeType::LedgerUpgradeMaxSorobanTxSetSize,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "LedgerUpgradeVersion",
        "LedgerUpgradeBaseFee",
        "LedgerUpgradeMaxTxSetSize",
        "LedgerUpgradeBaseReserve",
        "LedgerUpgradeFlags",
        "LedgerUpgradeConfig",
        "LedgerUpgradeMaxSorobanTxSetSize",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LedgerUpgradeVersion => "LedgerUpgradeVersion",

            Self::LedgerUpgradeBaseFee => "LedgerUpgradeBaseFee",

            Self::LedgerUpgradeMaxTxSetSize => "LedgerUpgradeMaxTxSetSize",

            Self::LedgerUpgradeBaseReserve => "LedgerUpgradeBaseReserve",

            Self::LedgerUpgradeFlags => "LedgerUpgradeFlags",

            Self::LedgerUpgradeConfig => "LedgerUpgradeConfig",

            Self::LedgerUpgradeMaxSorobanTxSetSize => "LedgerUpgradeMaxSorobanTxSetSize",
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerUpgradeType; 7] {
        Self::VARIANTS
    }
}

impl Name for LedgerUpgradeType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LedgerUpgradeType> for LedgerUpgradeType {
    fn variants() -> slice::Iter<'static, LedgerUpgradeType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LedgerUpgradeType {}

impl fmt::Display for LedgerUpgradeType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LedgerUpgradeType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            1 => LedgerUpgradeType::LedgerUpgradeVersion,

            2 => LedgerUpgradeType::LedgerUpgradeBaseFee,

            3 => LedgerUpgradeType::LedgerUpgradeMaxTxSetSize,

            4 => LedgerUpgradeType::LedgerUpgradeBaseReserve,

            5 => LedgerUpgradeType::LedgerUpgradeFlags,

            6 => LedgerUpgradeType::LedgerUpgradeConfig,

            7 => LedgerUpgradeType::LedgerUpgradeMaxSorobanTxSetSize,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LedgerUpgradeType> for i32 {
    #[must_use]
    fn from(e: LedgerUpgradeType) -> Self {
        e as Self
    }
}

impl ReadXdr for LedgerUpgradeType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerUpgradeType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ConfigUpgradeSetKey
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ConfigUpgradeSetKey {
    pub contract_id: ContractId,

    pub content_hash: Hash,
}

impl ReadXdr for ConfigUpgradeSetKey {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                contract_id: ContractId::read_xdr(r)?,

                content_hash: Hash::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigUpgradeSetKey {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.contract_id.write_xdr(w)?;

            self.content_hash.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerUpgrade
// union with discriminant LedgerUpgradeType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LedgerUpgrade {
    LedgerUpgradeVersion(u32),

    LedgerUpgradeBaseFee(u32),

    LedgerUpgradeMaxTxSetSize(u32),

    LedgerUpgradeBaseReserve(u32),

    LedgerUpgradeFlags(u32),

    LedgerUpgradeConfig(ConfigUpgradeSetKey),

    LedgerUpgradeMaxSorobanTxSetSize(u32),
}

#[cfg(feature = "alloc")]
impl Default for LedgerUpgrade {
    fn default() -> Self {
        Self::LedgerUpgradeVersion(u32::default())
    }
}

impl LedgerUpgrade {
    pub const VARIANTS: [LedgerUpgradeType; 7] = [
        LedgerUpgradeType::LedgerUpgradeVersion,
        LedgerUpgradeType::LedgerUpgradeBaseFee,
        LedgerUpgradeType::LedgerUpgradeMaxTxSetSize,
        LedgerUpgradeType::LedgerUpgradeBaseReserve,
        LedgerUpgradeType::LedgerUpgradeFlags,
        LedgerUpgradeType::LedgerUpgradeConfig,
        LedgerUpgradeType::LedgerUpgradeMaxSorobanTxSetSize,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "LedgerUpgradeVersion",
        "LedgerUpgradeBaseFee",
        "LedgerUpgradeMaxTxSetSize",
        "LedgerUpgradeBaseReserve",
        "LedgerUpgradeFlags",
        "LedgerUpgradeConfig",
        "LedgerUpgradeMaxSorobanTxSetSize",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LedgerUpgradeVersion(_) => "LedgerUpgradeVersion",

            Self::LedgerUpgradeBaseFee(_) => "LedgerUpgradeBaseFee",

            Self::LedgerUpgradeMaxTxSetSize(_) => "LedgerUpgradeMaxTxSetSize",

            Self::LedgerUpgradeBaseReserve(_) => "LedgerUpgradeBaseReserve",

            Self::LedgerUpgradeFlags(_) => "LedgerUpgradeFlags",

            Self::LedgerUpgradeConfig(_) => "LedgerUpgradeConfig",

            Self::LedgerUpgradeMaxSorobanTxSetSize(_) => "LedgerUpgradeMaxSorobanTxSetSize",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LedgerUpgradeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::LedgerUpgradeVersion(_) => LedgerUpgradeType::LedgerUpgradeVersion,

            Self::LedgerUpgradeBaseFee(_) => LedgerUpgradeType::LedgerUpgradeBaseFee,

            Self::LedgerUpgradeMaxTxSetSize(_) => LedgerUpgradeType::LedgerUpgradeMaxTxSetSize,

            Self::LedgerUpgradeBaseReserve(_) => LedgerUpgradeType::LedgerUpgradeBaseReserve,

            Self::LedgerUpgradeFlags(_) => LedgerUpgradeType::LedgerUpgradeFlags,

            Self::LedgerUpgradeConfig(_) => LedgerUpgradeType::LedgerUpgradeConfig,

            Self::LedgerUpgradeMaxSorobanTxSetSize(_) => {
                LedgerUpgradeType::LedgerUpgradeMaxSorobanTxSetSize
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerUpgradeType; 7] {
        Self::VARIANTS
    }
}

impl Name for LedgerUpgrade {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LedgerUpgradeType> for LedgerUpgrade {
    #[must_use]
    fn discriminant(&self) -> LedgerUpgradeType {
        Self::discriminant(self)
    }
}

impl Variants<LedgerUpgradeType> for LedgerUpgrade {
    fn variants() -> slice::Iter<'static, LedgerUpgradeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LedgerUpgradeType> for LedgerUpgrade {}

impl ReadXdr for LedgerUpgrade {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: LedgerUpgradeType = <LedgerUpgradeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LedgerUpgradeType::LedgerUpgradeVersion => {
                    Self::LedgerUpgradeVersion(u32::read_xdr(r)?)
                }

                LedgerUpgradeType::LedgerUpgradeBaseFee => {
                    Self::LedgerUpgradeBaseFee(u32::read_xdr(r)?)
                }

                LedgerUpgradeType::LedgerUpgradeMaxTxSetSize => {
                    Self::LedgerUpgradeMaxTxSetSize(u32::read_xdr(r)?)
                }

                LedgerUpgradeType::LedgerUpgradeBaseReserve => {
                    Self::LedgerUpgradeBaseReserve(u32::read_xdr(r)?)
                }

                LedgerUpgradeType::LedgerUpgradeFlags => {
                    Self::LedgerUpgradeFlags(u32::read_xdr(r)?)
                }

                LedgerUpgradeType::LedgerUpgradeConfig => {
                    Self::LedgerUpgradeConfig(ConfigUpgradeSetKey::read_xdr(r)?)
                }

                LedgerUpgradeType::LedgerUpgradeMaxSorobanTxSetSize => {
                    Self::LedgerUpgradeMaxSorobanTxSetSize(u32::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerUpgrade {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::LedgerUpgradeVersion(v) => v.write_xdr(w)?,

                Self::LedgerUpgradeBaseFee(v) => v.write_xdr(w)?,

                Self::LedgerUpgradeMaxTxSetSize(v) => v.write_xdr(w)?,

                Self::LedgerUpgradeBaseReserve(v) => v.write_xdr(w)?,

                Self::LedgerUpgradeFlags(v) => v.write_xdr(w)?,

                Self::LedgerUpgradeConfig(v) => v.write_xdr(w)?,

                Self::LedgerUpgradeMaxSorobanTxSetSize(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ConfigUpgradeSet
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ConfigUpgradeSet {
    pub updated_entry: VecM<ConfigSettingEntry>,
}

impl ReadXdr for ConfigUpgradeSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                updated_entry: VecM::<ConfigSettingEntry>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigUpgradeSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.updated_entry.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TxSetComponentType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum TxSetComponentType {
    #[cfg_attr(feature = "alloc", default)]
    TxsetCompTxsMaybeDiscountedFee = 0,
}

impl TxSetComponentType {
    pub const VARIANTS: [TxSetComponentType; 1] =
        [TxSetComponentType::TxsetCompTxsMaybeDiscountedFee];
    pub const VARIANTS_STR: [&'static str; 1] = ["TxsetCompTxsMaybeDiscountedFee"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxsetCompTxsMaybeDiscountedFee => "TxsetCompTxsMaybeDiscountedFee",
        }
    }

    #[must_use]
    pub const fn variants() -> [TxSetComponentType; 1] {
        Self::VARIANTS
    }
}

impl Name for TxSetComponentType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TxSetComponentType> for TxSetComponentType {
    fn variants() -> slice::Iter<'static, TxSetComponentType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for TxSetComponentType {}

impl fmt::Display for TxSetComponentType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for TxSetComponentType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => TxSetComponentType::TxsetCompTxsMaybeDiscountedFee,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<TxSetComponentType> for i32 {
    #[must_use]
    fn from(e: TxSetComponentType) -> Self {
        e as Self
    }
}

impl ReadXdr for TxSetComponentType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for TxSetComponentType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// DependentTxCluster
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct DependentTxCluster(pub VecM<TransactionEnvelope>);

impl From<DependentTxCluster> for VecM<TransactionEnvelope> {
    #[must_use]
    fn from(x: DependentTxCluster) -> Self {
        x.0
    }
}

impl From<VecM<TransactionEnvelope>> for DependentTxCluster {
    #[must_use]
    fn from(x: VecM<TransactionEnvelope>) -> Self {
        DependentTxCluster(x)
    }
}

impl AsRef<VecM<TransactionEnvelope>> for DependentTxCluster {
    #[must_use]
    fn as_ref(&self) -> &VecM<TransactionEnvelope> {
        &self.0
    }
}

impl ReadXdr for DependentTxCluster {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = VecM::<TransactionEnvelope>::read_xdr(r)?;
            let v = DependentTxCluster(i);
            Ok(v)
        })
    }
}

impl WriteXdr for DependentTxCluster {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for DependentTxCluster {
    type Target = VecM<TransactionEnvelope>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<DependentTxCluster> for Vec<TransactionEnvelope> {
    #[must_use]
    fn from(x: DependentTxCluster) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<TransactionEnvelope>> for DependentTxCluster {
    type Error = Error;
    fn try_from(x: Vec<TransactionEnvelope>) -> Result<Self, Error> {
        Ok(DependentTxCluster(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<TransactionEnvelope>> for DependentTxCluster {
    type Error = Error;
    fn try_from(x: &Vec<TransactionEnvelope>) -> Result<Self, Error> {
        Ok(DependentTxCluster(x.try_into()?))
    }
}

impl AsRef<Vec<TransactionEnvelope>> for DependentTxCluster {
    #[must_use]
    fn as_ref(&self) -> &Vec<TransactionEnvelope> {
        &self.0 .0
    }
}

impl AsRef<[TransactionEnvelope]> for DependentTxCluster {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[TransactionEnvelope] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[TransactionEnvelope] {
        self.0 .0
    }
}

/// ParallelTxExecutionStage
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ParallelTxExecutionStage(pub VecM<DependentTxCluster>);

impl From<ParallelTxExecutionStage> for VecM<DependentTxCluster> {
    #[must_use]
    fn from(x: ParallelTxExecutionStage) -> Self {
        x.0
    }
}

impl From<VecM<DependentTxCluster>> for ParallelTxExecutionStage {
    #[must_use]
    fn from(x: VecM<DependentTxCluster>) -> Self {
        ParallelTxExecutionStage(x)
    }
}

impl AsRef<VecM<DependentTxCluster>> for ParallelTxExecutionStage {
    #[must_use]
    fn as_ref(&self) -> &VecM<DependentTxCluster> {
        &self.0
    }
}

impl ReadXdr for ParallelTxExecutionStage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = VecM::<DependentTxCluster>::read_xdr(r)?;
            let v = ParallelTxExecutionStage(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ParallelTxExecutionStage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ParallelTxExecutionStage {
    type Target = VecM<DependentTxCluster>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ParallelTxExecutionStage> for Vec<DependentTxCluster> {
    #[must_use]
    fn from(x: ParallelTxExecutionStage) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<DependentTxCluster>> for ParallelTxExecutionStage {
    type Error = Error;
    fn try_from(x: Vec<DependentTxCluster>) -> Result<Self, Error> {
        Ok(ParallelTxExecutionStage(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<DependentTxCluster>> for ParallelTxExecutionStage {
    type Error = Error;
    fn try_from(x: &Vec<DependentTxCluster>) -> Result<Self, Error> {
        Ok(ParallelTxExecutionStage(x.try_into()?))
    }
}

impl AsRef<Vec<DependentTxCluster>> for ParallelTxExecutionStage {
    #[must_use]
    fn as_ref(&self) -> &Vec<DependentTxCluster> {
        &self.0 .0
    }
}

impl AsRef<[DependentTxCluster]> for ParallelTxExecutionStage {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[DependentTxCluster] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[DependentTxCluster] {
        self.0 .0
    }
}

/// ParallelTxsComponent
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ParallelTxsComponent {
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "Option<NumberOrString>")
    )]
    pub base_fee: Option<i64>,

    pub execution_stages: VecM<ParallelTxExecutionStage>,
}

impl ReadXdr for ParallelTxsComponent {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                base_fee: Option::<i64>::read_xdr(r)?,

                execution_stages: VecM::<ParallelTxExecutionStage>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ParallelTxsComponent {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.base_fee.write_xdr(w)?;

            self.execution_stages.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TxSetComponent
// union with discriminant TxSetComponentType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TxSetComponent {
    TxsetCompTxsMaybeDiscountedFee(TxSetComponentTxsMaybeDiscountedFee),
}

#[cfg(feature = "alloc")]
impl Default for TxSetComponent {
    fn default() -> Self {
        Self::TxsetCompTxsMaybeDiscountedFee(TxSetComponentTxsMaybeDiscountedFee::default())
    }
}

impl TxSetComponent {
    pub const VARIANTS: [TxSetComponentType; 1] =
        [TxSetComponentType::TxsetCompTxsMaybeDiscountedFee];
    pub const VARIANTS_STR: [&'static str; 1] = ["TxsetCompTxsMaybeDiscountedFee"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxsetCompTxsMaybeDiscountedFee(_) => "TxsetCompTxsMaybeDiscountedFee",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> TxSetComponentType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::TxsetCompTxsMaybeDiscountedFee(_) => {
                TxSetComponentType::TxsetCompTxsMaybeDiscountedFee
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [TxSetComponentType; 1] {
        Self::VARIANTS
    }
}

impl Name for TxSetComponent {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<TxSetComponentType> for TxSetComponent {
    #[must_use]
    fn discriminant(&self) -> TxSetComponentType {
        Self::discriminant(self)
    }
}

impl Variants<TxSetComponentType> for TxSetComponent {
    fn variants() -> slice::Iter<'static, TxSetComponentType> {
        Self::VARIANTS.iter()
    }
}

impl Union<TxSetComponentType> for TxSetComponent {}

impl ReadXdr for TxSetComponent {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: TxSetComponentType = <TxSetComponentType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                TxSetComponentType::TxsetCompTxsMaybeDiscountedFee => {
                    Self::TxsetCompTxsMaybeDiscountedFee(
                        TxSetComponentTxsMaybeDiscountedFee::read_xdr(r)?,
                    )
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TxSetComponent {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::TxsetCompTxsMaybeDiscountedFee(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionPhase
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TransactionPhase {
    V0(VecM<TxSetComponent>),

    V1(ParallelTxsComponent),
}

#[cfg(feature = "alloc")]
impl Default for TransactionPhase {
    fn default() -> Self {
        Self::V0(VecM::<TxSetComponent>::default())
    }
}

impl TransactionPhase {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for TransactionPhase {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionPhase {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionPhase {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionPhase {}

impl ReadXdr for TransactionPhase {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(VecM::<TxSetComponent>::read_xdr(r)?),

                1 => Self::V1(ParallelTxsComponent::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionPhase {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionSet
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionSet {
    pub previous_ledger_hash: Hash,

    pub txs: VecM<TransactionEnvelope>,
}

impl ReadXdr for TransactionSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                previous_ledger_hash: Hash::read_xdr(r)?,

                txs: VecM::<TransactionEnvelope>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.previous_ledger_hash.write_xdr(w)?;

            self.txs.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionSetV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionSetV1 {
    pub previous_ledger_hash: Hash,

    pub phases: VecM<TransactionPhase>,
}

impl ReadXdr for TransactionSetV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                previous_ledger_hash: Hash::read_xdr(r)?,

                phases: VecM::<TransactionPhase>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionSetV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.previous_ledger_hash.write_xdr(w)?;

            self.phases.write_xdr(w)?;

            Ok(())
        })
    }
}

/// GeneralizedTransactionSet
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum GeneralizedTransactionSet {
    V1(TransactionSetV1),
}

#[cfg(feature = "alloc")]
impl Default for GeneralizedTransactionSet {
    fn default() -> Self {
        Self::V1(TransactionSetV1::default())
    }
}

impl GeneralizedTransactionSet {
    pub const VARIANTS: [i32; 1] = [1];
    pub const VARIANTS_STR: [&'static str; 1] = ["V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for GeneralizedTransactionSet {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for GeneralizedTransactionSet {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for GeneralizedTransactionSet {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for GeneralizedTransactionSet {}

impl ReadXdr for GeneralizedTransactionSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                1 => Self::V1(TransactionSetV1::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for GeneralizedTransactionSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionResultPair
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionResultPair {
    pub transaction_hash: Hash,

    pub result: TransactionResult,
}

impl ReadXdr for TransactionResultPair {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                transaction_hash: Hash::read_xdr(r)?,

                result: TransactionResult::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionResultPair {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.transaction_hash.write_xdr(w)?;

            self.result.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionResultSet
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionResultSet {
    pub results: VecM<TransactionResultPair>,
}

impl ReadXdr for TransactionResultSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                results: VecM::<TransactionResultPair>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionResultSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.results.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionHistoryEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionHistoryEntry {
    pub ledger_seq: u32,

    pub tx_set: TransactionSet,

    pub ext: TransactionHistoryEntryExt,
}

impl ReadXdr for TransactionHistoryEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_seq: u32::read_xdr(r)?,

                tx_set: TransactionSet::read_xdr(r)?,

                ext: TransactionHistoryEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionHistoryEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_seq.write_xdr(w)?;

            self.tx_set.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionHistoryResultEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionHistoryResultEntry {
    pub ledger_seq: u32,

    pub tx_result_set: TransactionResultSet,

    pub ext: TransactionHistoryResultEntryExt,
}

impl ReadXdr for TransactionHistoryResultEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_seq: u32::read_xdr(r)?,

                tx_result_set: TransactionResultSet::read_xdr(r)?,

                ext: TransactionHistoryResultEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionHistoryResultEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_seq.write_xdr(w)?;

            self.tx_result_set.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerHeaderHistoryEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerHeaderHistoryEntry {
    pub hash: Hash,

    pub header: LedgerHeader,

    pub ext: LedgerHeaderHistoryEntryExt,
}

impl ReadXdr for LedgerHeaderHistoryEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hash: Hash::read_xdr(r)?,

                header: LedgerHeader::read_xdr(r)?,

                ext: LedgerHeaderHistoryEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerHeaderHistoryEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.hash.write_xdr(w)?;

            self.header.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerScpMessages
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerScpMessages {
    pub ledger_seq: u32,

    pub messages: VecM<ScpEnvelope>,
}

impl ReadXdr for LedgerScpMessages {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_seq: u32::read_xdr(r)?,

                messages: VecM::<ScpEnvelope>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerScpMessages {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_seq.write_xdr(w)?;

            self.messages.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScpHistoryEntryV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ScpHistoryEntryV0 {
    pub quorum_sets: VecM<ScpQuorumSet>,

    pub ledger_messages: LedgerScpMessages,
}

impl ReadXdr for ScpHistoryEntryV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                quorum_sets: VecM::<ScpQuorumSet>::read_xdr(r)?,

                ledger_messages: LedgerScpMessages::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpHistoryEntryV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.quorum_sets.write_xdr(w)?;

            self.ledger_messages.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ScpHistoryEntry
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ScpHistoryEntry {
    V0(ScpHistoryEntryV0),
}

#[cfg(feature = "alloc")]
impl Default for ScpHistoryEntry {
    fn default() -> Self {
        Self::V0(ScpHistoryEntryV0::default())
    }
}

impl ScpHistoryEntry {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for ScpHistoryEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ScpHistoryEntry {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ScpHistoryEntry {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ScpHistoryEntry {}

impl ReadXdr for ScpHistoryEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(ScpHistoryEntryV0::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScpHistoryEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerEntryChangeType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum LedgerEntryChangeType {
    #[cfg_attr(feature = "alloc", default)]
    LedgerEntryCreated = 0,

    LedgerEntryUpdated = 1,

    LedgerEntryRemoved = 2,

    LedgerEntryState = 3,

    LedgerEntryRestored = 4,
}

impl LedgerEntryChangeType {
    pub const VARIANTS: [LedgerEntryChangeType; 5] = [
        LedgerEntryChangeType::LedgerEntryCreated,
        LedgerEntryChangeType::LedgerEntryUpdated,
        LedgerEntryChangeType::LedgerEntryRemoved,
        LedgerEntryChangeType::LedgerEntryState,
        LedgerEntryChangeType::LedgerEntryRestored,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "LedgerEntryCreated",
        "LedgerEntryUpdated",
        "LedgerEntryRemoved",
        "LedgerEntryState",
        "LedgerEntryRestored",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LedgerEntryCreated => "LedgerEntryCreated",

            Self::LedgerEntryUpdated => "LedgerEntryUpdated",

            Self::LedgerEntryRemoved => "LedgerEntryRemoved",

            Self::LedgerEntryState => "LedgerEntryState",

            Self::LedgerEntryRestored => "LedgerEntryRestored",
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerEntryChangeType; 5] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryChangeType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LedgerEntryChangeType> for LedgerEntryChangeType {
    fn variants() -> slice::Iter<'static, LedgerEntryChangeType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LedgerEntryChangeType {}

impl fmt::Display for LedgerEntryChangeType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LedgerEntryChangeType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => LedgerEntryChangeType::LedgerEntryCreated,

            1 => LedgerEntryChangeType::LedgerEntryUpdated,

            2 => LedgerEntryChangeType::LedgerEntryRemoved,

            3 => LedgerEntryChangeType::LedgerEntryState,

            4 => LedgerEntryChangeType::LedgerEntryRestored,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LedgerEntryChangeType> for i32 {
    #[must_use]
    fn from(e: LedgerEntryChangeType) -> Self {
        e as Self
    }
}

impl ReadXdr for LedgerEntryChangeType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryChangeType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LedgerEntryChange
// union with discriminant LedgerEntryChangeType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LedgerEntryChange {
    LedgerEntryCreated(LedgerEntry),

    LedgerEntryUpdated(LedgerEntry),

    LedgerEntryRemoved(LedgerKey),

    LedgerEntryState(LedgerEntry),

    LedgerEntryRestored(LedgerEntry),
}

#[cfg(feature = "alloc")]
impl Default for LedgerEntryChange {
    fn default() -> Self {
        Self::LedgerEntryCreated(LedgerEntry::default())
    }
}

impl LedgerEntryChange {
    pub const VARIANTS: [LedgerEntryChangeType; 5] = [
        LedgerEntryChangeType::LedgerEntryCreated,
        LedgerEntryChangeType::LedgerEntryUpdated,
        LedgerEntryChangeType::LedgerEntryRemoved,
        LedgerEntryChangeType::LedgerEntryState,
        LedgerEntryChangeType::LedgerEntryRestored,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "LedgerEntryCreated",
        "LedgerEntryUpdated",
        "LedgerEntryRemoved",
        "LedgerEntryState",
        "LedgerEntryRestored",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LedgerEntryCreated(_) => "LedgerEntryCreated",

            Self::LedgerEntryUpdated(_) => "LedgerEntryUpdated",

            Self::LedgerEntryRemoved(_) => "LedgerEntryRemoved",

            Self::LedgerEntryState(_) => "LedgerEntryState",

            Self::LedgerEntryRestored(_) => "LedgerEntryRestored",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LedgerEntryChangeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::LedgerEntryCreated(_) => LedgerEntryChangeType::LedgerEntryCreated,

            Self::LedgerEntryUpdated(_) => LedgerEntryChangeType::LedgerEntryUpdated,

            Self::LedgerEntryRemoved(_) => LedgerEntryChangeType::LedgerEntryRemoved,

            Self::LedgerEntryState(_) => LedgerEntryChangeType::LedgerEntryState,

            Self::LedgerEntryRestored(_) => LedgerEntryChangeType::LedgerEntryRestored,
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerEntryChangeType; 5] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryChange {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LedgerEntryChangeType> for LedgerEntryChange {
    #[must_use]
    fn discriminant(&self) -> LedgerEntryChangeType {
        Self::discriminant(self)
    }
}

impl Variants<LedgerEntryChangeType> for LedgerEntryChange {
    fn variants() -> slice::Iter<'static, LedgerEntryChangeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LedgerEntryChangeType> for LedgerEntryChange {}

impl ReadXdr for LedgerEntryChange {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: LedgerEntryChangeType = <LedgerEntryChangeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LedgerEntryChangeType::LedgerEntryCreated => {
                    Self::LedgerEntryCreated(LedgerEntry::read_xdr(r)?)
                }

                LedgerEntryChangeType::LedgerEntryUpdated => {
                    Self::LedgerEntryUpdated(LedgerEntry::read_xdr(r)?)
                }

                LedgerEntryChangeType::LedgerEntryRemoved => {
                    Self::LedgerEntryRemoved(LedgerKey::read_xdr(r)?)
                }

                LedgerEntryChangeType::LedgerEntryState => {
                    Self::LedgerEntryState(LedgerEntry::read_xdr(r)?)
                }

                LedgerEntryChangeType::LedgerEntryRestored => {
                    Self::LedgerEntryRestored(LedgerEntry::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryChange {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::LedgerEntryCreated(v) => v.write_xdr(w)?,

                Self::LedgerEntryUpdated(v) => v.write_xdr(w)?,

                Self::LedgerEntryRemoved(v) => v.write_xdr(w)?,

                Self::LedgerEntryState(v) => v.write_xdr(w)?,

                Self::LedgerEntryRestored(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerEntryChanges
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerEntryChanges(pub VecM<LedgerEntryChange>);

impl From<LedgerEntryChanges> for VecM<LedgerEntryChange> {
    #[must_use]
    fn from(x: LedgerEntryChanges) -> Self {
        x.0
    }
}

impl From<VecM<LedgerEntryChange>> for LedgerEntryChanges {
    #[must_use]
    fn from(x: VecM<LedgerEntryChange>) -> Self {
        LedgerEntryChanges(x)
    }
}

impl AsRef<VecM<LedgerEntryChange>> for LedgerEntryChanges {
    #[must_use]
    fn as_ref(&self) -> &VecM<LedgerEntryChange> {
        &self.0
    }
}

impl ReadXdr for LedgerEntryChanges {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = VecM::<LedgerEntryChange>::read_xdr(r)?;
            let v = LedgerEntryChanges(i);
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryChanges {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for LedgerEntryChanges {
    type Target = VecM<LedgerEntryChange>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<LedgerEntryChanges> for Vec<LedgerEntryChange> {
    #[must_use]
    fn from(x: LedgerEntryChanges) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<LedgerEntryChange>> for LedgerEntryChanges {
    type Error = Error;
    fn try_from(x: Vec<LedgerEntryChange>) -> Result<Self, Error> {
        Ok(LedgerEntryChanges(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<LedgerEntryChange>> for LedgerEntryChanges {
    type Error = Error;
    fn try_from(x: &Vec<LedgerEntryChange>) -> Result<Self, Error> {
        Ok(LedgerEntryChanges(x.try_into()?))
    }
}

impl AsRef<Vec<LedgerEntryChange>> for LedgerEntryChanges {
    #[must_use]
    fn as_ref(&self) -> &Vec<LedgerEntryChange> {
        &self.0 .0
    }
}

impl AsRef<[LedgerEntryChange]> for LedgerEntryChanges {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[LedgerEntryChange] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[LedgerEntryChange] {
        self.0 .0
    }
}

/// OperationMeta
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct OperationMeta {
    pub changes: LedgerEntryChanges,
}

impl ReadXdr for OperationMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                changes: LedgerEntryChanges::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for OperationMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.changes.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionMetaV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionMetaV1 {
    pub tx_changes: LedgerEntryChanges,

    pub operations: VecM<OperationMeta>,
}

impl ReadXdr for TransactionMetaV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_changes: LedgerEntryChanges::read_xdr(r)?,

                operations: VecM::<OperationMeta>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionMetaV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.tx_changes.write_xdr(w)?;

            self.operations.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionMetaV2
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionMetaV2 {
    pub tx_changes_before: LedgerEntryChanges,

    pub operations: VecM<OperationMeta>,

    pub tx_changes_after: LedgerEntryChanges,
}

impl ReadXdr for TransactionMetaV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_changes_before: LedgerEntryChanges::read_xdr(r)?,

                operations: VecM::<OperationMeta>::read_xdr(r)?,

                tx_changes_after: LedgerEntryChanges::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionMetaV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.tx_changes_before.write_xdr(w)?;

            self.operations.write_xdr(w)?;

            self.tx_changes_after.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ContractEventType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ContractEventType {
    #[cfg_attr(feature = "alloc", default)]
    System = 0,

    Contract = 1,

    Diagnostic = 2,
}

impl ContractEventType {
    pub const VARIANTS: [ContractEventType; 3] = [
        ContractEventType::System,
        ContractEventType::Contract,
        ContractEventType::Diagnostic,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["System", "Contract", "Diagnostic"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::System => "System",

            Self::Contract => "Contract",

            Self::Diagnostic => "Diagnostic",
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractEventType; 3] {
        Self::VARIANTS
    }
}

impl Name for ContractEventType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ContractEventType> for ContractEventType {
    fn variants() -> slice::Iter<'static, ContractEventType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ContractEventType {}

impl fmt::Display for ContractEventType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ContractEventType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ContractEventType::System,

            1 => ContractEventType::Contract,

            2 => ContractEventType::Diagnostic,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ContractEventType> for i32 {
    #[must_use]
    fn from(e: ContractEventType) -> Self {
        e as Self
    }
}

impl ReadXdr for ContractEventType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ContractEventType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractEvent
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ContractEvent {
    pub ext: ExtensionPoint,

    pub contract_id: Option<ContractId>,

    pub type_: ContractEventType,

    pub body: ContractEventBody,
}

impl ReadXdr for ContractEvent {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                contract_id: Option::<ContractId>::read_xdr(r)?,

                type_: ContractEventType::read_xdr(r)?,

                body: ContractEventBody::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractEvent {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.contract_id.write_xdr(w)?;

            self.type_.write_xdr(w)?;

            self.body.write_xdr(w)?;

            Ok(())
        })
    }
}

/// DiagnosticEvent
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct DiagnosticEvent {
    pub in_successful_contract_call: bool,

    pub event: ContractEvent,
}

impl ReadXdr for DiagnosticEvent {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                in_successful_contract_call: bool::read_xdr(r)?,

                event: ContractEvent::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for DiagnosticEvent {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.in_successful_contract_call.write_xdr(w)?;

            self.event.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SorobanTransactionMetaExtV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SorobanTransactionMetaExtV1 {
    pub ext: ExtensionPoint,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub total_non_refundable_resource_fee_charged: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub total_refundable_resource_fee_charged: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub rent_fee_charged: i64,
}

impl ReadXdr for SorobanTransactionMetaExtV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                total_non_refundable_resource_fee_charged: i64::read_xdr(r)?,

                total_refundable_resource_fee_charged: i64::read_xdr(r)?,

                rent_fee_charged: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanTransactionMetaExtV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.total_non_refundable_resource_fee_charged
                .write_xdr(w)?;

            self.total_refundable_resource_fee_charged.write_xdr(w)?;

            self.rent_fee_charged.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SorobanTransactionMetaExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum SorobanTransactionMetaExt {
    V0,

    V1(SorobanTransactionMetaExtV1),
}

#[cfg(feature = "alloc")]
impl Default for SorobanTransactionMetaExt {
    fn default() -> Self {
        Self::V0
    }
}

impl SorobanTransactionMetaExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for SorobanTransactionMetaExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for SorobanTransactionMetaExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for SorobanTransactionMetaExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for SorobanTransactionMetaExt {}

impl ReadXdr for SorobanTransactionMetaExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(SorobanTransactionMetaExtV1::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanTransactionMetaExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SorobanTransactionMeta
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SorobanTransactionMeta {
    pub ext: SorobanTransactionMetaExt,

    pub events: VecM<ContractEvent>,

    pub return_value: ScVal,

    pub diagnostic_events: VecM<DiagnosticEvent>,
}

impl ReadXdr for SorobanTransactionMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: SorobanTransactionMetaExt::read_xdr(r)?,

                events: VecM::<ContractEvent>::read_xdr(r)?,

                return_value: ScVal::read_xdr(r)?,

                diagnostic_events: VecM::<DiagnosticEvent>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanTransactionMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.events.write_xdr(w)?;

            self.return_value.write_xdr(w)?;

            self.diagnostic_events.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionMetaV3
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionMetaV3 {
    pub ext: ExtensionPoint,

    pub tx_changes_before: LedgerEntryChanges,

    pub operations: VecM<OperationMeta>,

    pub tx_changes_after: LedgerEntryChanges,

    pub soroban_meta: Option<SorobanTransactionMeta>,
}

impl ReadXdr for TransactionMetaV3 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                tx_changes_before: LedgerEntryChanges::read_xdr(r)?,

                operations: VecM::<OperationMeta>::read_xdr(r)?,

                tx_changes_after: LedgerEntryChanges::read_xdr(r)?,

                soroban_meta: Option::<SorobanTransactionMeta>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionMetaV3 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.tx_changes_before.write_xdr(w)?;

            self.operations.write_xdr(w)?;

            self.tx_changes_after.write_xdr(w)?;

            self.soroban_meta.write_xdr(w)?;

            Ok(())
        })
    }
}

/// OperationMetaV2
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct OperationMetaV2 {
    pub ext: ExtensionPoint,

    pub changes: LedgerEntryChanges,

    pub events: VecM<ContractEvent>,
}

impl ReadXdr for OperationMetaV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                changes: LedgerEntryChanges::read_xdr(r)?,

                events: VecM::<ContractEvent>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for OperationMetaV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.changes.write_xdr(w)?;

            self.events.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SorobanTransactionMetaV2
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SorobanTransactionMetaV2 {
    pub ext: SorobanTransactionMetaExt,

    pub return_value: Option<ScVal>,
}

impl ReadXdr for SorobanTransactionMetaV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: SorobanTransactionMetaExt::read_xdr(r)?,

                return_value: Option::<ScVal>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanTransactionMetaV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.return_value.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionEventStage
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum TransactionEventStage {
    #[cfg_attr(feature = "alloc", default)]
    TransactionEventStageBeforeAllTxs = 0,

    TransactionEventStageAfterTx = 1,

    TransactionEventStageAfterAllTxs = 2,
}

impl TransactionEventStage {
    pub const VARIANTS: [TransactionEventStage; 3] = [
        TransactionEventStage::TransactionEventStageBeforeAllTxs,
        TransactionEventStage::TransactionEventStageAfterTx,
        TransactionEventStage::TransactionEventStageAfterAllTxs,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "TransactionEventStageBeforeAllTxs",
        "TransactionEventStageAfterTx",
        "TransactionEventStageAfterAllTxs",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TransactionEventStageBeforeAllTxs => "TransactionEventStageBeforeAllTxs",

            Self::TransactionEventStageAfterTx => "TransactionEventStageAfterTx",

            Self::TransactionEventStageAfterAllTxs => "TransactionEventStageAfterAllTxs",
        }
    }

    #[must_use]
    pub const fn variants() -> [TransactionEventStage; 3] {
        Self::VARIANTS
    }
}

impl Name for TransactionEventStage {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TransactionEventStage> for TransactionEventStage {
    fn variants() -> slice::Iter<'static, TransactionEventStage> {
        Self::VARIANTS.iter()
    }
}

impl Enum for TransactionEventStage {}

impl fmt::Display for TransactionEventStage {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for TransactionEventStage {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => TransactionEventStage::TransactionEventStageBeforeAllTxs,

            1 => TransactionEventStage::TransactionEventStageAfterTx,

            2 => TransactionEventStage::TransactionEventStageAfterAllTxs,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<TransactionEventStage> for i32 {
    #[must_use]
    fn from(e: TransactionEventStage) -> Self {
        e as Self
    }
}

impl ReadXdr for TransactionEventStage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionEventStage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// TransactionEvent
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionEvent {
    pub stage: TransactionEventStage,

    pub event: ContractEvent,
}

impl ReadXdr for TransactionEvent {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                stage: TransactionEventStage::read_xdr(r)?,

                event: ContractEvent::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionEvent {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.stage.write_xdr(w)?;

            self.event.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionMetaV4
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionMetaV4 {
    pub ext: ExtensionPoint,

    pub tx_changes_before: LedgerEntryChanges,

    pub operations: VecM<OperationMetaV2>,

    pub tx_changes_after: LedgerEntryChanges,

    pub soroban_meta: Option<SorobanTransactionMetaV2>,

    pub events: VecM<TransactionEvent>,

    pub diagnostic_events: VecM<DiagnosticEvent>,
}

impl ReadXdr for TransactionMetaV4 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                tx_changes_before: LedgerEntryChanges::read_xdr(r)?,

                operations: VecM::<OperationMetaV2>::read_xdr(r)?,

                tx_changes_after: LedgerEntryChanges::read_xdr(r)?,

                soroban_meta: Option::<SorobanTransactionMetaV2>::read_xdr(r)?,

                events: VecM::<TransactionEvent>::read_xdr(r)?,

                diagnostic_events: VecM::<DiagnosticEvent>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionMetaV4 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.tx_changes_before.write_xdr(w)?;

            self.operations.write_xdr(w)?;

            self.tx_changes_after.write_xdr(w)?;

            self.soroban_meta.write_xdr(w)?;

            self.events.write_xdr(w)?;

            self.diagnostic_events.write_xdr(w)?;

            Ok(())
        })
    }
}

/// InvokeHostFunctionSuccessPreImage
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct InvokeHostFunctionSuccessPreImage {
    pub return_value: ScVal,

    pub events: VecM<ContractEvent>,
}

impl ReadXdr for InvokeHostFunctionSuccessPreImage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                return_value: ScVal::read_xdr(r)?,

                events: VecM::<ContractEvent>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InvokeHostFunctionSuccessPreImage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.return_value.write_xdr(w)?;

            self.events.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionMeta
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TransactionMeta {
    V0(VecM<OperationMeta>),

    V1(TransactionMetaV1),

    V2(TransactionMetaV2),

    V3(TransactionMetaV3),

    V4(TransactionMetaV4),
}

#[cfg(feature = "alloc")]
impl Default for TransactionMeta {
    fn default() -> Self {
        Self::V0(VecM::<OperationMeta>::default())
    }
}

impl TransactionMeta {
    pub const VARIANTS: [i32; 5] = [0, 1, 2, 3, 4];
    pub const VARIANTS_STR: [&'static str; 5] = ["V0", "V1", "V2", "V3", "V4"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",

            Self::V1(_) => "V1",

            Self::V2(_) => "V2",

            Self::V3(_) => "V3",

            Self::V4(_) => "V4",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,

            Self::V1(_) => 1,

            Self::V2(_) => 2,

            Self::V3(_) => 3,

            Self::V4(_) => 4,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 5] {
        Self::VARIANTS
    }
}

impl Name for TransactionMeta {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionMeta {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionMeta {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionMeta {}

impl ReadXdr for TransactionMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(VecM::<OperationMeta>::read_xdr(r)?),

                1 => Self::V1(TransactionMetaV1::read_xdr(r)?),

                2 => Self::V2(TransactionMetaV2::read_xdr(r)?),

                3 => Self::V3(TransactionMetaV3::read_xdr(r)?),

                4 => Self::V4(TransactionMetaV4::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,

                Self::V2(v) => v.write_xdr(w)?,

                Self::V3(v) => v.write_xdr(w)?,

                Self::V4(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionResultMeta
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionResultMeta {
    pub result: TransactionResultPair,

    pub fee_processing: LedgerEntryChanges,

    pub tx_apply_processing: TransactionMeta,
}

impl ReadXdr for TransactionResultMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                result: TransactionResultPair::read_xdr(r)?,

                fee_processing: LedgerEntryChanges::read_xdr(r)?,

                tx_apply_processing: TransactionMeta::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionResultMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.result.write_xdr(w)?;

            self.fee_processing.write_xdr(w)?;

            self.tx_apply_processing.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionResultMetaV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionResultMetaV1 {
    pub ext: ExtensionPoint,

    pub result: TransactionResultPair,

    pub fee_processing: LedgerEntryChanges,

    pub tx_apply_processing: TransactionMeta,

    pub post_tx_apply_fee_processing: LedgerEntryChanges,
}

impl ReadXdr for TransactionResultMetaV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                result: TransactionResultPair::read_xdr(r)?,

                fee_processing: LedgerEntryChanges::read_xdr(r)?,

                tx_apply_processing: TransactionMeta::read_xdr(r)?,

                post_tx_apply_fee_processing: LedgerEntryChanges::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionResultMetaV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.result.write_xdr(w)?;

            self.fee_processing.write_xdr(w)?;

            self.tx_apply_processing.write_xdr(w)?;

            self.post_tx_apply_fee_processing.write_xdr(w)?;

            Ok(())
        })
    }
}

/// UpgradeEntryMeta
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct UpgradeEntryMeta {
    pub upgrade: LedgerUpgrade,

    pub changes: LedgerEntryChanges,
}

impl ReadXdr for UpgradeEntryMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                upgrade: LedgerUpgrade::read_xdr(r)?,

                changes: LedgerEntryChanges::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for UpgradeEntryMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.upgrade.write_xdr(w)?;

            self.changes.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerCloseMetaV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerCloseMetaV0 {
    pub ledger_header: LedgerHeaderHistoryEntry,

    pub tx_set: TransactionSet,

    pub tx_processing: VecM<TransactionResultMeta>,

    pub upgrades_processing: VecM<UpgradeEntryMeta>,

    pub scp_info: VecM<ScpHistoryEntry>,
}

impl ReadXdr for LedgerCloseMetaV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_header: LedgerHeaderHistoryEntry::read_xdr(r)?,

                tx_set: TransactionSet::read_xdr(r)?,

                tx_processing: VecM::<TransactionResultMeta>::read_xdr(r)?,

                upgrades_processing: VecM::<UpgradeEntryMeta>::read_xdr(r)?,

                scp_info: VecM::<ScpHistoryEntry>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerCloseMetaV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_header.write_xdr(w)?;

            self.tx_set.write_xdr(w)?;

            self.tx_processing.write_xdr(w)?;

            self.upgrades_processing.write_xdr(w)?;

            self.scp_info.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerCloseMetaExtV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerCloseMetaExtV1 {
    pub ext: ExtensionPoint,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub soroban_fee_write1_kb: i64,
}

impl ReadXdr for LedgerCloseMetaExtV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                soroban_fee_write1_kb: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerCloseMetaExtV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.soroban_fee_write1_kb.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerCloseMetaExt
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LedgerCloseMetaExt {
    V0,

    V1(LedgerCloseMetaExtV1),
}

#[cfg(feature = "alloc")]
impl Default for LedgerCloseMetaExt {
    fn default() -> Self {
        Self::V0
    }
}

impl LedgerCloseMetaExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",

            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,

            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for LedgerCloseMetaExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerCloseMetaExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerCloseMetaExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerCloseMetaExt {}

impl ReadXdr for LedgerCloseMetaExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                1 => Self::V1(LedgerCloseMetaExtV1::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerCloseMetaExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerCloseMetaV1
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerCloseMetaV1 {
    pub ext: LedgerCloseMetaExt,

    pub ledger_header: LedgerHeaderHistoryEntry,

    pub tx_set: GeneralizedTransactionSet,

    pub tx_processing: VecM<TransactionResultMeta>,

    pub upgrades_processing: VecM<UpgradeEntryMeta>,

    pub scp_info: VecM<ScpHistoryEntry>,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub total_byte_size_of_live_soroban_state: u64,

    pub evicted_keys: VecM<LedgerKey>,

    pub unused: VecM<LedgerEntry>,
}

impl ReadXdr for LedgerCloseMetaV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: LedgerCloseMetaExt::read_xdr(r)?,

                ledger_header: LedgerHeaderHistoryEntry::read_xdr(r)?,

                tx_set: GeneralizedTransactionSet::read_xdr(r)?,

                tx_processing: VecM::<TransactionResultMeta>::read_xdr(r)?,

                upgrades_processing: VecM::<UpgradeEntryMeta>::read_xdr(r)?,

                scp_info: VecM::<ScpHistoryEntry>::read_xdr(r)?,

                total_byte_size_of_live_soroban_state: u64::read_xdr(r)?,

                evicted_keys: VecM::<LedgerKey>::read_xdr(r)?,

                unused: VecM::<LedgerEntry>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerCloseMetaV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.ledger_header.write_xdr(w)?;

            self.tx_set.write_xdr(w)?;

            self.tx_processing.write_xdr(w)?;

            self.upgrades_processing.write_xdr(w)?;

            self.scp_info.write_xdr(w)?;

            self.total_byte_size_of_live_soroban_state.write_xdr(w)?;

            self.evicted_keys.write_xdr(w)?;

            self.unused.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerCloseMetaV2
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerCloseMetaV2 {
    pub ext: LedgerCloseMetaExt,

    pub ledger_header: LedgerHeaderHistoryEntry,

    pub tx_set: GeneralizedTransactionSet,

    pub tx_processing: VecM<TransactionResultMetaV1>,

    pub upgrades_processing: VecM<UpgradeEntryMeta>,

    pub scp_info: VecM<ScpHistoryEntry>,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub total_byte_size_of_live_soroban_state: u64,

    pub evicted_keys: VecM<LedgerKey>,
}

impl ReadXdr for LedgerCloseMetaV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: LedgerCloseMetaExt::read_xdr(r)?,

                ledger_header: LedgerHeaderHistoryEntry::read_xdr(r)?,

                tx_set: GeneralizedTransactionSet::read_xdr(r)?,

                tx_processing: VecM::<TransactionResultMetaV1>::read_xdr(r)?,

                upgrades_processing: VecM::<UpgradeEntryMeta>::read_xdr(r)?,

                scp_info: VecM::<ScpHistoryEntry>::read_xdr(r)?,

                total_byte_size_of_live_soroban_state: u64::read_xdr(r)?,

                evicted_keys: VecM::<LedgerKey>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerCloseMetaV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.ledger_header.write_xdr(w)?;

            self.tx_set.write_xdr(w)?;

            self.tx_processing.write_xdr(w)?;

            self.upgrades_processing.write_xdr(w)?;

            self.scp_info.write_xdr(w)?;

            self.total_byte_size_of_live_soroban_state.write_xdr(w)?;

            self.evicted_keys.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerCloseMeta
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LedgerCloseMeta {
    V0(LedgerCloseMetaV0),

    V1(LedgerCloseMetaV1),

    V2(LedgerCloseMetaV2),
}

#[cfg(feature = "alloc")]
impl Default for LedgerCloseMeta {
    fn default() -> Self {
        Self::V0(LedgerCloseMetaV0::default())
    }
}

impl LedgerCloseMeta {
    pub const VARIANTS: [i32; 3] = [0, 1, 2];
    pub const VARIANTS_STR: [&'static str; 3] = ["V0", "V1", "V2"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",

            Self::V1(_) => "V1",

            Self::V2(_) => "V2",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,

            Self::V1(_) => 1,

            Self::V2(_) => 2,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 3] {
        Self::VARIANTS
    }
}

impl Name for LedgerCloseMeta {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerCloseMeta {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerCloseMeta {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerCloseMeta {}

impl ReadXdr for LedgerCloseMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(LedgerCloseMetaV0::read_xdr(r)?),

                1 => Self::V1(LedgerCloseMetaV1::read_xdr(r)?),

                2 => Self::V2(LedgerCloseMetaV2::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerCloseMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,

                Self::V1(v) => v.write_xdr(w)?,

                Self::V2(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ErrorCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ErrorCode {
    #[cfg_attr(feature = "alloc", default)]
    ErrMisc = 0,

    ErrData = 1,

    ErrConf = 2,

    ErrAuth = 3,

    ErrLoad = 4,
}

impl ErrorCode {
    pub const VARIANTS: [ErrorCode; 5] = [
        ErrorCode::ErrMisc,
        ErrorCode::ErrData,
        ErrorCode::ErrConf,
        ErrorCode::ErrAuth,
        ErrorCode::ErrLoad,
    ];
    pub const VARIANTS_STR: [&'static str; 5] =
        ["ErrMisc", "ErrData", "ErrConf", "ErrAuth", "ErrLoad"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ErrMisc => "ErrMisc",

            Self::ErrData => "ErrData",

            Self::ErrConf => "ErrConf",

            Self::ErrAuth => "ErrAuth",

            Self::ErrLoad => "ErrLoad",
        }
    }

    #[must_use]
    pub const fn variants() -> [ErrorCode; 5] {
        Self::VARIANTS
    }
}

impl Name for ErrorCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ErrorCode> for ErrorCode {
    fn variants() -> slice::Iter<'static, ErrorCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ErrorCode {}

impl fmt::Display for ErrorCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ErrorCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ErrorCode::ErrMisc,

            1 => ErrorCode::ErrData,

            2 => ErrorCode::ErrConf,

            3 => ErrorCode::ErrAuth,

            4 => ErrorCode::ErrLoad,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ErrorCode> for i32 {
    #[must_use]
    fn from(e: ErrorCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ErrorCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ErrorCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SError
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SError {
    pub code: ErrorCode,

    pub msg: StringM<100>,
}

impl ReadXdr for SError {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                code: ErrorCode::read_xdr(r)?,

                msg: StringM::<100>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SError {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.code.write_xdr(w)?;

            self.msg.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SendMore
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SendMore {
    pub num_messages: u32,
}

impl ReadXdr for SendMore {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                num_messages: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SendMore {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.num_messages.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SendMoreExtended
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SendMoreExtended {
    pub num_messages: u32,

    pub num_bytes: u32,
}

impl ReadXdr for SendMoreExtended {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                num_messages: u32::read_xdr(r)?,

                num_bytes: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SendMoreExtended {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.num_messages.write_xdr(w)?;

            self.num_bytes.write_xdr(w)?;

            Ok(())
        })
    }
}

/// AuthCert
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct AuthCert {
    pub pubkey: Curve25519Public,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub expiration: u64,

    pub sig: Signature,
}

impl ReadXdr for AuthCert {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                pubkey: Curve25519Public::read_xdr(r)?,

                expiration: u64::read_xdr(r)?,

                sig: Signature::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AuthCert {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.pubkey.write_xdr(w)?;

            self.expiration.write_xdr(w)?;

            self.sig.write_xdr(w)?;

            Ok(())
        })
    }
}

/// Hello
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Hello {
    pub ledger_version: u32,

    pub overlay_version: u32,

    pub overlay_min_version: u32,

    pub network_id: Hash,

    pub version_str: StringM<100>,

    pub listening_port: i32,

    pub peer_id: NodeId,

    pub cert: AuthCert,

    pub nonce: Uint256,
}

impl ReadXdr for Hello {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_version: u32::read_xdr(r)?,

                overlay_version: u32::read_xdr(r)?,

                overlay_min_version: u32::read_xdr(r)?,

                network_id: Hash::read_xdr(r)?,

                version_str: StringM::<100>::read_xdr(r)?,

                listening_port: i32::read_xdr(r)?,

                peer_id: NodeId::read_xdr(r)?,

                cert: AuthCert::read_xdr(r)?,

                nonce: Uint256::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Hello {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ledger_version.write_xdr(w)?;

            self.overlay_version.write_xdr(w)?;

            self.overlay_min_version.write_xdr(w)?;

            self.network_id.write_xdr(w)?;

            self.version_str.write_xdr(w)?;

            self.listening_port.write_xdr(w)?;

            self.peer_id.write_xdr(w)?;

            self.cert.write_xdr(w)?;

            self.nonce.write_xdr(w)?;

            Ok(())
        })
    }
}

pub const AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED: u64 = 200;

/// Auth
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Auth {
    pub flags: i32,
}

impl ReadXdr for Auth {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                flags: i32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Auth {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.flags.write_xdr(w)?;

            Ok(())
        })
    }
}

/// IpAddrType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum IpAddrType {
    #[cfg_attr(feature = "alloc", default)]
    IPv4 = 0,

    IPv6 = 1,
}

impl IpAddrType {
    pub const VARIANTS: [IpAddrType; 2] = [IpAddrType::IPv4, IpAddrType::IPv6];
    pub const VARIANTS_STR: [&'static str; 2] = ["IPv4", "IPv6"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::IPv4 => "IPv4",

            Self::IPv6 => "IPv6",
        }
    }

    #[must_use]
    pub const fn variants() -> [IpAddrType; 2] {
        Self::VARIANTS
    }
}

impl Name for IpAddrType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<IpAddrType> for IpAddrType {
    fn variants() -> slice::Iter<'static, IpAddrType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for IpAddrType {}

impl fmt::Display for IpAddrType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for IpAddrType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => IpAddrType::IPv4,

            1 => IpAddrType::IPv6,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<IpAddrType> for i32 {
    #[must_use]
    fn from(e: IpAddrType) -> Self {
        e as Self
    }
}

impl ReadXdr for IpAddrType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for IpAddrType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// PeerAddress
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct PeerAddress {
    pub ip: PeerAddressIp,

    pub port: u32,

    pub num_failures: u32,
}

impl ReadXdr for PeerAddress {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ip: PeerAddressIp::read_xdr(r)?,

                port: u32::read_xdr(r)?,

                num_failures: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PeerAddress {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ip.write_xdr(w)?;

            self.port.write_xdr(w)?;

            self.num_failures.write_xdr(w)?;

            Ok(())
        })
    }
}

/// MessageType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum MessageType {
    #[cfg_attr(feature = "alloc", default)]
    ErrorMsg = 0,

    Auth = 2,

    DontHave = 3,

    Peers = 5,

    GetTxSet = 6,

    TxSet = 7,

    GeneralizedTxSet = 17,

    Transaction = 8,

    GetScpQuorumset = 9,

    ScpQuorumset = 10,

    ScpMessage = 11,

    GetScpState = 12,

    Hello = 13,

    SendMore = 16,

    SendMoreExtended = 20,

    FloodAdvert = 18,

    FloodDemand = 19,

    TimeSlicedSurveyRequest = 21,

    TimeSlicedSurveyResponse = 22,

    TimeSlicedSurveyStartCollecting = 23,

    TimeSlicedSurveyStopCollecting = 24,
}

impl MessageType {
    pub const VARIANTS: [MessageType; 21] = [
        MessageType::ErrorMsg,
        MessageType::Auth,
        MessageType::DontHave,
        MessageType::Peers,
        MessageType::GetTxSet,
        MessageType::TxSet,
        MessageType::GeneralizedTxSet,
        MessageType::Transaction,
        MessageType::GetScpQuorumset,
        MessageType::ScpQuorumset,
        MessageType::ScpMessage,
        MessageType::GetScpState,
        MessageType::Hello,
        MessageType::SendMore,
        MessageType::SendMoreExtended,
        MessageType::FloodAdvert,
        MessageType::FloodDemand,
        MessageType::TimeSlicedSurveyRequest,
        MessageType::TimeSlicedSurveyResponse,
        MessageType::TimeSlicedSurveyStartCollecting,
        MessageType::TimeSlicedSurveyStopCollecting,
    ];
    pub const VARIANTS_STR: [&'static str; 21] = [
        "ErrorMsg",
        "Auth",
        "DontHave",
        "Peers",
        "GetTxSet",
        "TxSet",
        "GeneralizedTxSet",
        "Transaction",
        "GetScpQuorumset",
        "ScpQuorumset",
        "ScpMessage",
        "GetScpState",
        "Hello",
        "SendMore",
        "SendMoreExtended",
        "FloodAdvert",
        "FloodDemand",
        "TimeSlicedSurveyRequest",
        "TimeSlicedSurveyResponse",
        "TimeSlicedSurveyStartCollecting",
        "TimeSlicedSurveyStopCollecting",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ErrorMsg => "ErrorMsg",

            Self::Auth => "Auth",

            Self::DontHave => "DontHave",

            Self::Peers => "Peers",

            Self::GetTxSet => "GetTxSet",

            Self::TxSet => "TxSet",

            Self::GeneralizedTxSet => "GeneralizedTxSet",

            Self::Transaction => "Transaction",

            Self::GetScpQuorumset => "GetScpQuorumset",

            Self::ScpQuorumset => "ScpQuorumset",

            Self::ScpMessage => "ScpMessage",

            Self::GetScpState => "GetScpState",

            Self::Hello => "Hello",

            Self::SendMore => "SendMore",

            Self::SendMoreExtended => "SendMoreExtended",

            Self::FloodAdvert => "FloodAdvert",

            Self::FloodDemand => "FloodDemand",

            Self::TimeSlicedSurveyRequest => "TimeSlicedSurveyRequest",

            Self::TimeSlicedSurveyResponse => "TimeSlicedSurveyResponse",

            Self::TimeSlicedSurveyStartCollecting => "TimeSlicedSurveyStartCollecting",

            Self::TimeSlicedSurveyStopCollecting => "TimeSlicedSurveyStopCollecting",
        }
    }

    #[must_use]
    pub const fn variants() -> [MessageType; 21] {
        Self::VARIANTS
    }
}

impl Name for MessageType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<MessageType> for MessageType {
    fn variants() -> slice::Iter<'static, MessageType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for MessageType {}

impl fmt::Display for MessageType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for MessageType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => MessageType::ErrorMsg,

            2 => MessageType::Auth,

            3 => MessageType::DontHave,

            5 => MessageType::Peers,

            6 => MessageType::GetTxSet,

            7 => MessageType::TxSet,

            17 => MessageType::GeneralizedTxSet,

            8 => MessageType::Transaction,

            9 => MessageType::GetScpQuorumset,

            10 => MessageType::ScpQuorumset,

            11 => MessageType::ScpMessage,

            12 => MessageType::GetScpState,

            13 => MessageType::Hello,

            16 => MessageType::SendMore,

            20 => MessageType::SendMoreExtended,

            18 => MessageType::FloodAdvert,

            19 => MessageType::FloodDemand,

            21 => MessageType::TimeSlicedSurveyRequest,

            22 => MessageType::TimeSlicedSurveyResponse,

            23 => MessageType::TimeSlicedSurveyStartCollecting,

            24 => MessageType::TimeSlicedSurveyStopCollecting,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<MessageType> for i32 {
    #[must_use]
    fn from(e: MessageType) -> Self {
        e as Self
    }
}

impl ReadXdr for MessageType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for MessageType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// DontHave
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct DontHave {
    pub type_: MessageType,

    pub req_hash: Uint256,
}

impl ReadXdr for DontHave {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                type_: MessageType::read_xdr(r)?,

                req_hash: Uint256::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for DontHave {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.type_.write_xdr(w)?;

            self.req_hash.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SurveyMessageCommandType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum SurveyMessageCommandType {
    #[cfg_attr(feature = "alloc", default)]
    TimeSlicedSurveyTopology = 1,
}

impl SurveyMessageCommandType {
    pub const VARIANTS: [SurveyMessageCommandType; 1] =
        [SurveyMessageCommandType::TimeSlicedSurveyTopology];
    pub const VARIANTS_STR: [&'static str; 1] = ["TimeSlicedSurveyTopology"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TimeSlicedSurveyTopology => "TimeSlicedSurveyTopology",
        }
    }

    #[must_use]
    pub const fn variants() -> [SurveyMessageCommandType; 1] {
        Self::VARIANTS
    }
}

impl Name for SurveyMessageCommandType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SurveyMessageCommandType> for SurveyMessageCommandType {
    fn variants() -> slice::Iter<'static, SurveyMessageCommandType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SurveyMessageCommandType {}

impl fmt::Display for SurveyMessageCommandType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SurveyMessageCommandType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            1 => SurveyMessageCommandType::TimeSlicedSurveyTopology,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SurveyMessageCommandType> for i32 {
    #[must_use]
    fn from(e: SurveyMessageCommandType) -> Self {
        e as Self
    }
}

impl ReadXdr for SurveyMessageCommandType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SurveyMessageCommandType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SurveyMessageResponseType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum SurveyMessageResponseType {
    #[cfg_attr(feature = "alloc", default)]
    SurveyTopologyResponseV2 = 2,
}

impl SurveyMessageResponseType {
    pub const VARIANTS: [SurveyMessageResponseType; 1] =
        [SurveyMessageResponseType::SurveyTopologyResponseV2];
    pub const VARIANTS_STR: [&'static str; 1] = ["SurveyTopologyResponseV2"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SurveyTopologyResponseV2 => "SurveyTopologyResponseV2",
        }
    }

    #[must_use]
    pub const fn variants() -> [SurveyMessageResponseType; 1] {
        Self::VARIANTS
    }
}

impl Name for SurveyMessageResponseType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SurveyMessageResponseType> for SurveyMessageResponseType {
    fn variants() -> slice::Iter<'static, SurveyMessageResponseType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SurveyMessageResponseType {}

impl fmt::Display for SurveyMessageResponseType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SurveyMessageResponseType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            2 => SurveyMessageResponseType::SurveyTopologyResponseV2,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SurveyMessageResponseType> for i32 {
    #[must_use]
    fn from(e: SurveyMessageResponseType) -> Self {
        e as Self
    }
}

impl ReadXdr for SurveyMessageResponseType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SurveyMessageResponseType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// TimeSlicedSurveyStartCollectingMessage
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TimeSlicedSurveyStartCollectingMessage {
    pub surveyor_id: NodeId,

    pub nonce: u32,

    pub ledger_num: u32,
}

impl ReadXdr for TimeSlicedSurveyStartCollectingMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                surveyor_id: NodeId::read_xdr(r)?,

                nonce: u32::read_xdr(r)?,

                ledger_num: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TimeSlicedSurveyStartCollectingMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.surveyor_id.write_xdr(w)?;

            self.nonce.write_xdr(w)?;

            self.ledger_num.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SignedTimeSlicedSurveyStartCollectingMessage
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SignedTimeSlicedSurveyStartCollectingMessage {
    pub signature: Signature,

    pub start_collecting: TimeSlicedSurveyStartCollectingMessage,
}

impl ReadXdr for SignedTimeSlicedSurveyStartCollectingMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                signature: Signature::read_xdr(r)?,

                start_collecting: TimeSlicedSurveyStartCollectingMessage::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SignedTimeSlicedSurveyStartCollectingMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.signature.write_xdr(w)?;

            self.start_collecting.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TimeSlicedSurveyStopCollectingMessage
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TimeSlicedSurveyStopCollectingMessage {
    pub surveyor_id: NodeId,

    pub nonce: u32,

    pub ledger_num: u32,
}

impl ReadXdr for TimeSlicedSurveyStopCollectingMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                surveyor_id: NodeId::read_xdr(r)?,

                nonce: u32::read_xdr(r)?,

                ledger_num: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TimeSlicedSurveyStopCollectingMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.surveyor_id.write_xdr(w)?;

            self.nonce.write_xdr(w)?;

            self.ledger_num.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SignedTimeSlicedSurveyStopCollectingMessage
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SignedTimeSlicedSurveyStopCollectingMessage {
    pub signature: Signature,

    pub stop_collecting: TimeSlicedSurveyStopCollectingMessage,
}

impl ReadXdr for SignedTimeSlicedSurveyStopCollectingMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                signature: Signature::read_xdr(r)?,

                stop_collecting: TimeSlicedSurveyStopCollectingMessage::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SignedTimeSlicedSurveyStopCollectingMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.signature.write_xdr(w)?;

            self.stop_collecting.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SurveyRequestMessage
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SurveyRequestMessage {
    pub surveyor_peer_id: NodeId,

    pub surveyed_peer_id: NodeId,

    pub ledger_num: u32,

    pub encryption_key: Curve25519Public,

    pub command_type: SurveyMessageCommandType,
}

impl ReadXdr for SurveyRequestMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                surveyor_peer_id: NodeId::read_xdr(r)?,

                surveyed_peer_id: NodeId::read_xdr(r)?,

                ledger_num: u32::read_xdr(r)?,

                encryption_key: Curve25519Public::read_xdr(r)?,

                command_type: SurveyMessageCommandType::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SurveyRequestMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.surveyor_peer_id.write_xdr(w)?;

            self.surveyed_peer_id.write_xdr(w)?;

            self.ledger_num.write_xdr(w)?;

            self.encryption_key.write_xdr(w)?;

            self.command_type.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TimeSlicedSurveyRequestMessage
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TimeSlicedSurveyRequestMessage {
    pub request: SurveyRequestMessage,

    pub nonce: u32,

    pub inbound_peers_index: u32,

    pub outbound_peers_index: u32,
}

impl ReadXdr for TimeSlicedSurveyRequestMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                request: SurveyRequestMessage::read_xdr(r)?,

                nonce: u32::read_xdr(r)?,

                inbound_peers_index: u32::read_xdr(r)?,

                outbound_peers_index: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TimeSlicedSurveyRequestMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.request.write_xdr(w)?;

            self.nonce.write_xdr(w)?;

            self.inbound_peers_index.write_xdr(w)?;

            self.outbound_peers_index.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SignedTimeSlicedSurveyRequestMessage
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SignedTimeSlicedSurveyRequestMessage {
    pub request_signature: Signature,

    pub request: TimeSlicedSurveyRequestMessage,
}

impl ReadXdr for SignedTimeSlicedSurveyRequestMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                request_signature: Signature::read_xdr(r)?,

                request: TimeSlicedSurveyRequestMessage::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SignedTimeSlicedSurveyRequestMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.request_signature.write_xdr(w)?;

            self.request.write_xdr(w)?;

            Ok(())
        })
    }
}

/// EncryptedBody
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct EncryptedBody(pub BytesM<64000>);

impl From<EncryptedBody> for BytesM<64000> {
    #[must_use]
    fn from(x: EncryptedBody) -> Self {
        x.0
    }
}

impl From<BytesM<64000>> for EncryptedBody {
    #[must_use]
    fn from(x: BytesM<64000>) -> Self {
        EncryptedBody(x)
    }
}

impl AsRef<BytesM<64000>> for EncryptedBody {
    #[must_use]
    fn as_ref(&self) -> &BytesM<64000> {
        &self.0
    }
}

impl ReadXdr for EncryptedBody {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = BytesM::<64000>::read_xdr(r)?;
            let v = EncryptedBody(i);
            Ok(v)
        })
    }
}

impl WriteXdr for EncryptedBody {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for EncryptedBody {
    type Target = BytesM<64000>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<EncryptedBody> for Vec<u8> {
    #[must_use]
    fn from(x: EncryptedBody) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for EncryptedBody {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        Ok(EncryptedBody(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for EncryptedBody {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        Ok(EncryptedBody(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for EncryptedBody {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for EncryptedBody {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// SurveyResponseMessage
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SurveyResponseMessage {
    pub surveyor_peer_id: NodeId,

    pub surveyed_peer_id: NodeId,

    pub ledger_num: u32,

    pub command_type: SurveyMessageCommandType,

    pub encrypted_body: EncryptedBody,
}

impl ReadXdr for SurveyResponseMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                surveyor_peer_id: NodeId::read_xdr(r)?,

                surveyed_peer_id: NodeId::read_xdr(r)?,

                ledger_num: u32::read_xdr(r)?,

                command_type: SurveyMessageCommandType::read_xdr(r)?,

                encrypted_body: EncryptedBody::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SurveyResponseMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.surveyor_peer_id.write_xdr(w)?;

            self.surveyed_peer_id.write_xdr(w)?;

            self.ledger_num.write_xdr(w)?;

            self.command_type.write_xdr(w)?;

            self.encrypted_body.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TimeSlicedSurveyResponseMessage
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TimeSlicedSurveyResponseMessage {
    pub response: SurveyResponseMessage,

    pub nonce: u32,
}

impl ReadXdr for TimeSlicedSurveyResponseMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                response: SurveyResponseMessage::read_xdr(r)?,

                nonce: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TimeSlicedSurveyResponseMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.response.write_xdr(w)?;

            self.nonce.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SignedTimeSlicedSurveyResponseMessage
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SignedTimeSlicedSurveyResponseMessage {
    pub response_signature: Signature,

    pub response: TimeSlicedSurveyResponseMessage,
}

impl ReadXdr for SignedTimeSlicedSurveyResponseMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                response_signature: Signature::read_xdr(r)?,

                response: TimeSlicedSurveyResponseMessage::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SignedTimeSlicedSurveyResponseMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.response_signature.write_xdr(w)?;

            self.response.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PeerStats
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct PeerStats {
    pub id: NodeId,

    pub version_str: StringM<100>,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub messages_read: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub messages_written: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub bytes_read: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub bytes_written: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub seconds_connected: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub unique_flood_bytes_recv: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub duplicate_flood_bytes_recv: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub unique_fetch_bytes_recv: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub duplicate_fetch_bytes_recv: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub unique_flood_message_recv: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub duplicate_flood_message_recv: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub unique_fetch_message_recv: u64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub duplicate_fetch_message_recv: u64,
}

impl ReadXdr for PeerStats {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                id: NodeId::read_xdr(r)?,

                version_str: StringM::<100>::read_xdr(r)?,

                messages_read: u64::read_xdr(r)?,

                messages_written: u64::read_xdr(r)?,

                bytes_read: u64::read_xdr(r)?,

                bytes_written: u64::read_xdr(r)?,

                seconds_connected: u64::read_xdr(r)?,

                unique_flood_bytes_recv: u64::read_xdr(r)?,

                duplicate_flood_bytes_recv: u64::read_xdr(r)?,

                unique_fetch_bytes_recv: u64::read_xdr(r)?,

                duplicate_fetch_bytes_recv: u64::read_xdr(r)?,

                unique_flood_message_recv: u64::read_xdr(r)?,

                duplicate_flood_message_recv: u64::read_xdr(r)?,

                unique_fetch_message_recv: u64::read_xdr(r)?,

                duplicate_fetch_message_recv: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PeerStats {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.id.write_xdr(w)?;

            self.version_str.write_xdr(w)?;

            self.messages_read.write_xdr(w)?;

            self.messages_written.write_xdr(w)?;

            self.bytes_read.write_xdr(w)?;

            self.bytes_written.write_xdr(w)?;

            self.seconds_connected.write_xdr(w)?;

            self.unique_flood_bytes_recv.write_xdr(w)?;

            self.duplicate_flood_bytes_recv.write_xdr(w)?;

            self.unique_fetch_bytes_recv.write_xdr(w)?;

            self.duplicate_fetch_bytes_recv.write_xdr(w)?;

            self.unique_flood_message_recv.write_xdr(w)?;

            self.duplicate_flood_message_recv.write_xdr(w)?;

            self.unique_fetch_message_recv.write_xdr(w)?;

            self.duplicate_fetch_message_recv.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TimeSlicedNodeData
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TimeSlicedNodeData {
    pub added_authenticated_peers: u32,

    pub dropped_authenticated_peers: u32,

    pub total_inbound_peer_count: u32,

    pub total_outbound_peer_count: u32,

    pub p75_scp_first_to_self_latency_ms: u32,

    pub p75_scp_self_to_other_latency_ms: u32,

    pub lost_sync_count: u32,

    pub is_validator: bool,

    pub max_inbound_peer_count: u32,

    pub max_outbound_peer_count: u32,
}

impl ReadXdr for TimeSlicedNodeData {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                added_authenticated_peers: u32::read_xdr(r)?,

                dropped_authenticated_peers: u32::read_xdr(r)?,

                total_inbound_peer_count: u32::read_xdr(r)?,

                total_outbound_peer_count: u32::read_xdr(r)?,

                p75_scp_first_to_self_latency_ms: u32::read_xdr(r)?,

                p75_scp_self_to_other_latency_ms: u32::read_xdr(r)?,

                lost_sync_count: u32::read_xdr(r)?,

                is_validator: bool::read_xdr(r)?,

                max_inbound_peer_count: u32::read_xdr(r)?,

                max_outbound_peer_count: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TimeSlicedNodeData {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.added_authenticated_peers.write_xdr(w)?;

            self.dropped_authenticated_peers.write_xdr(w)?;

            self.total_inbound_peer_count.write_xdr(w)?;

            self.total_outbound_peer_count.write_xdr(w)?;

            self.p75_scp_first_to_self_latency_ms.write_xdr(w)?;

            self.p75_scp_self_to_other_latency_ms.write_xdr(w)?;

            self.lost_sync_count.write_xdr(w)?;

            self.is_validator.write_xdr(w)?;

            self.max_inbound_peer_count.write_xdr(w)?;

            self.max_outbound_peer_count.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TimeSlicedPeerData
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TimeSlicedPeerData {
    pub peer_stats: PeerStats,

    pub average_latency_ms: u32,
}

impl ReadXdr for TimeSlicedPeerData {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                peer_stats: PeerStats::read_xdr(r)?,

                average_latency_ms: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TimeSlicedPeerData {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.peer_stats.write_xdr(w)?;

            self.average_latency_ms.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TimeSlicedPeerDataList
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TimeSlicedPeerDataList(pub VecM<TimeSlicedPeerData, 25>);

impl From<TimeSlicedPeerDataList> for VecM<TimeSlicedPeerData, 25> {
    #[must_use]
    fn from(x: TimeSlicedPeerDataList) -> Self {
        x.0
    }
}

impl From<VecM<TimeSlicedPeerData, 25>> for TimeSlicedPeerDataList {
    #[must_use]
    fn from(x: VecM<TimeSlicedPeerData, 25>) -> Self {
        TimeSlicedPeerDataList(x)
    }
}

impl AsRef<VecM<TimeSlicedPeerData, 25>> for TimeSlicedPeerDataList {
    #[must_use]
    fn as_ref(&self) -> &VecM<TimeSlicedPeerData, 25> {
        &self.0
    }
}

impl ReadXdr for TimeSlicedPeerDataList {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = VecM::<TimeSlicedPeerData, 25>::read_xdr(r)?;
            let v = TimeSlicedPeerDataList(i);
            Ok(v)
        })
    }
}

impl WriteXdr for TimeSlicedPeerDataList {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for TimeSlicedPeerDataList {
    type Target = VecM<TimeSlicedPeerData, 25>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<TimeSlicedPeerDataList> for Vec<TimeSlicedPeerData> {
    #[must_use]
    fn from(x: TimeSlicedPeerDataList) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<TimeSlicedPeerData>> for TimeSlicedPeerDataList {
    type Error = Error;
    fn try_from(x: Vec<TimeSlicedPeerData>) -> Result<Self, Error> {
        Ok(TimeSlicedPeerDataList(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<TimeSlicedPeerData>> for TimeSlicedPeerDataList {
    type Error = Error;
    fn try_from(x: &Vec<TimeSlicedPeerData>) -> Result<Self, Error> {
        Ok(TimeSlicedPeerDataList(x.try_into()?))
    }
}

impl AsRef<Vec<TimeSlicedPeerData>> for TimeSlicedPeerDataList {
    #[must_use]
    fn as_ref(&self) -> &Vec<TimeSlicedPeerData> {
        &self.0 .0
    }
}

impl AsRef<[TimeSlicedPeerData]> for TimeSlicedPeerDataList {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[TimeSlicedPeerData] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[TimeSlicedPeerData] {
        self.0 .0
    }
}

/// TopologyResponseBodyV2
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TopologyResponseBodyV2 {
    pub inbound_peers: TimeSlicedPeerDataList,

    pub outbound_peers: TimeSlicedPeerDataList,

    pub node_data: TimeSlicedNodeData,
}

impl ReadXdr for TopologyResponseBodyV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                inbound_peers: TimeSlicedPeerDataList::read_xdr(r)?,

                outbound_peers: TimeSlicedPeerDataList::read_xdr(r)?,

                node_data: TimeSlicedNodeData::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TopologyResponseBodyV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.inbound_peers.write_xdr(w)?;

            self.outbound_peers.write_xdr(w)?;

            self.node_data.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SurveyResponseBody
// union with discriminant SurveyMessageResponseType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum SurveyResponseBody {
    SurveyTopologyResponseV2(TopologyResponseBodyV2),
}

#[cfg(feature = "alloc")]
impl Default for SurveyResponseBody {
    fn default() -> Self {
        Self::SurveyTopologyResponseV2(TopologyResponseBodyV2::default())
    }
}

impl SurveyResponseBody {
    pub const VARIANTS: [SurveyMessageResponseType; 1] =
        [SurveyMessageResponseType::SurveyTopologyResponseV2];
    pub const VARIANTS_STR: [&'static str; 1] = ["SurveyTopologyResponseV2"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SurveyTopologyResponseV2(_) => "SurveyTopologyResponseV2",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SurveyMessageResponseType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::SurveyTopologyResponseV2(_) => {
                SurveyMessageResponseType::SurveyTopologyResponseV2
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [SurveyMessageResponseType; 1] {
        Self::VARIANTS
    }
}

impl Name for SurveyResponseBody {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SurveyMessageResponseType> for SurveyResponseBody {
    #[must_use]
    fn discriminant(&self) -> SurveyMessageResponseType {
        Self::discriminant(self)
    }
}

impl Variants<SurveyMessageResponseType> for SurveyResponseBody {
    fn variants() -> slice::Iter<'static, SurveyMessageResponseType> {
        Self::VARIANTS.iter()
    }
}

impl Union<SurveyMessageResponseType> for SurveyResponseBody {}

impl ReadXdr for SurveyResponseBody {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: SurveyMessageResponseType =
                <SurveyMessageResponseType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                SurveyMessageResponseType::SurveyTopologyResponseV2 => {
                    Self::SurveyTopologyResponseV2(TopologyResponseBodyV2::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SurveyResponseBody {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::SurveyTopologyResponseV2(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

pub const TX_ADVERT_VECTOR_MAX_SIZE: u64 = 1000;

/// TxAdvertVector
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TxAdvertVector(pub VecM<Hash, TxAdvertVectorMaxSize>);

impl From<TxAdvertVector> for VecM<Hash, TxAdvertVectorMaxSize> {
    #[must_use]
    fn from(x: TxAdvertVector) -> Self {
        x.0
    }
}

impl From<VecM<Hash, TxAdvertVectorMaxSize>> for TxAdvertVector {
    #[must_use]
    fn from(x: VecM<Hash, TxAdvertVectorMaxSize>) -> Self {
        TxAdvertVector(x)
    }
}

impl AsRef<VecM<Hash, TxAdvertVectorMaxSize>> for TxAdvertVector {
    #[must_use]
    fn as_ref(&self) -> &VecM<Hash, TxAdvertVectorMaxSize> {
        &self.0
    }
}

impl ReadXdr for TxAdvertVector {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = VecM::<Hash, TxAdvertVectorMaxSize>::read_xdr(r)?;
            let v = TxAdvertVector(i);
            Ok(v)
        })
    }
}

impl WriteXdr for TxAdvertVector {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for TxAdvertVector {
    type Target = VecM<Hash, TxAdvertVectorMaxSize>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<TxAdvertVector> for Vec<Hash> {
    #[must_use]
    fn from(x: TxAdvertVector) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<Hash>> for TxAdvertVector {
    type Error = Error;
    fn try_from(x: Vec<Hash>) -> Result<Self, Error> {
        Ok(TxAdvertVector(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<Hash>> for TxAdvertVector {
    type Error = Error;
    fn try_from(x: &Vec<Hash>) -> Result<Self, Error> {
        Ok(TxAdvertVector(x.try_into()?))
    }
}

impl AsRef<Vec<Hash>> for TxAdvertVector {
    #[must_use]
    fn as_ref(&self) -> &Vec<Hash> {
        &self.0 .0
    }
}

impl AsRef<[Hash]> for TxAdvertVector {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[Hash] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[Hash] {
        self.0 .0
    }
}

/// FloodAdvert
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct FloodAdvert {
    pub tx_hashes: TxAdvertVector,
}

impl ReadXdr for FloodAdvert {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_hashes: TxAdvertVector::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for FloodAdvert {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.tx_hashes.write_xdr(w)?;

            Ok(())
        })
    }
}

pub const TX_DEMAND_VECTOR_MAX_SIZE: u64 = 1000;

/// TxDemandVector
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TxDemandVector(pub VecM<Hash, TxDemandVectorMaxSize>);

impl From<TxDemandVector> for VecM<Hash, TxDemandVectorMaxSize> {
    #[must_use]
    fn from(x: TxDemandVector) -> Self {
        x.0
    }
}

impl From<VecM<Hash, TxDemandVectorMaxSize>> for TxDemandVector {
    #[must_use]
    fn from(x: VecM<Hash, TxDemandVectorMaxSize>) -> Self {
        TxDemandVector(x)
    }
}

impl AsRef<VecM<Hash, TxDemandVectorMaxSize>> for TxDemandVector {
    #[must_use]
    fn as_ref(&self) -> &VecM<Hash, TxDemandVectorMaxSize> {
        &self.0
    }
}

impl ReadXdr for TxDemandVector {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = VecM::<Hash, TxDemandVectorMaxSize>::read_xdr(r)?;
            let v = TxDemandVector(i);
            Ok(v)
        })
    }
}

impl WriteXdr for TxDemandVector {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for TxDemandVector {
    type Target = VecM<Hash, TxDemandVectorMaxSize>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<TxDemandVector> for Vec<Hash> {
    #[must_use]
    fn from(x: TxDemandVector) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<Hash>> for TxDemandVector {
    type Error = Error;
    fn try_from(x: Vec<Hash>) -> Result<Self, Error> {
        Ok(TxDemandVector(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<Hash>> for TxDemandVector {
    type Error = Error;
    fn try_from(x: &Vec<Hash>) -> Result<Self, Error> {
        Ok(TxDemandVector(x.try_into()?))
    }
}

impl AsRef<Vec<Hash>> for TxDemandVector {
    #[must_use]
    fn as_ref(&self) -> &Vec<Hash> {
        &self.0 .0
    }
}

impl AsRef<[Hash]> for TxDemandVector {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[Hash] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[Hash] {
        self.0 .0
    }
}

/// FloodDemand
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct FloodDemand {
    pub tx_hashes: TxDemandVector,
}

impl ReadXdr for FloodDemand {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_hashes: TxDemandVector::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for FloodDemand {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.tx_hashes.write_xdr(w)?;

            Ok(())
        })
    }
}

/// StellarMessage
// union with discriminant MessageType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum StellarMessage {
    ErrorMsg(SError),

    Hello(Hello),

    Auth(Auth),

    DontHave(DontHave),

    Peers(VecM<PeerAddress, 100>),

    GetTxSet(Uint256),

    TxSet(TransactionSet),

    GeneralizedTxSet(GeneralizedTransactionSet),

    Transaction(TransactionEnvelope),

    TimeSlicedSurveyRequest(SignedTimeSlicedSurveyRequestMessage),

    TimeSlicedSurveyResponse(SignedTimeSlicedSurveyResponseMessage),

    TimeSlicedSurveyStartCollecting(SignedTimeSlicedSurveyStartCollectingMessage),

    TimeSlicedSurveyStopCollecting(SignedTimeSlicedSurveyStopCollectingMessage),

    GetScpQuorumset(Uint256),

    ScpQuorumset(ScpQuorumSet),

    ScpMessage(ScpEnvelope),

    GetScpState(u32),

    SendMore(SendMore),

    SendMoreExtended(SendMoreExtended),

    FloodAdvert(FloodAdvert),

    FloodDemand(FloodDemand),
}

#[cfg(feature = "alloc")]
impl Default for StellarMessage {
    fn default() -> Self {
        Self::ErrorMsg(SError::default())
    }
}

impl StellarMessage {
    pub const VARIANTS: [MessageType; 21] = [
        MessageType::ErrorMsg,
        MessageType::Hello,
        MessageType::Auth,
        MessageType::DontHave,
        MessageType::Peers,
        MessageType::GetTxSet,
        MessageType::TxSet,
        MessageType::GeneralizedTxSet,
        MessageType::Transaction,
        MessageType::TimeSlicedSurveyRequest,
        MessageType::TimeSlicedSurveyResponse,
        MessageType::TimeSlicedSurveyStartCollecting,
        MessageType::TimeSlicedSurveyStopCollecting,
        MessageType::GetScpQuorumset,
        MessageType::ScpQuorumset,
        MessageType::ScpMessage,
        MessageType::GetScpState,
        MessageType::SendMore,
        MessageType::SendMoreExtended,
        MessageType::FloodAdvert,
        MessageType::FloodDemand,
    ];
    pub const VARIANTS_STR: [&'static str; 21] = [
        "ErrorMsg",
        "Hello",
        "Auth",
        "DontHave",
        "Peers",
        "GetTxSet",
        "TxSet",
        "GeneralizedTxSet",
        "Transaction",
        "TimeSlicedSurveyRequest",
        "TimeSlicedSurveyResponse",
        "TimeSlicedSurveyStartCollecting",
        "TimeSlicedSurveyStopCollecting",
        "GetScpQuorumset",
        "ScpQuorumset",
        "ScpMessage",
        "GetScpState",
        "SendMore",
        "SendMoreExtended",
        "FloodAdvert",
        "FloodDemand",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ErrorMsg(_) => "ErrorMsg",

            Self::Hello(_) => "Hello",

            Self::Auth(_) => "Auth",

            Self::DontHave(_) => "DontHave",

            Self::Peers(_) => "Peers",

            Self::GetTxSet(_) => "GetTxSet",

            Self::TxSet(_) => "TxSet",

            Self::GeneralizedTxSet(_) => "GeneralizedTxSet",

            Self::Transaction(_) => "Transaction",

            Self::TimeSlicedSurveyRequest(_) => "TimeSlicedSurveyRequest",

            Self::TimeSlicedSurveyResponse(_) => "TimeSlicedSurveyResponse",

            Self::TimeSlicedSurveyStartCollecting(_) => "TimeSlicedSurveyStartCollecting",

            Self::TimeSlicedSurveyStopCollecting(_) => "TimeSlicedSurveyStopCollecting",

            Self::GetScpQuorumset(_) => "GetScpQuorumset",

            Self::ScpQuorumset(_) => "ScpQuorumset",

            Self::ScpMessage(_) => "ScpMessage",

            Self::GetScpState(_) => "GetScpState",

            Self::SendMore(_) => "SendMore",

            Self::SendMoreExtended(_) => "SendMoreExtended",

            Self::FloodAdvert(_) => "FloodAdvert",

            Self::FloodDemand(_) => "FloodDemand",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> MessageType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ErrorMsg(_) => MessageType::ErrorMsg,

            Self::Hello(_) => MessageType::Hello,

            Self::Auth(_) => MessageType::Auth,

            Self::DontHave(_) => MessageType::DontHave,

            Self::Peers(_) => MessageType::Peers,

            Self::GetTxSet(_) => MessageType::GetTxSet,

            Self::TxSet(_) => MessageType::TxSet,

            Self::GeneralizedTxSet(_) => MessageType::GeneralizedTxSet,

            Self::Transaction(_) => MessageType::Transaction,

            Self::TimeSlicedSurveyRequest(_) => MessageType::TimeSlicedSurveyRequest,

            Self::TimeSlicedSurveyResponse(_) => MessageType::TimeSlicedSurveyResponse,

            Self::TimeSlicedSurveyStartCollecting(_) => {
                MessageType::TimeSlicedSurveyStartCollecting
            }

            Self::TimeSlicedSurveyStopCollecting(_) => MessageType::TimeSlicedSurveyStopCollecting,

            Self::GetScpQuorumset(_) => MessageType::GetScpQuorumset,

            Self::ScpQuorumset(_) => MessageType::ScpQuorumset,

            Self::ScpMessage(_) => MessageType::ScpMessage,

            Self::GetScpState(_) => MessageType::GetScpState,

            Self::SendMore(_) => MessageType::SendMore,

            Self::SendMoreExtended(_) => MessageType::SendMoreExtended,

            Self::FloodAdvert(_) => MessageType::FloodAdvert,

            Self::FloodDemand(_) => MessageType::FloodDemand,
        }
    }

    #[must_use]
    pub const fn variants() -> [MessageType; 21] {
        Self::VARIANTS
    }
}

impl Name for StellarMessage {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<MessageType> for StellarMessage {
    #[must_use]
    fn discriminant(&self) -> MessageType {
        Self::discriminant(self)
    }
}

impl Variants<MessageType> for StellarMessage {
    fn variants() -> slice::Iter<'static, MessageType> {
        Self::VARIANTS.iter()
    }
}

impl Union<MessageType> for StellarMessage {}

impl ReadXdr for StellarMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: MessageType = <MessageType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                MessageType::ErrorMsg => Self::ErrorMsg(SError::read_xdr(r)?),

                MessageType::Hello => Self::Hello(Hello::read_xdr(r)?),

                MessageType::Auth => Self::Auth(Auth::read_xdr(r)?),

                MessageType::DontHave => Self::DontHave(DontHave::read_xdr(r)?),

                MessageType::Peers => Self::Peers(VecM::<PeerAddress, 100>::read_xdr(r)?),

                MessageType::GetTxSet => Self::GetTxSet(Uint256::read_xdr(r)?),

                MessageType::TxSet => Self::TxSet(TransactionSet::read_xdr(r)?),

                MessageType::GeneralizedTxSet => {
                    Self::GeneralizedTxSet(GeneralizedTransactionSet::read_xdr(r)?)
                }

                MessageType::Transaction => Self::Transaction(TransactionEnvelope::read_xdr(r)?),

                MessageType::TimeSlicedSurveyRequest => Self::TimeSlicedSurveyRequest(
                    SignedTimeSlicedSurveyRequestMessage::read_xdr(r)?,
                ),

                MessageType::TimeSlicedSurveyResponse => Self::TimeSlicedSurveyResponse(
                    SignedTimeSlicedSurveyResponseMessage::read_xdr(r)?,
                ),

                MessageType::TimeSlicedSurveyStartCollecting => {
                    Self::TimeSlicedSurveyStartCollecting(
                        SignedTimeSlicedSurveyStartCollectingMessage::read_xdr(r)?,
                    )
                }

                MessageType::TimeSlicedSurveyStopCollecting => {
                    Self::TimeSlicedSurveyStopCollecting(
                        SignedTimeSlicedSurveyStopCollectingMessage::read_xdr(r)?,
                    )
                }

                MessageType::GetScpQuorumset => Self::GetScpQuorumset(Uint256::read_xdr(r)?),

                MessageType::ScpQuorumset => Self::ScpQuorumset(ScpQuorumSet::read_xdr(r)?),

                MessageType::ScpMessage => Self::ScpMessage(ScpEnvelope::read_xdr(r)?),

                MessageType::GetScpState => Self::GetScpState(u32::read_xdr(r)?),

                MessageType::SendMore => Self::SendMore(SendMore::read_xdr(r)?),

                MessageType::SendMoreExtended => {
                    Self::SendMoreExtended(SendMoreExtended::read_xdr(r)?)
                }

                MessageType::FloodAdvert => Self::FloodAdvert(FloodAdvert::read_xdr(r)?),

                MessageType::FloodDemand => Self::FloodDemand(FloodDemand::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for StellarMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ErrorMsg(v) => v.write_xdr(w)?,

                Self::Hello(v) => v.write_xdr(w)?,

                Self::Auth(v) => v.write_xdr(w)?,

                Self::DontHave(v) => v.write_xdr(w)?,

                Self::Peers(v) => v.write_xdr(w)?,

                Self::GetTxSet(v) => v.write_xdr(w)?,

                Self::TxSet(v) => v.write_xdr(w)?,

                Self::GeneralizedTxSet(v) => v.write_xdr(w)?,

                Self::Transaction(v) => v.write_xdr(w)?,

                Self::TimeSlicedSurveyRequest(v) => v.write_xdr(w)?,

                Self::TimeSlicedSurveyResponse(v) => v.write_xdr(w)?,

                Self::TimeSlicedSurveyStartCollecting(v) => v.write_xdr(w)?,

                Self::TimeSlicedSurveyStopCollecting(v) => v.write_xdr(w)?,

                Self::GetScpQuorumset(v) => v.write_xdr(w)?,

                Self::ScpQuorumset(v) => v.write_xdr(w)?,

                Self::ScpMessage(v) => v.write_xdr(w)?,

                Self::GetScpState(v) => v.write_xdr(w)?,

                Self::SendMore(v) => v.write_xdr(w)?,

                Self::SendMoreExtended(v) => v.write_xdr(w)?,

                Self::FloodAdvert(v) => v.write_xdr(w)?,

                Self::FloodDemand(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AuthenticatedMessage
// union with discriminant u32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum AuthenticatedMessage {
    V0(AuthenticatedMessageV0),
}

#[cfg(feature = "alloc")]
impl Default for AuthenticatedMessage {
    fn default() -> Self {
        Self::V0(AuthenticatedMessageV0::default())
    }
}

impl AuthenticatedMessage {
    pub const VARIANTS: [u32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> u32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [u32; 1] {
        Self::VARIANTS
    }
}

impl Name for AuthenticatedMessage {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<u32> for AuthenticatedMessage {
    #[must_use]
    fn discriminant(&self) -> u32 {
        Self::discriminant(self)
    }
}

impl Variants<u32> for AuthenticatedMessage {
    fn variants() -> slice::Iter<'static, u32> {
        Self::VARIANTS.iter()
    }
}

impl Union<u32> for AuthenticatedMessage {}

impl ReadXdr for AuthenticatedMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: u32 = <u32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(AuthenticatedMessageV0::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AuthenticatedMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

pub const MAX_OPS_PER_TX: u64 = 100;

/// LiquidityPoolParameters
// union with discriminant LiquidityPoolType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LiquidityPoolParameters {
    LiquidityPoolConstantProduct(LiquidityPoolConstantProductParameters),
}

#[cfg(feature = "alloc")]
impl Default for LiquidityPoolParameters {
    fn default() -> Self {
        Self::LiquidityPoolConstantProduct(LiquidityPoolConstantProductParameters::default())
    }
}

impl LiquidityPoolParameters {
    pub const VARIANTS: [LiquidityPoolType; 1] = [LiquidityPoolType::LiquidityPoolConstantProduct];
    pub const VARIANTS_STR: [&'static str; 1] = ["LiquidityPoolConstantProduct"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LiquidityPoolConstantProduct(_) => "LiquidityPoolConstantProduct",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LiquidityPoolType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::LiquidityPoolConstantProduct(_) => {
                LiquidityPoolType::LiquidityPoolConstantProduct
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolType; 1] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolParameters {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LiquidityPoolType> for LiquidityPoolParameters {
    #[must_use]
    fn discriminant(&self) -> LiquidityPoolType {
        Self::discriminant(self)
    }
}

impl Variants<LiquidityPoolType> for LiquidityPoolParameters {
    fn variants() -> slice::Iter<'static, LiquidityPoolType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LiquidityPoolType> for LiquidityPoolParameters {}

impl ReadXdr for LiquidityPoolParameters {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: LiquidityPoolType = <LiquidityPoolType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LiquidityPoolType::LiquidityPoolConstantProduct => {
                    Self::LiquidityPoolConstantProduct(
                        LiquidityPoolConstantProductParameters::read_xdr(r)?,
                    )
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolParameters {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::LiquidityPoolConstantProduct(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// MuxedAccount
// union with discriminant CryptoKeyType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[allow(clippy::large_enum_variant)]
pub enum MuxedAccount {
    KeyTypeEd25519(Uint256),

    KeyTypeMuxedEd25519(MuxedAccountMed25519),
}

#[cfg(feature = "alloc")]
impl Default for MuxedAccount {
    fn default() -> Self {
        Self::KeyTypeEd25519(Uint256::default())
    }
}

impl MuxedAccount {
    pub const VARIANTS: [CryptoKeyType; 2] = [
        CryptoKeyType::KeyTypeEd25519,
        CryptoKeyType::KeyTypeMuxedEd25519,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["KeyTypeEd25519", "KeyTypeMuxedEd25519"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::KeyTypeEd25519(_) => "KeyTypeEd25519",

            Self::KeyTypeMuxedEd25519(_) => "KeyTypeMuxedEd25519",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> CryptoKeyType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::KeyTypeEd25519(_) => CryptoKeyType::KeyTypeEd25519,

            Self::KeyTypeMuxedEd25519(_) => CryptoKeyType::KeyTypeMuxedEd25519,
        }
    }

    #[must_use]
    pub const fn variants() -> [CryptoKeyType; 2] {
        Self::VARIANTS
    }
}

impl Name for MuxedAccount {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<CryptoKeyType> for MuxedAccount {
    #[must_use]
    fn discriminant(&self) -> CryptoKeyType {
        Self::discriminant(self)
    }
}

impl Variants<CryptoKeyType> for MuxedAccount {
    fn variants() -> slice::Iter<'static, CryptoKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Union<CryptoKeyType> for MuxedAccount {}

impl ReadXdr for MuxedAccount {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: CryptoKeyType = <CryptoKeyType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                CryptoKeyType::KeyTypeEd25519 => Self::KeyTypeEd25519(Uint256::read_xdr(r)?),

                CryptoKeyType::KeyTypeMuxedEd25519 => {
                    Self::KeyTypeMuxedEd25519(MuxedAccountMed25519::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for MuxedAccount {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::KeyTypeEd25519(v) => v.write_xdr(w)?,

                Self::KeyTypeMuxedEd25519(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// DecoratedSignature
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct DecoratedSignature {
    pub hint: SignatureHint,

    pub signature: Signature,
}

impl ReadXdr for DecoratedSignature {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hint: SignatureHint::read_xdr(r)?,

                signature: Signature::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for DecoratedSignature {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.hint.write_xdr(w)?;

            self.signature.write_xdr(w)?;

            Ok(())
        })
    }
}

/// OperationType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum OperationType {
    #[cfg_attr(feature = "alloc", default)]
    CreateAccount = 0,

    Payment = 1,

    PathPaymentStrictReceive = 2,

    ManageSellOffer = 3,

    CreatePassiveSellOffer = 4,

    SetOptions = 5,

    ChangeTrust = 6,

    AllowTrust = 7,

    AccountMerge = 8,

    Inflation = 9,

    ManageData = 10,

    BumpSequence = 11,

    ManageBuyOffer = 12,

    PathPaymentStrictSend = 13,

    CreateClaimableBalance = 14,

    ClaimClaimableBalance = 15,

    BeginSponsoringFutureReserves = 16,

    EndSponsoringFutureReserves = 17,

    RevokeSponsorship = 18,

    Clawback = 19,

    ClawbackClaimableBalance = 20,

    SetTrustLineFlags = 21,

    LiquidityPoolDeposit = 22,

    LiquidityPoolWithdraw = 23,

    InvokeHostFunction = 24,

    ExtendFootprintTtl = 25,

    RestoreFootprint = 26,
}

impl OperationType {
    pub const VARIANTS: [OperationType; 27] = [
        OperationType::CreateAccount,
        OperationType::Payment,
        OperationType::PathPaymentStrictReceive,
        OperationType::ManageSellOffer,
        OperationType::CreatePassiveSellOffer,
        OperationType::SetOptions,
        OperationType::ChangeTrust,
        OperationType::AllowTrust,
        OperationType::AccountMerge,
        OperationType::Inflation,
        OperationType::ManageData,
        OperationType::BumpSequence,
        OperationType::ManageBuyOffer,
        OperationType::PathPaymentStrictSend,
        OperationType::CreateClaimableBalance,
        OperationType::ClaimClaimableBalance,
        OperationType::BeginSponsoringFutureReserves,
        OperationType::EndSponsoringFutureReserves,
        OperationType::RevokeSponsorship,
        OperationType::Clawback,
        OperationType::ClawbackClaimableBalance,
        OperationType::SetTrustLineFlags,
        OperationType::LiquidityPoolDeposit,
        OperationType::LiquidityPoolWithdraw,
        OperationType::InvokeHostFunction,
        OperationType::ExtendFootprintTtl,
        OperationType::RestoreFootprint,
    ];
    pub const VARIANTS_STR: [&'static str; 27] = [
        "CreateAccount",
        "Payment",
        "PathPaymentStrictReceive",
        "ManageSellOffer",
        "CreatePassiveSellOffer",
        "SetOptions",
        "ChangeTrust",
        "AllowTrust",
        "AccountMerge",
        "Inflation",
        "ManageData",
        "BumpSequence",
        "ManageBuyOffer",
        "PathPaymentStrictSend",
        "CreateClaimableBalance",
        "ClaimClaimableBalance",
        "BeginSponsoringFutureReserves",
        "EndSponsoringFutureReserves",
        "RevokeSponsorship",
        "Clawback",
        "ClawbackClaimableBalance",
        "SetTrustLineFlags",
        "LiquidityPoolDeposit",
        "LiquidityPoolWithdraw",
        "InvokeHostFunction",
        "ExtendFootprintTtl",
        "RestoreFootprint",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::CreateAccount => "CreateAccount",

            Self::Payment => "Payment",

            Self::PathPaymentStrictReceive => "PathPaymentStrictReceive",

            Self::ManageSellOffer => "ManageSellOffer",

            Self::CreatePassiveSellOffer => "CreatePassiveSellOffer",

            Self::SetOptions => "SetOptions",

            Self::ChangeTrust => "ChangeTrust",

            Self::AllowTrust => "AllowTrust",

            Self::AccountMerge => "AccountMerge",

            Self::Inflation => "Inflation",

            Self::ManageData => "ManageData",

            Self::BumpSequence => "BumpSequence",

            Self::ManageBuyOffer => "ManageBuyOffer",

            Self::PathPaymentStrictSend => "PathPaymentStrictSend",

            Self::CreateClaimableBalance => "CreateClaimableBalance",

            Self::ClaimClaimableBalance => "ClaimClaimableBalance",

            Self::BeginSponsoringFutureReserves => "BeginSponsoringFutureReserves",

            Self::EndSponsoringFutureReserves => "EndSponsoringFutureReserves",

            Self::RevokeSponsorship => "RevokeSponsorship",

            Self::Clawback => "Clawback",

            Self::ClawbackClaimableBalance => "ClawbackClaimableBalance",

            Self::SetTrustLineFlags => "SetTrustLineFlags",

            Self::LiquidityPoolDeposit => "LiquidityPoolDeposit",

            Self::LiquidityPoolWithdraw => "LiquidityPoolWithdraw",

            Self::InvokeHostFunction => "InvokeHostFunction",

            Self::ExtendFootprintTtl => "ExtendFootprintTtl",

            Self::RestoreFootprint => "RestoreFootprint",
        }
    }

    #[must_use]
    pub const fn variants() -> [OperationType; 27] {
        Self::VARIANTS
    }
}

impl Name for OperationType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<OperationType> for OperationType {
    fn variants() -> slice::Iter<'static, OperationType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for OperationType {}

impl fmt::Display for OperationType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for OperationType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => OperationType::CreateAccount,

            1 => OperationType::Payment,

            2 => OperationType::PathPaymentStrictReceive,

            3 => OperationType::ManageSellOffer,

            4 => OperationType::CreatePassiveSellOffer,

            5 => OperationType::SetOptions,

            6 => OperationType::ChangeTrust,

            7 => OperationType::AllowTrust,

            8 => OperationType::AccountMerge,

            9 => OperationType::Inflation,

            10 => OperationType::ManageData,

            11 => OperationType::BumpSequence,

            12 => OperationType::ManageBuyOffer,

            13 => OperationType::PathPaymentStrictSend,

            14 => OperationType::CreateClaimableBalance,

            15 => OperationType::ClaimClaimableBalance,

            16 => OperationType::BeginSponsoringFutureReserves,

            17 => OperationType::EndSponsoringFutureReserves,

            18 => OperationType::RevokeSponsorship,

            19 => OperationType::Clawback,

            20 => OperationType::ClawbackClaimableBalance,

            21 => OperationType::SetTrustLineFlags,

            22 => OperationType::LiquidityPoolDeposit,

            23 => OperationType::LiquidityPoolWithdraw,

            24 => OperationType::InvokeHostFunction,

            25 => OperationType::ExtendFootprintTtl,

            26 => OperationType::RestoreFootprint,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<OperationType> for i32 {
    #[must_use]
    fn from(e: OperationType) -> Self {
        e as Self
    }
}

impl ReadXdr for OperationType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for OperationType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// CreateAccountOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct CreateAccountOp {
    pub destination: AccountId,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub starting_balance: i64,
}

impl ReadXdr for CreateAccountOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                destination: AccountId::read_xdr(r)?,

                starting_balance: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for CreateAccountOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.destination.write_xdr(w)?;

            self.starting_balance.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PaymentOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct PaymentOp {
    pub destination: MuxedAccount,

    pub asset: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount: i64,
}

impl ReadXdr for PaymentOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                destination: MuxedAccount::read_xdr(r)?,

                asset: Asset::read_xdr(r)?,

                amount: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PaymentOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.destination.write_xdr(w)?;

            self.asset.write_xdr(w)?;

            self.amount.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PathPaymentStrictReceiveOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct PathPaymentStrictReceiveOp {
    pub send_asset: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub send_max: i64,

    pub destination: MuxedAccount,

    pub dest_asset: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub dest_amount: i64,

    pub path: VecM<Asset, 5>,
}

impl ReadXdr for PathPaymentStrictReceiveOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                send_asset: Asset::read_xdr(r)?,

                send_max: i64::read_xdr(r)?,

                destination: MuxedAccount::read_xdr(r)?,

                dest_asset: Asset::read_xdr(r)?,

                dest_amount: i64::read_xdr(r)?,

                path: VecM::<Asset, 5>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PathPaymentStrictReceiveOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.send_asset.write_xdr(w)?;

            self.send_max.write_xdr(w)?;

            self.destination.write_xdr(w)?;

            self.dest_asset.write_xdr(w)?;

            self.dest_amount.write_xdr(w)?;

            self.path.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PathPaymentStrictSendOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct PathPaymentStrictSendOp {
    pub send_asset: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub send_amount: i64,

    pub destination: MuxedAccount,

    pub dest_asset: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub dest_min: i64,

    pub path: VecM<Asset, 5>,
}

impl ReadXdr for PathPaymentStrictSendOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                send_asset: Asset::read_xdr(r)?,

                send_amount: i64::read_xdr(r)?,

                destination: MuxedAccount::read_xdr(r)?,

                dest_asset: Asset::read_xdr(r)?,

                dest_min: i64::read_xdr(r)?,

                path: VecM::<Asset, 5>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PathPaymentStrictSendOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.send_asset.write_xdr(w)?;

            self.send_amount.write_xdr(w)?;

            self.destination.write_xdr(w)?;

            self.dest_asset.write_xdr(w)?;

            self.dest_min.write_xdr(w)?;

            self.path.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ManageSellOfferOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ManageSellOfferOp {
    pub selling: Asset,

    pub buying: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount: i64,

    pub price: Price,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub offer_id: i64,
}

impl ReadXdr for ManageSellOfferOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                selling: Asset::read_xdr(r)?,

                buying: Asset::read_xdr(r)?,

                amount: i64::read_xdr(r)?,

                price: Price::read_xdr(r)?,

                offer_id: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ManageSellOfferOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.selling.write_xdr(w)?;

            self.buying.write_xdr(w)?;

            self.amount.write_xdr(w)?;

            self.price.write_xdr(w)?;

            self.offer_id.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ManageBuyOfferOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ManageBuyOfferOp {
    pub selling: Asset,

    pub buying: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub buy_amount: i64,

    pub price: Price,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub offer_id: i64,
}

impl ReadXdr for ManageBuyOfferOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                selling: Asset::read_xdr(r)?,

                buying: Asset::read_xdr(r)?,

                buy_amount: i64::read_xdr(r)?,

                price: Price::read_xdr(r)?,

                offer_id: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ManageBuyOfferOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.selling.write_xdr(w)?;

            self.buying.write_xdr(w)?;

            self.buy_amount.write_xdr(w)?;

            self.price.write_xdr(w)?;

            self.offer_id.write_xdr(w)?;

            Ok(())
        })
    }
}

/// CreatePassiveSellOfferOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct CreatePassiveSellOfferOp {
    pub selling: Asset,

    pub buying: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount: i64,

    pub price: Price,
}

impl ReadXdr for CreatePassiveSellOfferOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                selling: Asset::read_xdr(r)?,

                buying: Asset::read_xdr(r)?,

                amount: i64::read_xdr(r)?,

                price: Price::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for CreatePassiveSellOfferOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.selling.write_xdr(w)?;

            self.buying.write_xdr(w)?;

            self.amount.write_xdr(w)?;

            self.price.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SetOptionsOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SetOptionsOp {
    pub inflation_dest: Option<AccountId>,

    pub clear_flags: Option<u32>,

    pub set_flags: Option<u32>,

    pub master_weight: Option<u32>,

    pub low_threshold: Option<u32>,

    pub med_threshold: Option<u32>,

    pub high_threshold: Option<u32>,

    pub home_domain: Option<String32>,

    pub signer: Option<Signer>,
}

impl ReadXdr for SetOptionsOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                inflation_dest: Option::<AccountId>::read_xdr(r)?,

                clear_flags: Option::<u32>::read_xdr(r)?,

                set_flags: Option::<u32>::read_xdr(r)?,

                master_weight: Option::<u32>::read_xdr(r)?,

                low_threshold: Option::<u32>::read_xdr(r)?,

                med_threshold: Option::<u32>::read_xdr(r)?,

                high_threshold: Option::<u32>::read_xdr(r)?,

                home_domain: Option::<String32>::read_xdr(r)?,

                signer: Option::<Signer>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SetOptionsOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.inflation_dest.write_xdr(w)?;

            self.clear_flags.write_xdr(w)?;

            self.set_flags.write_xdr(w)?;

            self.master_weight.write_xdr(w)?;

            self.low_threshold.write_xdr(w)?;

            self.med_threshold.write_xdr(w)?;

            self.high_threshold.write_xdr(w)?;

            self.home_domain.write_xdr(w)?;

            self.signer.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ChangeTrustAsset
// union with discriminant AssetType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ChangeTrustAsset {
    AssetTypeNative,

    AssetTypeCreditAlphanum4(AlphaNum4),

    AssetTypeCreditAlphanum12(AlphaNum12),

    AssetTypePoolShare(LiquidityPoolParameters),
}

#[cfg(feature = "alloc")]
impl Default for ChangeTrustAsset {
    fn default() -> Self {
        Self::AssetTypeNative
    }
}

impl ChangeTrustAsset {
    pub const VARIANTS: [AssetType; 4] = [
        AssetType::AssetTypeNative,
        AssetType::AssetTypeCreditAlphanum4,
        AssetType::AssetTypeCreditAlphanum12,
        AssetType::AssetTypePoolShare,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "AssetTypeNative",
        "AssetTypeCreditAlphanum4",
        "AssetTypeCreditAlphanum12",
        "AssetTypePoolShare",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AssetTypeNative => "AssetTypeNative",

            Self::AssetTypeCreditAlphanum4(_) => "AssetTypeCreditAlphanum4",

            Self::AssetTypeCreditAlphanum12(_) => "AssetTypeCreditAlphanum12",

            Self::AssetTypePoolShare(_) => "AssetTypePoolShare",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AssetType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::AssetTypeNative => AssetType::AssetTypeNative,

            Self::AssetTypeCreditAlphanum4(_) => AssetType::AssetTypeCreditAlphanum4,

            Self::AssetTypeCreditAlphanum12(_) => AssetType::AssetTypeCreditAlphanum12,

            Self::AssetTypePoolShare(_) => AssetType::AssetTypePoolShare,
        }
    }

    #[must_use]
    pub const fn variants() -> [AssetType; 4] {
        Self::VARIANTS
    }
}

impl Name for ChangeTrustAsset {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AssetType> for ChangeTrustAsset {
    #[must_use]
    fn discriminant(&self) -> AssetType {
        Self::discriminant(self)
    }
}

impl Variants<AssetType> for ChangeTrustAsset {
    fn variants() -> slice::Iter<'static, AssetType> {
        Self::VARIANTS.iter()
    }
}

impl Union<AssetType> for ChangeTrustAsset {}

impl ReadXdr for ChangeTrustAsset {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: AssetType = <AssetType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AssetType::AssetTypeNative => Self::AssetTypeNative,

                AssetType::AssetTypeCreditAlphanum4 => {
                    Self::AssetTypeCreditAlphanum4(AlphaNum4::read_xdr(r)?)
                }

                AssetType::AssetTypeCreditAlphanum12 => {
                    Self::AssetTypeCreditAlphanum12(AlphaNum12::read_xdr(r)?)
                }

                AssetType::AssetTypePoolShare => {
                    Self::AssetTypePoolShare(LiquidityPoolParameters::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ChangeTrustAsset {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::AssetTypeNative => ().write_xdr(w)?,

                Self::AssetTypeCreditAlphanum4(v) => v.write_xdr(w)?,

                Self::AssetTypeCreditAlphanum12(v) => v.write_xdr(w)?,

                Self::AssetTypePoolShare(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ChangeTrustOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ChangeTrustOp {
    pub line: ChangeTrustAsset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub limit: i64,
}

impl ReadXdr for ChangeTrustOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                line: ChangeTrustAsset::read_xdr(r)?,

                limit: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ChangeTrustOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.line.write_xdr(w)?;

            self.limit.write_xdr(w)?;

            Ok(())
        })
    }
}

/// AllowTrustOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct AllowTrustOp {
    pub trustor: AccountId,

    pub asset: AssetCode,

    pub authorize: u32,
}

impl ReadXdr for AllowTrustOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                trustor: AccountId::read_xdr(r)?,

                asset: AssetCode::read_xdr(r)?,

                authorize: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AllowTrustOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.trustor.write_xdr(w)?;

            self.asset.write_xdr(w)?;

            self.authorize.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ManageDataOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ManageDataOp {
    pub data_name: String64,

    pub data_value: Option<DataValue>,
}

impl ReadXdr for ManageDataOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                data_name: String64::read_xdr(r)?,

                data_value: Option::<DataValue>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ManageDataOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.data_name.write_xdr(w)?;

            self.data_value.write_xdr(w)?;

            Ok(())
        })
    }
}

/// BumpSequenceOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct BumpSequenceOp {
    pub bump_to: SequenceNumber,
}

impl ReadXdr for BumpSequenceOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                bump_to: SequenceNumber::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for BumpSequenceOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.bump_to.write_xdr(w)?;

            Ok(())
        })
    }
}

/// CreateClaimableBalanceOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct CreateClaimableBalanceOp {
    pub asset: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount: i64,

    pub claimants: VecM<Claimant, 10>,
}

impl ReadXdr for CreateClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                asset: Asset::read_xdr(r)?,

                amount: i64::read_xdr(r)?,

                claimants: VecM::<Claimant, 10>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for CreateClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.asset.write_xdr(w)?;

            self.amount.write_xdr(w)?;

            self.claimants.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ClaimClaimableBalanceOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ClaimClaimableBalanceOp {
    pub balance_id: ClaimableBalanceId,
}

impl ReadXdr for ClaimClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                balance_id: ClaimableBalanceId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.balance_id.write_xdr(w)?;

            Ok(())
        })
    }
}

/// BeginSponsoringFutureReservesOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct BeginSponsoringFutureReservesOp {
    pub sponsored_id: AccountId,
}

impl ReadXdr for BeginSponsoringFutureReservesOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                sponsored_id: AccountId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for BeginSponsoringFutureReservesOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.sponsored_id.write_xdr(w)?;

            Ok(())
        })
    }
}

/// RevokeSponsorshipType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum RevokeSponsorshipType {
    #[cfg_attr(feature = "alloc", default)]
    RevokeSponsorshipLedgerEntry = 0,

    RevokeSponsorshipSigner = 1,
}

impl RevokeSponsorshipType {
    pub const VARIANTS: [RevokeSponsorshipType; 2] = [
        RevokeSponsorshipType::RevokeSponsorshipLedgerEntry,
        RevokeSponsorshipType::RevokeSponsorshipSigner,
    ];
    pub const VARIANTS_STR: [&'static str; 2] =
        ["RevokeSponsorshipLedgerEntry", "RevokeSponsorshipSigner"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::RevokeSponsorshipLedgerEntry => "RevokeSponsorshipLedgerEntry",

            Self::RevokeSponsorshipSigner => "RevokeSponsorshipSigner",
        }
    }

    #[must_use]
    pub const fn variants() -> [RevokeSponsorshipType; 2] {
        Self::VARIANTS
    }
}

impl Name for RevokeSponsorshipType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<RevokeSponsorshipType> for RevokeSponsorshipType {
    fn variants() -> slice::Iter<'static, RevokeSponsorshipType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for RevokeSponsorshipType {}

impl fmt::Display for RevokeSponsorshipType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for RevokeSponsorshipType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => RevokeSponsorshipType::RevokeSponsorshipLedgerEntry,

            1 => RevokeSponsorshipType::RevokeSponsorshipSigner,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<RevokeSponsorshipType> for i32 {
    #[must_use]
    fn from(e: RevokeSponsorshipType) -> Self {
        e as Self
    }
}

impl ReadXdr for RevokeSponsorshipType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for RevokeSponsorshipType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// RevokeSponsorshipOp
// union with discriminant RevokeSponsorshipType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum RevokeSponsorshipOp {
    RevokeSponsorshipLedgerEntry(LedgerKey),

    RevokeSponsorshipSigner(RevokeSponsorshipOpSigner),
}

#[cfg(feature = "alloc")]
impl Default for RevokeSponsorshipOp {
    fn default() -> Self {
        Self::RevokeSponsorshipLedgerEntry(LedgerKey::default())
    }
}

impl RevokeSponsorshipOp {
    pub const VARIANTS: [RevokeSponsorshipType; 2] = [
        RevokeSponsorshipType::RevokeSponsorshipLedgerEntry,
        RevokeSponsorshipType::RevokeSponsorshipSigner,
    ];
    pub const VARIANTS_STR: [&'static str; 2] =
        ["RevokeSponsorshipLedgerEntry", "RevokeSponsorshipSigner"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::RevokeSponsorshipLedgerEntry(_) => "RevokeSponsorshipLedgerEntry",

            Self::RevokeSponsorshipSigner(_) => "RevokeSponsorshipSigner",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> RevokeSponsorshipType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::RevokeSponsorshipLedgerEntry(_) => {
                RevokeSponsorshipType::RevokeSponsorshipLedgerEntry
            }

            Self::RevokeSponsorshipSigner(_) => RevokeSponsorshipType::RevokeSponsorshipSigner,
        }
    }

    #[must_use]
    pub const fn variants() -> [RevokeSponsorshipType; 2] {
        Self::VARIANTS
    }
}

impl Name for RevokeSponsorshipOp {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<RevokeSponsorshipType> for RevokeSponsorshipOp {
    #[must_use]
    fn discriminant(&self) -> RevokeSponsorshipType {
        Self::discriminant(self)
    }
}

impl Variants<RevokeSponsorshipType> for RevokeSponsorshipOp {
    fn variants() -> slice::Iter<'static, RevokeSponsorshipType> {
        Self::VARIANTS.iter()
    }
}

impl Union<RevokeSponsorshipType> for RevokeSponsorshipOp {}

impl ReadXdr for RevokeSponsorshipOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: RevokeSponsorshipType = <RevokeSponsorshipType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                RevokeSponsorshipType::RevokeSponsorshipLedgerEntry => {
                    Self::RevokeSponsorshipLedgerEntry(LedgerKey::read_xdr(r)?)
                }

                RevokeSponsorshipType::RevokeSponsorshipSigner => {
                    Self::RevokeSponsorshipSigner(RevokeSponsorshipOpSigner::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for RevokeSponsorshipOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::RevokeSponsorshipLedgerEntry(v) => v.write_xdr(w)?,

                Self::RevokeSponsorshipSigner(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClawbackOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ClawbackOp {
    pub asset: Asset,

    pub from: MuxedAccount,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount: i64,
}

impl ReadXdr for ClawbackOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                asset: Asset::read_xdr(r)?,

                from: MuxedAccount::read_xdr(r)?,

                amount: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClawbackOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.asset.write_xdr(w)?;

            self.from.write_xdr(w)?;

            self.amount.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ClawbackClaimableBalanceOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ClawbackClaimableBalanceOp {
    pub balance_id: ClaimableBalanceId,
}

impl ReadXdr for ClawbackClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                balance_id: ClaimableBalanceId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClawbackClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.balance_id.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SetTrustLineFlagsOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SetTrustLineFlagsOp {
    pub trustor: AccountId,

    pub asset: Asset,

    pub clear_flags: u32,

    pub set_flags: u32,
}

impl ReadXdr for SetTrustLineFlagsOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                trustor: AccountId::read_xdr(r)?,

                asset: Asset::read_xdr(r)?,

                clear_flags: u32::read_xdr(r)?,

                set_flags: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SetTrustLineFlagsOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.trustor.write_xdr(w)?;

            self.asset.write_xdr(w)?;

            self.clear_flags.write_xdr(w)?;

            self.set_flags.write_xdr(w)?;

            Ok(())
        })
    }
}

pub const LIQUIDITY_POOL_FEE_V18: u64 = 30;

/// LiquidityPoolDepositOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LiquidityPoolDepositOp {
    pub liquidity_pool_id: PoolId,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub max_amount_a: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub max_amount_b: i64,

    pub min_price: Price,

    pub max_price: Price,
}

impl ReadXdr for LiquidityPoolDepositOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_id: PoolId::read_xdr(r)?,

                max_amount_a: i64::read_xdr(r)?,

                max_amount_b: i64::read_xdr(r)?,

                min_price: Price::read_xdr(r)?,

                max_price: Price::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LiquidityPoolDepositOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_id.write_xdr(w)?;

            self.max_amount_a.write_xdr(w)?;

            self.max_amount_b.write_xdr(w)?;

            self.min_price.write_xdr(w)?;

            self.max_price.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LiquidityPoolWithdrawOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LiquidityPoolWithdrawOp {
    pub liquidity_pool_id: PoolId,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub min_amount_a: i64,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub min_amount_b: i64,
}

impl ReadXdr for LiquidityPoolWithdrawOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_id: PoolId::read_xdr(r)?,

                amount: i64::read_xdr(r)?,

                min_amount_a: i64::read_xdr(r)?,

                min_amount_b: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LiquidityPoolWithdrawOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_id.write_xdr(w)?;

            self.amount.write_xdr(w)?;

            self.min_amount_a.write_xdr(w)?;

            self.min_amount_b.write_xdr(w)?;

            Ok(())
        })
    }
}

/// HostFunctionType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum HostFunctionType {
    #[cfg_attr(feature = "alloc", default)]
    HostFunctionTypeInvokeContract = 0,

    HostFunctionTypeCreateContract = 1,

    HostFunctionTypeUploadContractWasm = 2,

    HostFunctionTypeCreateContractV2 = 3,
}

impl HostFunctionType {
    pub const VARIANTS: [HostFunctionType; 4] = [
        HostFunctionType::HostFunctionTypeInvokeContract,
        HostFunctionType::HostFunctionTypeCreateContract,
        HostFunctionType::HostFunctionTypeUploadContractWasm,
        HostFunctionType::HostFunctionTypeCreateContractV2,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "HostFunctionTypeInvokeContract",
        "HostFunctionTypeCreateContract",
        "HostFunctionTypeUploadContractWasm",
        "HostFunctionTypeCreateContractV2",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::HostFunctionTypeInvokeContract => "HostFunctionTypeInvokeContract",

            Self::HostFunctionTypeCreateContract => "HostFunctionTypeCreateContract",

            Self::HostFunctionTypeUploadContractWasm => "HostFunctionTypeUploadContractWasm",

            Self::HostFunctionTypeCreateContractV2 => "HostFunctionTypeCreateContractV2",
        }
    }

    #[must_use]
    pub const fn variants() -> [HostFunctionType; 4] {
        Self::VARIANTS
    }
}

impl Name for HostFunctionType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<HostFunctionType> for HostFunctionType {
    fn variants() -> slice::Iter<'static, HostFunctionType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for HostFunctionType {}

impl fmt::Display for HostFunctionType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for HostFunctionType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => HostFunctionType::HostFunctionTypeInvokeContract,

            1 => HostFunctionType::HostFunctionTypeCreateContract,

            2 => HostFunctionType::HostFunctionTypeUploadContractWasm,

            3 => HostFunctionType::HostFunctionTypeCreateContractV2,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<HostFunctionType> for i32 {
    #[must_use]
    fn from(e: HostFunctionType) -> Self {
        e as Self
    }
}

impl ReadXdr for HostFunctionType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for HostFunctionType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractIdPreimageType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ContractIdPreimageType {
    #[cfg_attr(feature = "alloc", default)]
    ContractIdPreimageFromAddress = 0,

    ContractIdPreimageFromAsset = 1,
}

impl ContractIdPreimageType {
    pub const VARIANTS: [ContractIdPreimageType; 2] = [
        ContractIdPreimageType::ContractIdPreimageFromAddress,
        ContractIdPreimageType::ContractIdPreimageFromAsset,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = [
        "ContractIdPreimageFromAddress",
        "ContractIdPreimageFromAsset",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ContractIdPreimageFromAddress => "ContractIdPreimageFromAddress",

            Self::ContractIdPreimageFromAsset => "ContractIdPreimageFromAsset",
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractIdPreimageType; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractIdPreimageType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ContractIdPreimageType> for ContractIdPreimageType {
    fn variants() -> slice::Iter<'static, ContractIdPreimageType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ContractIdPreimageType {}

impl fmt::Display for ContractIdPreimageType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ContractIdPreimageType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ContractIdPreimageType::ContractIdPreimageFromAddress,

            1 => ContractIdPreimageType::ContractIdPreimageFromAsset,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ContractIdPreimageType> for i32 {
    #[must_use]
    fn from(e: ContractIdPreimageType) -> Self {
        e as Self
    }
}

impl ReadXdr for ContractIdPreimageType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ContractIdPreimageType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractIdPreimage
// union with discriminant ContractIdPreimageType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ContractIdPreimage {
    ContractIdPreimageFromAddress(ContractIdPreimageFromAddress),

    ContractIdPreimageFromAsset(Asset),
}

#[cfg(feature = "alloc")]
impl Default for ContractIdPreimage {
    fn default() -> Self {
        Self::ContractIdPreimageFromAddress(ContractIdPreimageFromAddress::default())
    }
}

impl ContractIdPreimage {
    pub const VARIANTS: [ContractIdPreimageType; 2] = [
        ContractIdPreimageType::ContractIdPreimageFromAddress,
        ContractIdPreimageType::ContractIdPreimageFromAsset,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = [
        "ContractIdPreimageFromAddress",
        "ContractIdPreimageFromAsset",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ContractIdPreimageFromAddress(_) => "ContractIdPreimageFromAddress",

            Self::ContractIdPreimageFromAsset(_) => "ContractIdPreimageFromAsset",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ContractIdPreimageType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ContractIdPreimageFromAddress(_) => {
                ContractIdPreimageType::ContractIdPreimageFromAddress
            }

            Self::ContractIdPreimageFromAsset(_) => {
                ContractIdPreimageType::ContractIdPreimageFromAsset
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractIdPreimageType; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractIdPreimage {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ContractIdPreimageType> for ContractIdPreimage {
    #[must_use]
    fn discriminant(&self) -> ContractIdPreimageType {
        Self::discriminant(self)
    }
}

impl Variants<ContractIdPreimageType> for ContractIdPreimage {
    fn variants() -> slice::Iter<'static, ContractIdPreimageType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ContractIdPreimageType> for ContractIdPreimage {}

impl ReadXdr for ContractIdPreimage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ContractIdPreimageType = <ContractIdPreimageType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ContractIdPreimageType::ContractIdPreimageFromAddress => {
                    Self::ContractIdPreimageFromAddress(ContractIdPreimageFromAddress::read_xdr(r)?)
                }

                ContractIdPreimageType::ContractIdPreimageFromAsset => {
                    Self::ContractIdPreimageFromAsset(Asset::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ContractIdPreimage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ContractIdPreimageFromAddress(v) => v.write_xdr(w)?,

                Self::ContractIdPreimageFromAsset(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// CreateContractArgs
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct CreateContractArgs {
    pub contract_id_preimage: ContractIdPreimage,

    pub executable: ContractExecutable,
}

impl ReadXdr for CreateContractArgs {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                contract_id_preimage: ContractIdPreimage::read_xdr(r)?,

                executable: ContractExecutable::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for CreateContractArgs {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.contract_id_preimage.write_xdr(w)?;

            self.executable.write_xdr(w)?;

            Ok(())
        })
    }
}

/// CreateContractArgsV2
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct CreateContractArgsV2 {
    pub contract_id_preimage: ContractIdPreimage,

    pub executable: ContractExecutable,

    pub constructor_args: VecM<ScVal>,
}

impl ReadXdr for CreateContractArgsV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                contract_id_preimage: ContractIdPreimage::read_xdr(r)?,

                executable: ContractExecutable::read_xdr(r)?,

                constructor_args: VecM::<ScVal>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for CreateContractArgsV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.contract_id_preimage.write_xdr(w)?;

            self.executable.write_xdr(w)?;

            self.constructor_args.write_xdr(w)?;

            Ok(())
        })
    }
}

/// InvokeContractArgs
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct InvokeContractArgs {
    pub contract_address: ScAddress,

    pub function_name: ScSymbol,

    pub args: VecM<ScVal>,
}

impl ReadXdr for InvokeContractArgs {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                contract_address: ScAddress::read_xdr(r)?,

                function_name: ScSymbol::read_xdr(r)?,

                args: VecM::<ScVal>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InvokeContractArgs {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.contract_address.write_xdr(w)?;

            self.function_name.write_xdr(w)?;

            self.args.write_xdr(w)?;

            Ok(())
        })
    }
}

/// HostFunction
// union with discriminant HostFunctionType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum HostFunction {
    HostFunctionTypeInvokeContract(InvokeContractArgs),

    HostFunctionTypeCreateContract(CreateContractArgs),

    HostFunctionTypeUploadContractWasm(BytesM),

    HostFunctionTypeCreateContractV2(CreateContractArgsV2),
}

#[cfg(feature = "alloc")]
impl Default for HostFunction {
    fn default() -> Self {
        Self::HostFunctionTypeInvokeContract(InvokeContractArgs::default())
    }
}

impl HostFunction {
    pub const VARIANTS: [HostFunctionType; 4] = [
        HostFunctionType::HostFunctionTypeInvokeContract,
        HostFunctionType::HostFunctionTypeCreateContract,
        HostFunctionType::HostFunctionTypeUploadContractWasm,
        HostFunctionType::HostFunctionTypeCreateContractV2,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "HostFunctionTypeInvokeContract",
        "HostFunctionTypeCreateContract",
        "HostFunctionTypeUploadContractWasm",
        "HostFunctionTypeCreateContractV2",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::HostFunctionTypeInvokeContract(_) => "HostFunctionTypeInvokeContract",

            Self::HostFunctionTypeCreateContract(_) => "HostFunctionTypeCreateContract",

            Self::HostFunctionTypeUploadContractWasm(_) => "HostFunctionTypeUploadContractWasm",

            Self::HostFunctionTypeCreateContractV2(_) => "HostFunctionTypeCreateContractV2",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> HostFunctionType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::HostFunctionTypeInvokeContract(_) => {
                HostFunctionType::HostFunctionTypeInvokeContract
            }

            Self::HostFunctionTypeCreateContract(_) => {
                HostFunctionType::HostFunctionTypeCreateContract
            }

            Self::HostFunctionTypeUploadContractWasm(_) => {
                HostFunctionType::HostFunctionTypeUploadContractWasm
            }

            Self::HostFunctionTypeCreateContractV2(_) => {
                HostFunctionType::HostFunctionTypeCreateContractV2
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [HostFunctionType; 4] {
        Self::VARIANTS
    }
}

impl Name for HostFunction {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<HostFunctionType> for HostFunction {
    #[must_use]
    fn discriminant(&self) -> HostFunctionType {
        Self::discriminant(self)
    }
}

impl Variants<HostFunctionType> for HostFunction {
    fn variants() -> slice::Iter<'static, HostFunctionType> {
        Self::VARIANTS.iter()
    }
}

impl Union<HostFunctionType> for HostFunction {}

impl ReadXdr for HostFunction {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: HostFunctionType = <HostFunctionType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                HostFunctionType::HostFunctionTypeInvokeContract => {
                    Self::HostFunctionTypeInvokeContract(InvokeContractArgs::read_xdr(r)?)
                }

                HostFunctionType::HostFunctionTypeCreateContract => {
                    Self::HostFunctionTypeCreateContract(CreateContractArgs::read_xdr(r)?)
                }

                HostFunctionType::HostFunctionTypeUploadContractWasm => {
                    Self::HostFunctionTypeUploadContractWasm(BytesM::read_xdr(r)?)
                }

                HostFunctionType::HostFunctionTypeCreateContractV2 => {
                    Self::HostFunctionTypeCreateContractV2(CreateContractArgsV2::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for HostFunction {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::HostFunctionTypeInvokeContract(v) => v.write_xdr(w)?,

                Self::HostFunctionTypeCreateContract(v) => v.write_xdr(w)?,

                Self::HostFunctionTypeUploadContractWasm(v) => v.write_xdr(w)?,

                Self::HostFunctionTypeCreateContractV2(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SorobanAuthorizedFunctionType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum SorobanAuthorizedFunctionType {
    #[cfg_attr(feature = "alloc", default)]
    SorobanAuthorizedFunctionTypeContractFn = 0,

    SorobanAuthorizedFunctionTypeCreateContractHostFn = 1,

    SorobanAuthorizedFunctionTypeCreateContractV2HostFn = 2,
}

impl SorobanAuthorizedFunctionType {
    pub const VARIANTS: [SorobanAuthorizedFunctionType; 3] = [
        SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeContractFn,
        SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractHostFn,
        SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractV2HostFn,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "SorobanAuthorizedFunctionTypeContractFn",
        "SorobanAuthorizedFunctionTypeCreateContractHostFn",
        "SorobanAuthorizedFunctionTypeCreateContractV2HostFn",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SorobanAuthorizedFunctionTypeContractFn => {
                "SorobanAuthorizedFunctionTypeContractFn"
            }

            Self::SorobanAuthorizedFunctionTypeCreateContractHostFn => {
                "SorobanAuthorizedFunctionTypeCreateContractHostFn"
            }

            Self::SorobanAuthorizedFunctionTypeCreateContractV2HostFn => {
                "SorobanAuthorizedFunctionTypeCreateContractV2HostFn"
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [SorobanAuthorizedFunctionType; 3] {
        Self::VARIANTS
    }
}

impl Name for SorobanAuthorizedFunctionType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SorobanAuthorizedFunctionType> for SorobanAuthorizedFunctionType {
    fn variants() -> slice::Iter<'static, SorobanAuthorizedFunctionType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SorobanAuthorizedFunctionType {}

impl fmt::Display for SorobanAuthorizedFunctionType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SorobanAuthorizedFunctionType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeContractFn,

            1 => SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractHostFn,

            2 => SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractV2HostFn,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SorobanAuthorizedFunctionType> for i32 {
    #[must_use]
    fn from(e: SorobanAuthorizedFunctionType) -> Self {
        e as Self
    }
}

impl ReadXdr for SorobanAuthorizedFunctionType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanAuthorizedFunctionType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SorobanAuthorizedFunction
// union with discriminant SorobanAuthorizedFunctionType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum SorobanAuthorizedFunction {
    SorobanAuthorizedFunctionTypeContractFn(InvokeContractArgs),

    SorobanAuthorizedFunctionTypeCreateContractHostFn(CreateContractArgs),

    SorobanAuthorizedFunctionTypeCreateContractV2HostFn(CreateContractArgsV2),
}

#[cfg(feature = "alloc")]
impl Default for SorobanAuthorizedFunction {
    fn default() -> Self {
        Self::SorobanAuthorizedFunctionTypeContractFn(InvokeContractArgs::default())
    }
}

impl SorobanAuthorizedFunction {
    pub const VARIANTS: [SorobanAuthorizedFunctionType; 3] = [
        SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeContractFn,
        SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractHostFn,
        SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractV2HostFn,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "SorobanAuthorizedFunctionTypeContractFn",
        "SorobanAuthorizedFunctionTypeCreateContractHostFn",
        "SorobanAuthorizedFunctionTypeCreateContractV2HostFn",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SorobanAuthorizedFunctionTypeContractFn(_) => {
                "SorobanAuthorizedFunctionTypeContractFn"
            }

            Self::SorobanAuthorizedFunctionTypeCreateContractHostFn(_) => {
                "SorobanAuthorizedFunctionTypeCreateContractHostFn"
            }

            Self::SorobanAuthorizedFunctionTypeCreateContractV2HostFn(_) => {
                "SorobanAuthorizedFunctionTypeCreateContractV2HostFn"
            }
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SorobanAuthorizedFunctionType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::SorobanAuthorizedFunctionTypeContractFn(_) => {
                SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeContractFn
            }

            Self::SorobanAuthorizedFunctionTypeCreateContractHostFn(_) => {
                SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractHostFn
            }

            Self::SorobanAuthorizedFunctionTypeCreateContractV2HostFn(_) => {
                SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractV2HostFn
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [SorobanAuthorizedFunctionType; 3] {
        Self::VARIANTS
    }
}

impl Name for SorobanAuthorizedFunction {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SorobanAuthorizedFunctionType> for SorobanAuthorizedFunction {
    #[must_use]
    fn discriminant(&self) -> SorobanAuthorizedFunctionType {
        Self::discriminant(self)
    }
}

impl Variants<SorobanAuthorizedFunctionType> for SorobanAuthorizedFunction {
    fn variants() -> slice::Iter<'static, SorobanAuthorizedFunctionType> {
        Self::VARIANTS.iter()
    }
}

impl Union<SorobanAuthorizedFunctionType> for SorobanAuthorizedFunction {}

impl ReadXdr for SorobanAuthorizedFunction {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: SorobanAuthorizedFunctionType = <SorobanAuthorizedFunctionType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {


                SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeContractFn => Self::SorobanAuthorizedFunctionTypeContractFn(InvokeContractArgs::read_xdr(r)?),



                SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractHostFn => Self::SorobanAuthorizedFunctionTypeCreateContractHostFn(CreateContractArgs::read_xdr(r)?),



                SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractV2HostFn => Self::SorobanAuthorizedFunctionTypeCreateContractV2HostFn(CreateContractArgsV2::read_xdr(r)?),


                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanAuthorizedFunction {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::SorobanAuthorizedFunctionTypeContractFn(v) => v.write_xdr(w)?,

                Self::SorobanAuthorizedFunctionTypeCreateContractHostFn(v) => v.write_xdr(w)?,

                Self::SorobanAuthorizedFunctionTypeCreateContractV2HostFn(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SorobanAuthorizedInvocation
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SorobanAuthorizedInvocation {
    pub function: SorobanAuthorizedFunction,

    pub sub_invocations: VecM<SorobanAuthorizedInvocation>,
}

impl ReadXdr for SorobanAuthorizedInvocation {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                function: SorobanAuthorizedFunction::read_xdr(r)?,

                sub_invocations: VecM::<SorobanAuthorizedInvocation>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanAuthorizedInvocation {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.function.write_xdr(w)?;

            self.sub_invocations.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SorobanAddressCredentials
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SorobanAddressCredentials {
    pub address: ScAddress,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub nonce: i64,

    pub signature_expiration_ledger: u32,

    pub signature: ScVal,
}

impl ReadXdr for SorobanAddressCredentials {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                address: ScAddress::read_xdr(r)?,

                nonce: i64::read_xdr(r)?,

                signature_expiration_ledger: u32::read_xdr(r)?,

                signature: ScVal::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanAddressCredentials {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.address.write_xdr(w)?;

            self.nonce.write_xdr(w)?;

            self.signature_expiration_ledger.write_xdr(w)?;

            self.signature.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SorobanCredentialsType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum SorobanCredentialsType {
    #[cfg_attr(feature = "alloc", default)]
    SorobanCredentialsSourceAccount = 0,

    SorobanCredentialsAddress = 1,
}

impl SorobanCredentialsType {
    pub const VARIANTS: [SorobanCredentialsType; 2] = [
        SorobanCredentialsType::SorobanCredentialsSourceAccount,
        SorobanCredentialsType::SorobanCredentialsAddress,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = [
        "SorobanCredentialsSourceAccount",
        "SorobanCredentialsAddress",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SorobanCredentialsSourceAccount => "SorobanCredentialsSourceAccount",

            Self::SorobanCredentialsAddress => "SorobanCredentialsAddress",
        }
    }

    #[must_use]
    pub const fn variants() -> [SorobanCredentialsType; 2] {
        Self::VARIANTS
    }
}

impl Name for SorobanCredentialsType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SorobanCredentialsType> for SorobanCredentialsType {
    fn variants() -> slice::Iter<'static, SorobanCredentialsType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SorobanCredentialsType {}

impl fmt::Display for SorobanCredentialsType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SorobanCredentialsType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => SorobanCredentialsType::SorobanCredentialsSourceAccount,

            1 => SorobanCredentialsType::SorobanCredentialsAddress,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SorobanCredentialsType> for i32 {
    #[must_use]
    fn from(e: SorobanCredentialsType) -> Self {
        e as Self
    }
}

impl ReadXdr for SorobanCredentialsType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanCredentialsType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SorobanCredentials
// union with discriminant SorobanCredentialsType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum SorobanCredentials {
    SorobanCredentialsSourceAccount,

    SorobanCredentialsAddress(SorobanAddressCredentials),
}

#[cfg(feature = "alloc")]
impl Default for SorobanCredentials {
    fn default() -> Self {
        Self::SorobanCredentialsSourceAccount
    }
}

impl SorobanCredentials {
    pub const VARIANTS: [SorobanCredentialsType; 2] = [
        SorobanCredentialsType::SorobanCredentialsSourceAccount,
        SorobanCredentialsType::SorobanCredentialsAddress,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = [
        "SorobanCredentialsSourceAccount",
        "SorobanCredentialsAddress",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SorobanCredentialsSourceAccount => "SorobanCredentialsSourceAccount",

            Self::SorobanCredentialsAddress(_) => "SorobanCredentialsAddress",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SorobanCredentialsType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::SorobanCredentialsSourceAccount => {
                SorobanCredentialsType::SorobanCredentialsSourceAccount
            }

            Self::SorobanCredentialsAddress(_) => SorobanCredentialsType::SorobanCredentialsAddress,
        }
    }

    #[must_use]
    pub const fn variants() -> [SorobanCredentialsType; 2] {
        Self::VARIANTS
    }
}

impl Name for SorobanCredentials {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SorobanCredentialsType> for SorobanCredentials {
    #[must_use]
    fn discriminant(&self) -> SorobanCredentialsType {
        Self::discriminant(self)
    }
}

impl Variants<SorobanCredentialsType> for SorobanCredentials {
    fn variants() -> slice::Iter<'static, SorobanCredentialsType> {
        Self::VARIANTS.iter()
    }
}

impl Union<SorobanCredentialsType> for SorobanCredentials {}

impl ReadXdr for SorobanCredentials {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: SorobanCredentialsType = <SorobanCredentialsType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                SorobanCredentialsType::SorobanCredentialsSourceAccount => {
                    Self::SorobanCredentialsSourceAccount
                }

                SorobanCredentialsType::SorobanCredentialsAddress => {
                    Self::SorobanCredentialsAddress(SorobanAddressCredentials::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanCredentials {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::SorobanCredentialsSourceAccount => ().write_xdr(w)?,

                Self::SorobanCredentialsAddress(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SorobanAuthorizationEntry
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SorobanAuthorizationEntry {
    pub credentials: SorobanCredentials,

    pub root_invocation: SorobanAuthorizedInvocation,
}

impl ReadXdr for SorobanAuthorizationEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                credentials: SorobanCredentials::read_xdr(r)?,

                root_invocation: SorobanAuthorizedInvocation::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanAuthorizationEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.credentials.write_xdr(w)?;

            self.root_invocation.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SorobanAuthorizationEntries
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SorobanAuthorizationEntries(pub VecM<SorobanAuthorizationEntry>);

impl From<SorobanAuthorizationEntries> for VecM<SorobanAuthorizationEntry> {
    #[must_use]
    fn from(x: SorobanAuthorizationEntries) -> Self {
        x.0
    }
}

impl From<VecM<SorobanAuthorizationEntry>> for SorobanAuthorizationEntries {
    #[must_use]
    fn from(x: VecM<SorobanAuthorizationEntry>) -> Self {
        SorobanAuthorizationEntries(x)
    }
}

impl AsRef<VecM<SorobanAuthorizationEntry>> for SorobanAuthorizationEntries {
    #[must_use]
    fn as_ref(&self) -> &VecM<SorobanAuthorizationEntry> {
        &self.0
    }
}

impl ReadXdr for SorobanAuthorizationEntries {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = VecM::<SorobanAuthorizationEntry>::read_xdr(r)?;
            let v = SorobanAuthorizationEntries(i);
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanAuthorizationEntries {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for SorobanAuthorizationEntries {
    type Target = VecM<SorobanAuthorizationEntry>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<SorobanAuthorizationEntries> for Vec<SorobanAuthorizationEntry> {
    #[must_use]
    fn from(x: SorobanAuthorizationEntries) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<SorobanAuthorizationEntry>> for SorobanAuthorizationEntries {
    type Error = Error;
    fn try_from(x: Vec<SorobanAuthorizationEntry>) -> Result<Self, Error> {
        Ok(SorobanAuthorizationEntries(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<SorobanAuthorizationEntry>> for SorobanAuthorizationEntries {
    type Error = Error;
    fn try_from(x: &Vec<SorobanAuthorizationEntry>) -> Result<Self, Error> {
        Ok(SorobanAuthorizationEntries(x.try_into()?))
    }
}

impl AsRef<Vec<SorobanAuthorizationEntry>> for SorobanAuthorizationEntries {
    #[must_use]
    fn as_ref(&self) -> &Vec<SorobanAuthorizationEntry> {
        &self.0 .0
    }
}

impl AsRef<[SorobanAuthorizationEntry]> for SorobanAuthorizationEntries {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[SorobanAuthorizationEntry] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[SorobanAuthorizationEntry] {
        self.0 .0
    }
}

/// InvokeHostFunctionOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct InvokeHostFunctionOp {
    pub host_function: HostFunction,

    pub auth: VecM<SorobanAuthorizationEntry>,
}

impl ReadXdr for InvokeHostFunctionOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                host_function: HostFunction::read_xdr(r)?,

                auth: VecM::<SorobanAuthorizationEntry>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InvokeHostFunctionOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.host_function.write_xdr(w)?;

            self.auth.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ExtendFootprintTtlOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ExtendFootprintTtlOp {
    pub ext: ExtensionPoint,

    pub extend_to: u32,
}

impl ReadXdr for ExtendFootprintTtlOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,

                extend_to: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ExtendFootprintTtlOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.extend_to.write_xdr(w)?;

            Ok(())
        })
    }
}

/// RestoreFootprintOp
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct RestoreFootprintOp {
    pub ext: ExtensionPoint,
}

impl ReadXdr for RestoreFootprintOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for RestoreFootprintOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// Operation
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Operation {
    pub source_account: Option<MuxedAccount>,

    pub body: OperationBody,
}

impl ReadXdr for Operation {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                source_account: Option::<MuxedAccount>::read_xdr(r)?,

                body: OperationBody::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Operation {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.source_account.write_xdr(w)?;

            self.body.write_xdr(w)?;

            Ok(())
        })
    }
}

/// HashIdPreimage
// union with discriminant EnvelopeType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum HashIdPreimage {
    EnvelopeTypeOpId(HashIdPreimageOperationId),

    EnvelopeTypePoolRevokeOpId(HashIdPreimageRevokeId),

    EnvelopeTypeContractId(HashIdPreimageContractId),

    EnvelopeTypeSorobanAuthorization(HashIdPreimageSorobanAuthorization),
}

#[cfg(feature = "alloc")]
impl Default for HashIdPreimage {
    fn default() -> Self {
        Self::EnvelopeTypeOpId(HashIdPreimageOperationId::default())
    }
}

impl HashIdPreimage {
    pub const VARIANTS: [EnvelopeType; 4] = [
        EnvelopeType::EnvelopeTypeOpId,
        EnvelopeType::EnvelopeTypePoolRevokeOpId,
        EnvelopeType::EnvelopeTypeContractId,
        EnvelopeType::EnvelopeTypeSorobanAuthorization,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "EnvelopeTypeOpId",
        "EnvelopeTypePoolRevokeOpId",
        "EnvelopeTypeContractId",
        "EnvelopeTypeSorobanAuthorization",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::EnvelopeTypeOpId(_) => "EnvelopeTypeOpId",

            Self::EnvelopeTypePoolRevokeOpId(_) => "EnvelopeTypePoolRevokeOpId",

            Self::EnvelopeTypeContractId(_) => "EnvelopeTypeContractId",

            Self::EnvelopeTypeSorobanAuthorization(_) => "EnvelopeTypeSorobanAuthorization",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> EnvelopeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::EnvelopeTypeOpId(_) => EnvelopeType::EnvelopeTypeOpId,

            Self::EnvelopeTypePoolRevokeOpId(_) => EnvelopeType::EnvelopeTypePoolRevokeOpId,

            Self::EnvelopeTypeContractId(_) => EnvelopeType::EnvelopeTypeContractId,

            Self::EnvelopeTypeSorobanAuthorization(_) => {
                EnvelopeType::EnvelopeTypeSorobanAuthorization
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [EnvelopeType; 4] {
        Self::VARIANTS
    }
}

impl Name for HashIdPreimage {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<EnvelopeType> for HashIdPreimage {
    #[must_use]
    fn discriminant(&self) -> EnvelopeType {
        Self::discriminant(self)
    }
}

impl Variants<EnvelopeType> for HashIdPreimage {
    fn variants() -> slice::Iter<'static, EnvelopeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<EnvelopeType> for HashIdPreimage {}

impl ReadXdr for HashIdPreimage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: EnvelopeType = <EnvelopeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                EnvelopeType::EnvelopeTypeOpId => {
                    Self::EnvelopeTypeOpId(HashIdPreimageOperationId::read_xdr(r)?)
                }

                EnvelopeType::EnvelopeTypePoolRevokeOpId => {
                    Self::EnvelopeTypePoolRevokeOpId(HashIdPreimageRevokeId::read_xdr(r)?)
                }

                EnvelopeType::EnvelopeTypeContractId => {
                    Self::EnvelopeTypeContractId(HashIdPreimageContractId::read_xdr(r)?)
                }

                EnvelopeType::EnvelopeTypeSorobanAuthorization => {
                    Self::EnvelopeTypeSorobanAuthorization(
                        HashIdPreimageSorobanAuthorization::read_xdr(r)?,
                    )
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for HashIdPreimage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::EnvelopeTypeOpId(v) => v.write_xdr(w)?,

                Self::EnvelopeTypePoolRevokeOpId(v) => v.write_xdr(w)?,

                Self::EnvelopeTypeContractId(v) => v.write_xdr(w)?,

                Self::EnvelopeTypeSorobanAuthorization(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// MemoType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum MemoType {
    #[cfg_attr(feature = "alloc", default)]
    MemoNone = 0,

    MemoText = 1,

    MemoId = 2,

    MemoHash = 3,

    MemoReturn = 4,
}

impl MemoType {
    pub const VARIANTS: [MemoType; 5] = [
        MemoType::MemoNone,
        MemoType::MemoText,
        MemoType::MemoId,
        MemoType::MemoHash,
        MemoType::MemoReturn,
    ];
    pub const VARIANTS_STR: [&'static str; 5] =
        ["MemoNone", "MemoText", "MemoId", "MemoHash", "MemoReturn"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::MemoNone => "MemoNone",

            Self::MemoText => "MemoText",

            Self::MemoId => "MemoId",

            Self::MemoHash => "MemoHash",

            Self::MemoReturn => "MemoReturn",
        }
    }

    #[must_use]
    pub const fn variants() -> [MemoType; 5] {
        Self::VARIANTS
    }
}

impl Name for MemoType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<MemoType> for MemoType {
    fn variants() -> slice::Iter<'static, MemoType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for MemoType {}

impl fmt::Display for MemoType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for MemoType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => MemoType::MemoNone,

            1 => MemoType::MemoText,

            2 => MemoType::MemoId,

            3 => MemoType::MemoHash,

            4 => MemoType::MemoReturn,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<MemoType> for i32 {
    #[must_use]
    fn from(e: MemoType) -> Self {
        e as Self
    }
}

impl ReadXdr for MemoType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for MemoType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// Memo
// union with discriminant MemoType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum Memo {
    MemoNone,

    MemoText(StringM<28>),

    MemoId(u64),

    MemoHash(Hash),

    MemoReturn(Hash),
}

#[cfg(feature = "alloc")]
impl Default for Memo {
    fn default() -> Self {
        Self::MemoNone
    }
}

impl Memo {
    pub const VARIANTS: [MemoType; 5] = [
        MemoType::MemoNone,
        MemoType::MemoText,
        MemoType::MemoId,
        MemoType::MemoHash,
        MemoType::MemoReturn,
    ];
    pub const VARIANTS_STR: [&'static str; 5] =
        ["MemoNone", "MemoText", "MemoId", "MemoHash", "MemoReturn"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::MemoNone => "MemoNone",

            Self::MemoText(_) => "MemoText",

            Self::MemoId(_) => "MemoId",

            Self::MemoHash(_) => "MemoHash",

            Self::MemoReturn(_) => "MemoReturn",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> MemoType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::MemoNone => MemoType::MemoNone,

            Self::MemoText(_) => MemoType::MemoText,

            Self::MemoId(_) => MemoType::MemoId,

            Self::MemoHash(_) => MemoType::MemoHash,

            Self::MemoReturn(_) => MemoType::MemoReturn,
        }
    }

    #[must_use]
    pub const fn variants() -> [MemoType; 5] {
        Self::VARIANTS
    }
}

impl Name for Memo {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<MemoType> for Memo {
    #[must_use]
    fn discriminant(&self) -> MemoType {
        Self::discriminant(self)
    }
}

impl Variants<MemoType> for Memo {
    fn variants() -> slice::Iter<'static, MemoType> {
        Self::VARIANTS.iter()
    }
}

impl Union<MemoType> for Memo {}

impl ReadXdr for Memo {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: MemoType = <MemoType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                MemoType::MemoNone => Self::MemoNone,

                MemoType::MemoText => Self::MemoText(StringM::<28>::read_xdr(r)?),

                MemoType::MemoId => Self::MemoId(u64::read_xdr(r)?),

                MemoType::MemoHash => Self::MemoHash(Hash::read_xdr(r)?),

                MemoType::MemoReturn => Self::MemoReturn(Hash::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for Memo {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::MemoNone => ().write_xdr(w)?,

                Self::MemoText(v) => v.write_xdr(w)?,

                Self::MemoId(v) => v.write_xdr(w)?,

                Self::MemoHash(v) => v.write_xdr(w)?,

                Self::MemoReturn(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TimeBounds
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TimeBounds {
    pub min_time: TimePoint,

    pub max_time: TimePoint,
}

impl ReadXdr for TimeBounds {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                min_time: TimePoint::read_xdr(r)?,

                max_time: TimePoint::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TimeBounds {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.min_time.write_xdr(w)?;

            self.max_time.write_xdr(w)?;

            Ok(())
        })
    }
}

/// LedgerBounds
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerBounds {
    pub min_ledger: u32,

    pub max_ledger: u32,
}

impl ReadXdr for LedgerBounds {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                min_ledger: u32::read_xdr(r)?,

                max_ledger: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerBounds {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.min_ledger.write_xdr(w)?;

            self.max_ledger.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PreconditionsV2
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct PreconditionsV2 {
    pub time_bounds: Option<TimeBounds>,

    pub ledger_bounds: Option<LedgerBounds>,

    pub min_seq_num: Option<SequenceNumber>,

    pub min_seq_age: Duration,

    pub min_seq_ledger_gap: u32,

    pub extra_signers: VecM<SignerKey, 2>,
}

impl ReadXdr for PreconditionsV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                time_bounds: Option::<TimeBounds>::read_xdr(r)?,

                ledger_bounds: Option::<LedgerBounds>::read_xdr(r)?,

                min_seq_num: Option::<SequenceNumber>::read_xdr(r)?,

                min_seq_age: Duration::read_xdr(r)?,

                min_seq_ledger_gap: u32::read_xdr(r)?,

                extra_signers: VecM::<SignerKey, 2>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PreconditionsV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.time_bounds.write_xdr(w)?;

            self.ledger_bounds.write_xdr(w)?;

            self.min_seq_num.write_xdr(w)?;

            self.min_seq_age.write_xdr(w)?;

            self.min_seq_ledger_gap.write_xdr(w)?;

            self.extra_signers.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PreconditionType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum PreconditionType {
    #[cfg_attr(feature = "alloc", default)]
    PrecondNone = 0,

    PrecondTime = 1,

    PrecondV2 = 2,
}

impl PreconditionType {
    pub const VARIANTS: [PreconditionType; 3] = [
        PreconditionType::PrecondNone,
        PreconditionType::PrecondTime,
        PreconditionType::PrecondV2,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["PrecondNone", "PrecondTime", "PrecondV2"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PrecondNone => "PrecondNone",

            Self::PrecondTime => "PrecondTime",

            Self::PrecondV2 => "PrecondV2",
        }
    }

    #[must_use]
    pub const fn variants() -> [PreconditionType; 3] {
        Self::VARIANTS
    }
}

impl Name for PreconditionType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<PreconditionType> for PreconditionType {
    fn variants() -> slice::Iter<'static, PreconditionType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for PreconditionType {}

impl fmt::Display for PreconditionType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for PreconditionType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => PreconditionType::PrecondNone,

            1 => PreconditionType::PrecondTime,

            2 => PreconditionType::PrecondV2,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<PreconditionType> for i32 {
    #[must_use]
    fn from(e: PreconditionType) -> Self {
        e as Self
    }
}

impl ReadXdr for PreconditionType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for PreconditionType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// Preconditions
// union with discriminant PreconditionType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum Preconditions {
    PrecondNone,

    PrecondTime(TimeBounds),

    PrecondV2(PreconditionsV2),
}

#[cfg(feature = "alloc")]
impl Default for Preconditions {
    fn default() -> Self {
        Self::PrecondNone
    }
}

impl Preconditions {
    pub const VARIANTS: [PreconditionType; 3] = [
        PreconditionType::PrecondNone,
        PreconditionType::PrecondTime,
        PreconditionType::PrecondV2,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["PrecondNone", "PrecondTime", "PrecondV2"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PrecondNone => "PrecondNone",

            Self::PrecondTime(_) => "PrecondTime",

            Self::PrecondV2(_) => "PrecondV2",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> PreconditionType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::PrecondNone => PreconditionType::PrecondNone,

            Self::PrecondTime(_) => PreconditionType::PrecondTime,

            Self::PrecondV2(_) => PreconditionType::PrecondV2,
        }
    }

    #[must_use]
    pub const fn variants() -> [PreconditionType; 3] {
        Self::VARIANTS
    }
}

impl Name for Preconditions {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<PreconditionType> for Preconditions {
    #[must_use]
    fn discriminant(&self) -> PreconditionType {
        Self::discriminant(self)
    }
}

impl Variants<PreconditionType> for Preconditions {
    fn variants() -> slice::Iter<'static, PreconditionType> {
        Self::VARIANTS.iter()
    }
}

impl Union<PreconditionType> for Preconditions {}

impl ReadXdr for Preconditions {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: PreconditionType = <PreconditionType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                PreconditionType::PrecondNone => Self::PrecondNone,

                PreconditionType::PrecondTime => Self::PrecondTime(TimeBounds::read_xdr(r)?),

                PreconditionType::PrecondV2 => Self::PrecondV2(PreconditionsV2::read_xdr(r)?),

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for Preconditions {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::PrecondNone => ().write_xdr(w)?,

                Self::PrecondTime(v) => v.write_xdr(w)?,

                Self::PrecondV2(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerFootprint
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct LedgerFootprint {
    pub read_only: VecM<LedgerKey>,

    pub read_write: VecM<LedgerKey>,
}

impl ReadXdr for LedgerFootprint {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                read_only: VecM::<LedgerKey>::read_xdr(r)?,

                read_write: VecM::<LedgerKey>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerFootprint {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.read_only.write_xdr(w)?;

            self.read_write.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SorobanResources
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SorobanResources {
    pub footprint: LedgerFootprint,

    pub instructions: u32,

    pub disk_read_bytes: u32,

    pub write_bytes: u32,
}

impl ReadXdr for SorobanResources {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                footprint: LedgerFootprint::read_xdr(r)?,

                instructions: u32::read_xdr(r)?,

                disk_read_bytes: u32::read_xdr(r)?,

                write_bytes: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanResources {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.footprint.write_xdr(w)?;

            self.instructions.write_xdr(w)?;

            self.disk_read_bytes.write_xdr(w)?;

            self.write_bytes.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SorobanResourcesExtV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SorobanResourcesExtV0 {
    pub archived_soroban_entries: VecM<u32>,
}

impl ReadXdr for SorobanResourcesExtV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                archived_soroban_entries: VecM::<u32>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanResourcesExtV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.archived_soroban_entries.write_xdr(w)?;

            Ok(())
        })
    }
}

/// SorobanTransactionData
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SorobanTransactionData {
    pub ext: SorobanTransactionDataExt,

    pub resources: SorobanResources,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub resource_fee: i64,
}

impl ReadXdr for SorobanTransactionData {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: SorobanTransactionDataExt::read_xdr(r)?,

                resources: SorobanResources::read_xdr(r)?,

                resource_fee: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanTransactionData {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;

            self.resources.write_xdr(w)?;

            self.resource_fee.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionV0 {
    pub source_account_ed25519: Uint256,

    pub fee: u32,

    pub seq_num: SequenceNumber,

    pub time_bounds: Option<TimeBounds>,

    pub memo: Memo,

    pub operations: VecM<Operation, MaxOpsPerTx>,

    pub ext: TransactionV0Ext,
}

impl ReadXdr for TransactionV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                source_account_ed25519: Uint256::read_xdr(r)?,

                fee: u32::read_xdr(r)?,

                seq_num: SequenceNumber::read_xdr(r)?,

                time_bounds: Option::<TimeBounds>::read_xdr(r)?,

                memo: Memo::read_xdr(r)?,

                operations: VecM::<Operation, MaxOpsPerTx>::read_xdr(r)?,

                ext: TransactionV0Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.source_account_ed25519.write_xdr(w)?;

            self.fee.write_xdr(w)?;

            self.seq_num.write_xdr(w)?;

            self.time_bounds.write_xdr(w)?;

            self.memo.write_xdr(w)?;

            self.operations.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionV0Envelope
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionV0Envelope {
    pub tx: TransactionV0,

    pub signatures: VecM<DecoratedSignature, 20>,
}

impl ReadXdr for TransactionV0Envelope {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx: TransactionV0::read_xdr(r)?,

                signatures: VecM::<DecoratedSignature, 20>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionV0Envelope {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.tx.write_xdr(w)?;

            self.signatures.write_xdr(w)?;

            Ok(())
        })
    }
}

/// Transaction
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Transaction {
    pub source_account: MuxedAccount,

    pub fee: u32,

    pub seq_num: SequenceNumber,

    pub cond: Preconditions,

    pub memo: Memo,

    pub operations: VecM<Operation, MaxOpsPerTx>,

    pub ext: TransactionExt,
}

impl ReadXdr for Transaction {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                source_account: MuxedAccount::read_xdr(r)?,

                fee: u32::read_xdr(r)?,

                seq_num: SequenceNumber::read_xdr(r)?,

                cond: Preconditions::read_xdr(r)?,

                memo: Memo::read_xdr(r)?,

                operations: VecM::<Operation, MaxOpsPerTx>::read_xdr(r)?,

                ext: TransactionExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Transaction {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.source_account.write_xdr(w)?;

            self.fee.write_xdr(w)?;

            self.seq_num.write_xdr(w)?;

            self.cond.write_xdr(w)?;

            self.memo.write_xdr(w)?;

            self.operations.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionV1Envelope
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionV1Envelope {
    pub tx: Transaction,

    pub signatures: VecM<DecoratedSignature, 20>,
}

impl ReadXdr for TransactionV1Envelope {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx: Transaction::read_xdr(r)?,

                signatures: VecM::<DecoratedSignature, 20>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionV1Envelope {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.tx.write_xdr(w)?;

            self.signatures.write_xdr(w)?;

            Ok(())
        })
    }
}

/// FeeBumpTransaction
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct FeeBumpTransaction {
    pub fee_source: MuxedAccount,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee: i64,

    pub inner_tx: FeeBumpTransactionInnerTx,

    pub ext: FeeBumpTransactionExt,
}

impl ReadXdr for FeeBumpTransaction {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                fee_source: MuxedAccount::read_xdr(r)?,

                fee: i64::read_xdr(r)?,

                inner_tx: FeeBumpTransactionInnerTx::read_xdr(r)?,

                ext: FeeBumpTransactionExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for FeeBumpTransaction {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.fee_source.write_xdr(w)?;

            self.fee.write_xdr(w)?;

            self.inner_tx.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// FeeBumpTransactionEnvelope
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct FeeBumpTransactionEnvelope {
    pub tx: FeeBumpTransaction,

    pub signatures: VecM<DecoratedSignature, 20>,
}

impl ReadXdr for FeeBumpTransactionEnvelope {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx: FeeBumpTransaction::read_xdr(r)?,

                signatures: VecM::<DecoratedSignature, 20>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for FeeBumpTransactionEnvelope {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.tx.write_xdr(w)?;

            self.signatures.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionEnvelope
// union with discriminant EnvelopeType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum TransactionEnvelope {
    EnvelopeTypeTxV0(TransactionV0Envelope),

    EnvelopeTypeTx(TransactionV1Envelope),

    EnvelopeTypeTxFeeBump(FeeBumpTransactionEnvelope),
}

impl TransactionEnvelope {
    pub const VARIANTS: [EnvelopeType; 3] = [
        EnvelopeType::EnvelopeTypeTxV0,
        EnvelopeType::EnvelopeTypeTx,
        EnvelopeType::EnvelopeTypeTxFeeBump,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "EnvelopeTypeTxV0",
        "EnvelopeTypeTx",
        "EnvelopeTypeTxFeeBump",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::EnvelopeTypeTxV0(_) => "EnvelopeTypeTxV0",

            Self::EnvelopeTypeTx(_) => "EnvelopeTypeTx",

            Self::EnvelopeTypeTxFeeBump(_) => "EnvelopeTypeTxFeeBump",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> EnvelopeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::EnvelopeTypeTxV0(_) => EnvelopeType::EnvelopeTypeTxV0,

            Self::EnvelopeTypeTx(_) => EnvelopeType::EnvelopeTypeTx,

            Self::EnvelopeTypeTxFeeBump(_) => EnvelopeType::EnvelopeTypeTxFeeBump,
        }
    }

    #[must_use]
    pub const fn variants() -> [EnvelopeType; 3] {
        Self::VARIANTS
    }
}

impl Name for TransactionEnvelope {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<EnvelopeType> for TransactionEnvelope {
    #[must_use]
    fn discriminant(&self) -> EnvelopeType {
        Self::discriminant(self)
    }
}

impl Variants<EnvelopeType> for TransactionEnvelope {
    fn variants() -> slice::Iter<'static, EnvelopeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<EnvelopeType> for TransactionEnvelope {}

impl ReadXdr for TransactionEnvelope {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: EnvelopeType = <EnvelopeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                EnvelopeType::EnvelopeTypeTxV0 => {
                    Self::EnvelopeTypeTxV0(TransactionV0Envelope::read_xdr(r)?)
                }

                EnvelopeType::EnvelopeTypeTx => {
                    Self::EnvelopeTypeTx(TransactionV1Envelope::read_xdr(r)?)
                }

                EnvelopeType::EnvelopeTypeTxFeeBump => {
                    Self::EnvelopeTypeTxFeeBump(FeeBumpTransactionEnvelope::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionEnvelope {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::EnvelopeTypeTxV0(v) => v.write_xdr(w)?,

                Self::EnvelopeTypeTx(v) => v.write_xdr(w)?,

                Self::EnvelopeTypeTxFeeBump(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionSignaturePayload
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionSignaturePayload {
    pub network_id: Hash,

    pub tagged_transaction: TransactionSignaturePayloadTaggedTransaction,
}

impl ReadXdr for TransactionSignaturePayload {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                network_id: Hash::read_xdr(r)?,

                tagged_transaction: TransactionSignaturePayloadTaggedTransaction::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionSignaturePayload {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.network_id.write_xdr(w)?;

            self.tagged_transaction.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ClaimAtomType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ClaimAtomType {
    #[cfg_attr(feature = "alloc", default)]
    ClaimAtomTypeV0 = 0,

    ClaimAtomTypeOrderBook = 1,

    ClaimAtomTypeLiquidityPool = 2,
}

impl ClaimAtomType {
    pub const VARIANTS: [ClaimAtomType; 3] = [
        ClaimAtomType::ClaimAtomTypeV0,
        ClaimAtomType::ClaimAtomTypeOrderBook,
        ClaimAtomType::ClaimAtomTypeLiquidityPool,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "ClaimAtomTypeV0",
        "ClaimAtomTypeOrderBook",
        "ClaimAtomTypeLiquidityPool",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimAtomTypeV0 => "ClaimAtomTypeV0",

            Self::ClaimAtomTypeOrderBook => "ClaimAtomTypeOrderBook",

            Self::ClaimAtomTypeLiquidityPool => "ClaimAtomTypeLiquidityPool",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimAtomType; 3] {
        Self::VARIANTS
    }
}

impl Name for ClaimAtomType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimAtomType> for ClaimAtomType {
    fn variants() -> slice::Iter<'static, ClaimAtomType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimAtomType {}

impl fmt::Display for ClaimAtomType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimAtomType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ClaimAtomType::ClaimAtomTypeV0,

            1 => ClaimAtomType::ClaimAtomTypeOrderBook,

            2 => ClaimAtomType::ClaimAtomTypeLiquidityPool,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimAtomType> for i32 {
    #[must_use]
    fn from(e: ClaimAtomType) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimAtomType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimAtomType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClaimOfferAtomV0
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ClaimOfferAtomV0 {
    pub seller_ed25519: Uint256,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub offer_id: i64,

    pub asset_sold: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount_sold: i64,

    pub asset_bought: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount_bought: i64,
}

impl ReadXdr for ClaimOfferAtomV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                seller_ed25519: Uint256::read_xdr(r)?,

                offer_id: i64::read_xdr(r)?,

                asset_sold: Asset::read_xdr(r)?,

                amount_sold: i64::read_xdr(r)?,

                asset_bought: Asset::read_xdr(r)?,

                amount_bought: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimOfferAtomV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.seller_ed25519.write_xdr(w)?;

            self.offer_id.write_xdr(w)?;

            self.asset_sold.write_xdr(w)?;

            self.amount_sold.write_xdr(w)?;

            self.asset_bought.write_xdr(w)?;

            self.amount_bought.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ClaimOfferAtom
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ClaimOfferAtom {
    pub seller_id: AccountId,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub offer_id: i64,

    pub asset_sold: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount_sold: i64,

    pub asset_bought: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount_bought: i64,
}

impl ReadXdr for ClaimOfferAtom {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                seller_id: AccountId::read_xdr(r)?,

                offer_id: i64::read_xdr(r)?,

                asset_sold: Asset::read_xdr(r)?,

                amount_sold: i64::read_xdr(r)?,

                asset_bought: Asset::read_xdr(r)?,

                amount_bought: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimOfferAtom {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.seller_id.write_xdr(w)?;

            self.offer_id.write_xdr(w)?;

            self.asset_sold.write_xdr(w)?;

            self.amount_sold.write_xdr(w)?;

            self.asset_bought.write_xdr(w)?;

            self.amount_bought.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ClaimLiquidityAtom
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ClaimLiquidityAtom {
    pub liquidity_pool_id: PoolId,

    pub asset_sold: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount_sold: i64,

    pub asset_bought: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount_bought: i64,
}

impl ReadXdr for ClaimLiquidityAtom {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_id: PoolId::read_xdr(r)?,

                asset_sold: Asset::read_xdr(r)?,

                amount_sold: i64::read_xdr(r)?,

                asset_bought: Asset::read_xdr(r)?,

                amount_bought: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimLiquidityAtom {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_id.write_xdr(w)?;

            self.asset_sold.write_xdr(w)?;

            self.amount_sold.write_xdr(w)?;

            self.asset_bought.write_xdr(w)?;

            self.amount_bought.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ClaimAtom
// union with discriminant ClaimAtomType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ClaimAtom {
    ClaimAtomTypeV0(ClaimOfferAtomV0),

    ClaimAtomTypeOrderBook(ClaimOfferAtom),

    ClaimAtomTypeLiquidityPool(ClaimLiquidityAtom),
}

#[cfg(feature = "alloc")]
impl Default for ClaimAtom {
    fn default() -> Self {
        Self::ClaimAtomTypeV0(ClaimOfferAtomV0::default())
    }
}

impl ClaimAtom {
    pub const VARIANTS: [ClaimAtomType; 3] = [
        ClaimAtomType::ClaimAtomTypeV0,
        ClaimAtomType::ClaimAtomTypeOrderBook,
        ClaimAtomType::ClaimAtomTypeLiquidityPool,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "ClaimAtomTypeV0",
        "ClaimAtomTypeOrderBook",
        "ClaimAtomTypeLiquidityPool",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimAtomTypeV0(_) => "ClaimAtomTypeV0",

            Self::ClaimAtomTypeOrderBook(_) => "ClaimAtomTypeOrderBook",

            Self::ClaimAtomTypeLiquidityPool(_) => "ClaimAtomTypeLiquidityPool",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClaimAtomType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ClaimAtomTypeV0(_) => ClaimAtomType::ClaimAtomTypeV0,

            Self::ClaimAtomTypeOrderBook(_) => ClaimAtomType::ClaimAtomTypeOrderBook,

            Self::ClaimAtomTypeLiquidityPool(_) => ClaimAtomType::ClaimAtomTypeLiquidityPool,
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimAtomType; 3] {
        Self::VARIANTS
    }
}

impl Name for ClaimAtom {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClaimAtomType> for ClaimAtom {
    #[must_use]
    fn discriminant(&self) -> ClaimAtomType {
        Self::discriminant(self)
    }
}

impl Variants<ClaimAtomType> for ClaimAtom {
    fn variants() -> slice::Iter<'static, ClaimAtomType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClaimAtomType> for ClaimAtom {}

impl ReadXdr for ClaimAtom {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ClaimAtomType = <ClaimAtomType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClaimAtomType::ClaimAtomTypeV0 => {
                    Self::ClaimAtomTypeV0(ClaimOfferAtomV0::read_xdr(r)?)
                }

                ClaimAtomType::ClaimAtomTypeOrderBook => {
                    Self::ClaimAtomTypeOrderBook(ClaimOfferAtom::read_xdr(r)?)
                }

                ClaimAtomType::ClaimAtomTypeLiquidityPool => {
                    Self::ClaimAtomTypeLiquidityPool(ClaimLiquidityAtom::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimAtom {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ClaimAtomTypeV0(v) => v.write_xdr(w)?,

                Self::ClaimAtomTypeOrderBook(v) => v.write_xdr(w)?,

                Self::ClaimAtomTypeLiquidityPool(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// CreateAccountResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum CreateAccountResultCode {
    #[cfg_attr(feature = "alloc", default)]
    CreateAccountSuccess = 0,

    CreateAccountMalformed = -1,

    CreateAccountUnderfunded = -2,

    CreateAccountLowReserve = -3,

    CreateAccountAlreadyExist = -4,
}

impl CreateAccountResultCode {
    pub const VARIANTS: [CreateAccountResultCode; 5] = [
        CreateAccountResultCode::CreateAccountSuccess,
        CreateAccountResultCode::CreateAccountMalformed,
        CreateAccountResultCode::CreateAccountUnderfunded,
        CreateAccountResultCode::CreateAccountLowReserve,
        CreateAccountResultCode::CreateAccountAlreadyExist,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "CreateAccountSuccess",
        "CreateAccountMalformed",
        "CreateAccountUnderfunded",
        "CreateAccountLowReserve",
        "CreateAccountAlreadyExist",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::CreateAccountSuccess => "CreateAccountSuccess",

            Self::CreateAccountMalformed => "CreateAccountMalformed",

            Self::CreateAccountUnderfunded => "CreateAccountUnderfunded",

            Self::CreateAccountLowReserve => "CreateAccountLowReserve",

            Self::CreateAccountAlreadyExist => "CreateAccountAlreadyExist",
        }
    }

    #[must_use]
    pub const fn variants() -> [CreateAccountResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for CreateAccountResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<CreateAccountResultCode> for CreateAccountResultCode {
    fn variants() -> slice::Iter<'static, CreateAccountResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for CreateAccountResultCode {}

impl fmt::Display for CreateAccountResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for CreateAccountResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => CreateAccountResultCode::CreateAccountSuccess,

            -1 => CreateAccountResultCode::CreateAccountMalformed,

            -2 => CreateAccountResultCode::CreateAccountUnderfunded,

            -3 => CreateAccountResultCode::CreateAccountLowReserve,

            -4 => CreateAccountResultCode::CreateAccountAlreadyExist,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<CreateAccountResultCode> for i32 {
    #[must_use]
    fn from(e: CreateAccountResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for CreateAccountResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for CreateAccountResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// CreateAccountResult
// union with discriminant CreateAccountResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum CreateAccountResult {
    CreateAccountSuccess,

    CreateAccountMalformed,

    CreateAccountUnderfunded,

    CreateAccountLowReserve,

    CreateAccountAlreadyExist,
}

#[cfg(feature = "alloc")]
impl Default for CreateAccountResult {
    fn default() -> Self {
        Self::CreateAccountSuccess
    }
}

impl CreateAccountResult {
    pub const VARIANTS: [CreateAccountResultCode; 5] = [
        CreateAccountResultCode::CreateAccountSuccess,
        CreateAccountResultCode::CreateAccountMalformed,
        CreateAccountResultCode::CreateAccountUnderfunded,
        CreateAccountResultCode::CreateAccountLowReserve,
        CreateAccountResultCode::CreateAccountAlreadyExist,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "CreateAccountSuccess",
        "CreateAccountMalformed",
        "CreateAccountUnderfunded",
        "CreateAccountLowReserve",
        "CreateAccountAlreadyExist",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::CreateAccountSuccess => "CreateAccountSuccess",

            Self::CreateAccountMalformed => "CreateAccountMalformed",

            Self::CreateAccountUnderfunded => "CreateAccountUnderfunded",

            Self::CreateAccountLowReserve => "CreateAccountLowReserve",

            Self::CreateAccountAlreadyExist => "CreateAccountAlreadyExist",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> CreateAccountResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::CreateAccountSuccess => CreateAccountResultCode::CreateAccountSuccess,

            Self::CreateAccountMalformed => CreateAccountResultCode::CreateAccountMalformed,

            Self::CreateAccountUnderfunded => CreateAccountResultCode::CreateAccountUnderfunded,

            Self::CreateAccountLowReserve => CreateAccountResultCode::CreateAccountLowReserve,

            Self::CreateAccountAlreadyExist => CreateAccountResultCode::CreateAccountAlreadyExist,
        }
    }

    #[must_use]
    pub const fn variants() -> [CreateAccountResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for CreateAccountResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<CreateAccountResultCode> for CreateAccountResult {
    #[must_use]
    fn discriminant(&self) -> CreateAccountResultCode {
        Self::discriminant(self)
    }
}

impl Variants<CreateAccountResultCode> for CreateAccountResult {
    fn variants() -> slice::Iter<'static, CreateAccountResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<CreateAccountResultCode> for CreateAccountResult {}

impl ReadXdr for CreateAccountResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: CreateAccountResultCode = <CreateAccountResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                CreateAccountResultCode::CreateAccountSuccess => Self::CreateAccountSuccess,

                CreateAccountResultCode::CreateAccountMalformed => Self::CreateAccountMalformed,

                CreateAccountResultCode::CreateAccountUnderfunded => Self::CreateAccountUnderfunded,

                CreateAccountResultCode::CreateAccountLowReserve => Self::CreateAccountLowReserve,

                CreateAccountResultCode::CreateAccountAlreadyExist => {
                    Self::CreateAccountAlreadyExist
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for CreateAccountResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::CreateAccountSuccess => ().write_xdr(w)?,

                Self::CreateAccountMalformed => ().write_xdr(w)?,

                Self::CreateAccountUnderfunded => ().write_xdr(w)?,

                Self::CreateAccountLowReserve => ().write_xdr(w)?,

                Self::CreateAccountAlreadyExist => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// PaymentResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum PaymentResultCode {
    #[cfg_attr(feature = "alloc", default)]
    PaymentSuccess = 0,

    PaymentMalformed = -1,

    PaymentUnderfunded = -2,

    PaymentSrcNoTrust = -3,

    PaymentSrcNotAuthorized = -4,

    PaymentNoDestination = -5,

    PaymentNoTrust = -6,

    PaymentNotAuthorized = -7,

    PaymentLineFull = -8,

    PaymentNoIssuer = -9,
}

impl PaymentResultCode {
    pub const VARIANTS: [PaymentResultCode; 10] = [
        PaymentResultCode::PaymentSuccess,
        PaymentResultCode::PaymentMalformed,
        PaymentResultCode::PaymentUnderfunded,
        PaymentResultCode::PaymentSrcNoTrust,
        PaymentResultCode::PaymentSrcNotAuthorized,
        PaymentResultCode::PaymentNoDestination,
        PaymentResultCode::PaymentNoTrust,
        PaymentResultCode::PaymentNotAuthorized,
        PaymentResultCode::PaymentLineFull,
        PaymentResultCode::PaymentNoIssuer,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "PaymentSuccess",
        "PaymentMalformed",
        "PaymentUnderfunded",
        "PaymentSrcNoTrust",
        "PaymentSrcNotAuthorized",
        "PaymentNoDestination",
        "PaymentNoTrust",
        "PaymentNotAuthorized",
        "PaymentLineFull",
        "PaymentNoIssuer",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PaymentSuccess => "PaymentSuccess",

            Self::PaymentMalformed => "PaymentMalformed",

            Self::PaymentUnderfunded => "PaymentUnderfunded",

            Self::PaymentSrcNoTrust => "PaymentSrcNoTrust",

            Self::PaymentSrcNotAuthorized => "PaymentSrcNotAuthorized",

            Self::PaymentNoDestination => "PaymentNoDestination",

            Self::PaymentNoTrust => "PaymentNoTrust",

            Self::PaymentNotAuthorized => "PaymentNotAuthorized",

            Self::PaymentLineFull => "PaymentLineFull",

            Self::PaymentNoIssuer => "PaymentNoIssuer",
        }
    }

    #[must_use]
    pub const fn variants() -> [PaymentResultCode; 10] {
        Self::VARIANTS
    }
}

impl Name for PaymentResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<PaymentResultCode> for PaymentResultCode {
    fn variants() -> slice::Iter<'static, PaymentResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for PaymentResultCode {}

impl fmt::Display for PaymentResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for PaymentResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => PaymentResultCode::PaymentSuccess,

            -1 => PaymentResultCode::PaymentMalformed,

            -2 => PaymentResultCode::PaymentUnderfunded,

            -3 => PaymentResultCode::PaymentSrcNoTrust,

            -4 => PaymentResultCode::PaymentSrcNotAuthorized,

            -5 => PaymentResultCode::PaymentNoDestination,

            -6 => PaymentResultCode::PaymentNoTrust,

            -7 => PaymentResultCode::PaymentNotAuthorized,

            -8 => PaymentResultCode::PaymentLineFull,

            -9 => PaymentResultCode::PaymentNoIssuer,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<PaymentResultCode> for i32 {
    #[must_use]
    fn from(e: PaymentResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for PaymentResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for PaymentResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// PaymentResult
// union with discriminant PaymentResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum PaymentResult {
    PaymentSuccess,

    PaymentMalformed,

    PaymentUnderfunded,

    PaymentSrcNoTrust,

    PaymentSrcNotAuthorized,

    PaymentNoDestination,

    PaymentNoTrust,

    PaymentNotAuthorized,

    PaymentLineFull,

    PaymentNoIssuer,
}

#[cfg(feature = "alloc")]
impl Default for PaymentResult {
    fn default() -> Self {
        Self::PaymentSuccess
    }
}

impl PaymentResult {
    pub const VARIANTS: [PaymentResultCode; 10] = [
        PaymentResultCode::PaymentSuccess,
        PaymentResultCode::PaymentMalformed,
        PaymentResultCode::PaymentUnderfunded,
        PaymentResultCode::PaymentSrcNoTrust,
        PaymentResultCode::PaymentSrcNotAuthorized,
        PaymentResultCode::PaymentNoDestination,
        PaymentResultCode::PaymentNoTrust,
        PaymentResultCode::PaymentNotAuthorized,
        PaymentResultCode::PaymentLineFull,
        PaymentResultCode::PaymentNoIssuer,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "PaymentSuccess",
        "PaymentMalformed",
        "PaymentUnderfunded",
        "PaymentSrcNoTrust",
        "PaymentSrcNotAuthorized",
        "PaymentNoDestination",
        "PaymentNoTrust",
        "PaymentNotAuthorized",
        "PaymentLineFull",
        "PaymentNoIssuer",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PaymentSuccess => "PaymentSuccess",

            Self::PaymentMalformed => "PaymentMalformed",

            Self::PaymentUnderfunded => "PaymentUnderfunded",

            Self::PaymentSrcNoTrust => "PaymentSrcNoTrust",

            Self::PaymentSrcNotAuthorized => "PaymentSrcNotAuthorized",

            Self::PaymentNoDestination => "PaymentNoDestination",

            Self::PaymentNoTrust => "PaymentNoTrust",

            Self::PaymentNotAuthorized => "PaymentNotAuthorized",

            Self::PaymentLineFull => "PaymentLineFull",

            Self::PaymentNoIssuer => "PaymentNoIssuer",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> PaymentResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::PaymentSuccess => PaymentResultCode::PaymentSuccess,

            Self::PaymentMalformed => PaymentResultCode::PaymentMalformed,

            Self::PaymentUnderfunded => PaymentResultCode::PaymentUnderfunded,

            Self::PaymentSrcNoTrust => PaymentResultCode::PaymentSrcNoTrust,

            Self::PaymentSrcNotAuthorized => PaymentResultCode::PaymentSrcNotAuthorized,

            Self::PaymentNoDestination => PaymentResultCode::PaymentNoDestination,

            Self::PaymentNoTrust => PaymentResultCode::PaymentNoTrust,

            Self::PaymentNotAuthorized => PaymentResultCode::PaymentNotAuthorized,

            Self::PaymentLineFull => PaymentResultCode::PaymentLineFull,

            Self::PaymentNoIssuer => PaymentResultCode::PaymentNoIssuer,
        }
    }

    #[must_use]
    pub const fn variants() -> [PaymentResultCode; 10] {
        Self::VARIANTS
    }
}

impl Name for PaymentResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<PaymentResultCode> for PaymentResult {
    #[must_use]
    fn discriminant(&self) -> PaymentResultCode {
        Self::discriminant(self)
    }
}

impl Variants<PaymentResultCode> for PaymentResult {
    fn variants() -> slice::Iter<'static, PaymentResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<PaymentResultCode> for PaymentResult {}

impl ReadXdr for PaymentResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: PaymentResultCode = <PaymentResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                PaymentResultCode::PaymentSuccess => Self::PaymentSuccess,

                PaymentResultCode::PaymentMalformed => Self::PaymentMalformed,

                PaymentResultCode::PaymentUnderfunded => Self::PaymentUnderfunded,

                PaymentResultCode::PaymentSrcNoTrust => Self::PaymentSrcNoTrust,

                PaymentResultCode::PaymentSrcNotAuthorized => Self::PaymentSrcNotAuthorized,

                PaymentResultCode::PaymentNoDestination => Self::PaymentNoDestination,

                PaymentResultCode::PaymentNoTrust => Self::PaymentNoTrust,

                PaymentResultCode::PaymentNotAuthorized => Self::PaymentNotAuthorized,

                PaymentResultCode::PaymentLineFull => Self::PaymentLineFull,

                PaymentResultCode::PaymentNoIssuer => Self::PaymentNoIssuer,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PaymentResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::PaymentSuccess => ().write_xdr(w)?,

                Self::PaymentMalformed => ().write_xdr(w)?,

                Self::PaymentUnderfunded => ().write_xdr(w)?,

                Self::PaymentSrcNoTrust => ().write_xdr(w)?,

                Self::PaymentSrcNotAuthorized => ().write_xdr(w)?,

                Self::PaymentNoDestination => ().write_xdr(w)?,

                Self::PaymentNoTrust => ().write_xdr(w)?,

                Self::PaymentNotAuthorized => ().write_xdr(w)?,

                Self::PaymentLineFull => ().write_xdr(w)?,

                Self::PaymentNoIssuer => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// PathPaymentStrictReceiveResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum PathPaymentStrictReceiveResultCode {
    #[cfg_attr(feature = "alloc", default)]
    PathPaymentStrictReceiveSuccess = 0,

    PathPaymentStrictReceiveMalformed = -1,

    PathPaymentStrictReceiveUnderfunded = -2,

    PathPaymentStrictReceiveSrcNoTrust = -3,

    PathPaymentStrictReceiveSrcNotAuthorized = -4,

    PathPaymentStrictReceiveNoDestination = -5,

    PathPaymentStrictReceiveNoTrust = -6,

    PathPaymentStrictReceiveNotAuthorized = -7,

    PathPaymentStrictReceiveLineFull = -8,

    PathPaymentStrictReceiveNoIssuer = -9,

    PathPaymentStrictReceiveTooFewOffers = -10,

    PathPaymentStrictReceiveOfferCrossSelf = -11,

    PathPaymentStrictReceiveOverSendmax = -12,
}

impl PathPaymentStrictReceiveResultCode {
    pub const VARIANTS: [PathPaymentStrictReceiveResultCode; 13] = [
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSuccess,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveMalformed,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveUnderfunded,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNoTrust,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNotAuthorized,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoDestination,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoTrust,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNotAuthorized,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveLineFull,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoIssuer,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveTooFewOffers,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOfferCrossSelf,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOverSendmax,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "PathPaymentStrictReceiveSuccess",
        "PathPaymentStrictReceiveMalformed",
        "PathPaymentStrictReceiveUnderfunded",
        "PathPaymentStrictReceiveSrcNoTrust",
        "PathPaymentStrictReceiveSrcNotAuthorized",
        "PathPaymentStrictReceiveNoDestination",
        "PathPaymentStrictReceiveNoTrust",
        "PathPaymentStrictReceiveNotAuthorized",
        "PathPaymentStrictReceiveLineFull",
        "PathPaymentStrictReceiveNoIssuer",
        "PathPaymentStrictReceiveTooFewOffers",
        "PathPaymentStrictReceiveOfferCrossSelf",
        "PathPaymentStrictReceiveOverSendmax",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PathPaymentStrictReceiveSuccess => "PathPaymentStrictReceiveSuccess",

            Self::PathPaymentStrictReceiveMalformed => "PathPaymentStrictReceiveMalformed",

            Self::PathPaymentStrictReceiveUnderfunded => "PathPaymentStrictReceiveUnderfunded",

            Self::PathPaymentStrictReceiveSrcNoTrust => "PathPaymentStrictReceiveSrcNoTrust",

            Self::PathPaymentStrictReceiveSrcNotAuthorized => {
                "PathPaymentStrictReceiveSrcNotAuthorized"
            }

            Self::PathPaymentStrictReceiveNoDestination => "PathPaymentStrictReceiveNoDestination",

            Self::PathPaymentStrictReceiveNoTrust => "PathPaymentStrictReceiveNoTrust",

            Self::PathPaymentStrictReceiveNotAuthorized => "PathPaymentStrictReceiveNotAuthorized",

            Self::PathPaymentStrictReceiveLineFull => "PathPaymentStrictReceiveLineFull",

            Self::PathPaymentStrictReceiveNoIssuer => "PathPaymentStrictReceiveNoIssuer",

            Self::PathPaymentStrictReceiveTooFewOffers => "PathPaymentStrictReceiveTooFewOffers",

            Self::PathPaymentStrictReceiveOfferCrossSelf => {
                "PathPaymentStrictReceiveOfferCrossSelf"
            }

            Self::PathPaymentStrictReceiveOverSendmax => "PathPaymentStrictReceiveOverSendmax",
        }
    }

    #[must_use]
    pub const fn variants() -> [PathPaymentStrictReceiveResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for PathPaymentStrictReceiveResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<PathPaymentStrictReceiveResultCode> for PathPaymentStrictReceiveResultCode {
    fn variants() -> slice::Iter<'static, PathPaymentStrictReceiveResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for PathPaymentStrictReceiveResultCode {}

impl fmt::Display for PathPaymentStrictReceiveResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for PathPaymentStrictReceiveResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSuccess,

            -1 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveMalformed,

            -2 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveUnderfunded,

            -3 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNoTrust,

            -4 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNotAuthorized,

            -5 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoDestination,

            -6 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoTrust,

            -7 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNotAuthorized,

            -8 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveLineFull,

            -9 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoIssuer,

            -10 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveTooFewOffers,

            -11 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOfferCrossSelf,

            -12 => PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOverSendmax,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<PathPaymentStrictReceiveResultCode> for i32 {
    #[must_use]
    fn from(e: PathPaymentStrictReceiveResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for PathPaymentStrictReceiveResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for PathPaymentStrictReceiveResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SimplePaymentResult
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SimplePaymentResult {
    pub destination: AccountId,

    pub asset: Asset,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount: i64,
}

impl ReadXdr for SimplePaymentResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                destination: AccountId::read_xdr(r)?,

                asset: Asset::read_xdr(r)?,

                amount: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SimplePaymentResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.destination.write_xdr(w)?;

            self.asset.write_xdr(w)?;

            self.amount.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PathPaymentStrictReceiveResult
// union with discriminant PathPaymentStrictReceiveResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum PathPaymentStrictReceiveResult {
    PathPaymentStrictReceiveSuccess(PathPaymentStrictReceiveResultSuccess),

    PathPaymentStrictReceiveMalformed,

    PathPaymentStrictReceiveUnderfunded,

    PathPaymentStrictReceiveSrcNoTrust,

    PathPaymentStrictReceiveSrcNotAuthorized,

    PathPaymentStrictReceiveNoDestination,

    PathPaymentStrictReceiveNoTrust,

    PathPaymentStrictReceiveNotAuthorized,

    PathPaymentStrictReceiveLineFull,

    PathPaymentStrictReceiveNoIssuer(Asset),

    PathPaymentStrictReceiveTooFewOffers,

    PathPaymentStrictReceiveOfferCrossSelf,

    PathPaymentStrictReceiveOverSendmax,
}

#[cfg(feature = "alloc")]
impl Default for PathPaymentStrictReceiveResult {
    fn default() -> Self {
        Self::PathPaymentStrictReceiveSuccess(PathPaymentStrictReceiveResultSuccess::default())
    }
}

impl PathPaymentStrictReceiveResult {
    pub const VARIANTS: [PathPaymentStrictReceiveResultCode; 13] = [
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSuccess,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveMalformed,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveUnderfunded,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNoTrust,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNotAuthorized,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoDestination,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoTrust,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNotAuthorized,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveLineFull,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoIssuer,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveTooFewOffers,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOfferCrossSelf,
        PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOverSendmax,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "PathPaymentStrictReceiveSuccess",
        "PathPaymentStrictReceiveMalformed",
        "PathPaymentStrictReceiveUnderfunded",
        "PathPaymentStrictReceiveSrcNoTrust",
        "PathPaymentStrictReceiveSrcNotAuthorized",
        "PathPaymentStrictReceiveNoDestination",
        "PathPaymentStrictReceiveNoTrust",
        "PathPaymentStrictReceiveNotAuthorized",
        "PathPaymentStrictReceiveLineFull",
        "PathPaymentStrictReceiveNoIssuer",
        "PathPaymentStrictReceiveTooFewOffers",
        "PathPaymentStrictReceiveOfferCrossSelf",
        "PathPaymentStrictReceiveOverSendmax",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PathPaymentStrictReceiveSuccess(_) => "PathPaymentStrictReceiveSuccess",

            Self::PathPaymentStrictReceiveMalformed => "PathPaymentStrictReceiveMalformed",

            Self::PathPaymentStrictReceiveUnderfunded => "PathPaymentStrictReceiveUnderfunded",

            Self::PathPaymentStrictReceiveSrcNoTrust => "PathPaymentStrictReceiveSrcNoTrust",

            Self::PathPaymentStrictReceiveSrcNotAuthorized => {
                "PathPaymentStrictReceiveSrcNotAuthorized"
            }

            Self::PathPaymentStrictReceiveNoDestination => "PathPaymentStrictReceiveNoDestination",

            Self::PathPaymentStrictReceiveNoTrust => "PathPaymentStrictReceiveNoTrust",

            Self::PathPaymentStrictReceiveNotAuthorized => "PathPaymentStrictReceiveNotAuthorized",

            Self::PathPaymentStrictReceiveLineFull => "PathPaymentStrictReceiveLineFull",

            Self::PathPaymentStrictReceiveNoIssuer(_) => "PathPaymentStrictReceiveNoIssuer",

            Self::PathPaymentStrictReceiveTooFewOffers => "PathPaymentStrictReceiveTooFewOffers",

            Self::PathPaymentStrictReceiveOfferCrossSelf => {
                "PathPaymentStrictReceiveOfferCrossSelf"
            }

            Self::PathPaymentStrictReceiveOverSendmax => "PathPaymentStrictReceiveOverSendmax",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> PathPaymentStrictReceiveResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::PathPaymentStrictReceiveSuccess(_) => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSuccess
            }

            Self::PathPaymentStrictReceiveMalformed => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveMalformed
            }

            Self::PathPaymentStrictReceiveUnderfunded => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveUnderfunded
            }

            Self::PathPaymentStrictReceiveSrcNoTrust => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNoTrust
            }

            Self::PathPaymentStrictReceiveSrcNotAuthorized => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNotAuthorized
            }

            Self::PathPaymentStrictReceiveNoDestination => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoDestination
            }

            Self::PathPaymentStrictReceiveNoTrust => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoTrust
            }

            Self::PathPaymentStrictReceiveNotAuthorized => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNotAuthorized
            }

            Self::PathPaymentStrictReceiveLineFull => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveLineFull
            }

            Self::PathPaymentStrictReceiveNoIssuer(_) => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoIssuer
            }

            Self::PathPaymentStrictReceiveTooFewOffers => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveTooFewOffers
            }

            Self::PathPaymentStrictReceiveOfferCrossSelf => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOfferCrossSelf
            }

            Self::PathPaymentStrictReceiveOverSendmax => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOverSendmax
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [PathPaymentStrictReceiveResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for PathPaymentStrictReceiveResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<PathPaymentStrictReceiveResultCode> for PathPaymentStrictReceiveResult {
    #[must_use]
    fn discriminant(&self) -> PathPaymentStrictReceiveResultCode {
        Self::discriminant(self)
    }
}

impl Variants<PathPaymentStrictReceiveResultCode> for PathPaymentStrictReceiveResult {
    fn variants() -> slice::Iter<'static, PathPaymentStrictReceiveResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<PathPaymentStrictReceiveResultCode> for PathPaymentStrictReceiveResult {}

impl ReadXdr for PathPaymentStrictReceiveResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: PathPaymentStrictReceiveResultCode =
                <PathPaymentStrictReceiveResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSuccess => {
                    Self::PathPaymentStrictReceiveSuccess(
                        PathPaymentStrictReceiveResultSuccess::read_xdr(r)?,
                    )
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveMalformed => {
                    Self::PathPaymentStrictReceiveMalformed
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveUnderfunded => {
                    Self::PathPaymentStrictReceiveUnderfunded
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNoTrust => {
                    Self::PathPaymentStrictReceiveSrcNoTrust
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNotAuthorized => {
                    Self::PathPaymentStrictReceiveSrcNotAuthorized
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoDestination => {
                    Self::PathPaymentStrictReceiveNoDestination
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoTrust => {
                    Self::PathPaymentStrictReceiveNoTrust
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNotAuthorized => {
                    Self::PathPaymentStrictReceiveNotAuthorized
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveLineFull => {
                    Self::PathPaymentStrictReceiveLineFull
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoIssuer => {
                    Self::PathPaymentStrictReceiveNoIssuer(Asset::read_xdr(r)?)
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveTooFewOffers => {
                    Self::PathPaymentStrictReceiveTooFewOffers
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOfferCrossSelf => {
                    Self::PathPaymentStrictReceiveOfferCrossSelf
                }

                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOverSendmax => {
                    Self::PathPaymentStrictReceiveOverSendmax
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PathPaymentStrictReceiveResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::PathPaymentStrictReceiveSuccess(v) => v.write_xdr(w)?,

                Self::PathPaymentStrictReceiveMalformed => ().write_xdr(w)?,

                Self::PathPaymentStrictReceiveUnderfunded => ().write_xdr(w)?,

                Self::PathPaymentStrictReceiveSrcNoTrust => ().write_xdr(w)?,

                Self::PathPaymentStrictReceiveSrcNotAuthorized => ().write_xdr(w)?,

                Self::PathPaymentStrictReceiveNoDestination => ().write_xdr(w)?,

                Self::PathPaymentStrictReceiveNoTrust => ().write_xdr(w)?,

                Self::PathPaymentStrictReceiveNotAuthorized => ().write_xdr(w)?,

                Self::PathPaymentStrictReceiveLineFull => ().write_xdr(w)?,

                Self::PathPaymentStrictReceiveNoIssuer(v) => v.write_xdr(w)?,

                Self::PathPaymentStrictReceiveTooFewOffers => ().write_xdr(w)?,

                Self::PathPaymentStrictReceiveOfferCrossSelf => ().write_xdr(w)?,

                Self::PathPaymentStrictReceiveOverSendmax => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// PathPaymentStrictSendResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum PathPaymentStrictSendResultCode {
    #[cfg_attr(feature = "alloc", default)]
    PathPaymentStrictSendSuccess = 0,

    PathPaymentStrictSendMalformed = -1,

    PathPaymentStrictSendUnderfunded = -2,

    PathPaymentStrictSendSrcNoTrust = -3,

    PathPaymentStrictSendSrcNotAuthorized = -4,

    PathPaymentStrictSendNoDestination = -5,

    PathPaymentStrictSendNoTrust = -6,

    PathPaymentStrictSendNotAuthorized = -7,

    PathPaymentStrictSendLineFull = -8,

    PathPaymentStrictSendNoIssuer = -9,

    PathPaymentStrictSendTooFewOffers = -10,

    PathPaymentStrictSendOfferCrossSelf = -11,

    PathPaymentStrictSendUnderDestmin = -12,
}

impl PathPaymentStrictSendResultCode {
    pub const VARIANTS: [PathPaymentStrictSendResultCode; 13] = [
        PathPaymentStrictSendResultCode::PathPaymentStrictSendSuccess,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendMalformed,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderfunded,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNoTrust,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNotAuthorized,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendNoDestination,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendNoTrust,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendNotAuthorized,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendLineFull,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendNoIssuer,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendTooFewOffers,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendOfferCrossSelf,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderDestmin,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "PathPaymentStrictSendSuccess",
        "PathPaymentStrictSendMalformed",
        "PathPaymentStrictSendUnderfunded",
        "PathPaymentStrictSendSrcNoTrust",
        "PathPaymentStrictSendSrcNotAuthorized",
        "PathPaymentStrictSendNoDestination",
        "PathPaymentStrictSendNoTrust",
        "PathPaymentStrictSendNotAuthorized",
        "PathPaymentStrictSendLineFull",
        "PathPaymentStrictSendNoIssuer",
        "PathPaymentStrictSendTooFewOffers",
        "PathPaymentStrictSendOfferCrossSelf",
        "PathPaymentStrictSendUnderDestmin",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PathPaymentStrictSendSuccess => "PathPaymentStrictSendSuccess",

            Self::PathPaymentStrictSendMalformed => "PathPaymentStrictSendMalformed",

            Self::PathPaymentStrictSendUnderfunded => "PathPaymentStrictSendUnderfunded",

            Self::PathPaymentStrictSendSrcNoTrust => "PathPaymentStrictSendSrcNoTrust",

            Self::PathPaymentStrictSendSrcNotAuthorized => "PathPaymentStrictSendSrcNotAuthorized",

            Self::PathPaymentStrictSendNoDestination => "PathPaymentStrictSendNoDestination",

            Self::PathPaymentStrictSendNoTrust => "PathPaymentStrictSendNoTrust",

            Self::PathPaymentStrictSendNotAuthorized => "PathPaymentStrictSendNotAuthorized",

            Self::PathPaymentStrictSendLineFull => "PathPaymentStrictSendLineFull",

            Self::PathPaymentStrictSendNoIssuer => "PathPaymentStrictSendNoIssuer",

            Self::PathPaymentStrictSendTooFewOffers => "PathPaymentStrictSendTooFewOffers",

            Self::PathPaymentStrictSendOfferCrossSelf => "PathPaymentStrictSendOfferCrossSelf",

            Self::PathPaymentStrictSendUnderDestmin => "PathPaymentStrictSendUnderDestmin",
        }
    }

    #[must_use]
    pub const fn variants() -> [PathPaymentStrictSendResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for PathPaymentStrictSendResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<PathPaymentStrictSendResultCode> for PathPaymentStrictSendResultCode {
    fn variants() -> slice::Iter<'static, PathPaymentStrictSendResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for PathPaymentStrictSendResultCode {}

impl fmt::Display for PathPaymentStrictSendResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for PathPaymentStrictSendResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => PathPaymentStrictSendResultCode::PathPaymentStrictSendSuccess,

            -1 => PathPaymentStrictSendResultCode::PathPaymentStrictSendMalformed,

            -2 => PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderfunded,

            -3 => PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNoTrust,

            -4 => PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNotAuthorized,

            -5 => PathPaymentStrictSendResultCode::PathPaymentStrictSendNoDestination,

            -6 => PathPaymentStrictSendResultCode::PathPaymentStrictSendNoTrust,

            -7 => PathPaymentStrictSendResultCode::PathPaymentStrictSendNotAuthorized,

            -8 => PathPaymentStrictSendResultCode::PathPaymentStrictSendLineFull,

            -9 => PathPaymentStrictSendResultCode::PathPaymentStrictSendNoIssuer,

            -10 => PathPaymentStrictSendResultCode::PathPaymentStrictSendTooFewOffers,

            -11 => PathPaymentStrictSendResultCode::PathPaymentStrictSendOfferCrossSelf,

            -12 => PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderDestmin,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<PathPaymentStrictSendResultCode> for i32 {
    #[must_use]
    fn from(e: PathPaymentStrictSendResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for PathPaymentStrictSendResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for PathPaymentStrictSendResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// PathPaymentStrictSendResult
// union with discriminant PathPaymentStrictSendResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum PathPaymentStrictSendResult {
    PathPaymentStrictSendSuccess(PathPaymentStrictSendResultSuccess),

    PathPaymentStrictSendMalformed,

    PathPaymentStrictSendUnderfunded,

    PathPaymentStrictSendSrcNoTrust,

    PathPaymentStrictSendSrcNotAuthorized,

    PathPaymentStrictSendNoDestination,

    PathPaymentStrictSendNoTrust,

    PathPaymentStrictSendNotAuthorized,

    PathPaymentStrictSendLineFull,

    PathPaymentStrictSendNoIssuer(Asset),

    PathPaymentStrictSendTooFewOffers,

    PathPaymentStrictSendOfferCrossSelf,

    PathPaymentStrictSendUnderDestmin,
}

#[cfg(feature = "alloc")]
impl Default for PathPaymentStrictSendResult {
    fn default() -> Self {
        Self::PathPaymentStrictSendSuccess(PathPaymentStrictSendResultSuccess::default())
    }
}

impl PathPaymentStrictSendResult {
    pub const VARIANTS: [PathPaymentStrictSendResultCode; 13] = [
        PathPaymentStrictSendResultCode::PathPaymentStrictSendSuccess,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendMalformed,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderfunded,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNoTrust,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNotAuthorized,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendNoDestination,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendNoTrust,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendNotAuthorized,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendLineFull,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendNoIssuer,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendTooFewOffers,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendOfferCrossSelf,
        PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderDestmin,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "PathPaymentStrictSendSuccess",
        "PathPaymentStrictSendMalformed",
        "PathPaymentStrictSendUnderfunded",
        "PathPaymentStrictSendSrcNoTrust",
        "PathPaymentStrictSendSrcNotAuthorized",
        "PathPaymentStrictSendNoDestination",
        "PathPaymentStrictSendNoTrust",
        "PathPaymentStrictSendNotAuthorized",
        "PathPaymentStrictSendLineFull",
        "PathPaymentStrictSendNoIssuer",
        "PathPaymentStrictSendTooFewOffers",
        "PathPaymentStrictSendOfferCrossSelf",
        "PathPaymentStrictSendUnderDestmin",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PathPaymentStrictSendSuccess(_) => "PathPaymentStrictSendSuccess",

            Self::PathPaymentStrictSendMalformed => "PathPaymentStrictSendMalformed",

            Self::PathPaymentStrictSendUnderfunded => "PathPaymentStrictSendUnderfunded",

            Self::PathPaymentStrictSendSrcNoTrust => "PathPaymentStrictSendSrcNoTrust",

            Self::PathPaymentStrictSendSrcNotAuthorized => "PathPaymentStrictSendSrcNotAuthorized",

            Self::PathPaymentStrictSendNoDestination => "PathPaymentStrictSendNoDestination",

            Self::PathPaymentStrictSendNoTrust => "PathPaymentStrictSendNoTrust",

            Self::PathPaymentStrictSendNotAuthorized => "PathPaymentStrictSendNotAuthorized",

            Self::PathPaymentStrictSendLineFull => "PathPaymentStrictSendLineFull",

            Self::PathPaymentStrictSendNoIssuer(_) => "PathPaymentStrictSendNoIssuer",

            Self::PathPaymentStrictSendTooFewOffers => "PathPaymentStrictSendTooFewOffers",

            Self::PathPaymentStrictSendOfferCrossSelf => "PathPaymentStrictSendOfferCrossSelf",

            Self::PathPaymentStrictSendUnderDestmin => "PathPaymentStrictSendUnderDestmin",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> PathPaymentStrictSendResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::PathPaymentStrictSendSuccess(_) => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendSuccess
            }

            Self::PathPaymentStrictSendMalformed => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendMalformed
            }

            Self::PathPaymentStrictSendUnderfunded => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderfunded
            }

            Self::PathPaymentStrictSendSrcNoTrust => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNoTrust
            }

            Self::PathPaymentStrictSendSrcNotAuthorized => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNotAuthorized
            }

            Self::PathPaymentStrictSendNoDestination => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendNoDestination
            }

            Self::PathPaymentStrictSendNoTrust => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendNoTrust
            }

            Self::PathPaymentStrictSendNotAuthorized => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendNotAuthorized
            }

            Self::PathPaymentStrictSendLineFull => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendLineFull
            }

            Self::PathPaymentStrictSendNoIssuer(_) => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendNoIssuer
            }

            Self::PathPaymentStrictSendTooFewOffers => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendTooFewOffers
            }

            Self::PathPaymentStrictSendOfferCrossSelf => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendOfferCrossSelf
            }

            Self::PathPaymentStrictSendUnderDestmin => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderDestmin
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [PathPaymentStrictSendResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for PathPaymentStrictSendResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<PathPaymentStrictSendResultCode> for PathPaymentStrictSendResult {
    #[must_use]
    fn discriminant(&self) -> PathPaymentStrictSendResultCode {
        Self::discriminant(self)
    }
}

impl Variants<PathPaymentStrictSendResultCode> for PathPaymentStrictSendResult {
    fn variants() -> slice::Iter<'static, PathPaymentStrictSendResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<PathPaymentStrictSendResultCode> for PathPaymentStrictSendResult {}

impl ReadXdr for PathPaymentStrictSendResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: PathPaymentStrictSendResultCode =
                <PathPaymentStrictSendResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendSuccess => {
                    Self::PathPaymentStrictSendSuccess(
                        PathPaymentStrictSendResultSuccess::read_xdr(r)?,
                    )
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendMalformed => {
                    Self::PathPaymentStrictSendMalformed
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderfunded => {
                    Self::PathPaymentStrictSendUnderfunded
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNoTrust => {
                    Self::PathPaymentStrictSendSrcNoTrust
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNotAuthorized => {
                    Self::PathPaymentStrictSendSrcNotAuthorized
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendNoDestination => {
                    Self::PathPaymentStrictSendNoDestination
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendNoTrust => {
                    Self::PathPaymentStrictSendNoTrust
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendNotAuthorized => {
                    Self::PathPaymentStrictSendNotAuthorized
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendLineFull => {
                    Self::PathPaymentStrictSendLineFull
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendNoIssuer => {
                    Self::PathPaymentStrictSendNoIssuer(Asset::read_xdr(r)?)
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendTooFewOffers => {
                    Self::PathPaymentStrictSendTooFewOffers
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendOfferCrossSelf => {
                    Self::PathPaymentStrictSendOfferCrossSelf
                }

                PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderDestmin => {
                    Self::PathPaymentStrictSendUnderDestmin
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PathPaymentStrictSendResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::PathPaymentStrictSendSuccess(v) => v.write_xdr(w)?,

                Self::PathPaymentStrictSendMalformed => ().write_xdr(w)?,

                Self::PathPaymentStrictSendUnderfunded => ().write_xdr(w)?,

                Self::PathPaymentStrictSendSrcNoTrust => ().write_xdr(w)?,

                Self::PathPaymentStrictSendSrcNotAuthorized => ().write_xdr(w)?,

                Self::PathPaymentStrictSendNoDestination => ().write_xdr(w)?,

                Self::PathPaymentStrictSendNoTrust => ().write_xdr(w)?,

                Self::PathPaymentStrictSendNotAuthorized => ().write_xdr(w)?,

                Self::PathPaymentStrictSendLineFull => ().write_xdr(w)?,

                Self::PathPaymentStrictSendNoIssuer(v) => v.write_xdr(w)?,

                Self::PathPaymentStrictSendTooFewOffers => ().write_xdr(w)?,

                Self::PathPaymentStrictSendOfferCrossSelf => ().write_xdr(w)?,

                Self::PathPaymentStrictSendUnderDestmin => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ManageSellOfferResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ManageSellOfferResultCode {
    #[cfg_attr(feature = "alloc", default)]
    ManageSellOfferSuccess = 0,

    ManageSellOfferMalformed = -1,

    ManageSellOfferSellNoTrust = -2,

    ManageSellOfferBuyNoTrust = -3,

    ManageSellOfferSellNotAuthorized = -4,

    ManageSellOfferBuyNotAuthorized = -5,

    ManageSellOfferLineFull = -6,

    ManageSellOfferUnderfunded = -7,

    ManageSellOfferCrossSelf = -8,

    ManageSellOfferSellNoIssuer = -9,

    ManageSellOfferBuyNoIssuer = -10,

    ManageSellOfferNotFound = -11,

    ManageSellOfferLowReserve = -12,
}

impl ManageSellOfferResultCode {
    pub const VARIANTS: [ManageSellOfferResultCode; 13] = [
        ManageSellOfferResultCode::ManageSellOfferSuccess,
        ManageSellOfferResultCode::ManageSellOfferMalformed,
        ManageSellOfferResultCode::ManageSellOfferSellNoTrust,
        ManageSellOfferResultCode::ManageSellOfferBuyNoTrust,
        ManageSellOfferResultCode::ManageSellOfferSellNotAuthorized,
        ManageSellOfferResultCode::ManageSellOfferBuyNotAuthorized,
        ManageSellOfferResultCode::ManageSellOfferLineFull,
        ManageSellOfferResultCode::ManageSellOfferUnderfunded,
        ManageSellOfferResultCode::ManageSellOfferCrossSelf,
        ManageSellOfferResultCode::ManageSellOfferSellNoIssuer,
        ManageSellOfferResultCode::ManageSellOfferBuyNoIssuer,
        ManageSellOfferResultCode::ManageSellOfferNotFound,
        ManageSellOfferResultCode::ManageSellOfferLowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "ManageSellOfferSuccess",
        "ManageSellOfferMalformed",
        "ManageSellOfferSellNoTrust",
        "ManageSellOfferBuyNoTrust",
        "ManageSellOfferSellNotAuthorized",
        "ManageSellOfferBuyNotAuthorized",
        "ManageSellOfferLineFull",
        "ManageSellOfferUnderfunded",
        "ManageSellOfferCrossSelf",
        "ManageSellOfferSellNoIssuer",
        "ManageSellOfferBuyNoIssuer",
        "ManageSellOfferNotFound",
        "ManageSellOfferLowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ManageSellOfferSuccess => "ManageSellOfferSuccess",

            Self::ManageSellOfferMalformed => "ManageSellOfferMalformed",

            Self::ManageSellOfferSellNoTrust => "ManageSellOfferSellNoTrust",

            Self::ManageSellOfferBuyNoTrust => "ManageSellOfferBuyNoTrust",

            Self::ManageSellOfferSellNotAuthorized => "ManageSellOfferSellNotAuthorized",

            Self::ManageSellOfferBuyNotAuthorized => "ManageSellOfferBuyNotAuthorized",

            Self::ManageSellOfferLineFull => "ManageSellOfferLineFull",

            Self::ManageSellOfferUnderfunded => "ManageSellOfferUnderfunded",

            Self::ManageSellOfferCrossSelf => "ManageSellOfferCrossSelf",

            Self::ManageSellOfferSellNoIssuer => "ManageSellOfferSellNoIssuer",

            Self::ManageSellOfferBuyNoIssuer => "ManageSellOfferBuyNoIssuer",

            Self::ManageSellOfferNotFound => "ManageSellOfferNotFound",

            Self::ManageSellOfferLowReserve => "ManageSellOfferLowReserve",
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageSellOfferResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for ManageSellOfferResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ManageSellOfferResultCode> for ManageSellOfferResultCode {
    fn variants() -> slice::Iter<'static, ManageSellOfferResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ManageSellOfferResultCode {}

impl fmt::Display for ManageSellOfferResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ManageSellOfferResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ManageSellOfferResultCode::ManageSellOfferSuccess,

            -1 => ManageSellOfferResultCode::ManageSellOfferMalformed,

            -2 => ManageSellOfferResultCode::ManageSellOfferSellNoTrust,

            -3 => ManageSellOfferResultCode::ManageSellOfferBuyNoTrust,

            -4 => ManageSellOfferResultCode::ManageSellOfferSellNotAuthorized,

            -5 => ManageSellOfferResultCode::ManageSellOfferBuyNotAuthorized,

            -6 => ManageSellOfferResultCode::ManageSellOfferLineFull,

            -7 => ManageSellOfferResultCode::ManageSellOfferUnderfunded,

            -8 => ManageSellOfferResultCode::ManageSellOfferCrossSelf,

            -9 => ManageSellOfferResultCode::ManageSellOfferSellNoIssuer,

            -10 => ManageSellOfferResultCode::ManageSellOfferBuyNoIssuer,

            -11 => ManageSellOfferResultCode::ManageSellOfferNotFound,

            -12 => ManageSellOfferResultCode::ManageSellOfferLowReserve,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ManageSellOfferResultCode> for i32 {
    #[must_use]
    fn from(e: ManageSellOfferResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ManageSellOfferResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ManageSellOfferResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ManageOfferEffect
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ManageOfferEffect {
    #[cfg_attr(feature = "alloc", default)]
    ManageOfferCreated = 0,

    ManageOfferUpdated = 1,

    ManageOfferDeleted = 2,
}

impl ManageOfferEffect {
    pub const VARIANTS: [ManageOfferEffect; 3] = [
        ManageOfferEffect::ManageOfferCreated,
        ManageOfferEffect::ManageOfferUpdated,
        ManageOfferEffect::ManageOfferDeleted,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "ManageOfferCreated",
        "ManageOfferUpdated",
        "ManageOfferDeleted",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ManageOfferCreated => "ManageOfferCreated",

            Self::ManageOfferUpdated => "ManageOfferUpdated",

            Self::ManageOfferDeleted => "ManageOfferDeleted",
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageOfferEffect; 3] {
        Self::VARIANTS
    }
}

impl Name for ManageOfferEffect {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ManageOfferEffect> for ManageOfferEffect {
    fn variants() -> slice::Iter<'static, ManageOfferEffect> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ManageOfferEffect {}

impl fmt::Display for ManageOfferEffect {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ManageOfferEffect {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ManageOfferEffect::ManageOfferCreated,

            1 => ManageOfferEffect::ManageOfferUpdated,

            2 => ManageOfferEffect::ManageOfferDeleted,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ManageOfferEffect> for i32 {
    #[must_use]
    fn from(e: ManageOfferEffect) -> Self {
        e as Self
    }
}

impl ReadXdr for ManageOfferEffect {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ManageOfferEffect {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ManageOfferSuccessResult
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ManageOfferSuccessResult {
    pub offers_claimed: VecM<ClaimAtom>,

    pub offer: ManageOfferSuccessResultOffer,
}

impl ReadXdr for ManageOfferSuccessResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                offers_claimed: VecM::<ClaimAtom>::read_xdr(r)?,

                offer: ManageOfferSuccessResultOffer::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ManageOfferSuccessResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.offers_claimed.write_xdr(w)?;

            self.offer.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ManageSellOfferResult
// union with discriminant ManageSellOfferResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ManageSellOfferResult {
    ManageSellOfferSuccess(ManageOfferSuccessResult),

    ManageSellOfferMalformed,

    ManageSellOfferSellNoTrust,

    ManageSellOfferBuyNoTrust,

    ManageSellOfferSellNotAuthorized,

    ManageSellOfferBuyNotAuthorized,

    ManageSellOfferLineFull,

    ManageSellOfferUnderfunded,

    ManageSellOfferCrossSelf,

    ManageSellOfferSellNoIssuer,

    ManageSellOfferBuyNoIssuer,

    ManageSellOfferNotFound,

    ManageSellOfferLowReserve,
}

#[cfg(feature = "alloc")]
impl Default for ManageSellOfferResult {
    fn default() -> Self {
        Self::ManageSellOfferSuccess(ManageOfferSuccessResult::default())
    }
}

impl ManageSellOfferResult {
    pub const VARIANTS: [ManageSellOfferResultCode; 13] = [
        ManageSellOfferResultCode::ManageSellOfferSuccess,
        ManageSellOfferResultCode::ManageSellOfferMalformed,
        ManageSellOfferResultCode::ManageSellOfferSellNoTrust,
        ManageSellOfferResultCode::ManageSellOfferBuyNoTrust,
        ManageSellOfferResultCode::ManageSellOfferSellNotAuthorized,
        ManageSellOfferResultCode::ManageSellOfferBuyNotAuthorized,
        ManageSellOfferResultCode::ManageSellOfferLineFull,
        ManageSellOfferResultCode::ManageSellOfferUnderfunded,
        ManageSellOfferResultCode::ManageSellOfferCrossSelf,
        ManageSellOfferResultCode::ManageSellOfferSellNoIssuer,
        ManageSellOfferResultCode::ManageSellOfferBuyNoIssuer,
        ManageSellOfferResultCode::ManageSellOfferNotFound,
        ManageSellOfferResultCode::ManageSellOfferLowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "ManageSellOfferSuccess",
        "ManageSellOfferMalformed",
        "ManageSellOfferSellNoTrust",
        "ManageSellOfferBuyNoTrust",
        "ManageSellOfferSellNotAuthorized",
        "ManageSellOfferBuyNotAuthorized",
        "ManageSellOfferLineFull",
        "ManageSellOfferUnderfunded",
        "ManageSellOfferCrossSelf",
        "ManageSellOfferSellNoIssuer",
        "ManageSellOfferBuyNoIssuer",
        "ManageSellOfferNotFound",
        "ManageSellOfferLowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ManageSellOfferSuccess(_) => "ManageSellOfferSuccess",

            Self::ManageSellOfferMalformed => "ManageSellOfferMalformed",

            Self::ManageSellOfferSellNoTrust => "ManageSellOfferSellNoTrust",

            Self::ManageSellOfferBuyNoTrust => "ManageSellOfferBuyNoTrust",

            Self::ManageSellOfferSellNotAuthorized => "ManageSellOfferSellNotAuthorized",

            Self::ManageSellOfferBuyNotAuthorized => "ManageSellOfferBuyNotAuthorized",

            Self::ManageSellOfferLineFull => "ManageSellOfferLineFull",

            Self::ManageSellOfferUnderfunded => "ManageSellOfferUnderfunded",

            Self::ManageSellOfferCrossSelf => "ManageSellOfferCrossSelf",

            Self::ManageSellOfferSellNoIssuer => "ManageSellOfferSellNoIssuer",

            Self::ManageSellOfferBuyNoIssuer => "ManageSellOfferBuyNoIssuer",

            Self::ManageSellOfferNotFound => "ManageSellOfferNotFound",

            Self::ManageSellOfferLowReserve => "ManageSellOfferLowReserve",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ManageSellOfferResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ManageSellOfferSuccess(_) => ManageSellOfferResultCode::ManageSellOfferSuccess,

            Self::ManageSellOfferMalformed => ManageSellOfferResultCode::ManageSellOfferMalformed,

            Self::ManageSellOfferSellNoTrust => {
                ManageSellOfferResultCode::ManageSellOfferSellNoTrust
            }

            Self::ManageSellOfferBuyNoTrust => ManageSellOfferResultCode::ManageSellOfferBuyNoTrust,

            Self::ManageSellOfferSellNotAuthorized => {
                ManageSellOfferResultCode::ManageSellOfferSellNotAuthorized
            }

            Self::ManageSellOfferBuyNotAuthorized => {
                ManageSellOfferResultCode::ManageSellOfferBuyNotAuthorized
            }

            Self::ManageSellOfferLineFull => ManageSellOfferResultCode::ManageSellOfferLineFull,

            Self::ManageSellOfferUnderfunded => {
                ManageSellOfferResultCode::ManageSellOfferUnderfunded
            }

            Self::ManageSellOfferCrossSelf => ManageSellOfferResultCode::ManageSellOfferCrossSelf,

            Self::ManageSellOfferSellNoIssuer => {
                ManageSellOfferResultCode::ManageSellOfferSellNoIssuer
            }

            Self::ManageSellOfferBuyNoIssuer => {
                ManageSellOfferResultCode::ManageSellOfferBuyNoIssuer
            }

            Self::ManageSellOfferNotFound => ManageSellOfferResultCode::ManageSellOfferNotFound,

            Self::ManageSellOfferLowReserve => ManageSellOfferResultCode::ManageSellOfferLowReserve,
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageSellOfferResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for ManageSellOfferResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ManageSellOfferResultCode> for ManageSellOfferResult {
    #[must_use]
    fn discriminant(&self) -> ManageSellOfferResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ManageSellOfferResultCode> for ManageSellOfferResult {
    fn variants() -> slice::Iter<'static, ManageSellOfferResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ManageSellOfferResultCode> for ManageSellOfferResult {}

impl ReadXdr for ManageSellOfferResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ManageSellOfferResultCode =
                <ManageSellOfferResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ManageSellOfferResultCode::ManageSellOfferSuccess => {
                    Self::ManageSellOfferSuccess(ManageOfferSuccessResult::read_xdr(r)?)
                }

                ManageSellOfferResultCode::ManageSellOfferMalformed => {
                    Self::ManageSellOfferMalformed
                }

                ManageSellOfferResultCode::ManageSellOfferSellNoTrust => {
                    Self::ManageSellOfferSellNoTrust
                }

                ManageSellOfferResultCode::ManageSellOfferBuyNoTrust => {
                    Self::ManageSellOfferBuyNoTrust
                }

                ManageSellOfferResultCode::ManageSellOfferSellNotAuthorized => {
                    Self::ManageSellOfferSellNotAuthorized
                }

                ManageSellOfferResultCode::ManageSellOfferBuyNotAuthorized => {
                    Self::ManageSellOfferBuyNotAuthorized
                }

                ManageSellOfferResultCode::ManageSellOfferLineFull => Self::ManageSellOfferLineFull,

                ManageSellOfferResultCode::ManageSellOfferUnderfunded => {
                    Self::ManageSellOfferUnderfunded
                }

                ManageSellOfferResultCode::ManageSellOfferCrossSelf => {
                    Self::ManageSellOfferCrossSelf
                }

                ManageSellOfferResultCode::ManageSellOfferSellNoIssuer => {
                    Self::ManageSellOfferSellNoIssuer
                }

                ManageSellOfferResultCode::ManageSellOfferBuyNoIssuer => {
                    Self::ManageSellOfferBuyNoIssuer
                }

                ManageSellOfferResultCode::ManageSellOfferNotFound => Self::ManageSellOfferNotFound,

                ManageSellOfferResultCode::ManageSellOfferLowReserve => {
                    Self::ManageSellOfferLowReserve
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ManageSellOfferResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ManageSellOfferSuccess(v) => v.write_xdr(w)?,

                Self::ManageSellOfferMalformed => ().write_xdr(w)?,

                Self::ManageSellOfferSellNoTrust => ().write_xdr(w)?,

                Self::ManageSellOfferBuyNoTrust => ().write_xdr(w)?,

                Self::ManageSellOfferSellNotAuthorized => ().write_xdr(w)?,

                Self::ManageSellOfferBuyNotAuthorized => ().write_xdr(w)?,

                Self::ManageSellOfferLineFull => ().write_xdr(w)?,

                Self::ManageSellOfferUnderfunded => ().write_xdr(w)?,

                Self::ManageSellOfferCrossSelf => ().write_xdr(w)?,

                Self::ManageSellOfferSellNoIssuer => ().write_xdr(w)?,

                Self::ManageSellOfferBuyNoIssuer => ().write_xdr(w)?,

                Self::ManageSellOfferNotFound => ().write_xdr(w)?,

                Self::ManageSellOfferLowReserve => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ManageBuyOfferResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ManageBuyOfferResultCode {
    #[cfg_attr(feature = "alloc", default)]
    ManageBuyOfferSuccess = 0,

    ManageBuyOfferMalformed = -1,

    ManageBuyOfferSellNoTrust = -2,

    ManageBuyOfferBuyNoTrust = -3,

    ManageBuyOfferSellNotAuthorized = -4,

    ManageBuyOfferBuyNotAuthorized = -5,

    ManageBuyOfferLineFull = -6,

    ManageBuyOfferUnderfunded = -7,

    ManageBuyOfferCrossSelf = -8,

    ManageBuyOfferSellNoIssuer = -9,

    ManageBuyOfferBuyNoIssuer = -10,

    ManageBuyOfferNotFound = -11,

    ManageBuyOfferLowReserve = -12,
}

impl ManageBuyOfferResultCode {
    pub const VARIANTS: [ManageBuyOfferResultCode; 13] = [
        ManageBuyOfferResultCode::ManageBuyOfferSuccess,
        ManageBuyOfferResultCode::ManageBuyOfferMalformed,
        ManageBuyOfferResultCode::ManageBuyOfferSellNoTrust,
        ManageBuyOfferResultCode::ManageBuyOfferBuyNoTrust,
        ManageBuyOfferResultCode::ManageBuyOfferSellNotAuthorized,
        ManageBuyOfferResultCode::ManageBuyOfferBuyNotAuthorized,
        ManageBuyOfferResultCode::ManageBuyOfferLineFull,
        ManageBuyOfferResultCode::ManageBuyOfferUnderfunded,
        ManageBuyOfferResultCode::ManageBuyOfferCrossSelf,
        ManageBuyOfferResultCode::ManageBuyOfferSellNoIssuer,
        ManageBuyOfferResultCode::ManageBuyOfferBuyNoIssuer,
        ManageBuyOfferResultCode::ManageBuyOfferNotFound,
        ManageBuyOfferResultCode::ManageBuyOfferLowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "ManageBuyOfferSuccess",
        "ManageBuyOfferMalformed",
        "ManageBuyOfferSellNoTrust",
        "ManageBuyOfferBuyNoTrust",
        "ManageBuyOfferSellNotAuthorized",
        "ManageBuyOfferBuyNotAuthorized",
        "ManageBuyOfferLineFull",
        "ManageBuyOfferUnderfunded",
        "ManageBuyOfferCrossSelf",
        "ManageBuyOfferSellNoIssuer",
        "ManageBuyOfferBuyNoIssuer",
        "ManageBuyOfferNotFound",
        "ManageBuyOfferLowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ManageBuyOfferSuccess => "ManageBuyOfferSuccess",

            Self::ManageBuyOfferMalformed => "ManageBuyOfferMalformed",

            Self::ManageBuyOfferSellNoTrust => "ManageBuyOfferSellNoTrust",

            Self::ManageBuyOfferBuyNoTrust => "ManageBuyOfferBuyNoTrust",

            Self::ManageBuyOfferSellNotAuthorized => "ManageBuyOfferSellNotAuthorized",

            Self::ManageBuyOfferBuyNotAuthorized => "ManageBuyOfferBuyNotAuthorized",

            Self::ManageBuyOfferLineFull => "ManageBuyOfferLineFull",

            Self::ManageBuyOfferUnderfunded => "ManageBuyOfferUnderfunded",

            Self::ManageBuyOfferCrossSelf => "ManageBuyOfferCrossSelf",

            Self::ManageBuyOfferSellNoIssuer => "ManageBuyOfferSellNoIssuer",

            Self::ManageBuyOfferBuyNoIssuer => "ManageBuyOfferBuyNoIssuer",

            Self::ManageBuyOfferNotFound => "ManageBuyOfferNotFound",

            Self::ManageBuyOfferLowReserve => "ManageBuyOfferLowReserve",
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageBuyOfferResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for ManageBuyOfferResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ManageBuyOfferResultCode> for ManageBuyOfferResultCode {
    fn variants() -> slice::Iter<'static, ManageBuyOfferResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ManageBuyOfferResultCode {}

impl fmt::Display for ManageBuyOfferResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ManageBuyOfferResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ManageBuyOfferResultCode::ManageBuyOfferSuccess,

            -1 => ManageBuyOfferResultCode::ManageBuyOfferMalformed,

            -2 => ManageBuyOfferResultCode::ManageBuyOfferSellNoTrust,

            -3 => ManageBuyOfferResultCode::ManageBuyOfferBuyNoTrust,

            -4 => ManageBuyOfferResultCode::ManageBuyOfferSellNotAuthorized,

            -5 => ManageBuyOfferResultCode::ManageBuyOfferBuyNotAuthorized,

            -6 => ManageBuyOfferResultCode::ManageBuyOfferLineFull,

            -7 => ManageBuyOfferResultCode::ManageBuyOfferUnderfunded,

            -8 => ManageBuyOfferResultCode::ManageBuyOfferCrossSelf,

            -9 => ManageBuyOfferResultCode::ManageBuyOfferSellNoIssuer,

            -10 => ManageBuyOfferResultCode::ManageBuyOfferBuyNoIssuer,

            -11 => ManageBuyOfferResultCode::ManageBuyOfferNotFound,

            -12 => ManageBuyOfferResultCode::ManageBuyOfferLowReserve,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ManageBuyOfferResultCode> for i32 {
    #[must_use]
    fn from(e: ManageBuyOfferResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ManageBuyOfferResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ManageBuyOfferResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ManageBuyOfferResult
// union with discriminant ManageBuyOfferResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ManageBuyOfferResult {
    ManageBuyOfferSuccess(ManageOfferSuccessResult),

    ManageBuyOfferMalformed,

    ManageBuyOfferSellNoTrust,

    ManageBuyOfferBuyNoTrust,

    ManageBuyOfferSellNotAuthorized,

    ManageBuyOfferBuyNotAuthorized,

    ManageBuyOfferLineFull,

    ManageBuyOfferUnderfunded,

    ManageBuyOfferCrossSelf,

    ManageBuyOfferSellNoIssuer,

    ManageBuyOfferBuyNoIssuer,

    ManageBuyOfferNotFound,

    ManageBuyOfferLowReserve,
}

#[cfg(feature = "alloc")]
impl Default for ManageBuyOfferResult {
    fn default() -> Self {
        Self::ManageBuyOfferSuccess(ManageOfferSuccessResult::default())
    }
}

impl ManageBuyOfferResult {
    pub const VARIANTS: [ManageBuyOfferResultCode; 13] = [
        ManageBuyOfferResultCode::ManageBuyOfferSuccess,
        ManageBuyOfferResultCode::ManageBuyOfferMalformed,
        ManageBuyOfferResultCode::ManageBuyOfferSellNoTrust,
        ManageBuyOfferResultCode::ManageBuyOfferBuyNoTrust,
        ManageBuyOfferResultCode::ManageBuyOfferSellNotAuthorized,
        ManageBuyOfferResultCode::ManageBuyOfferBuyNotAuthorized,
        ManageBuyOfferResultCode::ManageBuyOfferLineFull,
        ManageBuyOfferResultCode::ManageBuyOfferUnderfunded,
        ManageBuyOfferResultCode::ManageBuyOfferCrossSelf,
        ManageBuyOfferResultCode::ManageBuyOfferSellNoIssuer,
        ManageBuyOfferResultCode::ManageBuyOfferBuyNoIssuer,
        ManageBuyOfferResultCode::ManageBuyOfferNotFound,
        ManageBuyOfferResultCode::ManageBuyOfferLowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "ManageBuyOfferSuccess",
        "ManageBuyOfferMalformed",
        "ManageBuyOfferSellNoTrust",
        "ManageBuyOfferBuyNoTrust",
        "ManageBuyOfferSellNotAuthorized",
        "ManageBuyOfferBuyNotAuthorized",
        "ManageBuyOfferLineFull",
        "ManageBuyOfferUnderfunded",
        "ManageBuyOfferCrossSelf",
        "ManageBuyOfferSellNoIssuer",
        "ManageBuyOfferBuyNoIssuer",
        "ManageBuyOfferNotFound",
        "ManageBuyOfferLowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ManageBuyOfferSuccess(_) => "ManageBuyOfferSuccess",

            Self::ManageBuyOfferMalformed => "ManageBuyOfferMalformed",

            Self::ManageBuyOfferSellNoTrust => "ManageBuyOfferSellNoTrust",

            Self::ManageBuyOfferBuyNoTrust => "ManageBuyOfferBuyNoTrust",

            Self::ManageBuyOfferSellNotAuthorized => "ManageBuyOfferSellNotAuthorized",

            Self::ManageBuyOfferBuyNotAuthorized => "ManageBuyOfferBuyNotAuthorized",

            Self::ManageBuyOfferLineFull => "ManageBuyOfferLineFull",

            Self::ManageBuyOfferUnderfunded => "ManageBuyOfferUnderfunded",

            Self::ManageBuyOfferCrossSelf => "ManageBuyOfferCrossSelf",

            Self::ManageBuyOfferSellNoIssuer => "ManageBuyOfferSellNoIssuer",

            Self::ManageBuyOfferBuyNoIssuer => "ManageBuyOfferBuyNoIssuer",

            Self::ManageBuyOfferNotFound => "ManageBuyOfferNotFound",

            Self::ManageBuyOfferLowReserve => "ManageBuyOfferLowReserve",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ManageBuyOfferResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ManageBuyOfferSuccess(_) => ManageBuyOfferResultCode::ManageBuyOfferSuccess,

            Self::ManageBuyOfferMalformed => ManageBuyOfferResultCode::ManageBuyOfferMalformed,

            Self::ManageBuyOfferSellNoTrust => ManageBuyOfferResultCode::ManageBuyOfferSellNoTrust,

            Self::ManageBuyOfferBuyNoTrust => ManageBuyOfferResultCode::ManageBuyOfferBuyNoTrust,

            Self::ManageBuyOfferSellNotAuthorized => {
                ManageBuyOfferResultCode::ManageBuyOfferSellNotAuthorized
            }

            Self::ManageBuyOfferBuyNotAuthorized => {
                ManageBuyOfferResultCode::ManageBuyOfferBuyNotAuthorized
            }

            Self::ManageBuyOfferLineFull => ManageBuyOfferResultCode::ManageBuyOfferLineFull,

            Self::ManageBuyOfferUnderfunded => ManageBuyOfferResultCode::ManageBuyOfferUnderfunded,

            Self::ManageBuyOfferCrossSelf => ManageBuyOfferResultCode::ManageBuyOfferCrossSelf,

            Self::ManageBuyOfferSellNoIssuer => {
                ManageBuyOfferResultCode::ManageBuyOfferSellNoIssuer
            }

            Self::ManageBuyOfferBuyNoIssuer => ManageBuyOfferResultCode::ManageBuyOfferBuyNoIssuer,

            Self::ManageBuyOfferNotFound => ManageBuyOfferResultCode::ManageBuyOfferNotFound,

            Self::ManageBuyOfferLowReserve => ManageBuyOfferResultCode::ManageBuyOfferLowReserve,
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageBuyOfferResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for ManageBuyOfferResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ManageBuyOfferResultCode> for ManageBuyOfferResult {
    #[must_use]
    fn discriminant(&self) -> ManageBuyOfferResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ManageBuyOfferResultCode> for ManageBuyOfferResult {
    fn variants() -> slice::Iter<'static, ManageBuyOfferResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ManageBuyOfferResultCode> for ManageBuyOfferResult {}

impl ReadXdr for ManageBuyOfferResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ManageBuyOfferResultCode = <ManageBuyOfferResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ManageBuyOfferResultCode::ManageBuyOfferSuccess => {
                    Self::ManageBuyOfferSuccess(ManageOfferSuccessResult::read_xdr(r)?)
                }

                ManageBuyOfferResultCode::ManageBuyOfferMalformed => Self::ManageBuyOfferMalformed,

                ManageBuyOfferResultCode::ManageBuyOfferSellNoTrust => {
                    Self::ManageBuyOfferSellNoTrust
                }

                ManageBuyOfferResultCode::ManageBuyOfferBuyNoTrust => {
                    Self::ManageBuyOfferBuyNoTrust
                }

                ManageBuyOfferResultCode::ManageBuyOfferSellNotAuthorized => {
                    Self::ManageBuyOfferSellNotAuthorized
                }

                ManageBuyOfferResultCode::ManageBuyOfferBuyNotAuthorized => {
                    Self::ManageBuyOfferBuyNotAuthorized
                }

                ManageBuyOfferResultCode::ManageBuyOfferLineFull => Self::ManageBuyOfferLineFull,

                ManageBuyOfferResultCode::ManageBuyOfferUnderfunded => {
                    Self::ManageBuyOfferUnderfunded
                }

                ManageBuyOfferResultCode::ManageBuyOfferCrossSelf => Self::ManageBuyOfferCrossSelf,

                ManageBuyOfferResultCode::ManageBuyOfferSellNoIssuer => {
                    Self::ManageBuyOfferSellNoIssuer
                }

                ManageBuyOfferResultCode::ManageBuyOfferBuyNoIssuer => {
                    Self::ManageBuyOfferBuyNoIssuer
                }

                ManageBuyOfferResultCode::ManageBuyOfferNotFound => Self::ManageBuyOfferNotFound,

                ManageBuyOfferResultCode::ManageBuyOfferLowReserve => {
                    Self::ManageBuyOfferLowReserve
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ManageBuyOfferResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ManageBuyOfferSuccess(v) => v.write_xdr(w)?,

                Self::ManageBuyOfferMalformed => ().write_xdr(w)?,

                Self::ManageBuyOfferSellNoTrust => ().write_xdr(w)?,

                Self::ManageBuyOfferBuyNoTrust => ().write_xdr(w)?,

                Self::ManageBuyOfferSellNotAuthorized => ().write_xdr(w)?,

                Self::ManageBuyOfferBuyNotAuthorized => ().write_xdr(w)?,

                Self::ManageBuyOfferLineFull => ().write_xdr(w)?,

                Self::ManageBuyOfferUnderfunded => ().write_xdr(w)?,

                Self::ManageBuyOfferCrossSelf => ().write_xdr(w)?,

                Self::ManageBuyOfferSellNoIssuer => ().write_xdr(w)?,

                Self::ManageBuyOfferBuyNoIssuer => ().write_xdr(w)?,

                Self::ManageBuyOfferNotFound => ().write_xdr(w)?,

                Self::ManageBuyOfferLowReserve => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SetOptionsResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum SetOptionsResultCode {
    #[cfg_attr(feature = "alloc", default)]
    SetOptionsSuccess = 0,

    SetOptionsLowReserve = -1,

    SetOptionsTooManySigners = -2,

    SetOptionsBadFlags = -3,

    SetOptionsInvalidInflation = -4,

    SetOptionsCantChange = -5,

    SetOptionsUnknownFlag = -6,

    SetOptionsThresholdOutOfRange = -7,

    SetOptionsBadSigner = -8,

    SetOptionsInvalidHomeDomain = -9,

    SetOptionsAuthRevocableRequired = -10,
}

impl SetOptionsResultCode {
    pub const VARIANTS: [SetOptionsResultCode; 11] = [
        SetOptionsResultCode::SetOptionsSuccess,
        SetOptionsResultCode::SetOptionsLowReserve,
        SetOptionsResultCode::SetOptionsTooManySigners,
        SetOptionsResultCode::SetOptionsBadFlags,
        SetOptionsResultCode::SetOptionsInvalidInflation,
        SetOptionsResultCode::SetOptionsCantChange,
        SetOptionsResultCode::SetOptionsUnknownFlag,
        SetOptionsResultCode::SetOptionsThresholdOutOfRange,
        SetOptionsResultCode::SetOptionsBadSigner,
        SetOptionsResultCode::SetOptionsInvalidHomeDomain,
        SetOptionsResultCode::SetOptionsAuthRevocableRequired,
    ];
    pub const VARIANTS_STR: [&'static str; 11] = [
        "SetOptionsSuccess",
        "SetOptionsLowReserve",
        "SetOptionsTooManySigners",
        "SetOptionsBadFlags",
        "SetOptionsInvalidInflation",
        "SetOptionsCantChange",
        "SetOptionsUnknownFlag",
        "SetOptionsThresholdOutOfRange",
        "SetOptionsBadSigner",
        "SetOptionsInvalidHomeDomain",
        "SetOptionsAuthRevocableRequired",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SetOptionsSuccess => "SetOptionsSuccess",

            Self::SetOptionsLowReserve => "SetOptionsLowReserve",

            Self::SetOptionsTooManySigners => "SetOptionsTooManySigners",

            Self::SetOptionsBadFlags => "SetOptionsBadFlags",

            Self::SetOptionsInvalidInflation => "SetOptionsInvalidInflation",

            Self::SetOptionsCantChange => "SetOptionsCantChange",

            Self::SetOptionsUnknownFlag => "SetOptionsUnknownFlag",

            Self::SetOptionsThresholdOutOfRange => "SetOptionsThresholdOutOfRange",

            Self::SetOptionsBadSigner => "SetOptionsBadSigner",

            Self::SetOptionsInvalidHomeDomain => "SetOptionsInvalidHomeDomain",

            Self::SetOptionsAuthRevocableRequired => "SetOptionsAuthRevocableRequired",
        }
    }

    #[must_use]
    pub const fn variants() -> [SetOptionsResultCode; 11] {
        Self::VARIANTS
    }
}

impl Name for SetOptionsResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SetOptionsResultCode> for SetOptionsResultCode {
    fn variants() -> slice::Iter<'static, SetOptionsResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SetOptionsResultCode {}

impl fmt::Display for SetOptionsResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SetOptionsResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => SetOptionsResultCode::SetOptionsSuccess,

            -1 => SetOptionsResultCode::SetOptionsLowReserve,

            -2 => SetOptionsResultCode::SetOptionsTooManySigners,

            -3 => SetOptionsResultCode::SetOptionsBadFlags,

            -4 => SetOptionsResultCode::SetOptionsInvalidInflation,

            -5 => SetOptionsResultCode::SetOptionsCantChange,

            -6 => SetOptionsResultCode::SetOptionsUnknownFlag,

            -7 => SetOptionsResultCode::SetOptionsThresholdOutOfRange,

            -8 => SetOptionsResultCode::SetOptionsBadSigner,

            -9 => SetOptionsResultCode::SetOptionsInvalidHomeDomain,

            -10 => SetOptionsResultCode::SetOptionsAuthRevocableRequired,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SetOptionsResultCode> for i32 {
    #[must_use]
    fn from(e: SetOptionsResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for SetOptionsResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SetOptionsResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SetOptionsResult
// union with discriminant SetOptionsResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum SetOptionsResult {
    SetOptionsSuccess,

    SetOptionsLowReserve,

    SetOptionsTooManySigners,

    SetOptionsBadFlags,

    SetOptionsInvalidInflation,

    SetOptionsCantChange,

    SetOptionsUnknownFlag,

    SetOptionsThresholdOutOfRange,

    SetOptionsBadSigner,

    SetOptionsInvalidHomeDomain,

    SetOptionsAuthRevocableRequired,
}

#[cfg(feature = "alloc")]
impl Default for SetOptionsResult {
    fn default() -> Self {
        Self::SetOptionsSuccess
    }
}

impl SetOptionsResult {
    pub const VARIANTS: [SetOptionsResultCode; 11] = [
        SetOptionsResultCode::SetOptionsSuccess,
        SetOptionsResultCode::SetOptionsLowReserve,
        SetOptionsResultCode::SetOptionsTooManySigners,
        SetOptionsResultCode::SetOptionsBadFlags,
        SetOptionsResultCode::SetOptionsInvalidInflation,
        SetOptionsResultCode::SetOptionsCantChange,
        SetOptionsResultCode::SetOptionsUnknownFlag,
        SetOptionsResultCode::SetOptionsThresholdOutOfRange,
        SetOptionsResultCode::SetOptionsBadSigner,
        SetOptionsResultCode::SetOptionsInvalidHomeDomain,
        SetOptionsResultCode::SetOptionsAuthRevocableRequired,
    ];
    pub const VARIANTS_STR: [&'static str; 11] = [
        "SetOptionsSuccess",
        "SetOptionsLowReserve",
        "SetOptionsTooManySigners",
        "SetOptionsBadFlags",
        "SetOptionsInvalidInflation",
        "SetOptionsCantChange",
        "SetOptionsUnknownFlag",
        "SetOptionsThresholdOutOfRange",
        "SetOptionsBadSigner",
        "SetOptionsInvalidHomeDomain",
        "SetOptionsAuthRevocableRequired",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SetOptionsSuccess => "SetOptionsSuccess",

            Self::SetOptionsLowReserve => "SetOptionsLowReserve",

            Self::SetOptionsTooManySigners => "SetOptionsTooManySigners",

            Self::SetOptionsBadFlags => "SetOptionsBadFlags",

            Self::SetOptionsInvalidInflation => "SetOptionsInvalidInflation",

            Self::SetOptionsCantChange => "SetOptionsCantChange",

            Self::SetOptionsUnknownFlag => "SetOptionsUnknownFlag",

            Self::SetOptionsThresholdOutOfRange => "SetOptionsThresholdOutOfRange",

            Self::SetOptionsBadSigner => "SetOptionsBadSigner",

            Self::SetOptionsInvalidHomeDomain => "SetOptionsInvalidHomeDomain",

            Self::SetOptionsAuthRevocableRequired => "SetOptionsAuthRevocableRequired",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SetOptionsResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::SetOptionsSuccess => SetOptionsResultCode::SetOptionsSuccess,

            Self::SetOptionsLowReserve => SetOptionsResultCode::SetOptionsLowReserve,

            Self::SetOptionsTooManySigners => SetOptionsResultCode::SetOptionsTooManySigners,

            Self::SetOptionsBadFlags => SetOptionsResultCode::SetOptionsBadFlags,

            Self::SetOptionsInvalidInflation => SetOptionsResultCode::SetOptionsInvalidInflation,

            Self::SetOptionsCantChange => SetOptionsResultCode::SetOptionsCantChange,

            Self::SetOptionsUnknownFlag => SetOptionsResultCode::SetOptionsUnknownFlag,

            Self::SetOptionsThresholdOutOfRange => {
                SetOptionsResultCode::SetOptionsThresholdOutOfRange
            }

            Self::SetOptionsBadSigner => SetOptionsResultCode::SetOptionsBadSigner,

            Self::SetOptionsInvalidHomeDomain => SetOptionsResultCode::SetOptionsInvalidHomeDomain,

            Self::SetOptionsAuthRevocableRequired => {
                SetOptionsResultCode::SetOptionsAuthRevocableRequired
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [SetOptionsResultCode; 11] {
        Self::VARIANTS
    }
}

impl Name for SetOptionsResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SetOptionsResultCode> for SetOptionsResult {
    #[must_use]
    fn discriminant(&self) -> SetOptionsResultCode {
        Self::discriminant(self)
    }
}

impl Variants<SetOptionsResultCode> for SetOptionsResult {
    fn variants() -> slice::Iter<'static, SetOptionsResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<SetOptionsResultCode> for SetOptionsResult {}

impl ReadXdr for SetOptionsResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: SetOptionsResultCode = <SetOptionsResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                SetOptionsResultCode::SetOptionsSuccess => Self::SetOptionsSuccess,

                SetOptionsResultCode::SetOptionsLowReserve => Self::SetOptionsLowReserve,

                SetOptionsResultCode::SetOptionsTooManySigners => Self::SetOptionsTooManySigners,

                SetOptionsResultCode::SetOptionsBadFlags => Self::SetOptionsBadFlags,

                SetOptionsResultCode::SetOptionsInvalidInflation => {
                    Self::SetOptionsInvalidInflation
                }

                SetOptionsResultCode::SetOptionsCantChange => Self::SetOptionsCantChange,

                SetOptionsResultCode::SetOptionsUnknownFlag => Self::SetOptionsUnknownFlag,

                SetOptionsResultCode::SetOptionsThresholdOutOfRange => {
                    Self::SetOptionsThresholdOutOfRange
                }

                SetOptionsResultCode::SetOptionsBadSigner => Self::SetOptionsBadSigner,

                SetOptionsResultCode::SetOptionsInvalidHomeDomain => {
                    Self::SetOptionsInvalidHomeDomain
                }

                SetOptionsResultCode::SetOptionsAuthRevocableRequired => {
                    Self::SetOptionsAuthRevocableRequired
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SetOptionsResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::SetOptionsSuccess => ().write_xdr(w)?,

                Self::SetOptionsLowReserve => ().write_xdr(w)?,

                Self::SetOptionsTooManySigners => ().write_xdr(w)?,

                Self::SetOptionsBadFlags => ().write_xdr(w)?,

                Self::SetOptionsInvalidInflation => ().write_xdr(w)?,

                Self::SetOptionsCantChange => ().write_xdr(w)?,

                Self::SetOptionsUnknownFlag => ().write_xdr(w)?,

                Self::SetOptionsThresholdOutOfRange => ().write_xdr(w)?,

                Self::SetOptionsBadSigner => ().write_xdr(w)?,

                Self::SetOptionsInvalidHomeDomain => ().write_xdr(w)?,

                Self::SetOptionsAuthRevocableRequired => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ChangeTrustResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ChangeTrustResultCode {
    #[cfg_attr(feature = "alloc", default)]
    ChangeTrustSuccess = 0,

    ChangeTrustMalformed = -1,

    ChangeTrustNoIssuer = -2,

    ChangeTrustInvalidLimit = -3,

    ChangeTrustLowReserve = -4,

    ChangeTrustSelfNotAllowed = -5,

    ChangeTrustTrustLineMissing = -6,

    ChangeTrustCannotDelete = -7,

    ChangeTrustNotAuthMaintainLiabilities = -8,
}

impl ChangeTrustResultCode {
    pub const VARIANTS: [ChangeTrustResultCode; 9] = [
        ChangeTrustResultCode::ChangeTrustSuccess,
        ChangeTrustResultCode::ChangeTrustMalformed,
        ChangeTrustResultCode::ChangeTrustNoIssuer,
        ChangeTrustResultCode::ChangeTrustInvalidLimit,
        ChangeTrustResultCode::ChangeTrustLowReserve,
        ChangeTrustResultCode::ChangeTrustSelfNotAllowed,
        ChangeTrustResultCode::ChangeTrustTrustLineMissing,
        ChangeTrustResultCode::ChangeTrustCannotDelete,
        ChangeTrustResultCode::ChangeTrustNotAuthMaintainLiabilities,
    ];
    pub const VARIANTS_STR: [&'static str; 9] = [
        "ChangeTrustSuccess",
        "ChangeTrustMalformed",
        "ChangeTrustNoIssuer",
        "ChangeTrustInvalidLimit",
        "ChangeTrustLowReserve",
        "ChangeTrustSelfNotAllowed",
        "ChangeTrustTrustLineMissing",
        "ChangeTrustCannotDelete",
        "ChangeTrustNotAuthMaintainLiabilities",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ChangeTrustSuccess => "ChangeTrustSuccess",

            Self::ChangeTrustMalformed => "ChangeTrustMalformed",

            Self::ChangeTrustNoIssuer => "ChangeTrustNoIssuer",

            Self::ChangeTrustInvalidLimit => "ChangeTrustInvalidLimit",

            Self::ChangeTrustLowReserve => "ChangeTrustLowReserve",

            Self::ChangeTrustSelfNotAllowed => "ChangeTrustSelfNotAllowed",

            Self::ChangeTrustTrustLineMissing => "ChangeTrustTrustLineMissing",

            Self::ChangeTrustCannotDelete => "ChangeTrustCannotDelete",

            Self::ChangeTrustNotAuthMaintainLiabilities => "ChangeTrustNotAuthMaintainLiabilities",
        }
    }

    #[must_use]
    pub const fn variants() -> [ChangeTrustResultCode; 9] {
        Self::VARIANTS
    }
}

impl Name for ChangeTrustResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ChangeTrustResultCode> for ChangeTrustResultCode {
    fn variants() -> slice::Iter<'static, ChangeTrustResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ChangeTrustResultCode {}

impl fmt::Display for ChangeTrustResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ChangeTrustResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ChangeTrustResultCode::ChangeTrustSuccess,

            -1 => ChangeTrustResultCode::ChangeTrustMalformed,

            -2 => ChangeTrustResultCode::ChangeTrustNoIssuer,

            -3 => ChangeTrustResultCode::ChangeTrustInvalidLimit,

            -4 => ChangeTrustResultCode::ChangeTrustLowReserve,

            -5 => ChangeTrustResultCode::ChangeTrustSelfNotAllowed,

            -6 => ChangeTrustResultCode::ChangeTrustTrustLineMissing,

            -7 => ChangeTrustResultCode::ChangeTrustCannotDelete,

            -8 => ChangeTrustResultCode::ChangeTrustNotAuthMaintainLiabilities,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ChangeTrustResultCode> for i32 {
    #[must_use]
    fn from(e: ChangeTrustResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ChangeTrustResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ChangeTrustResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ChangeTrustResult
// union with discriminant ChangeTrustResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ChangeTrustResult {
    ChangeTrustSuccess,

    ChangeTrustMalformed,

    ChangeTrustNoIssuer,

    ChangeTrustInvalidLimit,

    ChangeTrustLowReserve,

    ChangeTrustSelfNotAllowed,

    ChangeTrustTrustLineMissing,

    ChangeTrustCannotDelete,

    ChangeTrustNotAuthMaintainLiabilities,
}

#[cfg(feature = "alloc")]
impl Default for ChangeTrustResult {
    fn default() -> Self {
        Self::ChangeTrustSuccess
    }
}

impl ChangeTrustResult {
    pub const VARIANTS: [ChangeTrustResultCode; 9] = [
        ChangeTrustResultCode::ChangeTrustSuccess,
        ChangeTrustResultCode::ChangeTrustMalformed,
        ChangeTrustResultCode::ChangeTrustNoIssuer,
        ChangeTrustResultCode::ChangeTrustInvalidLimit,
        ChangeTrustResultCode::ChangeTrustLowReserve,
        ChangeTrustResultCode::ChangeTrustSelfNotAllowed,
        ChangeTrustResultCode::ChangeTrustTrustLineMissing,
        ChangeTrustResultCode::ChangeTrustCannotDelete,
        ChangeTrustResultCode::ChangeTrustNotAuthMaintainLiabilities,
    ];
    pub const VARIANTS_STR: [&'static str; 9] = [
        "ChangeTrustSuccess",
        "ChangeTrustMalformed",
        "ChangeTrustNoIssuer",
        "ChangeTrustInvalidLimit",
        "ChangeTrustLowReserve",
        "ChangeTrustSelfNotAllowed",
        "ChangeTrustTrustLineMissing",
        "ChangeTrustCannotDelete",
        "ChangeTrustNotAuthMaintainLiabilities",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ChangeTrustSuccess => "ChangeTrustSuccess",

            Self::ChangeTrustMalformed => "ChangeTrustMalformed",

            Self::ChangeTrustNoIssuer => "ChangeTrustNoIssuer",

            Self::ChangeTrustInvalidLimit => "ChangeTrustInvalidLimit",

            Self::ChangeTrustLowReserve => "ChangeTrustLowReserve",

            Self::ChangeTrustSelfNotAllowed => "ChangeTrustSelfNotAllowed",

            Self::ChangeTrustTrustLineMissing => "ChangeTrustTrustLineMissing",

            Self::ChangeTrustCannotDelete => "ChangeTrustCannotDelete",

            Self::ChangeTrustNotAuthMaintainLiabilities => "ChangeTrustNotAuthMaintainLiabilities",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ChangeTrustResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ChangeTrustSuccess => ChangeTrustResultCode::ChangeTrustSuccess,

            Self::ChangeTrustMalformed => ChangeTrustResultCode::ChangeTrustMalformed,

            Self::ChangeTrustNoIssuer => ChangeTrustResultCode::ChangeTrustNoIssuer,

            Self::ChangeTrustInvalidLimit => ChangeTrustResultCode::ChangeTrustInvalidLimit,

            Self::ChangeTrustLowReserve => ChangeTrustResultCode::ChangeTrustLowReserve,

            Self::ChangeTrustSelfNotAllowed => ChangeTrustResultCode::ChangeTrustSelfNotAllowed,

            Self::ChangeTrustTrustLineMissing => ChangeTrustResultCode::ChangeTrustTrustLineMissing,

            Self::ChangeTrustCannotDelete => ChangeTrustResultCode::ChangeTrustCannotDelete,

            Self::ChangeTrustNotAuthMaintainLiabilities => {
                ChangeTrustResultCode::ChangeTrustNotAuthMaintainLiabilities
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [ChangeTrustResultCode; 9] {
        Self::VARIANTS
    }
}

impl Name for ChangeTrustResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ChangeTrustResultCode> for ChangeTrustResult {
    #[must_use]
    fn discriminant(&self) -> ChangeTrustResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ChangeTrustResultCode> for ChangeTrustResult {
    fn variants() -> slice::Iter<'static, ChangeTrustResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ChangeTrustResultCode> for ChangeTrustResult {}

impl ReadXdr for ChangeTrustResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ChangeTrustResultCode = <ChangeTrustResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ChangeTrustResultCode::ChangeTrustSuccess => Self::ChangeTrustSuccess,

                ChangeTrustResultCode::ChangeTrustMalformed => Self::ChangeTrustMalformed,

                ChangeTrustResultCode::ChangeTrustNoIssuer => Self::ChangeTrustNoIssuer,

                ChangeTrustResultCode::ChangeTrustInvalidLimit => Self::ChangeTrustInvalidLimit,

                ChangeTrustResultCode::ChangeTrustLowReserve => Self::ChangeTrustLowReserve,

                ChangeTrustResultCode::ChangeTrustSelfNotAllowed => Self::ChangeTrustSelfNotAllowed,

                ChangeTrustResultCode::ChangeTrustTrustLineMissing => {
                    Self::ChangeTrustTrustLineMissing
                }

                ChangeTrustResultCode::ChangeTrustCannotDelete => Self::ChangeTrustCannotDelete,

                ChangeTrustResultCode::ChangeTrustNotAuthMaintainLiabilities => {
                    Self::ChangeTrustNotAuthMaintainLiabilities
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ChangeTrustResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ChangeTrustSuccess => ().write_xdr(w)?,

                Self::ChangeTrustMalformed => ().write_xdr(w)?,

                Self::ChangeTrustNoIssuer => ().write_xdr(w)?,

                Self::ChangeTrustInvalidLimit => ().write_xdr(w)?,

                Self::ChangeTrustLowReserve => ().write_xdr(w)?,

                Self::ChangeTrustSelfNotAllowed => ().write_xdr(w)?,

                Self::ChangeTrustTrustLineMissing => ().write_xdr(w)?,

                Self::ChangeTrustCannotDelete => ().write_xdr(w)?,

                Self::ChangeTrustNotAuthMaintainLiabilities => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AllowTrustResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum AllowTrustResultCode {
    #[cfg_attr(feature = "alloc", default)]
    AllowTrustSuccess = 0,

    AllowTrustMalformed = -1,

    AllowTrustNoTrustLine = -2,

    AllowTrustTrustNotRequired = -3,

    AllowTrustCantRevoke = -4,

    AllowTrustSelfNotAllowed = -5,

    AllowTrustLowReserve = -6,
}

impl AllowTrustResultCode {
    pub const VARIANTS: [AllowTrustResultCode; 7] = [
        AllowTrustResultCode::AllowTrustSuccess,
        AllowTrustResultCode::AllowTrustMalformed,
        AllowTrustResultCode::AllowTrustNoTrustLine,
        AllowTrustResultCode::AllowTrustTrustNotRequired,
        AllowTrustResultCode::AllowTrustCantRevoke,
        AllowTrustResultCode::AllowTrustSelfNotAllowed,
        AllowTrustResultCode::AllowTrustLowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "AllowTrustSuccess",
        "AllowTrustMalformed",
        "AllowTrustNoTrustLine",
        "AllowTrustTrustNotRequired",
        "AllowTrustCantRevoke",
        "AllowTrustSelfNotAllowed",
        "AllowTrustLowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AllowTrustSuccess => "AllowTrustSuccess",

            Self::AllowTrustMalformed => "AllowTrustMalformed",

            Self::AllowTrustNoTrustLine => "AllowTrustNoTrustLine",

            Self::AllowTrustTrustNotRequired => "AllowTrustTrustNotRequired",

            Self::AllowTrustCantRevoke => "AllowTrustCantRevoke",

            Self::AllowTrustSelfNotAllowed => "AllowTrustSelfNotAllowed",

            Self::AllowTrustLowReserve => "AllowTrustLowReserve",
        }
    }

    #[must_use]
    pub const fn variants() -> [AllowTrustResultCode; 7] {
        Self::VARIANTS
    }
}

impl Name for AllowTrustResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<AllowTrustResultCode> for AllowTrustResultCode {
    fn variants() -> slice::Iter<'static, AllowTrustResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for AllowTrustResultCode {}

impl fmt::Display for AllowTrustResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for AllowTrustResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => AllowTrustResultCode::AllowTrustSuccess,

            -1 => AllowTrustResultCode::AllowTrustMalformed,

            -2 => AllowTrustResultCode::AllowTrustNoTrustLine,

            -3 => AllowTrustResultCode::AllowTrustTrustNotRequired,

            -4 => AllowTrustResultCode::AllowTrustCantRevoke,

            -5 => AllowTrustResultCode::AllowTrustSelfNotAllowed,

            -6 => AllowTrustResultCode::AllowTrustLowReserve,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<AllowTrustResultCode> for i32 {
    #[must_use]
    fn from(e: AllowTrustResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for AllowTrustResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for AllowTrustResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// AllowTrustResult
// union with discriminant AllowTrustResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum AllowTrustResult {
    AllowTrustSuccess,

    AllowTrustMalformed,

    AllowTrustNoTrustLine,

    AllowTrustTrustNotRequired,

    AllowTrustCantRevoke,

    AllowTrustSelfNotAllowed,

    AllowTrustLowReserve,
}

#[cfg(feature = "alloc")]
impl Default for AllowTrustResult {
    fn default() -> Self {
        Self::AllowTrustSuccess
    }
}

impl AllowTrustResult {
    pub const VARIANTS: [AllowTrustResultCode; 7] = [
        AllowTrustResultCode::AllowTrustSuccess,
        AllowTrustResultCode::AllowTrustMalformed,
        AllowTrustResultCode::AllowTrustNoTrustLine,
        AllowTrustResultCode::AllowTrustTrustNotRequired,
        AllowTrustResultCode::AllowTrustCantRevoke,
        AllowTrustResultCode::AllowTrustSelfNotAllowed,
        AllowTrustResultCode::AllowTrustLowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "AllowTrustSuccess",
        "AllowTrustMalformed",
        "AllowTrustNoTrustLine",
        "AllowTrustTrustNotRequired",
        "AllowTrustCantRevoke",
        "AllowTrustSelfNotAllowed",
        "AllowTrustLowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AllowTrustSuccess => "AllowTrustSuccess",

            Self::AllowTrustMalformed => "AllowTrustMalformed",

            Self::AllowTrustNoTrustLine => "AllowTrustNoTrustLine",

            Self::AllowTrustTrustNotRequired => "AllowTrustTrustNotRequired",

            Self::AllowTrustCantRevoke => "AllowTrustCantRevoke",

            Self::AllowTrustSelfNotAllowed => "AllowTrustSelfNotAllowed",

            Self::AllowTrustLowReserve => "AllowTrustLowReserve",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AllowTrustResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::AllowTrustSuccess => AllowTrustResultCode::AllowTrustSuccess,

            Self::AllowTrustMalformed => AllowTrustResultCode::AllowTrustMalformed,

            Self::AllowTrustNoTrustLine => AllowTrustResultCode::AllowTrustNoTrustLine,

            Self::AllowTrustTrustNotRequired => AllowTrustResultCode::AllowTrustTrustNotRequired,

            Self::AllowTrustCantRevoke => AllowTrustResultCode::AllowTrustCantRevoke,

            Self::AllowTrustSelfNotAllowed => AllowTrustResultCode::AllowTrustSelfNotAllowed,

            Self::AllowTrustLowReserve => AllowTrustResultCode::AllowTrustLowReserve,
        }
    }

    #[must_use]
    pub const fn variants() -> [AllowTrustResultCode; 7] {
        Self::VARIANTS
    }
}

impl Name for AllowTrustResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AllowTrustResultCode> for AllowTrustResult {
    #[must_use]
    fn discriminant(&self) -> AllowTrustResultCode {
        Self::discriminant(self)
    }
}

impl Variants<AllowTrustResultCode> for AllowTrustResult {
    fn variants() -> slice::Iter<'static, AllowTrustResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<AllowTrustResultCode> for AllowTrustResult {}

impl ReadXdr for AllowTrustResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: AllowTrustResultCode = <AllowTrustResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AllowTrustResultCode::AllowTrustSuccess => Self::AllowTrustSuccess,

                AllowTrustResultCode::AllowTrustMalformed => Self::AllowTrustMalformed,

                AllowTrustResultCode::AllowTrustNoTrustLine => Self::AllowTrustNoTrustLine,

                AllowTrustResultCode::AllowTrustTrustNotRequired => {
                    Self::AllowTrustTrustNotRequired
                }

                AllowTrustResultCode::AllowTrustCantRevoke => Self::AllowTrustCantRevoke,

                AllowTrustResultCode::AllowTrustSelfNotAllowed => Self::AllowTrustSelfNotAllowed,

                AllowTrustResultCode::AllowTrustLowReserve => Self::AllowTrustLowReserve,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AllowTrustResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::AllowTrustSuccess => ().write_xdr(w)?,

                Self::AllowTrustMalformed => ().write_xdr(w)?,

                Self::AllowTrustNoTrustLine => ().write_xdr(w)?,

                Self::AllowTrustTrustNotRequired => ().write_xdr(w)?,

                Self::AllowTrustCantRevoke => ().write_xdr(w)?,

                Self::AllowTrustSelfNotAllowed => ().write_xdr(w)?,

                Self::AllowTrustLowReserve => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AccountMergeResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum AccountMergeResultCode {
    #[cfg_attr(feature = "alloc", default)]
    AccountMergeSuccess = 0,

    AccountMergeMalformed = -1,

    AccountMergeNoAccount = -2,

    AccountMergeImmutableSet = -3,

    AccountMergeHasSubEntries = -4,

    AccountMergeSeqnumTooFar = -5,

    AccountMergeDestFull = -6,

    AccountMergeIsSponsor = -7,
}

impl AccountMergeResultCode {
    pub const VARIANTS: [AccountMergeResultCode; 8] = [
        AccountMergeResultCode::AccountMergeSuccess,
        AccountMergeResultCode::AccountMergeMalformed,
        AccountMergeResultCode::AccountMergeNoAccount,
        AccountMergeResultCode::AccountMergeImmutableSet,
        AccountMergeResultCode::AccountMergeHasSubEntries,
        AccountMergeResultCode::AccountMergeSeqnumTooFar,
        AccountMergeResultCode::AccountMergeDestFull,
        AccountMergeResultCode::AccountMergeIsSponsor,
    ];
    pub const VARIANTS_STR: [&'static str; 8] = [
        "AccountMergeSuccess",
        "AccountMergeMalformed",
        "AccountMergeNoAccount",
        "AccountMergeImmutableSet",
        "AccountMergeHasSubEntries",
        "AccountMergeSeqnumTooFar",
        "AccountMergeDestFull",
        "AccountMergeIsSponsor",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AccountMergeSuccess => "AccountMergeSuccess",

            Self::AccountMergeMalformed => "AccountMergeMalformed",

            Self::AccountMergeNoAccount => "AccountMergeNoAccount",

            Self::AccountMergeImmutableSet => "AccountMergeImmutableSet",

            Self::AccountMergeHasSubEntries => "AccountMergeHasSubEntries",

            Self::AccountMergeSeqnumTooFar => "AccountMergeSeqnumTooFar",

            Self::AccountMergeDestFull => "AccountMergeDestFull",

            Self::AccountMergeIsSponsor => "AccountMergeIsSponsor",
        }
    }

    #[must_use]
    pub const fn variants() -> [AccountMergeResultCode; 8] {
        Self::VARIANTS
    }
}

impl Name for AccountMergeResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<AccountMergeResultCode> for AccountMergeResultCode {
    fn variants() -> slice::Iter<'static, AccountMergeResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for AccountMergeResultCode {}

impl fmt::Display for AccountMergeResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for AccountMergeResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => AccountMergeResultCode::AccountMergeSuccess,

            -1 => AccountMergeResultCode::AccountMergeMalformed,

            -2 => AccountMergeResultCode::AccountMergeNoAccount,

            -3 => AccountMergeResultCode::AccountMergeImmutableSet,

            -4 => AccountMergeResultCode::AccountMergeHasSubEntries,

            -5 => AccountMergeResultCode::AccountMergeSeqnumTooFar,

            -6 => AccountMergeResultCode::AccountMergeDestFull,

            -7 => AccountMergeResultCode::AccountMergeIsSponsor,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<AccountMergeResultCode> for i32 {
    #[must_use]
    fn from(e: AccountMergeResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for AccountMergeResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for AccountMergeResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// AccountMergeResult
// union with discriminant AccountMergeResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum AccountMergeResult {
    AccountMergeSuccess(i64),

    AccountMergeMalformed,

    AccountMergeNoAccount,

    AccountMergeImmutableSet,

    AccountMergeHasSubEntries,

    AccountMergeSeqnumTooFar,

    AccountMergeDestFull,

    AccountMergeIsSponsor,
}

#[cfg(feature = "alloc")]
impl Default for AccountMergeResult {
    fn default() -> Self {
        Self::AccountMergeSuccess(i64::default())
    }
}

impl AccountMergeResult {
    pub const VARIANTS: [AccountMergeResultCode; 8] = [
        AccountMergeResultCode::AccountMergeSuccess,
        AccountMergeResultCode::AccountMergeMalformed,
        AccountMergeResultCode::AccountMergeNoAccount,
        AccountMergeResultCode::AccountMergeImmutableSet,
        AccountMergeResultCode::AccountMergeHasSubEntries,
        AccountMergeResultCode::AccountMergeSeqnumTooFar,
        AccountMergeResultCode::AccountMergeDestFull,
        AccountMergeResultCode::AccountMergeIsSponsor,
    ];
    pub const VARIANTS_STR: [&'static str; 8] = [
        "AccountMergeSuccess",
        "AccountMergeMalformed",
        "AccountMergeNoAccount",
        "AccountMergeImmutableSet",
        "AccountMergeHasSubEntries",
        "AccountMergeSeqnumTooFar",
        "AccountMergeDestFull",
        "AccountMergeIsSponsor",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AccountMergeSuccess(_) => "AccountMergeSuccess",

            Self::AccountMergeMalformed => "AccountMergeMalformed",

            Self::AccountMergeNoAccount => "AccountMergeNoAccount",

            Self::AccountMergeImmutableSet => "AccountMergeImmutableSet",

            Self::AccountMergeHasSubEntries => "AccountMergeHasSubEntries",

            Self::AccountMergeSeqnumTooFar => "AccountMergeSeqnumTooFar",

            Self::AccountMergeDestFull => "AccountMergeDestFull",

            Self::AccountMergeIsSponsor => "AccountMergeIsSponsor",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AccountMergeResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::AccountMergeSuccess(_) => AccountMergeResultCode::AccountMergeSuccess,

            Self::AccountMergeMalformed => AccountMergeResultCode::AccountMergeMalformed,

            Self::AccountMergeNoAccount => AccountMergeResultCode::AccountMergeNoAccount,

            Self::AccountMergeImmutableSet => AccountMergeResultCode::AccountMergeImmutableSet,

            Self::AccountMergeHasSubEntries => AccountMergeResultCode::AccountMergeHasSubEntries,

            Self::AccountMergeSeqnumTooFar => AccountMergeResultCode::AccountMergeSeqnumTooFar,

            Self::AccountMergeDestFull => AccountMergeResultCode::AccountMergeDestFull,

            Self::AccountMergeIsSponsor => AccountMergeResultCode::AccountMergeIsSponsor,
        }
    }

    #[must_use]
    pub const fn variants() -> [AccountMergeResultCode; 8] {
        Self::VARIANTS
    }
}

impl Name for AccountMergeResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AccountMergeResultCode> for AccountMergeResult {
    #[must_use]
    fn discriminant(&self) -> AccountMergeResultCode {
        Self::discriminant(self)
    }
}

impl Variants<AccountMergeResultCode> for AccountMergeResult {
    fn variants() -> slice::Iter<'static, AccountMergeResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<AccountMergeResultCode> for AccountMergeResult {}

impl ReadXdr for AccountMergeResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: AccountMergeResultCode = <AccountMergeResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AccountMergeResultCode::AccountMergeSuccess => {
                    Self::AccountMergeSuccess(i64::read_xdr(r)?)
                }

                AccountMergeResultCode::AccountMergeMalformed => Self::AccountMergeMalformed,

                AccountMergeResultCode::AccountMergeNoAccount => Self::AccountMergeNoAccount,

                AccountMergeResultCode::AccountMergeImmutableSet => Self::AccountMergeImmutableSet,

                AccountMergeResultCode::AccountMergeHasSubEntries => {
                    Self::AccountMergeHasSubEntries
                }

                AccountMergeResultCode::AccountMergeSeqnumTooFar => Self::AccountMergeSeqnumTooFar,

                AccountMergeResultCode::AccountMergeDestFull => Self::AccountMergeDestFull,

                AccountMergeResultCode::AccountMergeIsSponsor => Self::AccountMergeIsSponsor,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AccountMergeResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::AccountMergeSuccess(v) => v.write_xdr(w)?,

                Self::AccountMergeMalformed => ().write_xdr(w)?,

                Self::AccountMergeNoAccount => ().write_xdr(w)?,

                Self::AccountMergeImmutableSet => ().write_xdr(w)?,

                Self::AccountMergeHasSubEntries => ().write_xdr(w)?,

                Self::AccountMergeSeqnumTooFar => ().write_xdr(w)?,

                Self::AccountMergeDestFull => ().write_xdr(w)?,

                Self::AccountMergeIsSponsor => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// InflationResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum InflationResultCode {
    #[cfg_attr(feature = "alloc", default)]
    InflationSuccess = 0,

    InflationNotTime = -1,
}

impl InflationResultCode {
    pub const VARIANTS: [InflationResultCode; 2] = [
        InflationResultCode::InflationSuccess,
        InflationResultCode::InflationNotTime,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["InflationSuccess", "InflationNotTime"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::InflationSuccess => "InflationSuccess",

            Self::InflationNotTime => "InflationNotTime",
        }
    }

    #[must_use]
    pub const fn variants() -> [InflationResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for InflationResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<InflationResultCode> for InflationResultCode {
    fn variants() -> slice::Iter<'static, InflationResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for InflationResultCode {}

impl fmt::Display for InflationResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for InflationResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => InflationResultCode::InflationSuccess,

            -1 => InflationResultCode::InflationNotTime,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<InflationResultCode> for i32 {
    #[must_use]
    fn from(e: InflationResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for InflationResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for InflationResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// InflationPayout
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct InflationPayout {
    pub destination: AccountId,

    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub amount: i64,
}

impl ReadXdr for InflationPayout {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                destination: AccountId::read_xdr(r)?,

                amount: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InflationPayout {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.destination.write_xdr(w)?;

            self.amount.write_xdr(w)?;

            Ok(())
        })
    }
}

/// InflationResult
// union with discriminant InflationResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum InflationResult {
    InflationSuccess(VecM<InflationPayout>),

    InflationNotTime,
}

#[cfg(feature = "alloc")]
impl Default for InflationResult {
    fn default() -> Self {
        Self::InflationSuccess(VecM::<InflationPayout>::default())
    }
}

impl InflationResult {
    pub const VARIANTS: [InflationResultCode; 2] = [
        InflationResultCode::InflationSuccess,
        InflationResultCode::InflationNotTime,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["InflationSuccess", "InflationNotTime"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::InflationSuccess(_) => "InflationSuccess",

            Self::InflationNotTime => "InflationNotTime",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> InflationResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::InflationSuccess(_) => InflationResultCode::InflationSuccess,

            Self::InflationNotTime => InflationResultCode::InflationNotTime,
        }
    }

    #[must_use]
    pub const fn variants() -> [InflationResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for InflationResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<InflationResultCode> for InflationResult {
    #[must_use]
    fn discriminant(&self) -> InflationResultCode {
        Self::discriminant(self)
    }
}

impl Variants<InflationResultCode> for InflationResult {
    fn variants() -> slice::Iter<'static, InflationResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<InflationResultCode> for InflationResult {}

impl ReadXdr for InflationResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: InflationResultCode = <InflationResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                InflationResultCode::InflationSuccess => {
                    Self::InflationSuccess(VecM::<InflationPayout>::read_xdr(r)?)
                }

                InflationResultCode::InflationNotTime => Self::InflationNotTime,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for InflationResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::InflationSuccess(v) => v.write_xdr(w)?,

                Self::InflationNotTime => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ManageDataResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ManageDataResultCode {
    #[cfg_attr(feature = "alloc", default)]
    ManageDataSuccess = 0,

    ManageDataNotSupportedYet = -1,

    ManageDataNameNotFound = -2,

    ManageDataLowReserve = -3,

    ManageDataInvalidName = -4,
}

impl ManageDataResultCode {
    pub const VARIANTS: [ManageDataResultCode; 5] = [
        ManageDataResultCode::ManageDataSuccess,
        ManageDataResultCode::ManageDataNotSupportedYet,
        ManageDataResultCode::ManageDataNameNotFound,
        ManageDataResultCode::ManageDataLowReserve,
        ManageDataResultCode::ManageDataInvalidName,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "ManageDataSuccess",
        "ManageDataNotSupportedYet",
        "ManageDataNameNotFound",
        "ManageDataLowReserve",
        "ManageDataInvalidName",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ManageDataSuccess => "ManageDataSuccess",

            Self::ManageDataNotSupportedYet => "ManageDataNotSupportedYet",

            Self::ManageDataNameNotFound => "ManageDataNameNotFound",

            Self::ManageDataLowReserve => "ManageDataLowReserve",

            Self::ManageDataInvalidName => "ManageDataInvalidName",
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageDataResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for ManageDataResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ManageDataResultCode> for ManageDataResultCode {
    fn variants() -> slice::Iter<'static, ManageDataResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ManageDataResultCode {}

impl fmt::Display for ManageDataResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ManageDataResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ManageDataResultCode::ManageDataSuccess,

            -1 => ManageDataResultCode::ManageDataNotSupportedYet,

            -2 => ManageDataResultCode::ManageDataNameNotFound,

            -3 => ManageDataResultCode::ManageDataLowReserve,

            -4 => ManageDataResultCode::ManageDataInvalidName,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ManageDataResultCode> for i32 {
    #[must_use]
    fn from(e: ManageDataResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ManageDataResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ManageDataResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ManageDataResult
// union with discriminant ManageDataResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ManageDataResult {
    ManageDataSuccess,

    ManageDataNotSupportedYet,

    ManageDataNameNotFound,

    ManageDataLowReserve,

    ManageDataInvalidName,
}

#[cfg(feature = "alloc")]
impl Default for ManageDataResult {
    fn default() -> Self {
        Self::ManageDataSuccess
    }
}

impl ManageDataResult {
    pub const VARIANTS: [ManageDataResultCode; 5] = [
        ManageDataResultCode::ManageDataSuccess,
        ManageDataResultCode::ManageDataNotSupportedYet,
        ManageDataResultCode::ManageDataNameNotFound,
        ManageDataResultCode::ManageDataLowReserve,
        ManageDataResultCode::ManageDataInvalidName,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "ManageDataSuccess",
        "ManageDataNotSupportedYet",
        "ManageDataNameNotFound",
        "ManageDataLowReserve",
        "ManageDataInvalidName",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ManageDataSuccess => "ManageDataSuccess",

            Self::ManageDataNotSupportedYet => "ManageDataNotSupportedYet",

            Self::ManageDataNameNotFound => "ManageDataNameNotFound",

            Self::ManageDataLowReserve => "ManageDataLowReserve",

            Self::ManageDataInvalidName => "ManageDataInvalidName",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ManageDataResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ManageDataSuccess => ManageDataResultCode::ManageDataSuccess,

            Self::ManageDataNotSupportedYet => ManageDataResultCode::ManageDataNotSupportedYet,

            Self::ManageDataNameNotFound => ManageDataResultCode::ManageDataNameNotFound,

            Self::ManageDataLowReserve => ManageDataResultCode::ManageDataLowReserve,

            Self::ManageDataInvalidName => ManageDataResultCode::ManageDataInvalidName,
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageDataResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for ManageDataResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ManageDataResultCode> for ManageDataResult {
    #[must_use]
    fn discriminant(&self) -> ManageDataResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ManageDataResultCode> for ManageDataResult {
    fn variants() -> slice::Iter<'static, ManageDataResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ManageDataResultCode> for ManageDataResult {}

impl ReadXdr for ManageDataResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ManageDataResultCode = <ManageDataResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ManageDataResultCode::ManageDataSuccess => Self::ManageDataSuccess,

                ManageDataResultCode::ManageDataNotSupportedYet => Self::ManageDataNotSupportedYet,

                ManageDataResultCode::ManageDataNameNotFound => Self::ManageDataNameNotFound,

                ManageDataResultCode::ManageDataLowReserve => Self::ManageDataLowReserve,

                ManageDataResultCode::ManageDataInvalidName => Self::ManageDataInvalidName,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ManageDataResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ManageDataSuccess => ().write_xdr(w)?,

                Self::ManageDataNotSupportedYet => ().write_xdr(w)?,

                Self::ManageDataNameNotFound => ().write_xdr(w)?,

                Self::ManageDataLowReserve => ().write_xdr(w)?,

                Self::ManageDataInvalidName => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// BumpSequenceResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum BumpSequenceResultCode {
    #[cfg_attr(feature = "alloc", default)]
    BumpSequenceSuccess = 0,

    BumpSequenceBadSeq = -1,
}

impl BumpSequenceResultCode {
    pub const VARIANTS: [BumpSequenceResultCode; 2] = [
        BumpSequenceResultCode::BumpSequenceSuccess,
        BumpSequenceResultCode::BumpSequenceBadSeq,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["BumpSequenceSuccess", "BumpSequenceBadSeq"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::BumpSequenceSuccess => "BumpSequenceSuccess",

            Self::BumpSequenceBadSeq => "BumpSequenceBadSeq",
        }
    }

    #[must_use]
    pub const fn variants() -> [BumpSequenceResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for BumpSequenceResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<BumpSequenceResultCode> for BumpSequenceResultCode {
    fn variants() -> slice::Iter<'static, BumpSequenceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for BumpSequenceResultCode {}

impl fmt::Display for BumpSequenceResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for BumpSequenceResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => BumpSequenceResultCode::BumpSequenceSuccess,

            -1 => BumpSequenceResultCode::BumpSequenceBadSeq,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<BumpSequenceResultCode> for i32 {
    #[must_use]
    fn from(e: BumpSequenceResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for BumpSequenceResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for BumpSequenceResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// BumpSequenceResult
// union with discriminant BumpSequenceResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum BumpSequenceResult {
    BumpSequenceSuccess,

    BumpSequenceBadSeq,
}

#[cfg(feature = "alloc")]
impl Default for BumpSequenceResult {
    fn default() -> Self {
        Self::BumpSequenceSuccess
    }
}

impl BumpSequenceResult {
    pub const VARIANTS: [BumpSequenceResultCode; 2] = [
        BumpSequenceResultCode::BumpSequenceSuccess,
        BumpSequenceResultCode::BumpSequenceBadSeq,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["BumpSequenceSuccess", "BumpSequenceBadSeq"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::BumpSequenceSuccess => "BumpSequenceSuccess",

            Self::BumpSequenceBadSeq => "BumpSequenceBadSeq",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> BumpSequenceResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::BumpSequenceSuccess => BumpSequenceResultCode::BumpSequenceSuccess,

            Self::BumpSequenceBadSeq => BumpSequenceResultCode::BumpSequenceBadSeq,
        }
    }

    #[must_use]
    pub const fn variants() -> [BumpSequenceResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for BumpSequenceResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<BumpSequenceResultCode> for BumpSequenceResult {
    #[must_use]
    fn discriminant(&self) -> BumpSequenceResultCode {
        Self::discriminant(self)
    }
}

impl Variants<BumpSequenceResultCode> for BumpSequenceResult {
    fn variants() -> slice::Iter<'static, BumpSequenceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<BumpSequenceResultCode> for BumpSequenceResult {}

impl ReadXdr for BumpSequenceResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: BumpSequenceResultCode = <BumpSequenceResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                BumpSequenceResultCode::BumpSequenceSuccess => Self::BumpSequenceSuccess,

                BumpSequenceResultCode::BumpSequenceBadSeq => Self::BumpSequenceBadSeq,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for BumpSequenceResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::BumpSequenceSuccess => ().write_xdr(w)?,

                Self::BumpSequenceBadSeq => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// CreateClaimableBalanceResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum CreateClaimableBalanceResultCode {
    #[cfg_attr(feature = "alloc", default)]
    CreateClaimableBalanceSuccess = 0,

    CreateClaimableBalanceMalformed = -1,

    CreateClaimableBalanceLowReserve = -2,

    CreateClaimableBalanceNoTrust = -3,

    CreateClaimableBalanceNotAuthorized = -4,

    CreateClaimableBalanceUnderfunded = -5,
}

impl CreateClaimableBalanceResultCode {
    pub const VARIANTS: [CreateClaimableBalanceResultCode; 6] = [
        CreateClaimableBalanceResultCode::CreateClaimableBalanceSuccess,
        CreateClaimableBalanceResultCode::CreateClaimableBalanceMalformed,
        CreateClaimableBalanceResultCode::CreateClaimableBalanceLowReserve,
        CreateClaimableBalanceResultCode::CreateClaimableBalanceNoTrust,
        CreateClaimableBalanceResultCode::CreateClaimableBalanceNotAuthorized,
        CreateClaimableBalanceResultCode::CreateClaimableBalanceUnderfunded,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "CreateClaimableBalanceSuccess",
        "CreateClaimableBalanceMalformed",
        "CreateClaimableBalanceLowReserve",
        "CreateClaimableBalanceNoTrust",
        "CreateClaimableBalanceNotAuthorized",
        "CreateClaimableBalanceUnderfunded",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::CreateClaimableBalanceSuccess => "CreateClaimableBalanceSuccess",

            Self::CreateClaimableBalanceMalformed => "CreateClaimableBalanceMalformed",

            Self::CreateClaimableBalanceLowReserve => "CreateClaimableBalanceLowReserve",

            Self::CreateClaimableBalanceNoTrust => "CreateClaimableBalanceNoTrust",

            Self::CreateClaimableBalanceNotAuthorized => "CreateClaimableBalanceNotAuthorized",

            Self::CreateClaimableBalanceUnderfunded => "CreateClaimableBalanceUnderfunded",
        }
    }

    #[must_use]
    pub const fn variants() -> [CreateClaimableBalanceResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for CreateClaimableBalanceResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<CreateClaimableBalanceResultCode> for CreateClaimableBalanceResultCode {
    fn variants() -> slice::Iter<'static, CreateClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for CreateClaimableBalanceResultCode {}

impl fmt::Display for CreateClaimableBalanceResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for CreateClaimableBalanceResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => CreateClaimableBalanceResultCode::CreateClaimableBalanceSuccess,

            -1 => CreateClaimableBalanceResultCode::CreateClaimableBalanceMalformed,

            -2 => CreateClaimableBalanceResultCode::CreateClaimableBalanceLowReserve,

            -3 => CreateClaimableBalanceResultCode::CreateClaimableBalanceNoTrust,

            -4 => CreateClaimableBalanceResultCode::CreateClaimableBalanceNotAuthorized,

            -5 => CreateClaimableBalanceResultCode::CreateClaimableBalanceUnderfunded,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<CreateClaimableBalanceResultCode> for i32 {
    #[must_use]
    fn from(e: CreateClaimableBalanceResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for CreateClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for CreateClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// CreateClaimableBalanceResult
// union with discriminant CreateClaimableBalanceResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum CreateClaimableBalanceResult {
    CreateClaimableBalanceSuccess(ClaimableBalanceId),

    CreateClaimableBalanceMalformed,

    CreateClaimableBalanceLowReserve,

    CreateClaimableBalanceNoTrust,

    CreateClaimableBalanceNotAuthorized,

    CreateClaimableBalanceUnderfunded,
}

#[cfg(feature = "alloc")]
impl Default for CreateClaimableBalanceResult {
    fn default() -> Self {
        Self::CreateClaimableBalanceSuccess(ClaimableBalanceId::default())
    }
}

impl CreateClaimableBalanceResult {
    pub const VARIANTS: [CreateClaimableBalanceResultCode; 6] = [
        CreateClaimableBalanceResultCode::CreateClaimableBalanceSuccess,
        CreateClaimableBalanceResultCode::CreateClaimableBalanceMalformed,
        CreateClaimableBalanceResultCode::CreateClaimableBalanceLowReserve,
        CreateClaimableBalanceResultCode::CreateClaimableBalanceNoTrust,
        CreateClaimableBalanceResultCode::CreateClaimableBalanceNotAuthorized,
        CreateClaimableBalanceResultCode::CreateClaimableBalanceUnderfunded,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "CreateClaimableBalanceSuccess",
        "CreateClaimableBalanceMalformed",
        "CreateClaimableBalanceLowReserve",
        "CreateClaimableBalanceNoTrust",
        "CreateClaimableBalanceNotAuthorized",
        "CreateClaimableBalanceUnderfunded",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::CreateClaimableBalanceSuccess(_) => "CreateClaimableBalanceSuccess",

            Self::CreateClaimableBalanceMalformed => "CreateClaimableBalanceMalformed",

            Self::CreateClaimableBalanceLowReserve => "CreateClaimableBalanceLowReserve",

            Self::CreateClaimableBalanceNoTrust => "CreateClaimableBalanceNoTrust",

            Self::CreateClaimableBalanceNotAuthorized => "CreateClaimableBalanceNotAuthorized",

            Self::CreateClaimableBalanceUnderfunded => "CreateClaimableBalanceUnderfunded",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> CreateClaimableBalanceResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::CreateClaimableBalanceSuccess(_) => {
                CreateClaimableBalanceResultCode::CreateClaimableBalanceSuccess
            }

            Self::CreateClaimableBalanceMalformed => {
                CreateClaimableBalanceResultCode::CreateClaimableBalanceMalformed
            }

            Self::CreateClaimableBalanceLowReserve => {
                CreateClaimableBalanceResultCode::CreateClaimableBalanceLowReserve
            }

            Self::CreateClaimableBalanceNoTrust => {
                CreateClaimableBalanceResultCode::CreateClaimableBalanceNoTrust
            }

            Self::CreateClaimableBalanceNotAuthorized => {
                CreateClaimableBalanceResultCode::CreateClaimableBalanceNotAuthorized
            }

            Self::CreateClaimableBalanceUnderfunded => {
                CreateClaimableBalanceResultCode::CreateClaimableBalanceUnderfunded
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [CreateClaimableBalanceResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for CreateClaimableBalanceResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<CreateClaimableBalanceResultCode> for CreateClaimableBalanceResult {
    #[must_use]
    fn discriminant(&self) -> CreateClaimableBalanceResultCode {
        Self::discriminant(self)
    }
}

impl Variants<CreateClaimableBalanceResultCode> for CreateClaimableBalanceResult {
    fn variants() -> slice::Iter<'static, CreateClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<CreateClaimableBalanceResultCode> for CreateClaimableBalanceResult {}

impl ReadXdr for CreateClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: CreateClaimableBalanceResultCode =
                <CreateClaimableBalanceResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                CreateClaimableBalanceResultCode::CreateClaimableBalanceSuccess => {
                    Self::CreateClaimableBalanceSuccess(ClaimableBalanceId::read_xdr(r)?)
                }

                CreateClaimableBalanceResultCode::CreateClaimableBalanceMalformed => {
                    Self::CreateClaimableBalanceMalformed
                }

                CreateClaimableBalanceResultCode::CreateClaimableBalanceLowReserve => {
                    Self::CreateClaimableBalanceLowReserve
                }

                CreateClaimableBalanceResultCode::CreateClaimableBalanceNoTrust => {
                    Self::CreateClaimableBalanceNoTrust
                }

                CreateClaimableBalanceResultCode::CreateClaimableBalanceNotAuthorized => {
                    Self::CreateClaimableBalanceNotAuthorized
                }

                CreateClaimableBalanceResultCode::CreateClaimableBalanceUnderfunded => {
                    Self::CreateClaimableBalanceUnderfunded
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for CreateClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::CreateClaimableBalanceSuccess(v) => v.write_xdr(w)?,

                Self::CreateClaimableBalanceMalformed => ().write_xdr(w)?,

                Self::CreateClaimableBalanceLowReserve => ().write_xdr(w)?,

                Self::CreateClaimableBalanceNoTrust => ().write_xdr(w)?,

                Self::CreateClaimableBalanceNotAuthorized => ().write_xdr(w)?,

                Self::CreateClaimableBalanceUnderfunded => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClaimClaimableBalanceResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ClaimClaimableBalanceResultCode {
    #[cfg_attr(feature = "alloc", default)]
    ClaimClaimableBalanceSuccess = 0,

    ClaimClaimableBalanceDoesNotExist = -1,

    ClaimClaimableBalanceCannotClaim = -2,

    ClaimClaimableBalanceLineFull = -3,

    ClaimClaimableBalanceNoTrust = -4,

    ClaimClaimableBalanceNotAuthorized = -5,
}

impl ClaimClaimableBalanceResultCode {
    pub const VARIANTS: [ClaimClaimableBalanceResultCode; 6] = [
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceSuccess,
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceDoesNotExist,
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceCannotClaim,
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceLineFull,
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNoTrust,
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNotAuthorized,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "ClaimClaimableBalanceSuccess",
        "ClaimClaimableBalanceDoesNotExist",
        "ClaimClaimableBalanceCannotClaim",
        "ClaimClaimableBalanceLineFull",
        "ClaimClaimableBalanceNoTrust",
        "ClaimClaimableBalanceNotAuthorized",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimClaimableBalanceSuccess => "ClaimClaimableBalanceSuccess",

            Self::ClaimClaimableBalanceDoesNotExist => "ClaimClaimableBalanceDoesNotExist",

            Self::ClaimClaimableBalanceCannotClaim => "ClaimClaimableBalanceCannotClaim",

            Self::ClaimClaimableBalanceLineFull => "ClaimClaimableBalanceLineFull",

            Self::ClaimClaimableBalanceNoTrust => "ClaimClaimableBalanceNoTrust",

            Self::ClaimClaimableBalanceNotAuthorized => "ClaimClaimableBalanceNotAuthorized",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimClaimableBalanceResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for ClaimClaimableBalanceResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimClaimableBalanceResultCode> for ClaimClaimableBalanceResultCode {
    fn variants() -> slice::Iter<'static, ClaimClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimClaimableBalanceResultCode {}

impl fmt::Display for ClaimClaimableBalanceResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimClaimableBalanceResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ClaimClaimableBalanceResultCode::ClaimClaimableBalanceSuccess,

            -1 => ClaimClaimableBalanceResultCode::ClaimClaimableBalanceDoesNotExist,

            -2 => ClaimClaimableBalanceResultCode::ClaimClaimableBalanceCannotClaim,

            -3 => ClaimClaimableBalanceResultCode::ClaimClaimableBalanceLineFull,

            -4 => ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNoTrust,

            -5 => ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNotAuthorized,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimClaimableBalanceResultCode> for i32 {
    #[must_use]
    fn from(e: ClaimClaimableBalanceResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClaimClaimableBalanceResult
// union with discriminant ClaimClaimableBalanceResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ClaimClaimableBalanceResult {
    ClaimClaimableBalanceSuccess,

    ClaimClaimableBalanceDoesNotExist,

    ClaimClaimableBalanceCannotClaim,

    ClaimClaimableBalanceLineFull,

    ClaimClaimableBalanceNoTrust,

    ClaimClaimableBalanceNotAuthorized,
}

#[cfg(feature = "alloc")]
impl Default for ClaimClaimableBalanceResult {
    fn default() -> Self {
        Self::ClaimClaimableBalanceSuccess
    }
}

impl ClaimClaimableBalanceResult {
    pub const VARIANTS: [ClaimClaimableBalanceResultCode; 6] = [
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceSuccess,
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceDoesNotExist,
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceCannotClaim,
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceLineFull,
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNoTrust,
        ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNotAuthorized,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "ClaimClaimableBalanceSuccess",
        "ClaimClaimableBalanceDoesNotExist",
        "ClaimClaimableBalanceCannotClaim",
        "ClaimClaimableBalanceLineFull",
        "ClaimClaimableBalanceNoTrust",
        "ClaimClaimableBalanceNotAuthorized",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimClaimableBalanceSuccess => "ClaimClaimableBalanceSuccess",

            Self::ClaimClaimableBalanceDoesNotExist => "ClaimClaimableBalanceDoesNotExist",

            Self::ClaimClaimableBalanceCannotClaim => "ClaimClaimableBalanceCannotClaim",

            Self::ClaimClaimableBalanceLineFull => "ClaimClaimableBalanceLineFull",

            Self::ClaimClaimableBalanceNoTrust => "ClaimClaimableBalanceNoTrust",

            Self::ClaimClaimableBalanceNotAuthorized => "ClaimClaimableBalanceNotAuthorized",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClaimClaimableBalanceResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ClaimClaimableBalanceSuccess => {
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceSuccess
            }

            Self::ClaimClaimableBalanceDoesNotExist => {
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceDoesNotExist
            }

            Self::ClaimClaimableBalanceCannotClaim => {
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceCannotClaim
            }

            Self::ClaimClaimableBalanceLineFull => {
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceLineFull
            }

            Self::ClaimClaimableBalanceNoTrust => {
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNoTrust
            }

            Self::ClaimClaimableBalanceNotAuthorized => {
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNotAuthorized
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimClaimableBalanceResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for ClaimClaimableBalanceResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClaimClaimableBalanceResultCode> for ClaimClaimableBalanceResult {
    #[must_use]
    fn discriminant(&self) -> ClaimClaimableBalanceResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ClaimClaimableBalanceResultCode> for ClaimClaimableBalanceResult {
    fn variants() -> slice::Iter<'static, ClaimClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClaimClaimableBalanceResultCode> for ClaimClaimableBalanceResult {}

impl ReadXdr for ClaimClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ClaimClaimableBalanceResultCode =
                <ClaimClaimableBalanceResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceSuccess => {
                    Self::ClaimClaimableBalanceSuccess
                }

                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceDoesNotExist => {
                    Self::ClaimClaimableBalanceDoesNotExist
                }

                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceCannotClaim => {
                    Self::ClaimClaimableBalanceCannotClaim
                }

                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceLineFull => {
                    Self::ClaimClaimableBalanceLineFull
                }

                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNoTrust => {
                    Self::ClaimClaimableBalanceNoTrust
                }

                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNotAuthorized => {
                    Self::ClaimClaimableBalanceNotAuthorized
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ClaimClaimableBalanceSuccess => ().write_xdr(w)?,

                Self::ClaimClaimableBalanceDoesNotExist => ().write_xdr(w)?,

                Self::ClaimClaimableBalanceCannotClaim => ().write_xdr(w)?,

                Self::ClaimClaimableBalanceLineFull => ().write_xdr(w)?,

                Self::ClaimClaimableBalanceNoTrust => ().write_xdr(w)?,

                Self::ClaimClaimableBalanceNotAuthorized => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// BeginSponsoringFutureReservesResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum BeginSponsoringFutureReservesResultCode {
    #[cfg_attr(feature = "alloc", default)]
    BeginSponsoringFutureReservesSuccess = 0,

    BeginSponsoringFutureReservesMalformed = -1,

    BeginSponsoringFutureReservesAlreadySponsored = -2,

    BeginSponsoringFutureReservesRecursive = -3,
}

impl BeginSponsoringFutureReservesResultCode {
    pub const VARIANTS: [BeginSponsoringFutureReservesResultCode; 4] = [
        BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesSuccess,
        BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesMalformed,
        BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesAlreadySponsored,
        BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesRecursive,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "BeginSponsoringFutureReservesSuccess",
        "BeginSponsoringFutureReservesMalformed",
        "BeginSponsoringFutureReservesAlreadySponsored",
        "BeginSponsoringFutureReservesRecursive",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::BeginSponsoringFutureReservesSuccess => "BeginSponsoringFutureReservesSuccess",

            Self::BeginSponsoringFutureReservesMalformed => {
                "BeginSponsoringFutureReservesMalformed"
            }

            Self::BeginSponsoringFutureReservesAlreadySponsored => {
                "BeginSponsoringFutureReservesAlreadySponsored"
            }

            Self::BeginSponsoringFutureReservesRecursive => {
                "BeginSponsoringFutureReservesRecursive"
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [BeginSponsoringFutureReservesResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for BeginSponsoringFutureReservesResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<BeginSponsoringFutureReservesResultCode> for BeginSponsoringFutureReservesResultCode {
    fn variants() -> slice::Iter<'static, BeginSponsoringFutureReservesResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for BeginSponsoringFutureReservesResultCode {}

impl fmt::Display for BeginSponsoringFutureReservesResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for BeginSponsoringFutureReservesResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {

            0 => BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesSuccess,

            -1 => BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesMalformed,

            -2 => BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesAlreadySponsored,

            -3 => BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesRecursive,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<BeginSponsoringFutureReservesResultCode> for i32 {
    #[must_use]
    fn from(e: BeginSponsoringFutureReservesResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for BeginSponsoringFutureReservesResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for BeginSponsoringFutureReservesResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// BeginSponsoringFutureReservesResult
// union with discriminant BeginSponsoringFutureReservesResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum BeginSponsoringFutureReservesResult {
    BeginSponsoringFutureReservesSuccess,

    BeginSponsoringFutureReservesMalformed,

    BeginSponsoringFutureReservesAlreadySponsored,

    BeginSponsoringFutureReservesRecursive,
}

#[cfg(feature = "alloc")]
impl Default for BeginSponsoringFutureReservesResult {
    fn default() -> Self {
        Self::BeginSponsoringFutureReservesSuccess
    }
}

impl BeginSponsoringFutureReservesResult {
    pub const VARIANTS: [BeginSponsoringFutureReservesResultCode; 4] = [
        BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesSuccess,
        BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesMalformed,
        BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesAlreadySponsored,
        BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesRecursive,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "BeginSponsoringFutureReservesSuccess",
        "BeginSponsoringFutureReservesMalformed",
        "BeginSponsoringFutureReservesAlreadySponsored",
        "BeginSponsoringFutureReservesRecursive",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::BeginSponsoringFutureReservesSuccess => "BeginSponsoringFutureReservesSuccess",

            Self::BeginSponsoringFutureReservesMalformed => {
                "BeginSponsoringFutureReservesMalformed"
            }

            Self::BeginSponsoringFutureReservesAlreadySponsored => {
                "BeginSponsoringFutureReservesAlreadySponsored"
            }

            Self::BeginSponsoringFutureReservesRecursive => {
                "BeginSponsoringFutureReservesRecursive"
            }
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> BeginSponsoringFutureReservesResultCode {
        #[allow(clippy::match_same_arms)]
        match self {


            Self::BeginSponsoringFutureReservesSuccess => BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesSuccess,



            Self::BeginSponsoringFutureReservesMalformed => BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesMalformed,



            Self::BeginSponsoringFutureReservesAlreadySponsored => BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesAlreadySponsored,



            Self::BeginSponsoringFutureReservesRecursive => BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesRecursive,


        }
    }

    #[must_use]
    pub const fn variants() -> [BeginSponsoringFutureReservesResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for BeginSponsoringFutureReservesResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<BeginSponsoringFutureReservesResultCode> for BeginSponsoringFutureReservesResult {
    #[must_use]
    fn discriminant(&self) -> BeginSponsoringFutureReservesResultCode {
        Self::discriminant(self)
    }
}

impl Variants<BeginSponsoringFutureReservesResultCode> for BeginSponsoringFutureReservesResult {
    fn variants() -> slice::Iter<'static, BeginSponsoringFutureReservesResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<BeginSponsoringFutureReservesResultCode> for BeginSponsoringFutureReservesResult {}

impl ReadXdr for BeginSponsoringFutureReservesResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: BeginSponsoringFutureReservesResultCode = <BeginSponsoringFutureReservesResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {


                BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesSuccess => Self::BeginSponsoringFutureReservesSuccess,



                BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesMalformed => Self::BeginSponsoringFutureReservesMalformed,



                BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesAlreadySponsored => Self::BeginSponsoringFutureReservesAlreadySponsored,



                BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesRecursive => Self::BeginSponsoringFutureReservesRecursive,


                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for BeginSponsoringFutureReservesResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::BeginSponsoringFutureReservesSuccess => ().write_xdr(w)?,

                Self::BeginSponsoringFutureReservesMalformed => ().write_xdr(w)?,

                Self::BeginSponsoringFutureReservesAlreadySponsored => ().write_xdr(w)?,

                Self::BeginSponsoringFutureReservesRecursive => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// EndSponsoringFutureReservesResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum EndSponsoringFutureReservesResultCode {
    #[cfg_attr(feature = "alloc", default)]
    EndSponsoringFutureReservesSuccess = 0,

    EndSponsoringFutureReservesNotSponsored = -1,
}

impl EndSponsoringFutureReservesResultCode {
    pub const VARIANTS: [EndSponsoringFutureReservesResultCode; 2] = [
        EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesSuccess,
        EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesNotSponsored,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = [
        "EndSponsoringFutureReservesSuccess",
        "EndSponsoringFutureReservesNotSponsored",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::EndSponsoringFutureReservesSuccess => "EndSponsoringFutureReservesSuccess",

            Self::EndSponsoringFutureReservesNotSponsored => {
                "EndSponsoringFutureReservesNotSponsored"
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [EndSponsoringFutureReservesResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for EndSponsoringFutureReservesResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<EndSponsoringFutureReservesResultCode> for EndSponsoringFutureReservesResultCode {
    fn variants() -> slice::Iter<'static, EndSponsoringFutureReservesResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for EndSponsoringFutureReservesResultCode {}

impl fmt::Display for EndSponsoringFutureReservesResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for EndSponsoringFutureReservesResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesSuccess,

            -1 => EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesNotSponsored,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<EndSponsoringFutureReservesResultCode> for i32 {
    #[must_use]
    fn from(e: EndSponsoringFutureReservesResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for EndSponsoringFutureReservesResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for EndSponsoringFutureReservesResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// EndSponsoringFutureReservesResult
// union with discriminant EndSponsoringFutureReservesResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum EndSponsoringFutureReservesResult {
    EndSponsoringFutureReservesSuccess,

    EndSponsoringFutureReservesNotSponsored,
}

#[cfg(feature = "alloc")]
impl Default for EndSponsoringFutureReservesResult {
    fn default() -> Self {
        Self::EndSponsoringFutureReservesSuccess
    }
}

impl EndSponsoringFutureReservesResult {
    pub const VARIANTS: [EndSponsoringFutureReservesResultCode; 2] = [
        EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesSuccess,
        EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesNotSponsored,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = [
        "EndSponsoringFutureReservesSuccess",
        "EndSponsoringFutureReservesNotSponsored",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::EndSponsoringFutureReservesSuccess => "EndSponsoringFutureReservesSuccess",

            Self::EndSponsoringFutureReservesNotSponsored => {
                "EndSponsoringFutureReservesNotSponsored"
            }
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> EndSponsoringFutureReservesResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::EndSponsoringFutureReservesSuccess => {
                EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesSuccess
            }

            Self::EndSponsoringFutureReservesNotSponsored => {
                EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesNotSponsored
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [EndSponsoringFutureReservesResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for EndSponsoringFutureReservesResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<EndSponsoringFutureReservesResultCode> for EndSponsoringFutureReservesResult {
    #[must_use]
    fn discriminant(&self) -> EndSponsoringFutureReservesResultCode {
        Self::discriminant(self)
    }
}

impl Variants<EndSponsoringFutureReservesResultCode> for EndSponsoringFutureReservesResult {
    fn variants() -> slice::Iter<'static, EndSponsoringFutureReservesResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<EndSponsoringFutureReservesResultCode> for EndSponsoringFutureReservesResult {}

impl ReadXdr for EndSponsoringFutureReservesResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: EndSponsoringFutureReservesResultCode =
                <EndSponsoringFutureReservesResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesSuccess => {
                    Self::EndSponsoringFutureReservesSuccess
                }

                EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesNotSponsored => {
                    Self::EndSponsoringFutureReservesNotSponsored
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for EndSponsoringFutureReservesResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::EndSponsoringFutureReservesSuccess => ().write_xdr(w)?,

                Self::EndSponsoringFutureReservesNotSponsored => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// RevokeSponsorshipResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum RevokeSponsorshipResultCode {
    #[cfg_attr(feature = "alloc", default)]
    RevokeSponsorshipSuccess = 0,

    RevokeSponsorshipDoesNotExist = -1,

    RevokeSponsorshipNotSponsor = -2,

    RevokeSponsorshipLowReserve = -3,

    RevokeSponsorshipOnlyTransferable = -4,

    RevokeSponsorshipMalformed = -5,
}

impl RevokeSponsorshipResultCode {
    pub const VARIANTS: [RevokeSponsorshipResultCode; 6] = [
        RevokeSponsorshipResultCode::RevokeSponsorshipSuccess,
        RevokeSponsorshipResultCode::RevokeSponsorshipDoesNotExist,
        RevokeSponsorshipResultCode::RevokeSponsorshipNotSponsor,
        RevokeSponsorshipResultCode::RevokeSponsorshipLowReserve,
        RevokeSponsorshipResultCode::RevokeSponsorshipOnlyTransferable,
        RevokeSponsorshipResultCode::RevokeSponsorshipMalformed,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "RevokeSponsorshipSuccess",
        "RevokeSponsorshipDoesNotExist",
        "RevokeSponsorshipNotSponsor",
        "RevokeSponsorshipLowReserve",
        "RevokeSponsorshipOnlyTransferable",
        "RevokeSponsorshipMalformed",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::RevokeSponsorshipSuccess => "RevokeSponsorshipSuccess",

            Self::RevokeSponsorshipDoesNotExist => "RevokeSponsorshipDoesNotExist",

            Self::RevokeSponsorshipNotSponsor => "RevokeSponsorshipNotSponsor",

            Self::RevokeSponsorshipLowReserve => "RevokeSponsorshipLowReserve",

            Self::RevokeSponsorshipOnlyTransferable => "RevokeSponsorshipOnlyTransferable",

            Self::RevokeSponsorshipMalformed => "RevokeSponsorshipMalformed",
        }
    }

    #[must_use]
    pub const fn variants() -> [RevokeSponsorshipResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for RevokeSponsorshipResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<RevokeSponsorshipResultCode> for RevokeSponsorshipResultCode {
    fn variants() -> slice::Iter<'static, RevokeSponsorshipResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for RevokeSponsorshipResultCode {}

impl fmt::Display for RevokeSponsorshipResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for RevokeSponsorshipResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => RevokeSponsorshipResultCode::RevokeSponsorshipSuccess,

            -1 => RevokeSponsorshipResultCode::RevokeSponsorshipDoesNotExist,

            -2 => RevokeSponsorshipResultCode::RevokeSponsorshipNotSponsor,

            -3 => RevokeSponsorshipResultCode::RevokeSponsorshipLowReserve,

            -4 => RevokeSponsorshipResultCode::RevokeSponsorshipOnlyTransferable,

            -5 => RevokeSponsorshipResultCode::RevokeSponsorshipMalformed,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<RevokeSponsorshipResultCode> for i32 {
    #[must_use]
    fn from(e: RevokeSponsorshipResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for RevokeSponsorshipResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for RevokeSponsorshipResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// RevokeSponsorshipResult
// union with discriminant RevokeSponsorshipResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum RevokeSponsorshipResult {
    RevokeSponsorshipSuccess,

    RevokeSponsorshipDoesNotExist,

    RevokeSponsorshipNotSponsor,

    RevokeSponsorshipLowReserve,

    RevokeSponsorshipOnlyTransferable,

    RevokeSponsorshipMalformed,
}

#[cfg(feature = "alloc")]
impl Default for RevokeSponsorshipResult {
    fn default() -> Self {
        Self::RevokeSponsorshipSuccess
    }
}

impl RevokeSponsorshipResult {
    pub const VARIANTS: [RevokeSponsorshipResultCode; 6] = [
        RevokeSponsorshipResultCode::RevokeSponsorshipSuccess,
        RevokeSponsorshipResultCode::RevokeSponsorshipDoesNotExist,
        RevokeSponsorshipResultCode::RevokeSponsorshipNotSponsor,
        RevokeSponsorshipResultCode::RevokeSponsorshipLowReserve,
        RevokeSponsorshipResultCode::RevokeSponsorshipOnlyTransferable,
        RevokeSponsorshipResultCode::RevokeSponsorshipMalformed,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "RevokeSponsorshipSuccess",
        "RevokeSponsorshipDoesNotExist",
        "RevokeSponsorshipNotSponsor",
        "RevokeSponsorshipLowReserve",
        "RevokeSponsorshipOnlyTransferable",
        "RevokeSponsorshipMalformed",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::RevokeSponsorshipSuccess => "RevokeSponsorshipSuccess",

            Self::RevokeSponsorshipDoesNotExist => "RevokeSponsorshipDoesNotExist",

            Self::RevokeSponsorshipNotSponsor => "RevokeSponsorshipNotSponsor",

            Self::RevokeSponsorshipLowReserve => "RevokeSponsorshipLowReserve",

            Self::RevokeSponsorshipOnlyTransferable => "RevokeSponsorshipOnlyTransferable",

            Self::RevokeSponsorshipMalformed => "RevokeSponsorshipMalformed",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> RevokeSponsorshipResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::RevokeSponsorshipSuccess => RevokeSponsorshipResultCode::RevokeSponsorshipSuccess,

            Self::RevokeSponsorshipDoesNotExist => {
                RevokeSponsorshipResultCode::RevokeSponsorshipDoesNotExist
            }

            Self::RevokeSponsorshipNotSponsor => {
                RevokeSponsorshipResultCode::RevokeSponsorshipNotSponsor
            }

            Self::RevokeSponsorshipLowReserve => {
                RevokeSponsorshipResultCode::RevokeSponsorshipLowReserve
            }

            Self::RevokeSponsorshipOnlyTransferable => {
                RevokeSponsorshipResultCode::RevokeSponsorshipOnlyTransferable
            }

            Self::RevokeSponsorshipMalformed => {
                RevokeSponsorshipResultCode::RevokeSponsorshipMalformed
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [RevokeSponsorshipResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for RevokeSponsorshipResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<RevokeSponsorshipResultCode> for RevokeSponsorshipResult {
    #[must_use]
    fn discriminant(&self) -> RevokeSponsorshipResultCode {
        Self::discriminant(self)
    }
}

impl Variants<RevokeSponsorshipResultCode> for RevokeSponsorshipResult {
    fn variants() -> slice::Iter<'static, RevokeSponsorshipResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<RevokeSponsorshipResultCode> for RevokeSponsorshipResult {}

impl ReadXdr for RevokeSponsorshipResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: RevokeSponsorshipResultCode =
                <RevokeSponsorshipResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                RevokeSponsorshipResultCode::RevokeSponsorshipSuccess => {
                    Self::RevokeSponsorshipSuccess
                }

                RevokeSponsorshipResultCode::RevokeSponsorshipDoesNotExist => {
                    Self::RevokeSponsorshipDoesNotExist
                }

                RevokeSponsorshipResultCode::RevokeSponsorshipNotSponsor => {
                    Self::RevokeSponsorshipNotSponsor
                }

                RevokeSponsorshipResultCode::RevokeSponsorshipLowReserve => {
                    Self::RevokeSponsorshipLowReserve
                }

                RevokeSponsorshipResultCode::RevokeSponsorshipOnlyTransferable => {
                    Self::RevokeSponsorshipOnlyTransferable
                }

                RevokeSponsorshipResultCode::RevokeSponsorshipMalformed => {
                    Self::RevokeSponsorshipMalformed
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for RevokeSponsorshipResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::RevokeSponsorshipSuccess => ().write_xdr(w)?,

                Self::RevokeSponsorshipDoesNotExist => ().write_xdr(w)?,

                Self::RevokeSponsorshipNotSponsor => ().write_xdr(w)?,

                Self::RevokeSponsorshipLowReserve => ().write_xdr(w)?,

                Self::RevokeSponsorshipOnlyTransferable => ().write_xdr(w)?,

                Self::RevokeSponsorshipMalformed => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClawbackResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ClawbackResultCode {
    #[cfg_attr(feature = "alloc", default)]
    ClawbackSuccess = 0,

    ClawbackMalformed = -1,

    ClawbackNotClawbackEnabled = -2,

    ClawbackNoTrust = -3,

    ClawbackUnderfunded = -4,
}

impl ClawbackResultCode {
    pub const VARIANTS: [ClawbackResultCode; 5] = [
        ClawbackResultCode::ClawbackSuccess,
        ClawbackResultCode::ClawbackMalformed,
        ClawbackResultCode::ClawbackNotClawbackEnabled,
        ClawbackResultCode::ClawbackNoTrust,
        ClawbackResultCode::ClawbackUnderfunded,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "ClawbackSuccess",
        "ClawbackMalformed",
        "ClawbackNotClawbackEnabled",
        "ClawbackNoTrust",
        "ClawbackUnderfunded",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClawbackSuccess => "ClawbackSuccess",

            Self::ClawbackMalformed => "ClawbackMalformed",

            Self::ClawbackNotClawbackEnabled => "ClawbackNotClawbackEnabled",

            Self::ClawbackNoTrust => "ClawbackNoTrust",

            Self::ClawbackUnderfunded => "ClawbackUnderfunded",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClawbackResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for ClawbackResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClawbackResultCode> for ClawbackResultCode {
    fn variants() -> slice::Iter<'static, ClawbackResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClawbackResultCode {}

impl fmt::Display for ClawbackResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClawbackResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ClawbackResultCode::ClawbackSuccess,

            -1 => ClawbackResultCode::ClawbackMalformed,

            -2 => ClawbackResultCode::ClawbackNotClawbackEnabled,

            -3 => ClawbackResultCode::ClawbackNoTrust,

            -4 => ClawbackResultCode::ClawbackUnderfunded,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClawbackResultCode> for i32 {
    #[must_use]
    fn from(e: ClawbackResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ClawbackResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClawbackResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClawbackResult
// union with discriminant ClawbackResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ClawbackResult {
    ClawbackSuccess,

    ClawbackMalformed,

    ClawbackNotClawbackEnabled,

    ClawbackNoTrust,

    ClawbackUnderfunded,
}

#[cfg(feature = "alloc")]
impl Default for ClawbackResult {
    fn default() -> Self {
        Self::ClawbackSuccess
    }
}

impl ClawbackResult {
    pub const VARIANTS: [ClawbackResultCode; 5] = [
        ClawbackResultCode::ClawbackSuccess,
        ClawbackResultCode::ClawbackMalformed,
        ClawbackResultCode::ClawbackNotClawbackEnabled,
        ClawbackResultCode::ClawbackNoTrust,
        ClawbackResultCode::ClawbackUnderfunded,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "ClawbackSuccess",
        "ClawbackMalformed",
        "ClawbackNotClawbackEnabled",
        "ClawbackNoTrust",
        "ClawbackUnderfunded",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClawbackSuccess => "ClawbackSuccess",

            Self::ClawbackMalformed => "ClawbackMalformed",

            Self::ClawbackNotClawbackEnabled => "ClawbackNotClawbackEnabled",

            Self::ClawbackNoTrust => "ClawbackNoTrust",

            Self::ClawbackUnderfunded => "ClawbackUnderfunded",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClawbackResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ClawbackSuccess => ClawbackResultCode::ClawbackSuccess,

            Self::ClawbackMalformed => ClawbackResultCode::ClawbackMalformed,

            Self::ClawbackNotClawbackEnabled => ClawbackResultCode::ClawbackNotClawbackEnabled,

            Self::ClawbackNoTrust => ClawbackResultCode::ClawbackNoTrust,

            Self::ClawbackUnderfunded => ClawbackResultCode::ClawbackUnderfunded,
        }
    }

    #[must_use]
    pub const fn variants() -> [ClawbackResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for ClawbackResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClawbackResultCode> for ClawbackResult {
    #[must_use]
    fn discriminant(&self) -> ClawbackResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ClawbackResultCode> for ClawbackResult {
    fn variants() -> slice::Iter<'static, ClawbackResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClawbackResultCode> for ClawbackResult {}

impl ReadXdr for ClawbackResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ClawbackResultCode = <ClawbackResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClawbackResultCode::ClawbackSuccess => Self::ClawbackSuccess,

                ClawbackResultCode::ClawbackMalformed => Self::ClawbackMalformed,

                ClawbackResultCode::ClawbackNotClawbackEnabled => Self::ClawbackNotClawbackEnabled,

                ClawbackResultCode::ClawbackNoTrust => Self::ClawbackNoTrust,

                ClawbackResultCode::ClawbackUnderfunded => Self::ClawbackUnderfunded,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClawbackResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ClawbackSuccess => ().write_xdr(w)?,

                Self::ClawbackMalformed => ().write_xdr(w)?,

                Self::ClawbackNotClawbackEnabled => ().write_xdr(w)?,

                Self::ClawbackNoTrust => ().write_xdr(w)?,

                Self::ClawbackUnderfunded => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClawbackClaimableBalanceResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ClawbackClaimableBalanceResultCode {
    #[cfg_attr(feature = "alloc", default)]
    ClawbackClaimableBalanceSuccess = 0,

    ClawbackClaimableBalanceDoesNotExist = -1,

    ClawbackClaimableBalanceNotIssuer = -2,

    ClawbackClaimableBalanceNotClawbackEnabled = -3,
}

impl ClawbackClaimableBalanceResultCode {
    pub const VARIANTS: [ClawbackClaimableBalanceResultCode; 4] = [
        ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceSuccess,
        ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceDoesNotExist,
        ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotIssuer,
        ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotClawbackEnabled,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "ClawbackClaimableBalanceSuccess",
        "ClawbackClaimableBalanceDoesNotExist",
        "ClawbackClaimableBalanceNotIssuer",
        "ClawbackClaimableBalanceNotClawbackEnabled",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClawbackClaimableBalanceSuccess => "ClawbackClaimableBalanceSuccess",

            Self::ClawbackClaimableBalanceDoesNotExist => "ClawbackClaimableBalanceDoesNotExist",

            Self::ClawbackClaimableBalanceNotIssuer => "ClawbackClaimableBalanceNotIssuer",

            Self::ClawbackClaimableBalanceNotClawbackEnabled => {
                "ClawbackClaimableBalanceNotClawbackEnabled"
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [ClawbackClaimableBalanceResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for ClawbackClaimableBalanceResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClawbackClaimableBalanceResultCode> for ClawbackClaimableBalanceResultCode {
    fn variants() -> slice::Iter<'static, ClawbackClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClawbackClaimableBalanceResultCode {}

impl fmt::Display for ClawbackClaimableBalanceResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClawbackClaimableBalanceResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceSuccess,

            -1 => ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceDoesNotExist,

            -2 => ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotIssuer,

            -3 => ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotClawbackEnabled,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClawbackClaimableBalanceResultCode> for i32 {
    #[must_use]
    fn from(e: ClawbackClaimableBalanceResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ClawbackClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClawbackClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClawbackClaimableBalanceResult
// union with discriminant ClawbackClaimableBalanceResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ClawbackClaimableBalanceResult {
    ClawbackClaimableBalanceSuccess,

    ClawbackClaimableBalanceDoesNotExist,

    ClawbackClaimableBalanceNotIssuer,

    ClawbackClaimableBalanceNotClawbackEnabled,
}

#[cfg(feature = "alloc")]
impl Default for ClawbackClaimableBalanceResult {
    fn default() -> Self {
        Self::ClawbackClaimableBalanceSuccess
    }
}

impl ClawbackClaimableBalanceResult {
    pub const VARIANTS: [ClawbackClaimableBalanceResultCode; 4] = [
        ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceSuccess,
        ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceDoesNotExist,
        ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotIssuer,
        ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotClawbackEnabled,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "ClawbackClaimableBalanceSuccess",
        "ClawbackClaimableBalanceDoesNotExist",
        "ClawbackClaimableBalanceNotIssuer",
        "ClawbackClaimableBalanceNotClawbackEnabled",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClawbackClaimableBalanceSuccess => "ClawbackClaimableBalanceSuccess",

            Self::ClawbackClaimableBalanceDoesNotExist => "ClawbackClaimableBalanceDoesNotExist",

            Self::ClawbackClaimableBalanceNotIssuer => "ClawbackClaimableBalanceNotIssuer",

            Self::ClawbackClaimableBalanceNotClawbackEnabled => {
                "ClawbackClaimableBalanceNotClawbackEnabled"
            }
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClawbackClaimableBalanceResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ClawbackClaimableBalanceSuccess => {
                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceSuccess
            }

            Self::ClawbackClaimableBalanceDoesNotExist => {
                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceDoesNotExist
            }

            Self::ClawbackClaimableBalanceNotIssuer => {
                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotIssuer
            }

            Self::ClawbackClaimableBalanceNotClawbackEnabled => {
                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotClawbackEnabled
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [ClawbackClaimableBalanceResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for ClawbackClaimableBalanceResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClawbackClaimableBalanceResultCode> for ClawbackClaimableBalanceResult {
    #[must_use]
    fn discriminant(&self) -> ClawbackClaimableBalanceResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ClawbackClaimableBalanceResultCode> for ClawbackClaimableBalanceResult {
    fn variants() -> slice::Iter<'static, ClawbackClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClawbackClaimableBalanceResultCode> for ClawbackClaimableBalanceResult {}

impl ReadXdr for ClawbackClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ClawbackClaimableBalanceResultCode =
                <ClawbackClaimableBalanceResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceSuccess => {
                    Self::ClawbackClaimableBalanceSuccess
                }

                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceDoesNotExist => {
                    Self::ClawbackClaimableBalanceDoesNotExist
                }

                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotIssuer => {
                    Self::ClawbackClaimableBalanceNotIssuer
                }

                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotClawbackEnabled => {
                    Self::ClawbackClaimableBalanceNotClawbackEnabled
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClawbackClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ClawbackClaimableBalanceSuccess => ().write_xdr(w)?,

                Self::ClawbackClaimableBalanceDoesNotExist => ().write_xdr(w)?,

                Self::ClawbackClaimableBalanceNotIssuer => ().write_xdr(w)?,

                Self::ClawbackClaimableBalanceNotClawbackEnabled => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SetTrustLineFlagsResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum SetTrustLineFlagsResultCode {
    #[cfg_attr(feature = "alloc", default)]
    SetTrustLineFlagsSuccess = 0,

    SetTrustLineFlagsMalformed = -1,

    SetTrustLineFlagsNoTrustLine = -2,

    SetTrustLineFlagsCantRevoke = -3,

    SetTrustLineFlagsInvalidState = -4,

    SetTrustLineFlagsLowReserve = -5,
}

impl SetTrustLineFlagsResultCode {
    pub const VARIANTS: [SetTrustLineFlagsResultCode; 6] = [
        SetTrustLineFlagsResultCode::SetTrustLineFlagsSuccess,
        SetTrustLineFlagsResultCode::SetTrustLineFlagsMalformed,
        SetTrustLineFlagsResultCode::SetTrustLineFlagsNoTrustLine,
        SetTrustLineFlagsResultCode::SetTrustLineFlagsCantRevoke,
        SetTrustLineFlagsResultCode::SetTrustLineFlagsInvalidState,
        SetTrustLineFlagsResultCode::SetTrustLineFlagsLowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "SetTrustLineFlagsSuccess",
        "SetTrustLineFlagsMalformed",
        "SetTrustLineFlagsNoTrustLine",
        "SetTrustLineFlagsCantRevoke",
        "SetTrustLineFlagsInvalidState",
        "SetTrustLineFlagsLowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SetTrustLineFlagsSuccess => "SetTrustLineFlagsSuccess",

            Self::SetTrustLineFlagsMalformed => "SetTrustLineFlagsMalformed",

            Self::SetTrustLineFlagsNoTrustLine => "SetTrustLineFlagsNoTrustLine",

            Self::SetTrustLineFlagsCantRevoke => "SetTrustLineFlagsCantRevoke",

            Self::SetTrustLineFlagsInvalidState => "SetTrustLineFlagsInvalidState",

            Self::SetTrustLineFlagsLowReserve => "SetTrustLineFlagsLowReserve",
        }
    }

    #[must_use]
    pub const fn variants() -> [SetTrustLineFlagsResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for SetTrustLineFlagsResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SetTrustLineFlagsResultCode> for SetTrustLineFlagsResultCode {
    fn variants() -> slice::Iter<'static, SetTrustLineFlagsResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SetTrustLineFlagsResultCode {}

impl fmt::Display for SetTrustLineFlagsResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SetTrustLineFlagsResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => SetTrustLineFlagsResultCode::SetTrustLineFlagsSuccess,

            -1 => SetTrustLineFlagsResultCode::SetTrustLineFlagsMalformed,

            -2 => SetTrustLineFlagsResultCode::SetTrustLineFlagsNoTrustLine,

            -3 => SetTrustLineFlagsResultCode::SetTrustLineFlagsCantRevoke,

            -4 => SetTrustLineFlagsResultCode::SetTrustLineFlagsInvalidState,

            -5 => SetTrustLineFlagsResultCode::SetTrustLineFlagsLowReserve,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SetTrustLineFlagsResultCode> for i32 {
    #[must_use]
    fn from(e: SetTrustLineFlagsResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for SetTrustLineFlagsResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SetTrustLineFlagsResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SetTrustLineFlagsResult
// union with discriminant SetTrustLineFlagsResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum SetTrustLineFlagsResult {
    SetTrustLineFlagsSuccess,

    SetTrustLineFlagsMalformed,

    SetTrustLineFlagsNoTrustLine,

    SetTrustLineFlagsCantRevoke,

    SetTrustLineFlagsInvalidState,

    SetTrustLineFlagsLowReserve,
}

#[cfg(feature = "alloc")]
impl Default for SetTrustLineFlagsResult {
    fn default() -> Self {
        Self::SetTrustLineFlagsSuccess
    }
}

impl SetTrustLineFlagsResult {
    pub const VARIANTS: [SetTrustLineFlagsResultCode; 6] = [
        SetTrustLineFlagsResultCode::SetTrustLineFlagsSuccess,
        SetTrustLineFlagsResultCode::SetTrustLineFlagsMalformed,
        SetTrustLineFlagsResultCode::SetTrustLineFlagsNoTrustLine,
        SetTrustLineFlagsResultCode::SetTrustLineFlagsCantRevoke,
        SetTrustLineFlagsResultCode::SetTrustLineFlagsInvalidState,
        SetTrustLineFlagsResultCode::SetTrustLineFlagsLowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "SetTrustLineFlagsSuccess",
        "SetTrustLineFlagsMalformed",
        "SetTrustLineFlagsNoTrustLine",
        "SetTrustLineFlagsCantRevoke",
        "SetTrustLineFlagsInvalidState",
        "SetTrustLineFlagsLowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SetTrustLineFlagsSuccess => "SetTrustLineFlagsSuccess",

            Self::SetTrustLineFlagsMalformed => "SetTrustLineFlagsMalformed",

            Self::SetTrustLineFlagsNoTrustLine => "SetTrustLineFlagsNoTrustLine",

            Self::SetTrustLineFlagsCantRevoke => "SetTrustLineFlagsCantRevoke",

            Self::SetTrustLineFlagsInvalidState => "SetTrustLineFlagsInvalidState",

            Self::SetTrustLineFlagsLowReserve => "SetTrustLineFlagsLowReserve",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SetTrustLineFlagsResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::SetTrustLineFlagsSuccess => SetTrustLineFlagsResultCode::SetTrustLineFlagsSuccess,

            Self::SetTrustLineFlagsMalformed => {
                SetTrustLineFlagsResultCode::SetTrustLineFlagsMalformed
            }

            Self::SetTrustLineFlagsNoTrustLine => {
                SetTrustLineFlagsResultCode::SetTrustLineFlagsNoTrustLine
            }

            Self::SetTrustLineFlagsCantRevoke => {
                SetTrustLineFlagsResultCode::SetTrustLineFlagsCantRevoke
            }

            Self::SetTrustLineFlagsInvalidState => {
                SetTrustLineFlagsResultCode::SetTrustLineFlagsInvalidState
            }

            Self::SetTrustLineFlagsLowReserve => {
                SetTrustLineFlagsResultCode::SetTrustLineFlagsLowReserve
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [SetTrustLineFlagsResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for SetTrustLineFlagsResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SetTrustLineFlagsResultCode> for SetTrustLineFlagsResult {
    #[must_use]
    fn discriminant(&self) -> SetTrustLineFlagsResultCode {
        Self::discriminant(self)
    }
}

impl Variants<SetTrustLineFlagsResultCode> for SetTrustLineFlagsResult {
    fn variants() -> slice::Iter<'static, SetTrustLineFlagsResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<SetTrustLineFlagsResultCode> for SetTrustLineFlagsResult {}

impl ReadXdr for SetTrustLineFlagsResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: SetTrustLineFlagsResultCode =
                <SetTrustLineFlagsResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                SetTrustLineFlagsResultCode::SetTrustLineFlagsSuccess => {
                    Self::SetTrustLineFlagsSuccess
                }

                SetTrustLineFlagsResultCode::SetTrustLineFlagsMalformed => {
                    Self::SetTrustLineFlagsMalformed
                }

                SetTrustLineFlagsResultCode::SetTrustLineFlagsNoTrustLine => {
                    Self::SetTrustLineFlagsNoTrustLine
                }

                SetTrustLineFlagsResultCode::SetTrustLineFlagsCantRevoke => {
                    Self::SetTrustLineFlagsCantRevoke
                }

                SetTrustLineFlagsResultCode::SetTrustLineFlagsInvalidState => {
                    Self::SetTrustLineFlagsInvalidState
                }

                SetTrustLineFlagsResultCode::SetTrustLineFlagsLowReserve => {
                    Self::SetTrustLineFlagsLowReserve
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SetTrustLineFlagsResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::SetTrustLineFlagsSuccess => ().write_xdr(w)?,

                Self::SetTrustLineFlagsMalformed => ().write_xdr(w)?,

                Self::SetTrustLineFlagsNoTrustLine => ().write_xdr(w)?,

                Self::SetTrustLineFlagsCantRevoke => ().write_xdr(w)?,

                Self::SetTrustLineFlagsInvalidState => ().write_xdr(w)?,

                Self::SetTrustLineFlagsLowReserve => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LiquidityPoolDepositResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum LiquidityPoolDepositResultCode {
    #[cfg_attr(feature = "alloc", default)]
    LiquidityPoolDepositSuccess = 0,

    LiquidityPoolDepositMalformed = -1,

    LiquidityPoolDepositNoTrust = -2,

    LiquidityPoolDepositNotAuthorized = -3,

    LiquidityPoolDepositUnderfunded = -4,

    LiquidityPoolDepositLineFull = -5,

    LiquidityPoolDepositBadPrice = -6,

    LiquidityPoolDepositPoolFull = -7,
}

impl LiquidityPoolDepositResultCode {
    pub const VARIANTS: [LiquidityPoolDepositResultCode; 8] = [
        LiquidityPoolDepositResultCode::LiquidityPoolDepositSuccess,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositMalformed,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositNoTrust,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositNotAuthorized,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositUnderfunded,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositLineFull,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositBadPrice,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositPoolFull,
    ];
    pub const VARIANTS_STR: [&'static str; 8] = [
        "LiquidityPoolDepositSuccess",
        "LiquidityPoolDepositMalformed",
        "LiquidityPoolDepositNoTrust",
        "LiquidityPoolDepositNotAuthorized",
        "LiquidityPoolDepositUnderfunded",
        "LiquidityPoolDepositLineFull",
        "LiquidityPoolDepositBadPrice",
        "LiquidityPoolDepositPoolFull",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LiquidityPoolDepositSuccess => "LiquidityPoolDepositSuccess",

            Self::LiquidityPoolDepositMalformed => "LiquidityPoolDepositMalformed",

            Self::LiquidityPoolDepositNoTrust => "LiquidityPoolDepositNoTrust",

            Self::LiquidityPoolDepositNotAuthorized => "LiquidityPoolDepositNotAuthorized",

            Self::LiquidityPoolDepositUnderfunded => "LiquidityPoolDepositUnderfunded",

            Self::LiquidityPoolDepositLineFull => "LiquidityPoolDepositLineFull",

            Self::LiquidityPoolDepositBadPrice => "LiquidityPoolDepositBadPrice",

            Self::LiquidityPoolDepositPoolFull => "LiquidityPoolDepositPoolFull",
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolDepositResultCode; 8] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolDepositResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LiquidityPoolDepositResultCode> for LiquidityPoolDepositResultCode {
    fn variants() -> slice::Iter<'static, LiquidityPoolDepositResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LiquidityPoolDepositResultCode {}

impl fmt::Display for LiquidityPoolDepositResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LiquidityPoolDepositResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => LiquidityPoolDepositResultCode::LiquidityPoolDepositSuccess,

            -1 => LiquidityPoolDepositResultCode::LiquidityPoolDepositMalformed,

            -2 => LiquidityPoolDepositResultCode::LiquidityPoolDepositNoTrust,

            -3 => LiquidityPoolDepositResultCode::LiquidityPoolDepositNotAuthorized,

            -4 => LiquidityPoolDepositResultCode::LiquidityPoolDepositUnderfunded,

            -5 => LiquidityPoolDepositResultCode::LiquidityPoolDepositLineFull,

            -6 => LiquidityPoolDepositResultCode::LiquidityPoolDepositBadPrice,

            -7 => LiquidityPoolDepositResultCode::LiquidityPoolDepositPoolFull,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LiquidityPoolDepositResultCode> for i32 {
    #[must_use]
    fn from(e: LiquidityPoolDepositResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for LiquidityPoolDepositResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolDepositResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LiquidityPoolDepositResult
// union with discriminant LiquidityPoolDepositResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LiquidityPoolDepositResult {
    LiquidityPoolDepositSuccess,

    LiquidityPoolDepositMalformed,

    LiquidityPoolDepositNoTrust,

    LiquidityPoolDepositNotAuthorized,

    LiquidityPoolDepositUnderfunded,

    LiquidityPoolDepositLineFull,

    LiquidityPoolDepositBadPrice,

    LiquidityPoolDepositPoolFull,
}

#[cfg(feature = "alloc")]
impl Default for LiquidityPoolDepositResult {
    fn default() -> Self {
        Self::LiquidityPoolDepositSuccess
    }
}

impl LiquidityPoolDepositResult {
    pub const VARIANTS: [LiquidityPoolDepositResultCode; 8] = [
        LiquidityPoolDepositResultCode::LiquidityPoolDepositSuccess,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositMalformed,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositNoTrust,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositNotAuthorized,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositUnderfunded,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositLineFull,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositBadPrice,
        LiquidityPoolDepositResultCode::LiquidityPoolDepositPoolFull,
    ];
    pub const VARIANTS_STR: [&'static str; 8] = [
        "LiquidityPoolDepositSuccess",
        "LiquidityPoolDepositMalformed",
        "LiquidityPoolDepositNoTrust",
        "LiquidityPoolDepositNotAuthorized",
        "LiquidityPoolDepositUnderfunded",
        "LiquidityPoolDepositLineFull",
        "LiquidityPoolDepositBadPrice",
        "LiquidityPoolDepositPoolFull",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LiquidityPoolDepositSuccess => "LiquidityPoolDepositSuccess",

            Self::LiquidityPoolDepositMalformed => "LiquidityPoolDepositMalformed",

            Self::LiquidityPoolDepositNoTrust => "LiquidityPoolDepositNoTrust",

            Self::LiquidityPoolDepositNotAuthorized => "LiquidityPoolDepositNotAuthorized",

            Self::LiquidityPoolDepositUnderfunded => "LiquidityPoolDepositUnderfunded",

            Self::LiquidityPoolDepositLineFull => "LiquidityPoolDepositLineFull",

            Self::LiquidityPoolDepositBadPrice => "LiquidityPoolDepositBadPrice",

            Self::LiquidityPoolDepositPoolFull => "LiquidityPoolDepositPoolFull",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LiquidityPoolDepositResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::LiquidityPoolDepositSuccess => {
                LiquidityPoolDepositResultCode::LiquidityPoolDepositSuccess
            }

            Self::LiquidityPoolDepositMalformed => {
                LiquidityPoolDepositResultCode::LiquidityPoolDepositMalformed
            }

            Self::LiquidityPoolDepositNoTrust => {
                LiquidityPoolDepositResultCode::LiquidityPoolDepositNoTrust
            }

            Self::LiquidityPoolDepositNotAuthorized => {
                LiquidityPoolDepositResultCode::LiquidityPoolDepositNotAuthorized
            }

            Self::LiquidityPoolDepositUnderfunded => {
                LiquidityPoolDepositResultCode::LiquidityPoolDepositUnderfunded
            }

            Self::LiquidityPoolDepositLineFull => {
                LiquidityPoolDepositResultCode::LiquidityPoolDepositLineFull
            }

            Self::LiquidityPoolDepositBadPrice => {
                LiquidityPoolDepositResultCode::LiquidityPoolDepositBadPrice
            }

            Self::LiquidityPoolDepositPoolFull => {
                LiquidityPoolDepositResultCode::LiquidityPoolDepositPoolFull
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolDepositResultCode; 8] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolDepositResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LiquidityPoolDepositResultCode> for LiquidityPoolDepositResult {
    #[must_use]
    fn discriminant(&self) -> LiquidityPoolDepositResultCode {
        Self::discriminant(self)
    }
}

impl Variants<LiquidityPoolDepositResultCode> for LiquidityPoolDepositResult {
    fn variants() -> slice::Iter<'static, LiquidityPoolDepositResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<LiquidityPoolDepositResultCode> for LiquidityPoolDepositResult {}

impl ReadXdr for LiquidityPoolDepositResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: LiquidityPoolDepositResultCode =
                <LiquidityPoolDepositResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LiquidityPoolDepositResultCode::LiquidityPoolDepositSuccess => {
                    Self::LiquidityPoolDepositSuccess
                }

                LiquidityPoolDepositResultCode::LiquidityPoolDepositMalformed => {
                    Self::LiquidityPoolDepositMalformed
                }

                LiquidityPoolDepositResultCode::LiquidityPoolDepositNoTrust => {
                    Self::LiquidityPoolDepositNoTrust
                }

                LiquidityPoolDepositResultCode::LiquidityPoolDepositNotAuthorized => {
                    Self::LiquidityPoolDepositNotAuthorized
                }

                LiquidityPoolDepositResultCode::LiquidityPoolDepositUnderfunded => {
                    Self::LiquidityPoolDepositUnderfunded
                }

                LiquidityPoolDepositResultCode::LiquidityPoolDepositLineFull => {
                    Self::LiquidityPoolDepositLineFull
                }

                LiquidityPoolDepositResultCode::LiquidityPoolDepositBadPrice => {
                    Self::LiquidityPoolDepositBadPrice
                }

                LiquidityPoolDepositResultCode::LiquidityPoolDepositPoolFull => {
                    Self::LiquidityPoolDepositPoolFull
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolDepositResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::LiquidityPoolDepositSuccess => ().write_xdr(w)?,

                Self::LiquidityPoolDepositMalformed => ().write_xdr(w)?,

                Self::LiquidityPoolDepositNoTrust => ().write_xdr(w)?,

                Self::LiquidityPoolDepositNotAuthorized => ().write_xdr(w)?,

                Self::LiquidityPoolDepositUnderfunded => ().write_xdr(w)?,

                Self::LiquidityPoolDepositLineFull => ().write_xdr(w)?,

                Self::LiquidityPoolDepositBadPrice => ().write_xdr(w)?,

                Self::LiquidityPoolDepositPoolFull => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LiquidityPoolWithdrawResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum LiquidityPoolWithdrawResultCode {
    #[cfg_attr(feature = "alloc", default)]
    LiquidityPoolWithdrawSuccess = 0,

    LiquidityPoolWithdrawMalformed = -1,

    LiquidityPoolWithdrawNoTrust = -2,

    LiquidityPoolWithdrawUnderfunded = -3,

    LiquidityPoolWithdrawLineFull = -4,

    LiquidityPoolWithdrawUnderMinimum = -5,
}

impl LiquidityPoolWithdrawResultCode {
    pub const VARIANTS: [LiquidityPoolWithdrawResultCode; 6] = [
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawSuccess,
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawMalformed,
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawNoTrust,
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderfunded,
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawLineFull,
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderMinimum,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "LiquidityPoolWithdrawSuccess",
        "LiquidityPoolWithdrawMalformed",
        "LiquidityPoolWithdrawNoTrust",
        "LiquidityPoolWithdrawUnderfunded",
        "LiquidityPoolWithdrawLineFull",
        "LiquidityPoolWithdrawUnderMinimum",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LiquidityPoolWithdrawSuccess => "LiquidityPoolWithdrawSuccess",

            Self::LiquidityPoolWithdrawMalformed => "LiquidityPoolWithdrawMalformed",

            Self::LiquidityPoolWithdrawNoTrust => "LiquidityPoolWithdrawNoTrust",

            Self::LiquidityPoolWithdrawUnderfunded => "LiquidityPoolWithdrawUnderfunded",

            Self::LiquidityPoolWithdrawLineFull => "LiquidityPoolWithdrawLineFull",

            Self::LiquidityPoolWithdrawUnderMinimum => "LiquidityPoolWithdrawUnderMinimum",
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolWithdrawResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolWithdrawResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LiquidityPoolWithdrawResultCode> for LiquidityPoolWithdrawResultCode {
    fn variants() -> slice::Iter<'static, LiquidityPoolWithdrawResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LiquidityPoolWithdrawResultCode {}

impl fmt::Display for LiquidityPoolWithdrawResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LiquidityPoolWithdrawResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawSuccess,

            -1 => LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawMalformed,

            -2 => LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawNoTrust,

            -3 => LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderfunded,

            -4 => LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawLineFull,

            -5 => LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderMinimum,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LiquidityPoolWithdrawResultCode> for i32 {
    #[must_use]
    fn from(e: LiquidityPoolWithdrawResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for LiquidityPoolWithdrawResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolWithdrawResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LiquidityPoolWithdrawResult
// union with discriminant LiquidityPoolWithdrawResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum LiquidityPoolWithdrawResult {
    LiquidityPoolWithdrawSuccess,

    LiquidityPoolWithdrawMalformed,

    LiquidityPoolWithdrawNoTrust,

    LiquidityPoolWithdrawUnderfunded,

    LiquidityPoolWithdrawLineFull,

    LiquidityPoolWithdrawUnderMinimum,
}

#[cfg(feature = "alloc")]
impl Default for LiquidityPoolWithdrawResult {
    fn default() -> Self {
        Self::LiquidityPoolWithdrawSuccess
    }
}

impl LiquidityPoolWithdrawResult {
    pub const VARIANTS: [LiquidityPoolWithdrawResultCode; 6] = [
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawSuccess,
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawMalformed,
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawNoTrust,
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderfunded,
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawLineFull,
        LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderMinimum,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "LiquidityPoolWithdrawSuccess",
        "LiquidityPoolWithdrawMalformed",
        "LiquidityPoolWithdrawNoTrust",
        "LiquidityPoolWithdrawUnderfunded",
        "LiquidityPoolWithdrawLineFull",
        "LiquidityPoolWithdrawUnderMinimum",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LiquidityPoolWithdrawSuccess => "LiquidityPoolWithdrawSuccess",

            Self::LiquidityPoolWithdrawMalformed => "LiquidityPoolWithdrawMalformed",

            Self::LiquidityPoolWithdrawNoTrust => "LiquidityPoolWithdrawNoTrust",

            Self::LiquidityPoolWithdrawUnderfunded => "LiquidityPoolWithdrawUnderfunded",

            Self::LiquidityPoolWithdrawLineFull => "LiquidityPoolWithdrawLineFull",

            Self::LiquidityPoolWithdrawUnderMinimum => "LiquidityPoolWithdrawUnderMinimum",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LiquidityPoolWithdrawResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::LiquidityPoolWithdrawSuccess => {
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawSuccess
            }

            Self::LiquidityPoolWithdrawMalformed => {
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawMalformed
            }

            Self::LiquidityPoolWithdrawNoTrust => {
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawNoTrust
            }

            Self::LiquidityPoolWithdrawUnderfunded => {
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderfunded
            }

            Self::LiquidityPoolWithdrawLineFull => {
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawLineFull
            }

            Self::LiquidityPoolWithdrawUnderMinimum => {
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderMinimum
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolWithdrawResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolWithdrawResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LiquidityPoolWithdrawResultCode> for LiquidityPoolWithdrawResult {
    #[must_use]
    fn discriminant(&self) -> LiquidityPoolWithdrawResultCode {
        Self::discriminant(self)
    }
}

impl Variants<LiquidityPoolWithdrawResultCode> for LiquidityPoolWithdrawResult {
    fn variants() -> slice::Iter<'static, LiquidityPoolWithdrawResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<LiquidityPoolWithdrawResultCode> for LiquidityPoolWithdrawResult {}

impl ReadXdr for LiquidityPoolWithdrawResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: LiquidityPoolWithdrawResultCode =
                <LiquidityPoolWithdrawResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawSuccess => {
                    Self::LiquidityPoolWithdrawSuccess
                }

                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawMalformed => {
                    Self::LiquidityPoolWithdrawMalformed
                }

                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawNoTrust => {
                    Self::LiquidityPoolWithdrawNoTrust
                }

                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderfunded => {
                    Self::LiquidityPoolWithdrawUnderfunded
                }

                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawLineFull => {
                    Self::LiquidityPoolWithdrawLineFull
                }

                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderMinimum => {
                    Self::LiquidityPoolWithdrawUnderMinimum
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolWithdrawResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::LiquidityPoolWithdrawSuccess => ().write_xdr(w)?,

                Self::LiquidityPoolWithdrawMalformed => ().write_xdr(w)?,

                Self::LiquidityPoolWithdrawNoTrust => ().write_xdr(w)?,

                Self::LiquidityPoolWithdrawUnderfunded => ().write_xdr(w)?,

                Self::LiquidityPoolWithdrawLineFull => ().write_xdr(w)?,

                Self::LiquidityPoolWithdrawUnderMinimum => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// InvokeHostFunctionResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum InvokeHostFunctionResultCode {
    #[cfg_attr(feature = "alloc", default)]
    InvokeHostFunctionSuccess = 0,

    InvokeHostFunctionMalformed = -1,

    InvokeHostFunctionTrapped = -2,

    InvokeHostFunctionResourceLimitExceeded = -3,

    InvokeHostFunctionEntryArchived = -4,

    InvokeHostFunctionInsufficientRefundableFee = -5,
}

impl InvokeHostFunctionResultCode {
    pub const VARIANTS: [InvokeHostFunctionResultCode; 6] = [
        InvokeHostFunctionResultCode::InvokeHostFunctionSuccess,
        InvokeHostFunctionResultCode::InvokeHostFunctionMalformed,
        InvokeHostFunctionResultCode::InvokeHostFunctionTrapped,
        InvokeHostFunctionResultCode::InvokeHostFunctionResourceLimitExceeded,
        InvokeHostFunctionResultCode::InvokeHostFunctionEntryArchived,
        InvokeHostFunctionResultCode::InvokeHostFunctionInsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "InvokeHostFunctionSuccess",
        "InvokeHostFunctionMalformed",
        "InvokeHostFunctionTrapped",
        "InvokeHostFunctionResourceLimitExceeded",
        "InvokeHostFunctionEntryArchived",
        "InvokeHostFunctionInsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::InvokeHostFunctionSuccess => "InvokeHostFunctionSuccess",

            Self::InvokeHostFunctionMalformed => "InvokeHostFunctionMalformed",

            Self::InvokeHostFunctionTrapped => "InvokeHostFunctionTrapped",

            Self::InvokeHostFunctionResourceLimitExceeded => {
                "InvokeHostFunctionResourceLimitExceeded"
            }

            Self::InvokeHostFunctionEntryArchived => "InvokeHostFunctionEntryArchived",

            Self::InvokeHostFunctionInsufficientRefundableFee => {
                "InvokeHostFunctionInsufficientRefundableFee"
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [InvokeHostFunctionResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for InvokeHostFunctionResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<InvokeHostFunctionResultCode> for InvokeHostFunctionResultCode {
    fn variants() -> slice::Iter<'static, InvokeHostFunctionResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for InvokeHostFunctionResultCode {}

impl fmt::Display for InvokeHostFunctionResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for InvokeHostFunctionResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => InvokeHostFunctionResultCode::InvokeHostFunctionSuccess,

            -1 => InvokeHostFunctionResultCode::InvokeHostFunctionMalformed,

            -2 => InvokeHostFunctionResultCode::InvokeHostFunctionTrapped,

            -3 => InvokeHostFunctionResultCode::InvokeHostFunctionResourceLimitExceeded,

            -4 => InvokeHostFunctionResultCode::InvokeHostFunctionEntryArchived,

            -5 => InvokeHostFunctionResultCode::InvokeHostFunctionInsufficientRefundableFee,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<InvokeHostFunctionResultCode> for i32 {
    #[must_use]
    fn from(e: InvokeHostFunctionResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for InvokeHostFunctionResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for InvokeHostFunctionResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// InvokeHostFunctionResult
// union with discriminant InvokeHostFunctionResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum InvokeHostFunctionResult {
    InvokeHostFunctionSuccess(Hash),

    InvokeHostFunctionMalformed,

    InvokeHostFunctionTrapped,

    InvokeHostFunctionResourceLimitExceeded,

    InvokeHostFunctionEntryArchived,

    InvokeHostFunctionInsufficientRefundableFee,
}

#[cfg(feature = "alloc")]
impl Default for InvokeHostFunctionResult {
    fn default() -> Self {
        Self::InvokeHostFunctionSuccess(Hash::default())
    }
}

impl InvokeHostFunctionResult {
    pub const VARIANTS: [InvokeHostFunctionResultCode; 6] = [
        InvokeHostFunctionResultCode::InvokeHostFunctionSuccess,
        InvokeHostFunctionResultCode::InvokeHostFunctionMalformed,
        InvokeHostFunctionResultCode::InvokeHostFunctionTrapped,
        InvokeHostFunctionResultCode::InvokeHostFunctionResourceLimitExceeded,
        InvokeHostFunctionResultCode::InvokeHostFunctionEntryArchived,
        InvokeHostFunctionResultCode::InvokeHostFunctionInsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "InvokeHostFunctionSuccess",
        "InvokeHostFunctionMalformed",
        "InvokeHostFunctionTrapped",
        "InvokeHostFunctionResourceLimitExceeded",
        "InvokeHostFunctionEntryArchived",
        "InvokeHostFunctionInsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::InvokeHostFunctionSuccess(_) => "InvokeHostFunctionSuccess",

            Self::InvokeHostFunctionMalformed => "InvokeHostFunctionMalformed",

            Self::InvokeHostFunctionTrapped => "InvokeHostFunctionTrapped",

            Self::InvokeHostFunctionResourceLimitExceeded => {
                "InvokeHostFunctionResourceLimitExceeded"
            }

            Self::InvokeHostFunctionEntryArchived => "InvokeHostFunctionEntryArchived",

            Self::InvokeHostFunctionInsufficientRefundableFee => {
                "InvokeHostFunctionInsufficientRefundableFee"
            }
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> InvokeHostFunctionResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::InvokeHostFunctionSuccess(_) => {
                InvokeHostFunctionResultCode::InvokeHostFunctionSuccess
            }

            Self::InvokeHostFunctionMalformed => {
                InvokeHostFunctionResultCode::InvokeHostFunctionMalformed
            }

            Self::InvokeHostFunctionTrapped => {
                InvokeHostFunctionResultCode::InvokeHostFunctionTrapped
            }

            Self::InvokeHostFunctionResourceLimitExceeded => {
                InvokeHostFunctionResultCode::InvokeHostFunctionResourceLimitExceeded
            }

            Self::InvokeHostFunctionEntryArchived => {
                InvokeHostFunctionResultCode::InvokeHostFunctionEntryArchived
            }

            Self::InvokeHostFunctionInsufficientRefundableFee => {
                InvokeHostFunctionResultCode::InvokeHostFunctionInsufficientRefundableFee
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [InvokeHostFunctionResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for InvokeHostFunctionResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<InvokeHostFunctionResultCode> for InvokeHostFunctionResult {
    #[must_use]
    fn discriminant(&self) -> InvokeHostFunctionResultCode {
        Self::discriminant(self)
    }
}

impl Variants<InvokeHostFunctionResultCode> for InvokeHostFunctionResult {
    fn variants() -> slice::Iter<'static, InvokeHostFunctionResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<InvokeHostFunctionResultCode> for InvokeHostFunctionResult {}

impl ReadXdr for InvokeHostFunctionResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: InvokeHostFunctionResultCode =
                <InvokeHostFunctionResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                InvokeHostFunctionResultCode::InvokeHostFunctionSuccess => {
                    Self::InvokeHostFunctionSuccess(Hash::read_xdr(r)?)
                }

                InvokeHostFunctionResultCode::InvokeHostFunctionMalformed => {
                    Self::InvokeHostFunctionMalformed
                }

                InvokeHostFunctionResultCode::InvokeHostFunctionTrapped => {
                    Self::InvokeHostFunctionTrapped
                }

                InvokeHostFunctionResultCode::InvokeHostFunctionResourceLimitExceeded => {
                    Self::InvokeHostFunctionResourceLimitExceeded
                }

                InvokeHostFunctionResultCode::InvokeHostFunctionEntryArchived => {
                    Self::InvokeHostFunctionEntryArchived
                }

                InvokeHostFunctionResultCode::InvokeHostFunctionInsufficientRefundableFee => {
                    Self::InvokeHostFunctionInsufficientRefundableFee
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for InvokeHostFunctionResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::InvokeHostFunctionSuccess(v) => v.write_xdr(w)?,

                Self::InvokeHostFunctionMalformed => ().write_xdr(w)?,

                Self::InvokeHostFunctionTrapped => ().write_xdr(w)?,

                Self::InvokeHostFunctionResourceLimitExceeded => ().write_xdr(w)?,

                Self::InvokeHostFunctionEntryArchived => ().write_xdr(w)?,

                Self::InvokeHostFunctionInsufficientRefundableFee => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ExtendFootprintTtlResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ExtendFootprintTtlResultCode {
    #[cfg_attr(feature = "alloc", default)]
    ExtendFootprintTtlSuccess = 0,

    ExtendFootprintTtlMalformed = -1,

    ExtendFootprintTtlResourceLimitExceeded = -2,

    ExtendFootprintTtlInsufficientRefundableFee = -3,
}

impl ExtendFootprintTtlResultCode {
    pub const VARIANTS: [ExtendFootprintTtlResultCode; 4] = [
        ExtendFootprintTtlResultCode::ExtendFootprintTtlSuccess,
        ExtendFootprintTtlResultCode::ExtendFootprintTtlMalformed,
        ExtendFootprintTtlResultCode::ExtendFootprintTtlResourceLimitExceeded,
        ExtendFootprintTtlResultCode::ExtendFootprintTtlInsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "ExtendFootprintTtlSuccess",
        "ExtendFootprintTtlMalformed",
        "ExtendFootprintTtlResourceLimitExceeded",
        "ExtendFootprintTtlInsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ExtendFootprintTtlSuccess => "ExtendFootprintTtlSuccess",

            Self::ExtendFootprintTtlMalformed => "ExtendFootprintTtlMalformed",

            Self::ExtendFootprintTtlResourceLimitExceeded => {
                "ExtendFootprintTtlResourceLimitExceeded"
            }

            Self::ExtendFootprintTtlInsufficientRefundableFee => {
                "ExtendFootprintTtlInsufficientRefundableFee"
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [ExtendFootprintTtlResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for ExtendFootprintTtlResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ExtendFootprintTtlResultCode> for ExtendFootprintTtlResultCode {
    fn variants() -> slice::Iter<'static, ExtendFootprintTtlResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ExtendFootprintTtlResultCode {}

impl fmt::Display for ExtendFootprintTtlResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ExtendFootprintTtlResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ExtendFootprintTtlResultCode::ExtendFootprintTtlSuccess,

            -1 => ExtendFootprintTtlResultCode::ExtendFootprintTtlMalformed,

            -2 => ExtendFootprintTtlResultCode::ExtendFootprintTtlResourceLimitExceeded,

            -3 => ExtendFootprintTtlResultCode::ExtendFootprintTtlInsufficientRefundableFee,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ExtendFootprintTtlResultCode> for i32 {
    #[must_use]
    fn from(e: ExtendFootprintTtlResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ExtendFootprintTtlResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ExtendFootprintTtlResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ExtendFootprintTtlResult
// union with discriminant ExtendFootprintTtlResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ExtendFootprintTtlResult {
    ExtendFootprintTtlSuccess,

    ExtendFootprintTtlMalformed,

    ExtendFootprintTtlResourceLimitExceeded,

    ExtendFootprintTtlInsufficientRefundableFee,
}

#[cfg(feature = "alloc")]
impl Default for ExtendFootprintTtlResult {
    fn default() -> Self {
        Self::ExtendFootprintTtlSuccess
    }
}

impl ExtendFootprintTtlResult {
    pub const VARIANTS: [ExtendFootprintTtlResultCode; 4] = [
        ExtendFootprintTtlResultCode::ExtendFootprintTtlSuccess,
        ExtendFootprintTtlResultCode::ExtendFootprintTtlMalformed,
        ExtendFootprintTtlResultCode::ExtendFootprintTtlResourceLimitExceeded,
        ExtendFootprintTtlResultCode::ExtendFootprintTtlInsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "ExtendFootprintTtlSuccess",
        "ExtendFootprintTtlMalformed",
        "ExtendFootprintTtlResourceLimitExceeded",
        "ExtendFootprintTtlInsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ExtendFootprintTtlSuccess => "ExtendFootprintTtlSuccess",

            Self::ExtendFootprintTtlMalformed => "ExtendFootprintTtlMalformed",

            Self::ExtendFootprintTtlResourceLimitExceeded => {
                "ExtendFootprintTtlResourceLimitExceeded"
            }

            Self::ExtendFootprintTtlInsufficientRefundableFee => {
                "ExtendFootprintTtlInsufficientRefundableFee"
            }
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ExtendFootprintTtlResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ExtendFootprintTtlSuccess => {
                ExtendFootprintTtlResultCode::ExtendFootprintTtlSuccess
            }

            Self::ExtendFootprintTtlMalformed => {
                ExtendFootprintTtlResultCode::ExtendFootprintTtlMalformed
            }

            Self::ExtendFootprintTtlResourceLimitExceeded => {
                ExtendFootprintTtlResultCode::ExtendFootprintTtlResourceLimitExceeded
            }

            Self::ExtendFootprintTtlInsufficientRefundableFee => {
                ExtendFootprintTtlResultCode::ExtendFootprintTtlInsufficientRefundableFee
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [ExtendFootprintTtlResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for ExtendFootprintTtlResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ExtendFootprintTtlResultCode> for ExtendFootprintTtlResult {
    #[must_use]
    fn discriminant(&self) -> ExtendFootprintTtlResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ExtendFootprintTtlResultCode> for ExtendFootprintTtlResult {
    fn variants() -> slice::Iter<'static, ExtendFootprintTtlResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ExtendFootprintTtlResultCode> for ExtendFootprintTtlResult {}

impl ReadXdr for ExtendFootprintTtlResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ExtendFootprintTtlResultCode =
                <ExtendFootprintTtlResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ExtendFootprintTtlResultCode::ExtendFootprintTtlSuccess => {
                    Self::ExtendFootprintTtlSuccess
                }

                ExtendFootprintTtlResultCode::ExtendFootprintTtlMalformed => {
                    Self::ExtendFootprintTtlMalformed
                }

                ExtendFootprintTtlResultCode::ExtendFootprintTtlResourceLimitExceeded => {
                    Self::ExtendFootprintTtlResourceLimitExceeded
                }

                ExtendFootprintTtlResultCode::ExtendFootprintTtlInsufficientRefundableFee => {
                    Self::ExtendFootprintTtlInsufficientRefundableFee
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ExtendFootprintTtlResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ExtendFootprintTtlSuccess => ().write_xdr(w)?,

                Self::ExtendFootprintTtlMalformed => ().write_xdr(w)?,

                Self::ExtendFootprintTtlResourceLimitExceeded => ().write_xdr(w)?,

                Self::ExtendFootprintTtlInsufficientRefundableFee => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// RestoreFootprintResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum RestoreFootprintResultCode {
    #[cfg_attr(feature = "alloc", default)]
    RestoreFootprintSuccess = 0,

    RestoreFootprintMalformed = -1,

    RestoreFootprintResourceLimitExceeded = -2,

    RestoreFootprintInsufficientRefundableFee = -3,
}

impl RestoreFootprintResultCode {
    pub const VARIANTS: [RestoreFootprintResultCode; 4] = [
        RestoreFootprintResultCode::RestoreFootprintSuccess,
        RestoreFootprintResultCode::RestoreFootprintMalformed,
        RestoreFootprintResultCode::RestoreFootprintResourceLimitExceeded,
        RestoreFootprintResultCode::RestoreFootprintInsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "RestoreFootprintSuccess",
        "RestoreFootprintMalformed",
        "RestoreFootprintResourceLimitExceeded",
        "RestoreFootprintInsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::RestoreFootprintSuccess => "RestoreFootprintSuccess",

            Self::RestoreFootprintMalformed => "RestoreFootprintMalformed",

            Self::RestoreFootprintResourceLimitExceeded => "RestoreFootprintResourceLimitExceeded",

            Self::RestoreFootprintInsufficientRefundableFee => {
                "RestoreFootprintInsufficientRefundableFee"
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [RestoreFootprintResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for RestoreFootprintResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<RestoreFootprintResultCode> for RestoreFootprintResultCode {
    fn variants() -> slice::Iter<'static, RestoreFootprintResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for RestoreFootprintResultCode {}

impl fmt::Display for RestoreFootprintResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for RestoreFootprintResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => RestoreFootprintResultCode::RestoreFootprintSuccess,

            -1 => RestoreFootprintResultCode::RestoreFootprintMalformed,

            -2 => RestoreFootprintResultCode::RestoreFootprintResourceLimitExceeded,

            -3 => RestoreFootprintResultCode::RestoreFootprintInsufficientRefundableFee,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<RestoreFootprintResultCode> for i32 {
    #[must_use]
    fn from(e: RestoreFootprintResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for RestoreFootprintResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for RestoreFootprintResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// RestoreFootprintResult
// union with discriminant RestoreFootprintResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum RestoreFootprintResult {
    RestoreFootprintSuccess,

    RestoreFootprintMalformed,

    RestoreFootprintResourceLimitExceeded,

    RestoreFootprintInsufficientRefundableFee,
}

#[cfg(feature = "alloc")]
impl Default for RestoreFootprintResult {
    fn default() -> Self {
        Self::RestoreFootprintSuccess
    }
}

impl RestoreFootprintResult {
    pub const VARIANTS: [RestoreFootprintResultCode; 4] = [
        RestoreFootprintResultCode::RestoreFootprintSuccess,
        RestoreFootprintResultCode::RestoreFootprintMalformed,
        RestoreFootprintResultCode::RestoreFootprintResourceLimitExceeded,
        RestoreFootprintResultCode::RestoreFootprintInsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "RestoreFootprintSuccess",
        "RestoreFootprintMalformed",
        "RestoreFootprintResourceLimitExceeded",
        "RestoreFootprintInsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::RestoreFootprintSuccess => "RestoreFootprintSuccess",

            Self::RestoreFootprintMalformed => "RestoreFootprintMalformed",

            Self::RestoreFootprintResourceLimitExceeded => "RestoreFootprintResourceLimitExceeded",

            Self::RestoreFootprintInsufficientRefundableFee => {
                "RestoreFootprintInsufficientRefundableFee"
            }
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> RestoreFootprintResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::RestoreFootprintSuccess => RestoreFootprintResultCode::RestoreFootprintSuccess,

            Self::RestoreFootprintMalformed => {
                RestoreFootprintResultCode::RestoreFootprintMalformed
            }

            Self::RestoreFootprintResourceLimitExceeded => {
                RestoreFootprintResultCode::RestoreFootprintResourceLimitExceeded
            }

            Self::RestoreFootprintInsufficientRefundableFee => {
                RestoreFootprintResultCode::RestoreFootprintInsufficientRefundableFee
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [RestoreFootprintResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for RestoreFootprintResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<RestoreFootprintResultCode> for RestoreFootprintResult {
    #[must_use]
    fn discriminant(&self) -> RestoreFootprintResultCode {
        Self::discriminant(self)
    }
}

impl Variants<RestoreFootprintResultCode> for RestoreFootprintResult {
    fn variants() -> slice::Iter<'static, RestoreFootprintResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<RestoreFootprintResultCode> for RestoreFootprintResult {}

impl ReadXdr for RestoreFootprintResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: RestoreFootprintResultCode =
                <RestoreFootprintResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                RestoreFootprintResultCode::RestoreFootprintSuccess => {
                    Self::RestoreFootprintSuccess
                }

                RestoreFootprintResultCode::RestoreFootprintMalformed => {
                    Self::RestoreFootprintMalformed
                }

                RestoreFootprintResultCode::RestoreFootprintResourceLimitExceeded => {
                    Self::RestoreFootprintResourceLimitExceeded
                }

                RestoreFootprintResultCode::RestoreFootprintInsufficientRefundableFee => {
                    Self::RestoreFootprintInsufficientRefundableFee
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for RestoreFootprintResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::RestoreFootprintSuccess => ().write_xdr(w)?,

                Self::RestoreFootprintMalformed => ().write_xdr(w)?,

                Self::RestoreFootprintResourceLimitExceeded => ().write_xdr(w)?,

                Self::RestoreFootprintInsufficientRefundableFee => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// OperationResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum OperationResultCode {
    #[cfg_attr(feature = "alloc", default)]
    OpInner = 0,

    OpBadAuth = -1,

    OpNoAccount = -2,

    OpNotSupported = -3,

    OpTooManySubentries = -4,

    OpExceededWorkLimit = -5,

    OpTooManySponsoring = -6,
}

impl OperationResultCode {
    pub const VARIANTS: [OperationResultCode; 7] = [
        OperationResultCode::OpInner,
        OperationResultCode::OpBadAuth,
        OperationResultCode::OpNoAccount,
        OperationResultCode::OpNotSupported,
        OperationResultCode::OpTooManySubentries,
        OperationResultCode::OpExceededWorkLimit,
        OperationResultCode::OpTooManySponsoring,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "OpInner",
        "OpBadAuth",
        "OpNoAccount",
        "OpNotSupported",
        "OpTooManySubentries",
        "OpExceededWorkLimit",
        "OpTooManySponsoring",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::OpInner => "OpInner",

            Self::OpBadAuth => "OpBadAuth",

            Self::OpNoAccount => "OpNoAccount",

            Self::OpNotSupported => "OpNotSupported",

            Self::OpTooManySubentries => "OpTooManySubentries",

            Self::OpExceededWorkLimit => "OpExceededWorkLimit",

            Self::OpTooManySponsoring => "OpTooManySponsoring",
        }
    }

    #[must_use]
    pub const fn variants() -> [OperationResultCode; 7] {
        Self::VARIANTS
    }
}

impl Name for OperationResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<OperationResultCode> for OperationResultCode {
    fn variants() -> slice::Iter<'static, OperationResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for OperationResultCode {}

impl fmt::Display for OperationResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for OperationResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => OperationResultCode::OpInner,

            -1 => OperationResultCode::OpBadAuth,

            -2 => OperationResultCode::OpNoAccount,

            -3 => OperationResultCode::OpNotSupported,

            -4 => OperationResultCode::OpTooManySubentries,

            -5 => OperationResultCode::OpExceededWorkLimit,

            -6 => OperationResultCode::OpTooManySponsoring,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<OperationResultCode> for i32 {
    #[must_use]
    fn from(e: OperationResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for OperationResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for OperationResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// OperationResult
// union with discriminant OperationResultCode
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum OperationResult {
    OpInner(OperationResultTr),

    OpBadAuth,

    OpNoAccount,

    OpNotSupported,

    OpTooManySubentries,

    OpExceededWorkLimit,

    OpTooManySponsoring,
}

#[cfg(feature = "alloc")]
impl Default for OperationResult {
    fn default() -> Self {
        Self::OpInner(OperationResultTr::default())
    }
}

impl OperationResult {
    pub const VARIANTS: [OperationResultCode; 7] = [
        OperationResultCode::OpInner,
        OperationResultCode::OpBadAuth,
        OperationResultCode::OpNoAccount,
        OperationResultCode::OpNotSupported,
        OperationResultCode::OpTooManySubentries,
        OperationResultCode::OpExceededWorkLimit,
        OperationResultCode::OpTooManySponsoring,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "OpInner",
        "OpBadAuth",
        "OpNoAccount",
        "OpNotSupported",
        "OpTooManySubentries",
        "OpExceededWorkLimit",
        "OpTooManySponsoring",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::OpInner(_) => "OpInner",

            Self::OpBadAuth => "OpBadAuth",

            Self::OpNoAccount => "OpNoAccount",

            Self::OpNotSupported => "OpNotSupported",

            Self::OpTooManySubentries => "OpTooManySubentries",

            Self::OpExceededWorkLimit => "OpExceededWorkLimit",

            Self::OpTooManySponsoring => "OpTooManySponsoring",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> OperationResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::OpInner(_) => OperationResultCode::OpInner,

            Self::OpBadAuth => OperationResultCode::OpBadAuth,

            Self::OpNoAccount => OperationResultCode::OpNoAccount,

            Self::OpNotSupported => OperationResultCode::OpNotSupported,

            Self::OpTooManySubentries => OperationResultCode::OpTooManySubentries,

            Self::OpExceededWorkLimit => OperationResultCode::OpExceededWorkLimit,

            Self::OpTooManySponsoring => OperationResultCode::OpTooManySponsoring,
        }
    }

    #[must_use]
    pub const fn variants() -> [OperationResultCode; 7] {
        Self::VARIANTS
    }
}

impl Name for OperationResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<OperationResultCode> for OperationResult {
    #[must_use]
    fn discriminant(&self) -> OperationResultCode {
        Self::discriminant(self)
    }
}

impl Variants<OperationResultCode> for OperationResult {
    fn variants() -> slice::Iter<'static, OperationResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<OperationResultCode> for OperationResult {}

impl ReadXdr for OperationResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: OperationResultCode = <OperationResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                OperationResultCode::OpInner => Self::OpInner(OperationResultTr::read_xdr(r)?),

                OperationResultCode::OpBadAuth => Self::OpBadAuth,

                OperationResultCode::OpNoAccount => Self::OpNoAccount,

                OperationResultCode::OpNotSupported => Self::OpNotSupported,

                OperationResultCode::OpTooManySubentries => Self::OpTooManySubentries,

                OperationResultCode::OpExceededWorkLimit => Self::OpExceededWorkLimit,

                OperationResultCode::OpTooManySponsoring => Self::OpTooManySponsoring,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for OperationResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::OpInner(v) => v.write_xdr(w)?,

                Self::OpBadAuth => ().write_xdr(w)?,

                Self::OpNoAccount => ().write_xdr(w)?,

                Self::OpNotSupported => ().write_xdr(w)?,

                Self::OpTooManySubentries => ().write_xdr(w)?,

                Self::OpExceededWorkLimit => ().write_xdr(w)?,

                Self::OpTooManySponsoring => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionResultCode
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum TransactionResultCode {
    #[cfg_attr(feature = "alloc", default)]
    TxFeeBumpInnerSuccess = 1,

    TxSuccess = 0,

    TxFailed = -1,

    TxTooEarly = -2,

    TxTooLate = -3,

    TxMissingOperation = -4,

    TxBadSeq = -5,

    TxBadAuth = -6,

    TxInsufficientBalance = -7,

    TxNoAccount = -8,

    TxInsufficientFee = -9,

    TxBadAuthExtra = -10,

    TxInternalError = -11,

    TxNotSupported = -12,

    TxFeeBumpInnerFailed = -13,

    TxBadSponsorship = -14,

    TxBadMinSeqAgeOrGap = -15,

    TxMalformed = -16,

    TxSorobanInvalid = -17,
}

impl TransactionResultCode {
    pub const VARIANTS: [TransactionResultCode; 19] = [
        TransactionResultCode::TxFeeBumpInnerSuccess,
        TransactionResultCode::TxSuccess,
        TransactionResultCode::TxFailed,
        TransactionResultCode::TxTooEarly,
        TransactionResultCode::TxTooLate,
        TransactionResultCode::TxMissingOperation,
        TransactionResultCode::TxBadSeq,
        TransactionResultCode::TxBadAuth,
        TransactionResultCode::TxInsufficientBalance,
        TransactionResultCode::TxNoAccount,
        TransactionResultCode::TxInsufficientFee,
        TransactionResultCode::TxBadAuthExtra,
        TransactionResultCode::TxInternalError,
        TransactionResultCode::TxNotSupported,
        TransactionResultCode::TxFeeBumpInnerFailed,
        TransactionResultCode::TxBadSponsorship,
        TransactionResultCode::TxBadMinSeqAgeOrGap,
        TransactionResultCode::TxMalformed,
        TransactionResultCode::TxSorobanInvalid,
    ];
    pub const VARIANTS_STR: [&'static str; 19] = [
        "TxFeeBumpInnerSuccess",
        "TxSuccess",
        "TxFailed",
        "TxTooEarly",
        "TxTooLate",
        "TxMissingOperation",
        "TxBadSeq",
        "TxBadAuth",
        "TxInsufficientBalance",
        "TxNoAccount",
        "TxInsufficientFee",
        "TxBadAuthExtra",
        "TxInternalError",
        "TxNotSupported",
        "TxFeeBumpInnerFailed",
        "TxBadSponsorship",
        "TxBadMinSeqAgeOrGap",
        "TxMalformed",
        "TxSorobanInvalid",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxFeeBumpInnerSuccess => "TxFeeBumpInnerSuccess",

            Self::TxSuccess => "TxSuccess",

            Self::TxFailed => "TxFailed",

            Self::TxTooEarly => "TxTooEarly",

            Self::TxTooLate => "TxTooLate",

            Self::TxMissingOperation => "TxMissingOperation",

            Self::TxBadSeq => "TxBadSeq",

            Self::TxBadAuth => "TxBadAuth",

            Self::TxInsufficientBalance => "TxInsufficientBalance",

            Self::TxNoAccount => "TxNoAccount",

            Self::TxInsufficientFee => "TxInsufficientFee",

            Self::TxBadAuthExtra => "TxBadAuthExtra",

            Self::TxInternalError => "TxInternalError",

            Self::TxNotSupported => "TxNotSupported",

            Self::TxFeeBumpInnerFailed => "TxFeeBumpInnerFailed",

            Self::TxBadSponsorship => "TxBadSponsorship",

            Self::TxBadMinSeqAgeOrGap => "TxBadMinSeqAgeOrGap",

            Self::TxMalformed => "TxMalformed",

            Self::TxSorobanInvalid => "TxSorobanInvalid",
        }
    }

    #[must_use]
    pub const fn variants() -> [TransactionResultCode; 19] {
        Self::VARIANTS
    }
}

impl Name for TransactionResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TransactionResultCode> for TransactionResultCode {
    fn variants() -> slice::Iter<'static, TransactionResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for TransactionResultCode {}

impl fmt::Display for TransactionResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for TransactionResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            1 => TransactionResultCode::TxFeeBumpInnerSuccess,

            0 => TransactionResultCode::TxSuccess,

            -1 => TransactionResultCode::TxFailed,

            -2 => TransactionResultCode::TxTooEarly,

            -3 => TransactionResultCode::TxTooLate,

            -4 => TransactionResultCode::TxMissingOperation,

            -5 => TransactionResultCode::TxBadSeq,

            -6 => TransactionResultCode::TxBadAuth,

            -7 => TransactionResultCode::TxInsufficientBalance,

            -8 => TransactionResultCode::TxNoAccount,

            -9 => TransactionResultCode::TxInsufficientFee,

            -10 => TransactionResultCode::TxBadAuthExtra,

            -11 => TransactionResultCode::TxInternalError,

            -12 => TransactionResultCode::TxNotSupported,

            -13 => TransactionResultCode::TxFeeBumpInnerFailed,

            -14 => TransactionResultCode::TxBadSponsorship,

            -15 => TransactionResultCode::TxBadMinSeqAgeOrGap,

            -16 => TransactionResultCode::TxMalformed,

            -17 => TransactionResultCode::TxSorobanInvalid,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<TransactionResultCode> for i32 {
    #[must_use]
    fn from(e: TransactionResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for TransactionResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// InnerTransactionResult
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct InnerTransactionResult {
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee_charged: i64,

    pub result: InnerTransactionResultResult,

    pub ext: InnerTransactionResultExt,
}

impl ReadXdr for InnerTransactionResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                fee_charged: i64::read_xdr(r)?,

                result: InnerTransactionResultResult::read_xdr(r)?,

                ext: InnerTransactionResultExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InnerTransactionResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.fee_charged.write_xdr(w)?;

            self.result.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// InnerTransactionResultPair
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct InnerTransactionResultPair {
    pub transaction_hash: Hash,

    pub result: InnerTransactionResult,
}

impl ReadXdr for InnerTransactionResultPair {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                transaction_hash: Hash::read_xdr(r)?,

                result: InnerTransactionResult::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InnerTransactionResultPair {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.transaction_hash.write_xdr(w)?;

            self.result.write_xdr(w)?;

            Ok(())
        })
    }
}

/// TransactionResult
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TransactionResult {
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub fee_charged: i64,

    pub result: TransactionResultResult,

    pub ext: TransactionResultExt,
}

impl ReadXdr for TransactionResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                fee_charged: i64::read_xdr(r)?,

                result: TransactionResultResult::read_xdr(r)?,

                ext: TransactionResultExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.fee_charged.write_xdr(w)?;

            self.result.write_xdr(w)?;

            self.ext.write_xdr(w)?;

            Ok(())
        })
    }
}

/// Hash
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]

pub struct Hash(pub [u8; 32]);

impl core::fmt::Debug for Hash {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "Hash(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}

impl core::fmt::Display for Hash {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl core::str::FromStr for Hash {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        hex::decode(s).map_err(|_| Error::InvalidHex)?.try_into()
    }
}

#[cfg(feature = "schemars")]
impl schemars::JsonSchema for Hash {
    fn schema_name() -> String {
        "Hash".to_string()
    }

    fn is_referenceable() -> bool {
        false
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        let schema = String::json_schema(gen);
        if let schemars::schema::Schema::Object(mut schema) = schema {
            schema.extensions.insert(
                "contentEncoding".to_owned(),
                serde_json::Value::String("hex".to_string()),
            );
            schema.extensions.insert(
                "contentMediaType".to_owned(),
                serde_json::Value::String("application/binary".to_string()),
            );
            let string = *schema.string.unwrap_or_default().clone();
            schema.string = Some(Box::new(schemars::schema::StringValidation {
                max_length: 32_u32.checked_mul(2).map(Some).unwrap_or_default(),
                min_length: 32_u32.checked_mul(2).map(Some).unwrap_or_default(),
                ..string
            }));
            schema.into()
        } else {
            schema
        }
    }
}

impl From<Hash> for [u8; 32] {
    #[must_use]
    fn from(x: Hash) -> Self {
        x.0
    }
}

impl From<[u8; 32]> for Hash {
    #[must_use]
    fn from(x: [u8; 32]) -> Self {
        Hash(x)
    }
}

impl AsRef<[u8; 32]> for Hash {
    #[must_use]
    fn as_ref(&self) -> &[u8; 32] {
        &self.0
    }
}

impl ReadXdr for Hash {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = <[u8; 32]>::read_xdr(r)?;
            let v = Hash(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Hash {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Hash {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for Hash {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for Hash {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for Hash {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self, Error> {
        Ok(Hash(x.try_into()?))
    }
}

impl AsRef<[u8]> for Hash {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// Uint256
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]

pub struct Uint256(pub [u8; 32]);

impl core::fmt::Debug for Uint256 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "Uint256(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}

impl core::fmt::Display for Uint256 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl core::str::FromStr for Uint256 {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        hex::decode(s).map_err(|_| Error::InvalidHex)?.try_into()
    }
}

#[cfg(feature = "schemars")]
impl schemars::JsonSchema for Uint256 {
    fn schema_name() -> String {
        "Uint256".to_string()
    }

    fn is_referenceable() -> bool {
        false
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        let schema = String::json_schema(gen);
        if let schemars::schema::Schema::Object(mut schema) = schema {
            schema.extensions.insert(
                "contentEncoding".to_owned(),
                serde_json::Value::String("hex".to_string()),
            );
            schema.extensions.insert(
                "contentMediaType".to_owned(),
                serde_json::Value::String("application/binary".to_string()),
            );
            let string = *schema.string.unwrap_or_default().clone();
            schema.string = Some(Box::new(schemars::schema::StringValidation {
                max_length: 32_u32.checked_mul(2).map(Some).unwrap_or_default(),
                min_length: 32_u32.checked_mul(2).map(Some).unwrap_or_default(),
                ..string
            }));
            schema.into()
        } else {
            schema
        }
    }
}

impl From<Uint256> for [u8; 32] {
    #[must_use]
    fn from(x: Uint256) -> Self {
        x.0
    }
}

impl From<[u8; 32]> for Uint256 {
    #[must_use]
    fn from(x: [u8; 32]) -> Self {
        Uint256(x)
    }
}

impl AsRef<[u8; 32]> for Uint256 {
    #[must_use]
    fn as_ref(&self) -> &[u8; 32] {
        &self.0
    }
}

impl ReadXdr for Uint256 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = <[u8; 32]>::read_xdr(r)?;
            let v = Uint256(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Uint256 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Uint256 {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for Uint256 {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for Uint256 {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for Uint256 {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self, Error> {
        Ok(Uint256(x.try_into()?))
    }
}

impl AsRef<[u8]> for Uint256 {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

pub type Uint32 = u32;

pub type Int32 = i32;

pub type Uint64 = u64;

pub type Int64 = i64;

/// TimePoint
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct TimePoint(
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub u64,
);

impl From<TimePoint> for u64 {
    #[must_use]
    fn from(x: TimePoint) -> Self {
        x.0
    }
}

impl From<u64> for TimePoint {
    #[must_use]
    fn from(x: u64) -> Self {
        TimePoint(x)
    }
}

impl AsRef<u64> for TimePoint {
    #[must_use]
    fn as_ref(&self) -> &u64 {
        &self.0
    }
}

impl ReadXdr for TimePoint {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = u64::read_xdr(r)?;
            let v = TimePoint(i);
            Ok(v)
        })
    }
}

impl WriteXdr for TimePoint {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// Duration
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Duration(
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "NumberOrString")
    )]
    pub u64,
);

impl From<Duration> for u64 {
    #[must_use]
    fn from(x: Duration) -> Self {
        x.0
    }
}

impl From<u64> for Duration {
    #[must_use]
    fn from(x: u64) -> Self {
        Duration(x)
    }
}

impl AsRef<u64> for Duration {
    #[must_use]
    fn as_ref(&self) -> &u64 {
        &self.0
    }
}

impl ReadXdr for Duration {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = u64::read_xdr(r)?;
            let v = Duration(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Duration {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// ExtensionPoint
// union with discriminant i32
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[allow(clippy::large_enum_variant)]
pub enum ExtensionPoint {
    V0,
}

#[cfg(feature = "alloc")]
impl Default for ExtensionPoint {
    fn default() -> Self {
        Self::V0
    }
}

impl ExtensionPoint {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for ExtensionPoint {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ExtensionPoint {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ExtensionPoint {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ExtensionPoint {}

impl ReadXdr for ExtensionPoint {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ExtensionPoint {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// CryptoKeyType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum CryptoKeyType {
    #[cfg_attr(feature = "alloc", default)]
    KeyTypeEd25519 = 0,

    KeyTypePreAuthTx = 1,

    KeyTypeHashX = 2,

    KeyTypeEd25519SignedPayload = 3,

    KeyTypeMuxedEd25519 = 256,
}

impl CryptoKeyType {
    pub const VARIANTS: [CryptoKeyType; 5] = [
        CryptoKeyType::KeyTypeEd25519,
        CryptoKeyType::KeyTypePreAuthTx,
        CryptoKeyType::KeyTypeHashX,
        CryptoKeyType::KeyTypeEd25519SignedPayload,
        CryptoKeyType::KeyTypeMuxedEd25519,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "KeyTypeEd25519",
        "KeyTypePreAuthTx",
        "KeyTypeHashX",
        "KeyTypeEd25519SignedPayload",
        "KeyTypeMuxedEd25519",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::KeyTypeEd25519 => "KeyTypeEd25519",

            Self::KeyTypePreAuthTx => "KeyTypePreAuthTx",

            Self::KeyTypeHashX => "KeyTypeHashX",

            Self::KeyTypeEd25519SignedPayload => "KeyTypeEd25519SignedPayload",

            Self::KeyTypeMuxedEd25519 => "KeyTypeMuxedEd25519",
        }
    }

    #[must_use]
    pub const fn variants() -> [CryptoKeyType; 5] {
        Self::VARIANTS
    }
}

impl Name for CryptoKeyType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<CryptoKeyType> for CryptoKeyType {
    fn variants() -> slice::Iter<'static, CryptoKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for CryptoKeyType {}

impl fmt::Display for CryptoKeyType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for CryptoKeyType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => CryptoKeyType::KeyTypeEd25519,

            1 => CryptoKeyType::KeyTypePreAuthTx,

            2 => CryptoKeyType::KeyTypeHashX,

            3 => CryptoKeyType::KeyTypeEd25519SignedPayload,

            256 => CryptoKeyType::KeyTypeMuxedEd25519,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<CryptoKeyType> for i32 {
    #[must_use]
    fn from(e: CryptoKeyType) -> Self {
        e as Self
    }
}

impl ReadXdr for CryptoKeyType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for CryptoKeyType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// PublicKeyType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum PublicKeyType {
    #[cfg_attr(feature = "alloc", default)]
    PublicKeyTypeEd25519 = 0,
}

impl PublicKeyType {
    pub const VARIANTS: [PublicKeyType; 1] = [PublicKeyType::PublicKeyTypeEd25519];
    pub const VARIANTS_STR: [&'static str; 1] = ["PublicKeyTypeEd25519"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PublicKeyTypeEd25519 => "PublicKeyTypeEd25519",
        }
    }

    #[must_use]
    pub const fn variants() -> [PublicKeyType; 1] {
        Self::VARIANTS
    }
}

impl Name for PublicKeyType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<PublicKeyType> for PublicKeyType {
    fn variants() -> slice::Iter<'static, PublicKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for PublicKeyType {}

impl fmt::Display for PublicKeyType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for PublicKeyType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => PublicKeyType::PublicKeyTypeEd25519,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<PublicKeyType> for i32 {
    #[must_use]
    fn from(e: PublicKeyType) -> Self {
        e as Self
    }
}

impl ReadXdr for PublicKeyType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for PublicKeyType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SignerKeyType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum SignerKeyType {
    #[cfg_attr(feature = "alloc", default)]
    SignerKeyTypeEd25519 = 0,

    SignerKeyTypePreAuthTx = 0,

    SignerKeyTypeHashX = 0,

    SignerKeyTypeEd25519SignedPayload = 0,
}

impl SignerKeyType {
    pub const VARIANTS: [SignerKeyType; 4] = [
        SignerKeyType::SignerKeyTypeEd25519,
        SignerKeyType::SignerKeyTypePreAuthTx,
        SignerKeyType::SignerKeyTypeHashX,
        SignerKeyType::SignerKeyTypeEd25519SignedPayload,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "SignerKeyTypeEd25519",
        "SignerKeyTypePreAuthTx",
        "SignerKeyTypeHashX",
        "SignerKeyTypeEd25519SignedPayload",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SignerKeyTypeEd25519 => "SignerKeyTypeEd25519",

            Self::SignerKeyTypePreAuthTx => "SignerKeyTypePreAuthTx",

            Self::SignerKeyTypeHashX => "SignerKeyTypeHashX",

            Self::SignerKeyTypeEd25519SignedPayload => "SignerKeyTypeEd25519SignedPayload",
        }
    }

    #[must_use]
    pub const fn variants() -> [SignerKeyType; 4] {
        Self::VARIANTS
    }
}

impl Name for SignerKeyType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SignerKeyType> for SignerKeyType {
    fn variants() -> slice::Iter<'static, SignerKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SignerKeyType {}

impl fmt::Display for SignerKeyType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SignerKeyType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => SignerKeyType::SignerKeyTypeEd25519,

            0 => SignerKeyType::SignerKeyTypePreAuthTx,

            0 => SignerKeyType::SignerKeyTypeHashX,

            0 => SignerKeyType::SignerKeyTypeEd25519SignedPayload,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SignerKeyType> for i32 {
    #[must_use]
    fn from(e: SignerKeyType) -> Self {
        e as Self
    }
}

impl ReadXdr for SignerKeyType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SignerKeyType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// PublicKey
// union with discriminant PublicKeyType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[allow(clippy::large_enum_variant)]
pub enum PublicKey {
    PublicKeyTypeEd25519(Uint256),
}

#[cfg(feature = "alloc")]
impl Default for PublicKey {
    fn default() -> Self {
        Self::PublicKeyTypeEd25519(Uint256::default())
    }
}

impl PublicKey {
    pub const VARIANTS: [PublicKeyType; 1] = [PublicKeyType::PublicKeyTypeEd25519];
    pub const VARIANTS_STR: [&'static str; 1] = ["PublicKeyTypeEd25519"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PublicKeyTypeEd25519(_) => "PublicKeyTypeEd25519",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> PublicKeyType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::PublicKeyTypeEd25519(_) => PublicKeyType::PublicKeyTypeEd25519,
        }
    }

    #[must_use]
    pub const fn variants() -> [PublicKeyType; 1] {
        Self::VARIANTS
    }
}

impl Name for PublicKey {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<PublicKeyType> for PublicKey {
    #[must_use]
    fn discriminant(&self) -> PublicKeyType {
        Self::discriminant(self)
    }
}

impl Variants<PublicKeyType> for PublicKey {
    fn variants() -> slice::Iter<'static, PublicKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Union<PublicKeyType> for PublicKey {}

impl ReadXdr for PublicKey {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: PublicKeyType = <PublicKeyType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                PublicKeyType::PublicKeyTypeEd25519 => {
                    Self::PublicKeyTypeEd25519(Uint256::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PublicKey {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::PublicKeyTypeEd25519(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SignerKey
// union with discriminant SignerKeyType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[allow(clippy::large_enum_variant)]
pub enum SignerKey {
    SignerKeyTypeEd25519(Uint256),

    SignerKeyTypePreAuthTx(Uint256),

    SignerKeyTypeHashX(Uint256),

    SignerKeyTypeEd25519SignedPayload(SignerKeyEd25519SignedPayload),
}

#[cfg(feature = "alloc")]
impl Default for SignerKey {
    fn default() -> Self {
        Self::SignerKeyTypeEd25519(Uint256::default())
    }
}

impl SignerKey {
    pub const VARIANTS: [SignerKeyType; 4] = [
        SignerKeyType::SignerKeyTypeEd25519,
        SignerKeyType::SignerKeyTypePreAuthTx,
        SignerKeyType::SignerKeyTypeHashX,
        SignerKeyType::SignerKeyTypeEd25519SignedPayload,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "SignerKeyTypeEd25519",
        "SignerKeyTypePreAuthTx",
        "SignerKeyTypeHashX",
        "SignerKeyTypeEd25519SignedPayload",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SignerKeyTypeEd25519(_) => "SignerKeyTypeEd25519",

            Self::SignerKeyTypePreAuthTx(_) => "SignerKeyTypePreAuthTx",

            Self::SignerKeyTypeHashX(_) => "SignerKeyTypeHashX",

            Self::SignerKeyTypeEd25519SignedPayload(_) => "SignerKeyTypeEd25519SignedPayload",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SignerKeyType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::SignerKeyTypeEd25519(_) => SignerKeyType::SignerKeyTypeEd25519,

            Self::SignerKeyTypePreAuthTx(_) => SignerKeyType::SignerKeyTypePreAuthTx,

            Self::SignerKeyTypeHashX(_) => SignerKeyType::SignerKeyTypeHashX,

            Self::SignerKeyTypeEd25519SignedPayload(_) => {
                SignerKeyType::SignerKeyTypeEd25519SignedPayload
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [SignerKeyType; 4] {
        Self::VARIANTS
    }
}

impl Name for SignerKey {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SignerKeyType> for SignerKey {
    #[must_use]
    fn discriminant(&self) -> SignerKeyType {
        Self::discriminant(self)
    }
}

impl Variants<SignerKeyType> for SignerKey {
    fn variants() -> slice::Iter<'static, SignerKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Union<SignerKeyType> for SignerKey {}

impl ReadXdr for SignerKey {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: SignerKeyType = <SignerKeyType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                SignerKeyType::SignerKeyTypeEd25519 => {
                    Self::SignerKeyTypeEd25519(Uint256::read_xdr(r)?)
                }

                SignerKeyType::SignerKeyTypePreAuthTx => {
                    Self::SignerKeyTypePreAuthTx(Uint256::read_xdr(r)?)
                }

                SignerKeyType::SignerKeyTypeHashX => {
                    Self::SignerKeyTypeHashX(Uint256::read_xdr(r)?)
                }

                SignerKeyType::SignerKeyTypeEd25519SignedPayload => {
                    Self::SignerKeyTypeEd25519SignedPayload(
                        SignerKeyEd25519SignedPayload::read_xdr(r)?,
                    )
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SignerKey {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::SignerKeyTypeEd25519(v) => v.write_xdr(w)?,

                Self::SignerKeyTypePreAuthTx(v) => v.write_xdr(w)?,

                Self::SignerKeyTypeHashX(v) => v.write_xdr(w)?,

                Self::SignerKeyTypeEd25519SignedPayload(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// Signature
#[cfg_eval::cfg_eval]
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Signature(pub BytesM<64>);

impl From<Signature> for BytesM<64> {
    #[must_use]
    fn from(x: Signature) -> Self {
        x.0
    }
}

impl From<BytesM<64>> for Signature {
    #[must_use]
    fn from(x: BytesM<64>) -> Self {
        Signature(x)
    }
}

impl AsRef<BytesM<64>> for Signature {
    #[must_use]
    fn as_ref(&self) -> &BytesM<64> {
        &self.0
    }
}

impl ReadXdr for Signature {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = BytesM::<64>::read_xdr(r)?;
            let v = Signature(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Signature {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for Signature {
    type Target = BytesM<64>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<Signature> for Vec<u8> {
    #[must_use]
    fn from(x: Signature) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for Signature {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        Ok(Signature(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for Signature {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        Ok(Signature(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for Signature {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for Signature {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// SignatureHint
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]

pub struct SignatureHint(pub [u8; 4]);

impl core::fmt::Debug for SignatureHint {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "SignatureHint(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}

impl core::fmt::Display for SignatureHint {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl core::str::FromStr for SignatureHint {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        hex::decode(s).map_err(|_| Error::InvalidHex)?.try_into()
    }
}

#[cfg(feature = "schemars")]
impl schemars::JsonSchema for SignatureHint {
    fn schema_name() -> String {
        "SignatureHint".to_string()
    }

    fn is_referenceable() -> bool {
        false
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        let schema = String::json_schema(gen);
        if let schemars::schema::Schema::Object(mut schema) = schema {
            schema.extensions.insert(
                "contentEncoding".to_owned(),
                serde_json::Value::String("hex".to_string()),
            );
            schema.extensions.insert(
                "contentMediaType".to_owned(),
                serde_json::Value::String("application/binary".to_string()),
            );
            let string = *schema.string.unwrap_or_default().clone();
            schema.string = Some(Box::new(schemars::schema::StringValidation {
                max_length: 4_u32.checked_mul(2).map(Some).unwrap_or_default(),
                min_length: 4_u32.checked_mul(2).map(Some).unwrap_or_default(),
                ..string
            }));
            schema.into()
        } else {
            schema
        }
    }
}

impl From<SignatureHint> for [u8; 4] {
    #[must_use]
    fn from(x: SignatureHint) -> Self {
        x.0
    }
}

impl From<[u8; 4]> for SignatureHint {
    #[must_use]
    fn from(x: [u8; 4]) -> Self {
        SignatureHint(x)
    }
}

impl AsRef<[u8; 4]> for SignatureHint {
    #[must_use]
    fn as_ref(&self) -> &[u8; 4] {
        &self.0
    }
}

impl ReadXdr for SignatureHint {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = <[u8; 4]>::read_xdr(r)?;
            let v = SignatureHint(i);
            Ok(v)
        })
    }
}

impl WriteXdr for SignatureHint {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl SignatureHint {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for SignatureHint {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for SignatureHint {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for SignatureHint {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self, Error> {
        Ok(SignatureHint(x.try_into()?))
    }
}

impl AsRef<[u8]> for SignatureHint {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// NodeId
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]

pub struct NodeId(pub PublicKey);

impl From<NodeId> for PublicKey {
    #[must_use]
    fn from(x: NodeId) -> Self {
        x.0
    }
}

impl From<PublicKey> for NodeId {
    #[must_use]
    fn from(x: PublicKey) -> Self {
        NodeId(x)
    }
}

impl AsRef<PublicKey> for NodeId {
    #[must_use]
    fn as_ref(&self) -> &PublicKey {
        &self.0
    }
}

impl ReadXdr for NodeId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = PublicKey::read_xdr(r)?;
            let v = NodeId(i);
            Ok(v)
        })
    }
}

impl WriteXdr for NodeId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// AccountId
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]

pub struct AccountId(pub PublicKey);

impl From<AccountId> for PublicKey {
    #[must_use]
    fn from(x: AccountId) -> Self {
        x.0
    }
}

impl From<PublicKey> for AccountId {
    #[must_use]
    fn from(x: PublicKey) -> Self {
        AccountId(x)
    }
}

impl AsRef<PublicKey> for AccountId {
    #[must_use]
    fn as_ref(&self) -> &PublicKey {
        &self.0
    }
}

impl ReadXdr for AccountId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = PublicKey::read_xdr(r)?;
            let v = AccountId(i);
            Ok(v)
        })
    }
}

impl WriteXdr for AccountId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// ContractId
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]

pub struct ContractId(pub Hash);

impl From<ContractId> for Hash {
    #[must_use]
    fn from(x: ContractId) -> Self {
        x.0
    }
}

impl From<Hash> for ContractId {
    #[must_use]
    fn from(x: Hash) -> Self {
        ContractId(x)
    }
}

impl AsRef<Hash> for ContractId {
    #[must_use]
    fn as_ref(&self) -> &Hash {
        &self.0
    }
}

impl ReadXdr for ContractId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = Hash::read_xdr(r)?;
            let v = ContractId(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ContractId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// Curve25519Secret
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Curve25519Secret {
    pub key: [u8; 32],
}

impl ReadXdr for Curve25519Secret {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: <[u8; 32]>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Curve25519Secret {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;

            Ok(())
        })
    }
}

/// Curve25519Public
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct Curve25519Public {
    pub key: [u8; 32],
}

impl ReadXdr for Curve25519Public {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: <[u8; 32]>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Curve25519Public {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;

            Ok(())
        })
    }
}

/// HmacSha256Key
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct HmacSha256Key {
    pub key: [u8; 32],
}

impl ReadXdr for HmacSha256Key {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: <[u8; 32]>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HmacSha256Key {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;

            Ok(())
        })
    }
}

/// HmacSha256Mac
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct HmacSha256Mac {
    pub mac: [u8; 32],
}

impl ReadXdr for HmacSha256Mac {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                mac: <[u8; 32]>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HmacSha256Mac {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.mac.write_xdr(w)?;

            Ok(())
        })
    }
}

/// ShortHashSeed
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct ShortHashSeed {
    pub seed: [u8; 16],
}

impl ReadXdr for ShortHashSeed {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                seed: <[u8; 16]>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ShortHashSeed {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.seed.write_xdr(w)?;

            Ok(())
        })
    }
}

/// BinaryFuseFilterType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum BinaryFuseFilterType {
    #[cfg_attr(feature = "alloc", default)]
    BinaryFuseFilter8Bit = 0,

    BinaryFuseFilter16Bit = 1,

    BinaryFuseFilter32Bit = 2,
}

impl BinaryFuseFilterType {
    pub const VARIANTS: [BinaryFuseFilterType; 3] = [
        BinaryFuseFilterType::BinaryFuseFilter8Bit,
        BinaryFuseFilterType::BinaryFuseFilter16Bit,
        BinaryFuseFilterType::BinaryFuseFilter32Bit,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "BinaryFuseFilter8Bit",
        "BinaryFuseFilter16Bit",
        "BinaryFuseFilter32Bit",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::BinaryFuseFilter8Bit => "BinaryFuseFilter8Bit",

            Self::BinaryFuseFilter16Bit => "BinaryFuseFilter16Bit",

            Self::BinaryFuseFilter32Bit => "BinaryFuseFilter32Bit",
        }
    }

    #[must_use]
    pub const fn variants() -> [BinaryFuseFilterType; 3] {
        Self::VARIANTS
    }
}

impl Name for BinaryFuseFilterType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<BinaryFuseFilterType> for BinaryFuseFilterType {
    fn variants() -> slice::Iter<'static, BinaryFuseFilterType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for BinaryFuseFilterType {}

impl fmt::Display for BinaryFuseFilterType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for BinaryFuseFilterType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => BinaryFuseFilterType::BinaryFuseFilter8Bit,

            1 => BinaryFuseFilterType::BinaryFuseFilter16Bit,

            2 => BinaryFuseFilterType::BinaryFuseFilter32Bit,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<BinaryFuseFilterType> for i32 {
    #[must_use]
    fn from(e: BinaryFuseFilterType) -> Self {
        e as Self
    }
}

impl ReadXdr for BinaryFuseFilterType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for BinaryFuseFilterType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SerializedBinaryFuseFilter
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]

pub struct SerializedBinaryFuseFilter {
    pub type_: BinaryFuseFilterType,

    pub input_hash_seed: ShortHashSeed,

    pub filter_seed: ShortHashSeed,

    pub segment_length: u32,

    pub segement_length_mask: u32,

    pub segment_count: u32,

    pub segment_count_length: u32,

    pub fingerprint_length: u32,

    pub fingerprints: BytesM,
}

impl ReadXdr for SerializedBinaryFuseFilter {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            Ok(Self {
                type_: BinaryFuseFilterType::read_xdr(r)?,

                input_hash_seed: ShortHashSeed::read_xdr(r)?,

                filter_seed: ShortHashSeed::read_xdr(r)?,

                segment_length: u32::read_xdr(r)?,

                segement_length_mask: u32::read_xdr(r)?,

                segment_count: u32::read_xdr(r)?,

                segment_count_length: u32::read_xdr(r)?,

                fingerprint_length: u32::read_xdr(r)?,

                fingerprints: BytesM::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SerializedBinaryFuseFilter {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.type_.write_xdr(w)?;

            self.input_hash_seed.write_xdr(w)?;

            self.filter_seed.write_xdr(w)?;

            self.segment_length.write_xdr(w)?;

            self.segement_length_mask.write_xdr(w)?;

            self.segment_count.write_xdr(w)?;

            self.segment_count_length.write_xdr(w)?;

            self.fingerprint_length.write_xdr(w)?;

            self.fingerprints.write_xdr(w)?;

            Ok(())
        })
    }
}

/// PoolId
#[cfg_eval::cfg_eval]
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]

pub struct PoolId(pub Hash);

impl From<PoolId> for Hash {
    #[must_use]
    fn from(x: PoolId) -> Self {
        x.0
    }
}

impl From<Hash> for PoolId {
    #[must_use]
    fn from(x: Hash) -> Self {
        PoolId(x)
    }
}

impl AsRef<Hash> for PoolId {
    #[must_use]
    fn as_ref(&self) -> &Hash {
        &self.0
    }
}

impl ReadXdr for PoolId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = Hash::read_xdr(r)?;
            let v = PoolId(i);
            Ok(v)
        })
    }
}

impl WriteXdr for PoolId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// ClaimableBalanceIdType
// enum
#[cfg_attr(feature = "alloc", derive(Default))]
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[repr(i32)]
pub enum ClaimableBalanceIdType {
    #[cfg_attr(feature = "alloc", default)]
    ClaimableBalanceIdTypeV0 = 0,
}

impl ClaimableBalanceIdType {
    pub const VARIANTS: [ClaimableBalanceIdType; 1] =
        [ClaimableBalanceIdType::ClaimableBalanceIdTypeV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ClaimableBalanceIdTypeV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimableBalanceIdTypeV0 => "ClaimableBalanceIdTypeV0",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimableBalanceIdType; 1] {
        Self::VARIANTS
    }
}

impl Name for ClaimableBalanceIdType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimableBalanceIdType> for ClaimableBalanceIdType {
    fn variants() -> slice::Iter<'static, ClaimableBalanceIdType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimableBalanceIdType {}

impl fmt::Display for ClaimableBalanceIdType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimableBalanceIdType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self, Error> {
        let e = match i {
            0 => ClaimableBalanceIdType::ClaimableBalanceIdTypeV0,

            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimableBalanceIdType> for i32 {
    #[must_use]
    fn from(e: ClaimableBalanceIdType) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimableBalanceIdType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimableBalanceIdType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClaimableBalanceId
// union with discriminant ClaimableBalanceIdType
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[allow(clippy::large_enum_variant)]
pub enum ClaimableBalanceId {
    ClaimableBalanceIdTypeV0(Hash),
}

#[cfg(feature = "alloc")]
impl Default for ClaimableBalanceId {
    fn default() -> Self {
        Self::ClaimableBalanceIdTypeV0(Hash::default())
    }
}

impl ClaimableBalanceId {
    pub const VARIANTS: [ClaimableBalanceIdType; 1] =
        [ClaimableBalanceIdType::ClaimableBalanceIdTypeV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ClaimableBalanceIdTypeV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimableBalanceIdTypeV0(_) => "ClaimableBalanceIdTypeV0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClaimableBalanceIdType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ClaimableBalanceIdTypeV0(_) => ClaimableBalanceIdType::ClaimableBalanceIdTypeV0,
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimableBalanceIdType; 1] {
        Self::VARIANTS
    }
}

impl Name for ClaimableBalanceId {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClaimableBalanceIdType> for ClaimableBalanceId {
    #[must_use]
    fn discriminant(&self) -> ClaimableBalanceIdType {
        Self::discriminant(self)
    }
}

impl Variants<ClaimableBalanceIdType> for ClaimableBalanceId {
    fn variants() -> slice::Iter<'static, ClaimableBalanceIdType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClaimableBalanceIdType> for ClaimableBalanceId {}

impl ReadXdr for ClaimableBalanceId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: ClaimableBalanceIdType = <ClaimableBalanceIdType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClaimableBalanceIdType::ClaimableBalanceIdTypeV0 => {
                    Self::ClaimableBalanceIdTypeV0(Hash::read_xdr(r)?)
                }

                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimableBalanceId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ClaimableBalanceIdTypeV0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub enum TypeVariant {
    ScpStatementPrepare,

    ScpStatementConfirm,

    ScpStatementExternalize,

    ScpStatementPledges,

    ScEnvMetaEntryInterfaceVersion,

    AccountEntryExtensionV2Ext,

    AccountEntryExtensionV1Ext,

    AccountEntryExt,

    TrustLineEntryExtensionV2Ext,

    TrustLineEntryV1Ext,

    TrustLineEntryV1,

    TrustLineEntryExt,

    OfferEntryExt,

    DataEntryExt,

    ClaimantV0,

    ClaimableBalanceEntryExtensionV1Ext,

    ClaimableBalanceEntryExt,

    LiquidityPoolEntryConstantProduct,

    LiquidityPoolEntryBody,

    ContractCodeEntryV1,

    ContractCodeEntryExt,

    LedgerEntryExtensionV1Ext,

    LedgerEntryData,

    LedgerEntryExt,

    LedgerKeyAccount,

    LedgerKeyTrustLine,

    LedgerKeyOffer,

    LedgerKeyData,

    LedgerKeyClaimableBalance,

    LedgerKeyLiquidityPool,

    LedgerKeyContractData,

    LedgerKeyContractCode,

    LedgerKeyConfigSetting,

    LedgerKeyTtl,

    BucketMetadataExt,

    StellarValueExt,

    LedgerHeaderExtensionV1Ext,

    LedgerHeaderExt,

    TxSetComponentTxsMaybeDiscountedFee,

    TransactionHistoryEntryExt,

    TransactionHistoryResultEntryExt,

    LedgerHeaderHistoryEntryExt,

    ContractEventV0,

    ContractEventBody,

    PeerAddressIp,

    AuthenticatedMessageV0,

    MuxedAccountMed25519,

    RevokeSponsorshipOpSigner,

    ContractIdPreimageFromAddress,

    OperationBody,

    HashIdPreimageOperationId,

    HashIdPreimageRevokeId,

    HashIdPreimageContractId,

    HashIdPreimageSorobanAuthorization,

    SorobanTransactionDataExt,

    TransactionV0Ext,

    TransactionExt,

    FeeBumpTransactionInnerTx,

    FeeBumpTransactionExt,

    TransactionSignaturePayloadTaggedTransaction,

    PathPaymentStrictReceiveResultSuccess,

    PathPaymentStrictSendResultSuccess,

    ManageOfferSuccessResultOffer,

    OperationResultTr,

    InnerTransactionResultResult,

    InnerTransactionResultExt,

    TransactionResultResult,

    TransactionResultExt,

    SignerKeyEd25519SignedPayload,

    Value,

    ScpBallot,

    ScpStatementType,

    ScpNomination,

    ScpStatement,

    ScpEnvelope,

    ScpQuorumSet,

    ConfigSettingContractExecutionLanesV0,

    ConfigSettingContractComputeV0,

    ConfigSettingContractParallelComputeV0,

    ConfigSettingContractLedgerCostV0,

    ConfigSettingContractLedgerCostExtV0,

    ConfigSettingContractHistoricalDataV0,

    ConfigSettingContractEventsV0,

    ConfigSettingContractBandwidthV0,

    ContractCostType,

    ContractCostParamEntry,

    StateArchivalSettings,

    EvictionIterator,

    ConfigSettingScpTiming,

    ContractCostParams,

    ConfigSettingId,

    ConfigSettingEntry,

    ScEnvMetaKind,

    ScEnvMetaEntry,

    ScMetaV0,

    ScMetaKind,

    ScMetaEntry,

    ScSpecType,

    ScSpecTypeOption,

    ScSpecTypeResult,

    ScSpecTypeVec,

    ScSpecTypeMap,

    ScSpecTypeTuple,

    ScSpecTypeBytesN,

    ScSpecTypeUdt,

    ScSpecTypeDef,

    ScSpecUdtStructFieldV0,

    ScSpecUdtStructV0,

    ScSpecUdtUnionCaseVoidV0,

    ScSpecUdtUnionCaseTupleV0,

    ScSpecUdtUnionCaseV0Kind,

    ScSpecUdtUnionCaseV0,

    ScSpecUdtUnionV0,

    ScSpecUdtEnumCaseV0,

    ScSpecUdtEnumV0,

    ScSpecUdtErrorEnumCaseV0,

    ScSpecUdtErrorEnumV0,

    ScSpecFunctionInputV0,

    ScSpecFunctionV0,

    ScSpecEventParamLocationV0,

    ScSpecEventParamV0,

    ScSpecEventDataFormat,

    ScSpecEventV0,

    ScSpecEntryKind,

    ScSpecEntry,

    ScValType,

    ScErrorType,

    ScErrorCode,

    ScError,

    UInt128Parts,

    Int128Parts,

    UInt256Parts,

    Int256Parts,

    ContractExecutableType,

    ContractExecutable,

    ScAddressType,

    MuxedEd25519Account,

    ScAddress,

    ScVec,

    ScMap,

    ScBytes,

    ScString,

    ScSymbol,

    ScNonceKey,

    ScContractInstance,

    ScVal,

    ScMapEntry,

    LedgerCloseMetaBatch,

    StoredTransactionSet,

    StoredDebugTransactionSet,

    PersistedScpStateV0,

    PersistedScpStateV1,

    PersistedScpState,

    Thresholds,

    String32,

    String64,

    SequenceNumber,

    DataValue,

    AssetCode4,

    AssetCode12,

    AssetType,

    AssetCode,

    AlphaNum4,

    AlphaNum12,

    Asset,

    Price,

    Liabilities,

    ThresholdIndexes,

    LedgerEntryType,

    Signer,

    AccountFlags,

    SponsorshipDescriptor,

    AccountEntryExtensionV3,

    AccountEntryExtensionV2,

    AccountEntryExtensionV1,

    AccountEntry,

    TrustLineFlags,

    LiquidityPoolType,

    TrustLineAsset,

    TrustLineEntryExtensionV2,

    TrustLineEntry,

    OfferEntryFlags,

    OfferEntry,

    DataEntry,

    ClaimPredicateType,

    ClaimPredicate,

    ClaimantType,

    Claimant,

    ClaimableBalanceFlags,

    ClaimableBalanceEntryExtensionV1,

    ClaimableBalanceEntry,

    LiquidityPoolConstantProductParameters,

    LiquidityPoolEntry,

    ContractDataDurability,

    ContractDataEntry,

    ContractCodeCostInputs,

    ContractCodeEntry,

    TtlEntry,

    LedgerEntryExtensionV1,

    LedgerEntry,

    LedgerKey,

    EnvelopeType,

    BucketListType,

    BucketEntryType,

    HotArchiveBucketEntryType,

    BucketMetadata,

    BucketEntry,

    HotArchiveBucketEntry,

    UpgradeType,

    StellarValueType,

    LedgerCloseValueSignature,

    StellarValue,

    LedgerHeaderFlags,

    LedgerHeaderExtensionV1,

    LedgerHeader,

    LedgerUpgradeType,

    ConfigUpgradeSetKey,

    LedgerUpgrade,

    ConfigUpgradeSet,

    TxSetComponentType,

    DependentTxCluster,

    ParallelTxExecutionStage,

    ParallelTxsComponent,

    TxSetComponent,

    TransactionPhase,

    TransactionSet,

    TransactionSetV1,

    GeneralizedTransactionSet,

    TransactionResultPair,

    TransactionResultSet,

    TransactionHistoryEntry,

    TransactionHistoryResultEntry,

    LedgerHeaderHistoryEntry,

    LedgerScpMessages,

    ScpHistoryEntryV0,

    ScpHistoryEntry,

    LedgerEntryChangeType,

    LedgerEntryChange,

    LedgerEntryChanges,

    OperationMeta,

    TransactionMetaV1,

    TransactionMetaV2,

    ContractEventType,

    ContractEvent,

    DiagnosticEvent,

    SorobanTransactionMetaExtV1,

    SorobanTransactionMetaExt,

    SorobanTransactionMeta,

    TransactionMetaV3,

    OperationMetaV2,

    SorobanTransactionMetaV2,

    TransactionEventStage,

    TransactionEvent,

    TransactionMetaV4,

    InvokeHostFunctionSuccessPreImage,

    TransactionMeta,

    TransactionResultMeta,

    TransactionResultMetaV1,

    UpgradeEntryMeta,

    LedgerCloseMetaV0,

    LedgerCloseMetaExtV1,

    LedgerCloseMetaExt,

    LedgerCloseMetaV1,

    LedgerCloseMetaV2,

    LedgerCloseMeta,

    ErrorCode,

    SError,

    SendMore,

    SendMoreExtended,

    AuthCert,

    Hello,

    Auth,

    IpAddrType,

    PeerAddress,

    MessageType,

    DontHave,

    SurveyMessageCommandType,

    SurveyMessageResponseType,

    TimeSlicedSurveyStartCollectingMessage,

    SignedTimeSlicedSurveyStartCollectingMessage,

    TimeSlicedSurveyStopCollectingMessage,

    SignedTimeSlicedSurveyStopCollectingMessage,

    SurveyRequestMessage,

    TimeSlicedSurveyRequestMessage,

    SignedTimeSlicedSurveyRequestMessage,

    EncryptedBody,

    SurveyResponseMessage,

    TimeSlicedSurveyResponseMessage,

    SignedTimeSlicedSurveyResponseMessage,

    PeerStats,

    TimeSlicedNodeData,

    TimeSlicedPeerData,

    TimeSlicedPeerDataList,

    TopologyResponseBodyV2,

    SurveyResponseBody,

    TxAdvertVector,

    FloodAdvert,

    TxDemandVector,

    FloodDemand,

    StellarMessage,

    AuthenticatedMessage,

    LiquidityPoolParameters,

    MuxedAccount,

    DecoratedSignature,

    OperationType,

    CreateAccountOp,

    PaymentOp,

    PathPaymentStrictReceiveOp,

    PathPaymentStrictSendOp,

    ManageSellOfferOp,

    ManageBuyOfferOp,

    CreatePassiveSellOfferOp,

    SetOptionsOp,

    ChangeTrustAsset,

    ChangeTrustOp,

    AllowTrustOp,

    ManageDataOp,

    BumpSequenceOp,

    CreateClaimableBalanceOp,

    ClaimClaimableBalanceOp,

    BeginSponsoringFutureReservesOp,

    RevokeSponsorshipType,

    RevokeSponsorshipOp,

    ClawbackOp,

    ClawbackClaimableBalanceOp,

    SetTrustLineFlagsOp,

    LiquidityPoolDepositOp,

    LiquidityPoolWithdrawOp,

    HostFunctionType,

    ContractIdPreimageType,

    ContractIdPreimage,

    CreateContractArgs,

    CreateContractArgsV2,

    InvokeContractArgs,

    HostFunction,

    SorobanAuthorizedFunctionType,

    SorobanAuthorizedFunction,

    SorobanAuthorizedInvocation,

    SorobanAddressCredentials,

    SorobanCredentialsType,

    SorobanCredentials,

    SorobanAuthorizationEntry,

    SorobanAuthorizationEntries,

    InvokeHostFunctionOp,

    ExtendFootprintTtlOp,

    RestoreFootprintOp,

    Operation,

    HashIdPreimage,

    MemoType,

    Memo,

    TimeBounds,

    LedgerBounds,

    PreconditionsV2,

    PreconditionType,

    Preconditions,

    LedgerFootprint,

    SorobanResources,

    SorobanResourcesExtV0,

    SorobanTransactionData,

    TransactionV0,

    TransactionV0Envelope,

    Transaction,

    TransactionV1Envelope,

    FeeBumpTransaction,

    FeeBumpTransactionEnvelope,

    TransactionEnvelope,

    TransactionSignaturePayload,

    ClaimAtomType,

    ClaimOfferAtomV0,

    ClaimOfferAtom,

    ClaimLiquidityAtom,

    ClaimAtom,

    CreateAccountResultCode,

    CreateAccountResult,

    PaymentResultCode,

    PaymentResult,

    PathPaymentStrictReceiveResultCode,

    SimplePaymentResult,

    PathPaymentStrictReceiveResult,

    PathPaymentStrictSendResultCode,

    PathPaymentStrictSendResult,

    ManageSellOfferResultCode,

    ManageOfferEffect,

    ManageOfferSuccessResult,

    ManageSellOfferResult,

    ManageBuyOfferResultCode,

    ManageBuyOfferResult,

    SetOptionsResultCode,

    SetOptionsResult,

    ChangeTrustResultCode,

    ChangeTrustResult,

    AllowTrustResultCode,

    AllowTrustResult,

    AccountMergeResultCode,

    AccountMergeResult,

    InflationResultCode,

    InflationPayout,

    InflationResult,

    ManageDataResultCode,

    ManageDataResult,

    BumpSequenceResultCode,

    BumpSequenceResult,

    CreateClaimableBalanceResultCode,

    CreateClaimableBalanceResult,

    ClaimClaimableBalanceResultCode,

    ClaimClaimableBalanceResult,

    BeginSponsoringFutureReservesResultCode,

    BeginSponsoringFutureReservesResult,

    EndSponsoringFutureReservesResultCode,

    EndSponsoringFutureReservesResult,

    RevokeSponsorshipResultCode,

    RevokeSponsorshipResult,

    ClawbackResultCode,

    ClawbackResult,

    ClawbackClaimableBalanceResultCode,

    ClawbackClaimableBalanceResult,

    SetTrustLineFlagsResultCode,

    SetTrustLineFlagsResult,

    LiquidityPoolDepositResultCode,

    LiquidityPoolDepositResult,

    LiquidityPoolWithdrawResultCode,

    LiquidityPoolWithdrawResult,

    InvokeHostFunctionResultCode,

    InvokeHostFunctionResult,

    ExtendFootprintTtlResultCode,

    ExtendFootprintTtlResult,

    RestoreFootprintResultCode,

    RestoreFootprintResult,

    OperationResultCode,

    OperationResult,

    TransactionResultCode,

    InnerTransactionResult,

    InnerTransactionResultPair,

    TransactionResult,

    Hash,

    Uint256,

    Uint32,

    Int32,

    Uint64,

    Int64,

    TimePoint,

    Duration,

    ExtensionPoint,

    CryptoKeyType,

    PublicKeyType,

    SignerKeyType,

    PublicKey,

    SignerKey,

    Signature,

    SignatureHint,

    NodeId,

    AccountId,

    ContractId,

    Curve25519Secret,

    Curve25519Public,

    HmacSha256Key,

    HmacSha256Mac,

    ShortHashSeed,

    BinaryFuseFilterType,

    SerializedBinaryFuseFilter,

    PoolId,

    ClaimableBalanceIdType,

    ClaimableBalanceId,
}

impl TypeVariant {
    pub const VARIANTS: [TypeVariant; 463] = [
        TypeVariant::ScpStatementPrepare,
        TypeVariant::ScpStatementConfirm,
        TypeVariant::ScpStatementExternalize,
        TypeVariant::ScpStatementPledges,
        TypeVariant::ScEnvMetaEntryInterfaceVersion,
        TypeVariant::AccountEntryExtensionV2Ext,
        TypeVariant::AccountEntryExtensionV1Ext,
        TypeVariant::AccountEntryExt,
        TypeVariant::TrustLineEntryExtensionV2Ext,
        TypeVariant::TrustLineEntryV1Ext,
        TypeVariant::TrustLineEntryV1,
        TypeVariant::TrustLineEntryExt,
        TypeVariant::OfferEntryExt,
        TypeVariant::DataEntryExt,
        TypeVariant::ClaimantV0,
        TypeVariant::ClaimableBalanceEntryExtensionV1Ext,
        TypeVariant::ClaimableBalanceEntryExt,
        TypeVariant::LiquidityPoolEntryConstantProduct,
        TypeVariant::LiquidityPoolEntryBody,
        TypeVariant::ContractCodeEntryV1,
        TypeVariant::ContractCodeEntryExt,
        TypeVariant::LedgerEntryExtensionV1Ext,
        TypeVariant::LedgerEntryData,
        TypeVariant::LedgerEntryExt,
        TypeVariant::LedgerKeyAccount,
        TypeVariant::LedgerKeyTrustLine,
        TypeVariant::LedgerKeyOffer,
        TypeVariant::LedgerKeyData,
        TypeVariant::LedgerKeyClaimableBalance,
        TypeVariant::LedgerKeyLiquidityPool,
        TypeVariant::LedgerKeyContractData,
        TypeVariant::LedgerKeyContractCode,
        TypeVariant::LedgerKeyConfigSetting,
        TypeVariant::LedgerKeyTtl,
        TypeVariant::BucketMetadataExt,
        TypeVariant::StellarValueExt,
        TypeVariant::LedgerHeaderExtensionV1Ext,
        TypeVariant::LedgerHeaderExt,
        TypeVariant::TxSetComponentTxsMaybeDiscountedFee,
        TypeVariant::TransactionHistoryEntryExt,
        TypeVariant::TransactionHistoryResultEntryExt,
        TypeVariant::LedgerHeaderHistoryEntryExt,
        TypeVariant::ContractEventV0,
        TypeVariant::ContractEventBody,
        TypeVariant::PeerAddressIp,
        TypeVariant::AuthenticatedMessageV0,
        TypeVariant::MuxedAccountMed25519,
        TypeVariant::RevokeSponsorshipOpSigner,
        TypeVariant::ContractIdPreimageFromAddress,
        TypeVariant::OperationBody,
        TypeVariant::HashIdPreimageOperationId,
        TypeVariant::HashIdPreimageRevokeId,
        TypeVariant::HashIdPreimageContractId,
        TypeVariant::HashIdPreimageSorobanAuthorization,
        TypeVariant::SorobanTransactionDataExt,
        TypeVariant::TransactionV0Ext,
        TypeVariant::TransactionExt,
        TypeVariant::FeeBumpTransactionInnerTx,
        TypeVariant::FeeBumpTransactionExt,
        TypeVariant::TransactionSignaturePayloadTaggedTransaction,
        TypeVariant::PathPaymentStrictReceiveResultSuccess,
        TypeVariant::PathPaymentStrictSendResultSuccess,
        TypeVariant::ManageOfferSuccessResultOffer,
        TypeVariant::OperationResultTr,
        TypeVariant::InnerTransactionResultResult,
        TypeVariant::InnerTransactionResultExt,
        TypeVariant::TransactionResultResult,
        TypeVariant::TransactionResultExt,
        TypeVariant::SignerKeyEd25519SignedPayload,
        TypeVariant::Value,
        TypeVariant::ScpBallot,
        TypeVariant::ScpStatementType,
        TypeVariant::ScpNomination,
        TypeVariant::ScpStatement,
        TypeVariant::ScpEnvelope,
        TypeVariant::ScpQuorumSet,
        TypeVariant::ConfigSettingContractExecutionLanesV0,
        TypeVariant::ConfigSettingContractComputeV0,
        TypeVariant::ConfigSettingContractParallelComputeV0,
        TypeVariant::ConfigSettingContractLedgerCostV0,
        TypeVariant::ConfigSettingContractLedgerCostExtV0,
        TypeVariant::ConfigSettingContractHistoricalDataV0,
        TypeVariant::ConfigSettingContractEventsV0,
        TypeVariant::ConfigSettingContractBandwidthV0,
        TypeVariant::ContractCostType,
        TypeVariant::ContractCostParamEntry,
        TypeVariant::StateArchivalSettings,
        TypeVariant::EvictionIterator,
        TypeVariant::ConfigSettingScpTiming,
        TypeVariant::ContractCostParams,
        TypeVariant::ConfigSettingId,
        TypeVariant::ConfigSettingEntry,
        TypeVariant::ScEnvMetaKind,
        TypeVariant::ScEnvMetaEntry,
        TypeVariant::ScMetaV0,
        TypeVariant::ScMetaKind,
        TypeVariant::ScMetaEntry,
        TypeVariant::ScSpecType,
        TypeVariant::ScSpecTypeOption,
        TypeVariant::ScSpecTypeResult,
        TypeVariant::ScSpecTypeVec,
        TypeVariant::ScSpecTypeMap,
        TypeVariant::ScSpecTypeTuple,
        TypeVariant::ScSpecTypeBytesN,
        TypeVariant::ScSpecTypeUdt,
        TypeVariant::ScSpecTypeDef,
        TypeVariant::ScSpecUdtStructFieldV0,
        TypeVariant::ScSpecUdtStructV0,
        TypeVariant::ScSpecUdtUnionCaseVoidV0,
        TypeVariant::ScSpecUdtUnionCaseTupleV0,
        TypeVariant::ScSpecUdtUnionCaseV0Kind,
        TypeVariant::ScSpecUdtUnionCaseV0,
        TypeVariant::ScSpecUdtUnionV0,
        TypeVariant::ScSpecUdtEnumCaseV0,
        TypeVariant::ScSpecUdtEnumV0,
        TypeVariant::ScSpecUdtErrorEnumCaseV0,
        TypeVariant::ScSpecUdtErrorEnumV0,
        TypeVariant::ScSpecFunctionInputV0,
        TypeVariant::ScSpecFunctionV0,
        TypeVariant::ScSpecEventParamLocationV0,
        TypeVariant::ScSpecEventParamV0,
        TypeVariant::ScSpecEventDataFormat,
        TypeVariant::ScSpecEventV0,
        TypeVariant::ScSpecEntryKind,
        TypeVariant::ScSpecEntry,
        TypeVariant::ScValType,
        TypeVariant::ScErrorType,
        TypeVariant::ScErrorCode,
        TypeVariant::ScError,
        TypeVariant::UInt128Parts,
        TypeVariant::Int128Parts,
        TypeVariant::UInt256Parts,
        TypeVariant::Int256Parts,
        TypeVariant::ContractExecutableType,
        TypeVariant::ContractExecutable,
        TypeVariant::ScAddressType,
        TypeVariant::MuxedEd25519Account,
        TypeVariant::ScAddress,
        TypeVariant::ScVec,
        TypeVariant::ScMap,
        TypeVariant::ScBytes,
        TypeVariant::ScString,
        TypeVariant::ScSymbol,
        TypeVariant::ScNonceKey,
        TypeVariant::ScContractInstance,
        TypeVariant::ScVal,
        TypeVariant::ScMapEntry,
        TypeVariant::LedgerCloseMetaBatch,
        TypeVariant::StoredTransactionSet,
        TypeVariant::StoredDebugTransactionSet,
        TypeVariant::PersistedScpStateV0,
        TypeVariant::PersistedScpStateV1,
        TypeVariant::PersistedScpState,
        TypeVariant::Thresholds,
        TypeVariant::String32,
        TypeVariant::String64,
        TypeVariant::SequenceNumber,
        TypeVariant::DataValue,
        TypeVariant::AssetCode4,
        TypeVariant::AssetCode12,
        TypeVariant::AssetType,
        TypeVariant::AssetCode,
        TypeVariant::AlphaNum4,
        TypeVariant::AlphaNum12,
        TypeVariant::Asset,
        TypeVariant::Price,
        TypeVariant::Liabilities,
        TypeVariant::ThresholdIndexes,
        TypeVariant::LedgerEntryType,
        TypeVariant::Signer,
        TypeVariant::AccountFlags,
        TypeVariant::SponsorshipDescriptor,
        TypeVariant::AccountEntryExtensionV3,
        TypeVariant::AccountEntryExtensionV2,
        TypeVariant::AccountEntryExtensionV1,
        TypeVariant::AccountEntry,
        TypeVariant::TrustLineFlags,
        TypeVariant::LiquidityPoolType,
        TypeVariant::TrustLineAsset,
        TypeVariant::TrustLineEntryExtensionV2,
        TypeVariant::TrustLineEntry,
        TypeVariant::OfferEntryFlags,
        TypeVariant::OfferEntry,
        TypeVariant::DataEntry,
        TypeVariant::ClaimPredicateType,
        TypeVariant::ClaimPredicate,
        TypeVariant::ClaimantType,
        TypeVariant::Claimant,
        TypeVariant::ClaimableBalanceFlags,
        TypeVariant::ClaimableBalanceEntryExtensionV1,
        TypeVariant::ClaimableBalanceEntry,
        TypeVariant::LiquidityPoolConstantProductParameters,
        TypeVariant::LiquidityPoolEntry,
        TypeVariant::ContractDataDurability,
        TypeVariant::ContractDataEntry,
        TypeVariant::ContractCodeCostInputs,
        TypeVariant::ContractCodeEntry,
        TypeVariant::TtlEntry,
        TypeVariant::LedgerEntryExtensionV1,
        TypeVariant::LedgerEntry,
        TypeVariant::LedgerKey,
        TypeVariant::EnvelopeType,
        TypeVariant::BucketListType,
        TypeVariant::BucketEntryType,
        TypeVariant::HotArchiveBucketEntryType,
        TypeVariant::BucketMetadata,
        TypeVariant::BucketEntry,
        TypeVariant::HotArchiveBucketEntry,
        TypeVariant::UpgradeType,
        TypeVariant::StellarValueType,
        TypeVariant::LedgerCloseValueSignature,
        TypeVariant::StellarValue,
        TypeVariant::LedgerHeaderFlags,
        TypeVariant::LedgerHeaderExtensionV1,
        TypeVariant::LedgerHeader,
        TypeVariant::LedgerUpgradeType,
        TypeVariant::ConfigUpgradeSetKey,
        TypeVariant::LedgerUpgrade,
        TypeVariant::ConfigUpgradeSet,
        TypeVariant::TxSetComponentType,
        TypeVariant::DependentTxCluster,
        TypeVariant::ParallelTxExecutionStage,
        TypeVariant::ParallelTxsComponent,
        TypeVariant::TxSetComponent,
        TypeVariant::TransactionPhase,
        TypeVariant::TransactionSet,
        TypeVariant::TransactionSetV1,
        TypeVariant::GeneralizedTransactionSet,
        TypeVariant::TransactionResultPair,
        TypeVariant::TransactionResultSet,
        TypeVariant::TransactionHistoryEntry,
        TypeVariant::TransactionHistoryResultEntry,
        TypeVariant::LedgerHeaderHistoryEntry,
        TypeVariant::LedgerScpMessages,
        TypeVariant::ScpHistoryEntryV0,
        TypeVariant::ScpHistoryEntry,
        TypeVariant::LedgerEntryChangeType,
        TypeVariant::LedgerEntryChange,
        TypeVariant::LedgerEntryChanges,
        TypeVariant::OperationMeta,
        TypeVariant::TransactionMetaV1,
        TypeVariant::TransactionMetaV2,
        TypeVariant::ContractEventType,
        TypeVariant::ContractEvent,
        TypeVariant::DiagnosticEvent,
        TypeVariant::SorobanTransactionMetaExtV1,
        TypeVariant::SorobanTransactionMetaExt,
        TypeVariant::SorobanTransactionMeta,
        TypeVariant::TransactionMetaV3,
        TypeVariant::OperationMetaV2,
        TypeVariant::SorobanTransactionMetaV2,
        TypeVariant::TransactionEventStage,
        TypeVariant::TransactionEvent,
        TypeVariant::TransactionMetaV4,
        TypeVariant::InvokeHostFunctionSuccessPreImage,
        TypeVariant::TransactionMeta,
        TypeVariant::TransactionResultMeta,
        TypeVariant::TransactionResultMetaV1,
        TypeVariant::UpgradeEntryMeta,
        TypeVariant::LedgerCloseMetaV0,
        TypeVariant::LedgerCloseMetaExtV1,
        TypeVariant::LedgerCloseMetaExt,
        TypeVariant::LedgerCloseMetaV1,
        TypeVariant::LedgerCloseMetaV2,
        TypeVariant::LedgerCloseMeta,
        TypeVariant::ErrorCode,
        TypeVariant::SError,
        TypeVariant::SendMore,
        TypeVariant::SendMoreExtended,
        TypeVariant::AuthCert,
        TypeVariant::Hello,
        TypeVariant::Auth,
        TypeVariant::IpAddrType,
        TypeVariant::PeerAddress,
        TypeVariant::MessageType,
        TypeVariant::DontHave,
        TypeVariant::SurveyMessageCommandType,
        TypeVariant::SurveyMessageResponseType,
        TypeVariant::TimeSlicedSurveyStartCollectingMessage,
        TypeVariant::SignedTimeSlicedSurveyStartCollectingMessage,
        TypeVariant::TimeSlicedSurveyStopCollectingMessage,
        TypeVariant::SignedTimeSlicedSurveyStopCollectingMessage,
        TypeVariant::SurveyRequestMessage,
        TypeVariant::TimeSlicedSurveyRequestMessage,
        TypeVariant::SignedTimeSlicedSurveyRequestMessage,
        TypeVariant::EncryptedBody,
        TypeVariant::SurveyResponseMessage,
        TypeVariant::TimeSlicedSurveyResponseMessage,
        TypeVariant::SignedTimeSlicedSurveyResponseMessage,
        TypeVariant::PeerStats,
        TypeVariant::TimeSlicedNodeData,
        TypeVariant::TimeSlicedPeerData,
        TypeVariant::TimeSlicedPeerDataList,
        TypeVariant::TopologyResponseBodyV2,
        TypeVariant::SurveyResponseBody,
        TypeVariant::TxAdvertVector,
        TypeVariant::FloodAdvert,
        TypeVariant::TxDemandVector,
        TypeVariant::FloodDemand,
        TypeVariant::StellarMessage,
        TypeVariant::AuthenticatedMessage,
        TypeVariant::LiquidityPoolParameters,
        TypeVariant::MuxedAccount,
        TypeVariant::DecoratedSignature,
        TypeVariant::OperationType,
        TypeVariant::CreateAccountOp,
        TypeVariant::PaymentOp,
        TypeVariant::PathPaymentStrictReceiveOp,
        TypeVariant::PathPaymentStrictSendOp,
        TypeVariant::ManageSellOfferOp,
        TypeVariant::ManageBuyOfferOp,
        TypeVariant::CreatePassiveSellOfferOp,
        TypeVariant::SetOptionsOp,
        TypeVariant::ChangeTrustAsset,
        TypeVariant::ChangeTrustOp,
        TypeVariant::AllowTrustOp,
        TypeVariant::ManageDataOp,
        TypeVariant::BumpSequenceOp,
        TypeVariant::CreateClaimableBalanceOp,
        TypeVariant::ClaimClaimableBalanceOp,
        TypeVariant::BeginSponsoringFutureReservesOp,
        TypeVariant::RevokeSponsorshipType,
        TypeVariant::RevokeSponsorshipOp,
        TypeVariant::ClawbackOp,
        TypeVariant::ClawbackClaimableBalanceOp,
        TypeVariant::SetTrustLineFlagsOp,
        TypeVariant::LiquidityPoolDepositOp,
        TypeVariant::LiquidityPoolWithdrawOp,
        TypeVariant::HostFunctionType,
        TypeVariant::ContractIdPreimageType,
        TypeVariant::ContractIdPreimage,
        TypeVariant::CreateContractArgs,
        TypeVariant::CreateContractArgsV2,
        TypeVariant::InvokeContractArgs,
        TypeVariant::HostFunction,
        TypeVariant::SorobanAuthorizedFunctionType,
        TypeVariant::SorobanAuthorizedFunction,
        TypeVariant::SorobanAuthorizedInvocation,
        TypeVariant::SorobanAddressCredentials,
        TypeVariant::SorobanCredentialsType,
        TypeVariant::SorobanCredentials,
        TypeVariant::SorobanAuthorizationEntry,
        TypeVariant::SorobanAuthorizationEntries,
        TypeVariant::InvokeHostFunctionOp,
        TypeVariant::ExtendFootprintTtlOp,
        TypeVariant::RestoreFootprintOp,
        TypeVariant::Operation,
        TypeVariant::HashIdPreimage,
        TypeVariant::MemoType,
        TypeVariant::Memo,
        TypeVariant::TimeBounds,
        TypeVariant::LedgerBounds,
        TypeVariant::PreconditionsV2,
        TypeVariant::PreconditionType,
        TypeVariant::Preconditions,
        TypeVariant::LedgerFootprint,
        TypeVariant::SorobanResources,
        TypeVariant::SorobanResourcesExtV0,
        TypeVariant::SorobanTransactionData,
        TypeVariant::TransactionV0,
        TypeVariant::TransactionV0Envelope,
        TypeVariant::Transaction,
        TypeVariant::TransactionV1Envelope,
        TypeVariant::FeeBumpTransaction,
        TypeVariant::FeeBumpTransactionEnvelope,
        TypeVariant::TransactionEnvelope,
        TypeVariant::TransactionSignaturePayload,
        TypeVariant::ClaimAtomType,
        TypeVariant::ClaimOfferAtomV0,
        TypeVariant::ClaimOfferAtom,
        TypeVariant::ClaimLiquidityAtom,
        TypeVariant::ClaimAtom,
        TypeVariant::CreateAccountResultCode,
        TypeVariant::CreateAccountResult,
        TypeVariant::PaymentResultCode,
        TypeVariant::PaymentResult,
        TypeVariant::PathPaymentStrictReceiveResultCode,
        TypeVariant::SimplePaymentResult,
        TypeVariant::PathPaymentStrictReceiveResult,
        TypeVariant::PathPaymentStrictSendResultCode,
        TypeVariant::PathPaymentStrictSendResult,
        TypeVariant::ManageSellOfferResultCode,
        TypeVariant::ManageOfferEffect,
        TypeVariant::ManageOfferSuccessResult,
        TypeVariant::ManageSellOfferResult,
        TypeVariant::ManageBuyOfferResultCode,
        TypeVariant::ManageBuyOfferResult,
        TypeVariant::SetOptionsResultCode,
        TypeVariant::SetOptionsResult,
        TypeVariant::ChangeTrustResultCode,
        TypeVariant::ChangeTrustResult,
        TypeVariant::AllowTrustResultCode,
        TypeVariant::AllowTrustResult,
        TypeVariant::AccountMergeResultCode,
        TypeVariant::AccountMergeResult,
        TypeVariant::InflationResultCode,
        TypeVariant::InflationPayout,
        TypeVariant::InflationResult,
        TypeVariant::ManageDataResultCode,
        TypeVariant::ManageDataResult,
        TypeVariant::BumpSequenceResultCode,
        TypeVariant::BumpSequenceResult,
        TypeVariant::CreateClaimableBalanceResultCode,
        TypeVariant::CreateClaimableBalanceResult,
        TypeVariant::ClaimClaimableBalanceResultCode,
        TypeVariant::ClaimClaimableBalanceResult,
        TypeVariant::BeginSponsoringFutureReservesResultCode,
        TypeVariant::BeginSponsoringFutureReservesResult,
        TypeVariant::EndSponsoringFutureReservesResultCode,
        TypeVariant::EndSponsoringFutureReservesResult,
        TypeVariant::RevokeSponsorshipResultCode,
        TypeVariant::RevokeSponsorshipResult,
        TypeVariant::ClawbackResultCode,
        TypeVariant::ClawbackResult,
        TypeVariant::ClawbackClaimableBalanceResultCode,
        TypeVariant::ClawbackClaimableBalanceResult,
        TypeVariant::SetTrustLineFlagsResultCode,
        TypeVariant::SetTrustLineFlagsResult,
        TypeVariant::LiquidityPoolDepositResultCode,
        TypeVariant::LiquidityPoolDepositResult,
        TypeVariant::LiquidityPoolWithdrawResultCode,
        TypeVariant::LiquidityPoolWithdrawResult,
        TypeVariant::InvokeHostFunctionResultCode,
        TypeVariant::InvokeHostFunctionResult,
        TypeVariant::ExtendFootprintTtlResultCode,
        TypeVariant::ExtendFootprintTtlResult,
        TypeVariant::RestoreFootprintResultCode,
        TypeVariant::RestoreFootprintResult,
        TypeVariant::OperationResultCode,
        TypeVariant::OperationResult,
        TypeVariant::TransactionResultCode,
        TypeVariant::InnerTransactionResult,
        TypeVariant::InnerTransactionResultPair,
        TypeVariant::TransactionResult,
        TypeVariant::Hash,
        TypeVariant::Uint256,
        TypeVariant::Uint32,
        TypeVariant::Int32,
        TypeVariant::Uint64,
        TypeVariant::Int64,
        TypeVariant::TimePoint,
        TypeVariant::Duration,
        TypeVariant::ExtensionPoint,
        TypeVariant::CryptoKeyType,
        TypeVariant::PublicKeyType,
        TypeVariant::SignerKeyType,
        TypeVariant::PublicKey,
        TypeVariant::SignerKey,
        TypeVariant::Signature,
        TypeVariant::SignatureHint,
        TypeVariant::NodeId,
        TypeVariant::AccountId,
        TypeVariant::ContractId,
        TypeVariant::Curve25519Secret,
        TypeVariant::Curve25519Public,
        TypeVariant::HmacSha256Key,
        TypeVariant::HmacSha256Mac,
        TypeVariant::ShortHashSeed,
        TypeVariant::BinaryFuseFilterType,
        TypeVariant::SerializedBinaryFuseFilter,
        TypeVariant::PoolId,
        TypeVariant::ClaimableBalanceIdType,
        TypeVariant::ClaimableBalanceId,
    ];
    pub const VARIANTS_STR: [&'static str; 463] = [
        "ScpStatementPrepare",
        "ScpStatementConfirm",
        "ScpStatementExternalize",
        "ScpStatementPledges",
        "ScEnvMetaEntryInterfaceVersion",
        "AccountEntryExtensionV2Ext",
        "AccountEntryExtensionV1Ext",
        "AccountEntryExt",
        "TrustLineEntryExtensionV2Ext",
        "TrustLineEntryV1Ext",
        "TrustLineEntryV1",
        "TrustLineEntryExt",
        "OfferEntryExt",
        "DataEntryExt",
        "ClaimantV0",
        "ClaimableBalanceEntryExtensionV1Ext",
        "ClaimableBalanceEntryExt",
        "LiquidityPoolEntryConstantProduct",
        "LiquidityPoolEntryBody",
        "ContractCodeEntryV1",
        "ContractCodeEntryExt",
        "LedgerEntryExtensionV1Ext",
        "LedgerEntryData",
        "LedgerEntryExt",
        "LedgerKeyAccount",
        "LedgerKeyTrustLine",
        "LedgerKeyOffer",
        "LedgerKeyData",
        "LedgerKeyClaimableBalance",
        "LedgerKeyLiquidityPool",
        "LedgerKeyContractData",
        "LedgerKeyContractCode",
        "LedgerKeyConfigSetting",
        "LedgerKeyTtl",
        "BucketMetadataExt",
        "StellarValueExt",
        "LedgerHeaderExtensionV1Ext",
        "LedgerHeaderExt",
        "TxSetComponentTxsMaybeDiscountedFee",
        "TransactionHistoryEntryExt",
        "TransactionHistoryResultEntryExt",
        "LedgerHeaderHistoryEntryExt",
        "ContractEventV0",
        "ContractEventBody",
        "PeerAddressIp",
        "AuthenticatedMessageV0",
        "MuxedAccountMed25519",
        "RevokeSponsorshipOpSigner",
        "ContractIdPreimageFromAddress",
        "OperationBody",
        "HashIdPreimageOperationId",
        "HashIdPreimageRevokeId",
        "HashIdPreimageContractId",
        "HashIdPreimageSorobanAuthorization",
        "SorobanTransactionDataExt",
        "TransactionV0Ext",
        "TransactionExt",
        "FeeBumpTransactionInnerTx",
        "FeeBumpTransactionExt",
        "TransactionSignaturePayloadTaggedTransaction",
        "PathPaymentStrictReceiveResultSuccess",
        "PathPaymentStrictSendResultSuccess",
        "ManageOfferSuccessResultOffer",
        "OperationResultTr",
        "InnerTransactionResultResult",
        "InnerTransactionResultExt",
        "TransactionResultResult",
        "TransactionResultExt",
        "SignerKeyEd25519SignedPayload",
        "Value",
        "ScpBallot",
        "ScpStatementType",
        "ScpNomination",
        "ScpStatement",
        "ScpEnvelope",
        "ScpQuorumSet",
        "ConfigSettingContractExecutionLanesV0",
        "ConfigSettingContractComputeV0",
        "ConfigSettingContractParallelComputeV0",
        "ConfigSettingContractLedgerCostV0",
        "ConfigSettingContractLedgerCostExtV0",
        "ConfigSettingContractHistoricalDataV0",
        "ConfigSettingContractEventsV0",
        "ConfigSettingContractBandwidthV0",
        "ContractCostType",
        "ContractCostParamEntry",
        "StateArchivalSettings",
        "EvictionIterator",
        "ConfigSettingScpTiming",
        "ContractCostParams",
        "ConfigSettingId",
        "ConfigSettingEntry",
        "ScEnvMetaKind",
        "ScEnvMetaEntry",
        "ScMetaV0",
        "ScMetaKind",
        "ScMetaEntry",
        "ScSpecType",
        "ScSpecTypeOption",
        "ScSpecTypeResult",
        "ScSpecTypeVec",
        "ScSpecTypeMap",
        "ScSpecTypeTuple",
        "ScSpecTypeBytesN",
        "ScSpecTypeUdt",
        "ScSpecTypeDef",
        "ScSpecUdtStructFieldV0",
        "ScSpecUdtStructV0",
        "ScSpecUdtUnionCaseVoidV0",
        "ScSpecUdtUnionCaseTupleV0",
        "ScSpecUdtUnionCaseV0Kind",
        "ScSpecUdtUnionCaseV0",
        "ScSpecUdtUnionV0",
        "ScSpecUdtEnumCaseV0",
        "ScSpecUdtEnumV0",
        "ScSpecUdtErrorEnumCaseV0",
        "ScSpecUdtErrorEnumV0",
        "ScSpecFunctionInputV0",
        "ScSpecFunctionV0",
        "ScSpecEventParamLocationV0",
        "ScSpecEventParamV0",
        "ScSpecEventDataFormat",
        "ScSpecEventV0",
        "ScSpecEntryKind",
        "ScSpecEntry",
        "ScValType",
        "ScErrorType",
        "ScErrorCode",
        "ScError",
        "UInt128Parts",
        "Int128Parts",
        "UInt256Parts",
        "Int256Parts",
        "ContractExecutableType",
        "ContractExecutable",
        "ScAddressType",
        "MuxedEd25519Account",
        "ScAddress",
        "ScVec",
        "ScMap",
        "ScBytes",
        "ScString",
        "ScSymbol",
        "ScNonceKey",
        "ScContractInstance",
        "ScVal",
        "ScMapEntry",
        "LedgerCloseMetaBatch",
        "StoredTransactionSet",
        "StoredDebugTransactionSet",
        "PersistedScpStateV0",
        "PersistedScpStateV1",
        "PersistedScpState",
        "Thresholds",
        "String32",
        "String64",
        "SequenceNumber",
        "DataValue",
        "AssetCode4",
        "AssetCode12",
        "AssetType",
        "AssetCode",
        "AlphaNum4",
        "AlphaNum12",
        "Asset",
        "Price",
        "Liabilities",
        "ThresholdIndexes",
        "LedgerEntryType",
        "Signer",
        "AccountFlags",
        "SponsorshipDescriptor",
        "AccountEntryExtensionV3",
        "AccountEntryExtensionV2",
        "AccountEntryExtensionV1",
        "AccountEntry",
        "TrustLineFlags",
        "LiquidityPoolType",
        "TrustLineAsset",
        "TrustLineEntryExtensionV2",
        "TrustLineEntry",
        "OfferEntryFlags",
        "OfferEntry",
        "DataEntry",
        "ClaimPredicateType",
        "ClaimPredicate",
        "ClaimantType",
        "Claimant",
        "ClaimableBalanceFlags",
        "ClaimableBalanceEntryExtensionV1",
        "ClaimableBalanceEntry",
        "LiquidityPoolConstantProductParameters",
        "LiquidityPoolEntry",
        "ContractDataDurability",
        "ContractDataEntry",
        "ContractCodeCostInputs",
        "ContractCodeEntry",
        "TtlEntry",
        "LedgerEntryExtensionV1",
        "LedgerEntry",
        "LedgerKey",
        "EnvelopeType",
        "BucketListType",
        "BucketEntryType",
        "HotArchiveBucketEntryType",
        "BucketMetadata",
        "BucketEntry",
        "HotArchiveBucketEntry",
        "UpgradeType",
        "StellarValueType",
        "LedgerCloseValueSignature",
        "StellarValue",
        "LedgerHeaderFlags",
        "LedgerHeaderExtensionV1",
        "LedgerHeader",
        "LedgerUpgradeType",
        "ConfigUpgradeSetKey",
        "LedgerUpgrade",
        "ConfigUpgradeSet",
        "TxSetComponentType",
        "DependentTxCluster",
        "ParallelTxExecutionStage",
        "ParallelTxsComponent",
        "TxSetComponent",
        "TransactionPhase",
        "TransactionSet",
        "TransactionSetV1",
        "GeneralizedTransactionSet",
        "TransactionResultPair",
        "TransactionResultSet",
        "TransactionHistoryEntry",
        "TransactionHistoryResultEntry",
        "LedgerHeaderHistoryEntry",
        "LedgerScpMessages",
        "ScpHistoryEntryV0",
        "ScpHistoryEntry",
        "LedgerEntryChangeType",
        "LedgerEntryChange",
        "LedgerEntryChanges",
        "OperationMeta",
        "TransactionMetaV1",
        "TransactionMetaV2",
        "ContractEventType",
        "ContractEvent",
        "DiagnosticEvent",
        "SorobanTransactionMetaExtV1",
        "SorobanTransactionMetaExt",
        "SorobanTransactionMeta",
        "TransactionMetaV3",
        "OperationMetaV2",
        "SorobanTransactionMetaV2",
        "TransactionEventStage",
        "TransactionEvent",
        "TransactionMetaV4",
        "InvokeHostFunctionSuccessPreImage",
        "TransactionMeta",
        "TransactionResultMeta",
        "TransactionResultMetaV1",
        "UpgradeEntryMeta",
        "LedgerCloseMetaV0",
        "LedgerCloseMetaExtV1",
        "LedgerCloseMetaExt",
        "LedgerCloseMetaV1",
        "LedgerCloseMetaV2",
        "LedgerCloseMeta",
        "ErrorCode",
        "SError",
        "SendMore",
        "SendMoreExtended",
        "AuthCert",
        "Hello",
        "Auth",
        "IpAddrType",
        "PeerAddress",
        "MessageType",
        "DontHave",
        "SurveyMessageCommandType",
        "SurveyMessageResponseType",
        "TimeSlicedSurveyStartCollectingMessage",
        "SignedTimeSlicedSurveyStartCollectingMessage",
        "TimeSlicedSurveyStopCollectingMessage",
        "SignedTimeSlicedSurveyStopCollectingMessage",
        "SurveyRequestMessage",
        "TimeSlicedSurveyRequestMessage",
        "SignedTimeSlicedSurveyRequestMessage",
        "EncryptedBody",
        "SurveyResponseMessage",
        "TimeSlicedSurveyResponseMessage",
        "SignedTimeSlicedSurveyResponseMessage",
        "PeerStats",
        "TimeSlicedNodeData",
        "TimeSlicedPeerData",
        "TimeSlicedPeerDataList",
        "TopologyResponseBodyV2",
        "SurveyResponseBody",
        "TxAdvertVector",
        "FloodAdvert",
        "TxDemandVector",
        "FloodDemand",
        "StellarMessage",
        "AuthenticatedMessage",
        "LiquidityPoolParameters",
        "MuxedAccount",
        "DecoratedSignature",
        "OperationType",
        "CreateAccountOp",
        "PaymentOp",
        "PathPaymentStrictReceiveOp",
        "PathPaymentStrictSendOp",
        "ManageSellOfferOp",
        "ManageBuyOfferOp",
        "CreatePassiveSellOfferOp",
        "SetOptionsOp",
        "ChangeTrustAsset",
        "ChangeTrustOp",
        "AllowTrustOp",
        "ManageDataOp",
        "BumpSequenceOp",
        "CreateClaimableBalanceOp",
        "ClaimClaimableBalanceOp",
        "BeginSponsoringFutureReservesOp",
        "RevokeSponsorshipType",
        "RevokeSponsorshipOp",
        "ClawbackOp",
        "ClawbackClaimableBalanceOp",
        "SetTrustLineFlagsOp",
        "LiquidityPoolDepositOp",
        "LiquidityPoolWithdrawOp",
        "HostFunctionType",
        "ContractIdPreimageType",
        "ContractIdPreimage",
        "CreateContractArgs",
        "CreateContractArgsV2",
        "InvokeContractArgs",
        "HostFunction",
        "SorobanAuthorizedFunctionType",
        "SorobanAuthorizedFunction",
        "SorobanAuthorizedInvocation",
        "SorobanAddressCredentials",
        "SorobanCredentialsType",
        "SorobanCredentials",
        "SorobanAuthorizationEntry",
        "SorobanAuthorizationEntries",
        "InvokeHostFunctionOp",
        "ExtendFootprintTtlOp",
        "RestoreFootprintOp",
        "Operation",
        "HashIdPreimage",
        "MemoType",
        "Memo",
        "TimeBounds",
        "LedgerBounds",
        "PreconditionsV2",
        "PreconditionType",
        "Preconditions",
        "LedgerFootprint",
        "SorobanResources",
        "SorobanResourcesExtV0",
        "SorobanTransactionData",
        "TransactionV0",
        "TransactionV0Envelope",
        "Transaction",
        "TransactionV1Envelope",
        "FeeBumpTransaction",
        "FeeBumpTransactionEnvelope",
        "TransactionEnvelope",
        "TransactionSignaturePayload",
        "ClaimAtomType",
        "ClaimOfferAtomV0",
        "ClaimOfferAtom",
        "ClaimLiquidityAtom",
        "ClaimAtom",
        "CreateAccountResultCode",
        "CreateAccountResult",
        "PaymentResultCode",
        "PaymentResult",
        "PathPaymentStrictReceiveResultCode",
        "SimplePaymentResult",
        "PathPaymentStrictReceiveResult",
        "PathPaymentStrictSendResultCode",
        "PathPaymentStrictSendResult",
        "ManageSellOfferResultCode",
        "ManageOfferEffect",
        "ManageOfferSuccessResult",
        "ManageSellOfferResult",
        "ManageBuyOfferResultCode",
        "ManageBuyOfferResult",
        "SetOptionsResultCode",
        "SetOptionsResult",
        "ChangeTrustResultCode",
        "ChangeTrustResult",
        "AllowTrustResultCode",
        "AllowTrustResult",
        "AccountMergeResultCode",
        "AccountMergeResult",
        "InflationResultCode",
        "InflationPayout",
        "InflationResult",
        "ManageDataResultCode",
        "ManageDataResult",
        "BumpSequenceResultCode",
        "BumpSequenceResult",
        "CreateClaimableBalanceResultCode",
        "CreateClaimableBalanceResult",
        "ClaimClaimableBalanceResultCode",
        "ClaimClaimableBalanceResult",
        "BeginSponsoringFutureReservesResultCode",
        "BeginSponsoringFutureReservesResult",
        "EndSponsoringFutureReservesResultCode",
        "EndSponsoringFutureReservesResult",
        "RevokeSponsorshipResultCode",
        "RevokeSponsorshipResult",
        "ClawbackResultCode",
        "ClawbackResult",
        "ClawbackClaimableBalanceResultCode",
        "ClawbackClaimableBalanceResult",
        "SetTrustLineFlagsResultCode",
        "SetTrustLineFlagsResult",
        "LiquidityPoolDepositResultCode",
        "LiquidityPoolDepositResult",
        "LiquidityPoolWithdrawResultCode",
        "LiquidityPoolWithdrawResult",
        "InvokeHostFunctionResultCode",
        "InvokeHostFunctionResult",
        "ExtendFootprintTtlResultCode",
        "ExtendFootprintTtlResult",
        "RestoreFootprintResultCode",
        "RestoreFootprintResult",
        "OperationResultCode",
        "OperationResult",
        "TransactionResultCode",
        "InnerTransactionResult",
        "InnerTransactionResultPair",
        "TransactionResult",
        "Hash",
        "Uint256",
        "Uint32",
        "Int32",
        "Uint64",
        "Int64",
        "TimePoint",
        "Duration",
        "ExtensionPoint",
        "CryptoKeyType",
        "PublicKeyType",
        "SignerKeyType",
        "PublicKey",
        "SignerKey",
        "Signature",
        "SignatureHint",
        "NodeId",
        "AccountId",
        "ContractId",
        "Curve25519Secret",
        "Curve25519Public",
        "HmacSha256Key",
        "HmacSha256Mac",
        "ShortHashSeed",
        "BinaryFuseFilterType",
        "SerializedBinaryFuseFilter",
        "PoolId",
        "ClaimableBalanceIdType",
        "ClaimableBalanceId",
    ];

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScpStatementPrepare => "ScpStatementPrepare",

            Self::ScpStatementConfirm => "ScpStatementConfirm",

            Self::ScpStatementExternalize => "ScpStatementExternalize",

            Self::ScpStatementPledges => "ScpStatementPledges",

            Self::ScEnvMetaEntryInterfaceVersion => "ScEnvMetaEntryInterfaceVersion",

            Self::AccountEntryExtensionV2Ext => "AccountEntryExtensionV2Ext",

            Self::AccountEntryExtensionV1Ext => "AccountEntryExtensionV1Ext",

            Self::AccountEntryExt => "AccountEntryExt",

            Self::TrustLineEntryExtensionV2Ext => "TrustLineEntryExtensionV2Ext",

            Self::TrustLineEntryV1Ext => "TrustLineEntryV1Ext",

            Self::TrustLineEntryV1 => "TrustLineEntryV1",

            Self::TrustLineEntryExt => "TrustLineEntryExt",

            Self::OfferEntryExt => "OfferEntryExt",

            Self::DataEntryExt => "DataEntryExt",

            Self::ClaimantV0 => "ClaimantV0",

            Self::ClaimableBalanceEntryExtensionV1Ext => "ClaimableBalanceEntryExtensionV1Ext",

            Self::ClaimableBalanceEntryExt => "ClaimableBalanceEntryExt",

            Self::LiquidityPoolEntryConstantProduct => "LiquidityPoolEntryConstantProduct",

            Self::LiquidityPoolEntryBody => "LiquidityPoolEntryBody",

            Self::ContractCodeEntryV1 => "ContractCodeEntryV1",

            Self::ContractCodeEntryExt => "ContractCodeEntryExt",

            Self::LedgerEntryExtensionV1Ext => "LedgerEntryExtensionV1Ext",

            Self::LedgerEntryData => "LedgerEntryData",

            Self::LedgerEntryExt => "LedgerEntryExt",

            Self::LedgerKeyAccount => "LedgerKeyAccount",

            Self::LedgerKeyTrustLine => "LedgerKeyTrustLine",

            Self::LedgerKeyOffer => "LedgerKeyOffer",

            Self::LedgerKeyData => "LedgerKeyData",

            Self::LedgerKeyClaimableBalance => "LedgerKeyClaimableBalance",

            Self::LedgerKeyLiquidityPool => "LedgerKeyLiquidityPool",

            Self::LedgerKeyContractData => "LedgerKeyContractData",

            Self::LedgerKeyContractCode => "LedgerKeyContractCode",

            Self::LedgerKeyConfigSetting => "LedgerKeyConfigSetting",

            Self::LedgerKeyTtl => "LedgerKeyTtl",

            Self::BucketMetadataExt => "BucketMetadataExt",

            Self::StellarValueExt => "StellarValueExt",

            Self::LedgerHeaderExtensionV1Ext => "LedgerHeaderExtensionV1Ext",

            Self::LedgerHeaderExt => "LedgerHeaderExt",

            Self::TxSetComponentTxsMaybeDiscountedFee => "TxSetComponentTxsMaybeDiscountedFee",

            Self::TransactionHistoryEntryExt => "TransactionHistoryEntryExt",

            Self::TransactionHistoryResultEntryExt => "TransactionHistoryResultEntryExt",

            Self::LedgerHeaderHistoryEntryExt => "LedgerHeaderHistoryEntryExt",

            Self::ContractEventV0 => "ContractEventV0",

            Self::ContractEventBody => "ContractEventBody",

            Self::PeerAddressIp => "PeerAddressIp",

            Self::AuthenticatedMessageV0 => "AuthenticatedMessageV0",

            Self::MuxedAccountMed25519 => "MuxedAccountMed25519",

            Self::RevokeSponsorshipOpSigner => "RevokeSponsorshipOpSigner",

            Self::ContractIdPreimageFromAddress => "ContractIdPreimageFromAddress",

            Self::OperationBody => "OperationBody",

            Self::HashIdPreimageOperationId => "HashIdPreimageOperationId",

            Self::HashIdPreimageRevokeId => "HashIdPreimageRevokeId",

            Self::HashIdPreimageContractId => "HashIdPreimageContractId",

            Self::HashIdPreimageSorobanAuthorization => "HashIdPreimageSorobanAuthorization",

            Self::SorobanTransactionDataExt => "SorobanTransactionDataExt",

            Self::TransactionV0Ext => "TransactionV0Ext",

            Self::TransactionExt => "TransactionExt",

            Self::FeeBumpTransactionInnerTx => "FeeBumpTransactionInnerTx",

            Self::FeeBumpTransactionExt => "FeeBumpTransactionExt",

            Self::TransactionSignaturePayloadTaggedTransaction => {
                "TransactionSignaturePayloadTaggedTransaction"
            }

            Self::PathPaymentStrictReceiveResultSuccess => "PathPaymentStrictReceiveResultSuccess",

            Self::PathPaymentStrictSendResultSuccess => "PathPaymentStrictSendResultSuccess",

            Self::ManageOfferSuccessResultOffer => "ManageOfferSuccessResultOffer",

            Self::OperationResultTr => "OperationResultTr",

            Self::InnerTransactionResultResult => "InnerTransactionResultResult",

            Self::InnerTransactionResultExt => "InnerTransactionResultExt",

            Self::TransactionResultResult => "TransactionResultResult",

            Self::TransactionResultExt => "TransactionResultExt",

            Self::SignerKeyEd25519SignedPayload => "SignerKeyEd25519SignedPayload",

            Self::Value => "Value",

            Self::ScpBallot => "ScpBallot",

            Self::ScpStatementType => "ScpStatementType",

            Self::ScpNomination => "ScpNomination",

            Self::ScpStatement => "ScpStatement",

            Self::ScpEnvelope => "ScpEnvelope",

            Self::ScpQuorumSet => "ScpQuorumSet",

            Self::ConfigSettingContractExecutionLanesV0 => "ConfigSettingContractExecutionLanesV0",

            Self::ConfigSettingContractComputeV0 => "ConfigSettingContractComputeV0",

            Self::ConfigSettingContractParallelComputeV0 => {
                "ConfigSettingContractParallelComputeV0"
            }

            Self::ConfigSettingContractLedgerCostV0 => "ConfigSettingContractLedgerCostV0",

            Self::ConfigSettingContractLedgerCostExtV0 => "ConfigSettingContractLedgerCostExtV0",

            Self::ConfigSettingContractHistoricalDataV0 => "ConfigSettingContractHistoricalDataV0",

            Self::ConfigSettingContractEventsV0 => "ConfigSettingContractEventsV0",

            Self::ConfigSettingContractBandwidthV0 => "ConfigSettingContractBandwidthV0",

            Self::ContractCostType => "ContractCostType",

            Self::ContractCostParamEntry => "ContractCostParamEntry",

            Self::StateArchivalSettings => "StateArchivalSettings",

            Self::EvictionIterator => "EvictionIterator",

            Self::ConfigSettingScpTiming => "ConfigSettingScpTiming",

            Self::ContractCostParams => "ContractCostParams",

            Self::ConfigSettingId => "ConfigSettingId",

            Self::ConfigSettingEntry => "ConfigSettingEntry",

            Self::ScEnvMetaKind => "ScEnvMetaKind",

            Self::ScEnvMetaEntry => "ScEnvMetaEntry",

            Self::ScMetaV0 => "ScMetaV0",

            Self::ScMetaKind => "ScMetaKind",

            Self::ScMetaEntry => "ScMetaEntry",

            Self::ScSpecType => "ScSpecType",

            Self::ScSpecTypeOption => "ScSpecTypeOption",

            Self::ScSpecTypeResult => "ScSpecTypeResult",

            Self::ScSpecTypeVec => "ScSpecTypeVec",

            Self::ScSpecTypeMap => "ScSpecTypeMap",

            Self::ScSpecTypeTuple => "ScSpecTypeTuple",

            Self::ScSpecTypeBytesN => "ScSpecTypeBytesN",

            Self::ScSpecTypeUdt => "ScSpecTypeUdt",

            Self::ScSpecTypeDef => "ScSpecTypeDef",

            Self::ScSpecUdtStructFieldV0 => "ScSpecUdtStructFieldV0",

            Self::ScSpecUdtStructV0 => "ScSpecUdtStructV0",

            Self::ScSpecUdtUnionCaseVoidV0 => "ScSpecUdtUnionCaseVoidV0",

            Self::ScSpecUdtUnionCaseTupleV0 => "ScSpecUdtUnionCaseTupleV0",

            Self::ScSpecUdtUnionCaseV0Kind => "ScSpecUdtUnionCaseV0Kind",

            Self::ScSpecUdtUnionCaseV0 => "ScSpecUdtUnionCaseV0",

            Self::ScSpecUdtUnionV0 => "ScSpecUdtUnionV0",

            Self::ScSpecUdtEnumCaseV0 => "ScSpecUdtEnumCaseV0",

            Self::ScSpecUdtEnumV0 => "ScSpecUdtEnumV0",

            Self::ScSpecUdtErrorEnumCaseV0 => "ScSpecUdtErrorEnumCaseV0",

            Self::ScSpecUdtErrorEnumV0 => "ScSpecUdtErrorEnumV0",

            Self::ScSpecFunctionInputV0 => "ScSpecFunctionInputV0",

            Self::ScSpecFunctionV0 => "ScSpecFunctionV0",

            Self::ScSpecEventParamLocationV0 => "ScSpecEventParamLocationV0",

            Self::ScSpecEventParamV0 => "ScSpecEventParamV0",

            Self::ScSpecEventDataFormat => "ScSpecEventDataFormat",

            Self::ScSpecEventV0 => "ScSpecEventV0",

            Self::ScSpecEntryKind => "ScSpecEntryKind",

            Self::ScSpecEntry => "ScSpecEntry",

            Self::ScValType => "ScValType",

            Self::ScErrorType => "ScErrorType",

            Self::ScErrorCode => "ScErrorCode",

            Self::ScError => "ScError",

            Self::UInt128Parts => "UInt128Parts",

            Self::Int128Parts => "Int128Parts",

            Self::UInt256Parts => "UInt256Parts",

            Self::Int256Parts => "Int256Parts",

            Self::ContractExecutableType => "ContractExecutableType",

            Self::ContractExecutable => "ContractExecutable",

            Self::ScAddressType => "ScAddressType",

            Self::MuxedEd25519Account => "MuxedEd25519Account",

            Self::ScAddress => "ScAddress",

            Self::ScVec => "ScVec",

            Self::ScMap => "ScMap",

            Self::ScBytes => "ScBytes",

            Self::ScString => "ScString",

            Self::ScSymbol => "ScSymbol",

            Self::ScNonceKey => "ScNonceKey",

            Self::ScContractInstance => "ScContractInstance",

            Self::ScVal => "ScVal",

            Self::ScMapEntry => "ScMapEntry",

            Self::LedgerCloseMetaBatch => "LedgerCloseMetaBatch",

            Self::StoredTransactionSet => "StoredTransactionSet",

            Self::StoredDebugTransactionSet => "StoredDebugTransactionSet",

            Self::PersistedScpStateV0 => "PersistedScpStateV0",

            Self::PersistedScpStateV1 => "PersistedScpStateV1",

            Self::PersistedScpState => "PersistedScpState",

            Self::Thresholds => "Thresholds",

            Self::String32 => "String32",

            Self::String64 => "String64",

            Self::SequenceNumber => "SequenceNumber",

            Self::DataValue => "DataValue",

            Self::AssetCode4 => "AssetCode4",

            Self::AssetCode12 => "AssetCode12",

            Self::AssetType => "AssetType",

            Self::AssetCode => "AssetCode",

            Self::AlphaNum4 => "AlphaNum4",

            Self::AlphaNum12 => "AlphaNum12",

            Self::Asset => "Asset",

            Self::Price => "Price",

            Self::Liabilities => "Liabilities",

            Self::ThresholdIndexes => "ThresholdIndexes",

            Self::LedgerEntryType => "LedgerEntryType",

            Self::Signer => "Signer",

            Self::AccountFlags => "AccountFlags",

            Self::SponsorshipDescriptor => "SponsorshipDescriptor",

            Self::AccountEntryExtensionV3 => "AccountEntryExtensionV3",

            Self::AccountEntryExtensionV2 => "AccountEntryExtensionV2",

            Self::AccountEntryExtensionV1 => "AccountEntryExtensionV1",

            Self::AccountEntry => "AccountEntry",

            Self::TrustLineFlags => "TrustLineFlags",

            Self::LiquidityPoolType => "LiquidityPoolType",

            Self::TrustLineAsset => "TrustLineAsset",

            Self::TrustLineEntryExtensionV2 => "TrustLineEntryExtensionV2",

            Self::TrustLineEntry => "TrustLineEntry",

            Self::OfferEntryFlags => "OfferEntryFlags",

            Self::OfferEntry => "OfferEntry",

            Self::DataEntry => "DataEntry",

            Self::ClaimPredicateType => "ClaimPredicateType",

            Self::ClaimPredicate => "ClaimPredicate",

            Self::ClaimantType => "ClaimantType",

            Self::Claimant => "Claimant",

            Self::ClaimableBalanceFlags => "ClaimableBalanceFlags",

            Self::ClaimableBalanceEntryExtensionV1 => "ClaimableBalanceEntryExtensionV1",

            Self::ClaimableBalanceEntry => "ClaimableBalanceEntry",

            Self::LiquidityPoolConstantProductParameters => {
                "LiquidityPoolConstantProductParameters"
            }

            Self::LiquidityPoolEntry => "LiquidityPoolEntry",

            Self::ContractDataDurability => "ContractDataDurability",

            Self::ContractDataEntry => "ContractDataEntry",

            Self::ContractCodeCostInputs => "ContractCodeCostInputs",

            Self::ContractCodeEntry => "ContractCodeEntry",

            Self::TtlEntry => "TtlEntry",

            Self::LedgerEntryExtensionV1 => "LedgerEntryExtensionV1",

            Self::LedgerEntry => "LedgerEntry",

            Self::LedgerKey => "LedgerKey",

            Self::EnvelopeType => "EnvelopeType",

            Self::BucketListType => "BucketListType",

            Self::BucketEntryType => "BucketEntryType",

            Self::HotArchiveBucketEntryType => "HotArchiveBucketEntryType",

            Self::BucketMetadata => "BucketMetadata",

            Self::BucketEntry => "BucketEntry",

            Self::HotArchiveBucketEntry => "HotArchiveBucketEntry",

            Self::UpgradeType => "UpgradeType",

            Self::StellarValueType => "StellarValueType",

            Self::LedgerCloseValueSignature => "LedgerCloseValueSignature",

            Self::StellarValue => "StellarValue",

            Self::LedgerHeaderFlags => "LedgerHeaderFlags",

            Self::LedgerHeaderExtensionV1 => "LedgerHeaderExtensionV1",

            Self::LedgerHeader => "LedgerHeader",

            Self::LedgerUpgradeType => "LedgerUpgradeType",

            Self::ConfigUpgradeSetKey => "ConfigUpgradeSetKey",

            Self::LedgerUpgrade => "LedgerUpgrade",

            Self::ConfigUpgradeSet => "ConfigUpgradeSet",

            Self::TxSetComponentType => "TxSetComponentType",

            Self::DependentTxCluster => "DependentTxCluster",

            Self::ParallelTxExecutionStage => "ParallelTxExecutionStage",

            Self::ParallelTxsComponent => "ParallelTxsComponent",

            Self::TxSetComponent => "TxSetComponent",

            Self::TransactionPhase => "TransactionPhase",

            Self::TransactionSet => "TransactionSet",

            Self::TransactionSetV1 => "TransactionSetV1",

            Self::GeneralizedTransactionSet => "GeneralizedTransactionSet",

            Self::TransactionResultPair => "TransactionResultPair",

            Self::TransactionResultSet => "TransactionResultSet",

            Self::TransactionHistoryEntry => "TransactionHistoryEntry",

            Self::TransactionHistoryResultEntry => "TransactionHistoryResultEntry",

            Self::LedgerHeaderHistoryEntry => "LedgerHeaderHistoryEntry",

            Self::LedgerScpMessages => "LedgerScpMessages",

            Self::ScpHistoryEntryV0 => "ScpHistoryEntryV0",

            Self::ScpHistoryEntry => "ScpHistoryEntry",

            Self::LedgerEntryChangeType => "LedgerEntryChangeType",

            Self::LedgerEntryChange => "LedgerEntryChange",

            Self::LedgerEntryChanges => "LedgerEntryChanges",

            Self::OperationMeta => "OperationMeta",

            Self::TransactionMetaV1 => "TransactionMetaV1",

            Self::TransactionMetaV2 => "TransactionMetaV2",

            Self::ContractEventType => "ContractEventType",

            Self::ContractEvent => "ContractEvent",

            Self::DiagnosticEvent => "DiagnosticEvent",

            Self::SorobanTransactionMetaExtV1 => "SorobanTransactionMetaExtV1",

            Self::SorobanTransactionMetaExt => "SorobanTransactionMetaExt",

            Self::SorobanTransactionMeta => "SorobanTransactionMeta",

            Self::TransactionMetaV3 => "TransactionMetaV3",

            Self::OperationMetaV2 => "OperationMetaV2",

            Self::SorobanTransactionMetaV2 => "SorobanTransactionMetaV2",

            Self::TransactionEventStage => "TransactionEventStage",

            Self::TransactionEvent => "TransactionEvent",

            Self::TransactionMetaV4 => "TransactionMetaV4",

            Self::InvokeHostFunctionSuccessPreImage => "InvokeHostFunctionSuccessPreImage",

            Self::TransactionMeta => "TransactionMeta",

            Self::TransactionResultMeta => "TransactionResultMeta",

            Self::TransactionResultMetaV1 => "TransactionResultMetaV1",

            Self::UpgradeEntryMeta => "UpgradeEntryMeta",

            Self::LedgerCloseMetaV0 => "LedgerCloseMetaV0",

            Self::LedgerCloseMetaExtV1 => "LedgerCloseMetaExtV1",

            Self::LedgerCloseMetaExt => "LedgerCloseMetaExt",

            Self::LedgerCloseMetaV1 => "LedgerCloseMetaV1",

            Self::LedgerCloseMetaV2 => "LedgerCloseMetaV2",

            Self::LedgerCloseMeta => "LedgerCloseMeta",

            Self::ErrorCode => "ErrorCode",

            Self::SError => "SError",

            Self::SendMore => "SendMore",

            Self::SendMoreExtended => "SendMoreExtended",

            Self::AuthCert => "AuthCert",

            Self::Hello => "Hello",

            Self::Auth => "Auth",

            Self::IpAddrType => "IpAddrType",

            Self::PeerAddress => "PeerAddress",

            Self::MessageType => "MessageType",

            Self::DontHave => "DontHave",

            Self::SurveyMessageCommandType => "SurveyMessageCommandType",

            Self::SurveyMessageResponseType => "SurveyMessageResponseType",

            Self::TimeSlicedSurveyStartCollectingMessage => {
                "TimeSlicedSurveyStartCollectingMessage"
            }

            Self::SignedTimeSlicedSurveyStartCollectingMessage => {
                "SignedTimeSlicedSurveyStartCollectingMessage"
            }

            Self::TimeSlicedSurveyStopCollectingMessage => "TimeSlicedSurveyStopCollectingMessage",

            Self::SignedTimeSlicedSurveyStopCollectingMessage => {
                "SignedTimeSlicedSurveyStopCollectingMessage"
            }

            Self::SurveyRequestMessage => "SurveyRequestMessage",

            Self::TimeSlicedSurveyRequestMessage => "TimeSlicedSurveyRequestMessage",

            Self::SignedTimeSlicedSurveyRequestMessage => "SignedTimeSlicedSurveyRequestMessage",

            Self::EncryptedBody => "EncryptedBody",

            Self::SurveyResponseMessage => "SurveyResponseMessage",

            Self::TimeSlicedSurveyResponseMessage => "TimeSlicedSurveyResponseMessage",

            Self::SignedTimeSlicedSurveyResponseMessage => "SignedTimeSlicedSurveyResponseMessage",

            Self::PeerStats => "PeerStats",

            Self::TimeSlicedNodeData => "TimeSlicedNodeData",

            Self::TimeSlicedPeerData => "TimeSlicedPeerData",

            Self::TimeSlicedPeerDataList => "TimeSlicedPeerDataList",

            Self::TopologyResponseBodyV2 => "TopologyResponseBodyV2",

            Self::SurveyResponseBody => "SurveyResponseBody",

            Self::TxAdvertVector => "TxAdvertVector",

            Self::FloodAdvert => "FloodAdvert",

            Self::TxDemandVector => "TxDemandVector",

            Self::FloodDemand => "FloodDemand",

            Self::StellarMessage => "StellarMessage",

            Self::AuthenticatedMessage => "AuthenticatedMessage",

            Self::LiquidityPoolParameters => "LiquidityPoolParameters",

            Self::MuxedAccount => "MuxedAccount",

            Self::DecoratedSignature => "DecoratedSignature",

            Self::OperationType => "OperationType",

            Self::CreateAccountOp => "CreateAccountOp",

            Self::PaymentOp => "PaymentOp",

            Self::PathPaymentStrictReceiveOp => "PathPaymentStrictReceiveOp",

            Self::PathPaymentStrictSendOp => "PathPaymentStrictSendOp",

            Self::ManageSellOfferOp => "ManageSellOfferOp",

            Self::ManageBuyOfferOp => "ManageBuyOfferOp",

            Self::CreatePassiveSellOfferOp => "CreatePassiveSellOfferOp",

            Self::SetOptionsOp => "SetOptionsOp",

            Self::ChangeTrustAsset => "ChangeTrustAsset",

            Self::ChangeTrustOp => "ChangeTrustOp",

            Self::AllowTrustOp => "AllowTrustOp",

            Self::ManageDataOp => "ManageDataOp",

            Self::BumpSequenceOp => "BumpSequenceOp",

            Self::CreateClaimableBalanceOp => "CreateClaimableBalanceOp",

            Self::ClaimClaimableBalanceOp => "ClaimClaimableBalanceOp",

            Self::BeginSponsoringFutureReservesOp => "BeginSponsoringFutureReservesOp",

            Self::RevokeSponsorshipType => "RevokeSponsorshipType",

            Self::RevokeSponsorshipOp => "RevokeSponsorshipOp",

            Self::ClawbackOp => "ClawbackOp",

            Self::ClawbackClaimableBalanceOp => "ClawbackClaimableBalanceOp",

            Self::SetTrustLineFlagsOp => "SetTrustLineFlagsOp",

            Self::LiquidityPoolDepositOp => "LiquidityPoolDepositOp",

            Self::LiquidityPoolWithdrawOp => "LiquidityPoolWithdrawOp",

            Self::HostFunctionType => "HostFunctionType",

            Self::ContractIdPreimageType => "ContractIdPreimageType",

            Self::ContractIdPreimage => "ContractIdPreimage",

            Self::CreateContractArgs => "CreateContractArgs",

            Self::CreateContractArgsV2 => "CreateContractArgsV2",

            Self::InvokeContractArgs => "InvokeContractArgs",

            Self::HostFunction => "HostFunction",

            Self::SorobanAuthorizedFunctionType => "SorobanAuthorizedFunctionType",

            Self::SorobanAuthorizedFunction => "SorobanAuthorizedFunction",

            Self::SorobanAuthorizedInvocation => "SorobanAuthorizedInvocation",

            Self::SorobanAddressCredentials => "SorobanAddressCredentials",

            Self::SorobanCredentialsType => "SorobanCredentialsType",

            Self::SorobanCredentials => "SorobanCredentials",

            Self::SorobanAuthorizationEntry => "SorobanAuthorizationEntry",

            Self::SorobanAuthorizationEntries => "SorobanAuthorizationEntries",

            Self::InvokeHostFunctionOp => "InvokeHostFunctionOp",

            Self::ExtendFootprintTtlOp => "ExtendFootprintTtlOp",

            Self::RestoreFootprintOp => "RestoreFootprintOp",

            Self::Operation => "Operation",

            Self::HashIdPreimage => "HashIdPreimage",

            Self::MemoType => "MemoType",

            Self::Memo => "Memo",

            Self::TimeBounds => "TimeBounds",

            Self::LedgerBounds => "LedgerBounds",

            Self::PreconditionsV2 => "PreconditionsV2",

            Self::PreconditionType => "PreconditionType",

            Self::Preconditions => "Preconditions",

            Self::LedgerFootprint => "LedgerFootprint",

            Self::SorobanResources => "SorobanResources",

            Self::SorobanResourcesExtV0 => "SorobanResourcesExtV0",

            Self::SorobanTransactionData => "SorobanTransactionData",

            Self::TransactionV0 => "TransactionV0",

            Self::TransactionV0Envelope => "TransactionV0Envelope",

            Self::Transaction => "Transaction",

            Self::TransactionV1Envelope => "TransactionV1Envelope",

            Self::FeeBumpTransaction => "FeeBumpTransaction",

            Self::FeeBumpTransactionEnvelope => "FeeBumpTransactionEnvelope",

            Self::TransactionEnvelope => "TransactionEnvelope",

            Self::TransactionSignaturePayload => "TransactionSignaturePayload",

            Self::ClaimAtomType => "ClaimAtomType",

            Self::ClaimOfferAtomV0 => "ClaimOfferAtomV0",

            Self::ClaimOfferAtom => "ClaimOfferAtom",

            Self::ClaimLiquidityAtom => "ClaimLiquidityAtom",

            Self::ClaimAtom => "ClaimAtom",

            Self::CreateAccountResultCode => "CreateAccountResultCode",

            Self::CreateAccountResult => "CreateAccountResult",

            Self::PaymentResultCode => "PaymentResultCode",

            Self::PaymentResult => "PaymentResult",

            Self::PathPaymentStrictReceiveResultCode => "PathPaymentStrictReceiveResultCode",

            Self::SimplePaymentResult => "SimplePaymentResult",

            Self::PathPaymentStrictReceiveResult => "PathPaymentStrictReceiveResult",

            Self::PathPaymentStrictSendResultCode => "PathPaymentStrictSendResultCode",

            Self::PathPaymentStrictSendResult => "PathPaymentStrictSendResult",

            Self::ManageSellOfferResultCode => "ManageSellOfferResultCode",

            Self::ManageOfferEffect => "ManageOfferEffect",

            Self::ManageOfferSuccessResult => "ManageOfferSuccessResult",

            Self::ManageSellOfferResult => "ManageSellOfferResult",

            Self::ManageBuyOfferResultCode => "ManageBuyOfferResultCode",

            Self::ManageBuyOfferResult => "ManageBuyOfferResult",

            Self::SetOptionsResultCode => "SetOptionsResultCode",

            Self::SetOptionsResult => "SetOptionsResult",

            Self::ChangeTrustResultCode => "ChangeTrustResultCode",

            Self::ChangeTrustResult => "ChangeTrustResult",

            Self::AllowTrustResultCode => "AllowTrustResultCode",

            Self::AllowTrustResult => "AllowTrustResult",

            Self::AccountMergeResultCode => "AccountMergeResultCode",

            Self::AccountMergeResult => "AccountMergeResult",

            Self::InflationResultCode => "InflationResultCode",

            Self::InflationPayout => "InflationPayout",

            Self::InflationResult => "InflationResult",

            Self::ManageDataResultCode => "ManageDataResultCode",

            Self::ManageDataResult => "ManageDataResult",

            Self::BumpSequenceResultCode => "BumpSequenceResultCode",

            Self::BumpSequenceResult => "BumpSequenceResult",

            Self::CreateClaimableBalanceResultCode => "CreateClaimableBalanceResultCode",

            Self::CreateClaimableBalanceResult => "CreateClaimableBalanceResult",

            Self::ClaimClaimableBalanceResultCode => "ClaimClaimableBalanceResultCode",

            Self::ClaimClaimableBalanceResult => "ClaimClaimableBalanceResult",

            Self::BeginSponsoringFutureReservesResultCode => {
                "BeginSponsoringFutureReservesResultCode"
            }

            Self::BeginSponsoringFutureReservesResult => "BeginSponsoringFutureReservesResult",

            Self::EndSponsoringFutureReservesResultCode => "EndSponsoringFutureReservesResultCode",

            Self::EndSponsoringFutureReservesResult => "EndSponsoringFutureReservesResult",

            Self::RevokeSponsorshipResultCode => "RevokeSponsorshipResultCode",

            Self::RevokeSponsorshipResult => "RevokeSponsorshipResult",

            Self::ClawbackResultCode => "ClawbackResultCode",

            Self::ClawbackResult => "ClawbackResult",

            Self::ClawbackClaimableBalanceResultCode => "ClawbackClaimableBalanceResultCode",

            Self::ClawbackClaimableBalanceResult => "ClawbackClaimableBalanceResult",

            Self::SetTrustLineFlagsResultCode => "SetTrustLineFlagsResultCode",

            Self::SetTrustLineFlagsResult => "SetTrustLineFlagsResult",

            Self::LiquidityPoolDepositResultCode => "LiquidityPoolDepositResultCode",

            Self::LiquidityPoolDepositResult => "LiquidityPoolDepositResult",

            Self::LiquidityPoolWithdrawResultCode => "LiquidityPoolWithdrawResultCode",

            Self::LiquidityPoolWithdrawResult => "LiquidityPoolWithdrawResult",

            Self::InvokeHostFunctionResultCode => "InvokeHostFunctionResultCode",

            Self::InvokeHostFunctionResult => "InvokeHostFunctionResult",

            Self::ExtendFootprintTtlResultCode => "ExtendFootprintTtlResultCode",

            Self::ExtendFootprintTtlResult => "ExtendFootprintTtlResult",

            Self::RestoreFootprintResultCode => "RestoreFootprintResultCode",

            Self::RestoreFootprintResult => "RestoreFootprintResult",

            Self::OperationResultCode => "OperationResultCode",

            Self::OperationResult => "OperationResult",

            Self::TransactionResultCode => "TransactionResultCode",

            Self::InnerTransactionResult => "InnerTransactionResult",

            Self::InnerTransactionResultPair => "InnerTransactionResultPair",

            Self::TransactionResult => "TransactionResult",

            Self::Hash => "Hash",

            Self::Uint256 => "Uint256",

            Self::Uint32 => "Uint32",

            Self::Int32 => "Int32",

            Self::Uint64 => "Uint64",

            Self::Int64 => "Int64",

            Self::TimePoint => "TimePoint",

            Self::Duration => "Duration",

            Self::ExtensionPoint => "ExtensionPoint",

            Self::CryptoKeyType => "CryptoKeyType",

            Self::PublicKeyType => "PublicKeyType",

            Self::SignerKeyType => "SignerKeyType",

            Self::PublicKey => "PublicKey",

            Self::SignerKey => "SignerKey",

            Self::Signature => "Signature",

            Self::SignatureHint => "SignatureHint",

            Self::NodeId => "NodeId",

            Self::AccountId => "AccountId",

            Self::ContractId => "ContractId",

            Self::Curve25519Secret => "Curve25519Secret",

            Self::Curve25519Public => "Curve25519Public",

            Self::HmacSha256Key => "HmacSha256Key",

            Self::HmacSha256Mac => "HmacSha256Mac",

            Self::ShortHashSeed => "ShortHashSeed",

            Self::BinaryFuseFilterType => "BinaryFuseFilterType",

            Self::SerializedBinaryFuseFilter => "SerializedBinaryFuseFilter",

            Self::PoolId => "PoolId",

            Self::ClaimableBalanceIdType => "ClaimableBalanceIdType",

            Self::ClaimableBalanceId => "ClaimableBalanceId",
        }
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn variants() -> [TypeVariant; 463] {
        Self::VARIANTS
    }

    #[cfg(feature = "schemars")]
    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub fn json_schema(&self, gen: schemars::gen::SchemaGenerator) -> schemars::schema::RootSchema {
        match self {
            Self::ScpStatementPrepare => gen.into_root_schema_for::<ScpStatementPrepare>(),

            Self::ScpStatementConfirm => gen.into_root_schema_for::<ScpStatementConfirm>(),

            Self::ScpStatementExternalize => gen.into_root_schema_for::<ScpStatementExternalize>(),

            Self::ScpStatementPledges => gen.into_root_schema_for::<ScpStatementPledges>(),

            Self::ScEnvMetaEntryInterfaceVersion => {
                gen.into_root_schema_for::<ScEnvMetaEntryInterfaceVersion>()
            }

            Self::AccountEntryExtensionV2Ext => {
                gen.into_root_schema_for::<AccountEntryExtensionV2Ext>()
            }

            Self::AccountEntryExtensionV1Ext => {
                gen.into_root_schema_for::<AccountEntryExtensionV1Ext>()
            }

            Self::AccountEntryExt => gen.into_root_schema_for::<AccountEntryExt>(),

            Self::TrustLineEntryExtensionV2Ext => {
                gen.into_root_schema_for::<TrustLineEntryExtensionV2Ext>()
            }

            Self::TrustLineEntryV1Ext => gen.into_root_schema_for::<TrustLineEntryV1Ext>(),

            Self::TrustLineEntryV1 => gen.into_root_schema_for::<TrustLineEntryV1>(),

            Self::TrustLineEntryExt => gen.into_root_schema_for::<TrustLineEntryExt>(),

            Self::OfferEntryExt => gen.into_root_schema_for::<OfferEntryExt>(),

            Self::DataEntryExt => gen.into_root_schema_for::<DataEntryExt>(),

            Self::ClaimantV0 => gen.into_root_schema_for::<ClaimantV0>(),

            Self::ClaimableBalanceEntryExtensionV1Ext => {
                gen.into_root_schema_for::<ClaimableBalanceEntryExtensionV1Ext>()
            }

            Self::ClaimableBalanceEntryExt => {
                gen.into_root_schema_for::<ClaimableBalanceEntryExt>()
            }

            Self::LiquidityPoolEntryConstantProduct => {
                gen.into_root_schema_for::<LiquidityPoolEntryConstantProduct>()
            }

            Self::LiquidityPoolEntryBody => gen.into_root_schema_for::<LiquidityPoolEntryBody>(),

            Self::ContractCodeEntryV1 => gen.into_root_schema_for::<ContractCodeEntryV1>(),

            Self::ContractCodeEntryExt => gen.into_root_schema_for::<ContractCodeEntryExt>(),

            Self::LedgerEntryExtensionV1Ext => {
                gen.into_root_schema_for::<LedgerEntryExtensionV1Ext>()
            }

            Self::LedgerEntryData => gen.into_root_schema_for::<LedgerEntryData>(),

            Self::LedgerEntryExt => gen.into_root_schema_for::<LedgerEntryExt>(),

            Self::LedgerKeyAccount => gen.into_root_schema_for::<LedgerKeyAccount>(),

            Self::LedgerKeyTrustLine => gen.into_root_schema_for::<LedgerKeyTrustLine>(),

            Self::LedgerKeyOffer => gen.into_root_schema_for::<LedgerKeyOffer>(),

            Self::LedgerKeyData => gen.into_root_schema_for::<LedgerKeyData>(),

            Self::LedgerKeyClaimableBalance => {
                gen.into_root_schema_for::<LedgerKeyClaimableBalance>()
            }

            Self::LedgerKeyLiquidityPool => gen.into_root_schema_for::<LedgerKeyLiquidityPool>(),

            Self::LedgerKeyContractData => gen.into_root_schema_for::<LedgerKeyContractData>(),

            Self::LedgerKeyContractCode => gen.into_root_schema_for::<LedgerKeyContractCode>(),

            Self::LedgerKeyConfigSetting => gen.into_root_schema_for::<LedgerKeyConfigSetting>(),

            Self::LedgerKeyTtl => gen.into_root_schema_for::<LedgerKeyTtl>(),

            Self::BucketMetadataExt => gen.into_root_schema_for::<BucketMetadataExt>(),

            Self::StellarValueExt => gen.into_root_schema_for::<StellarValueExt>(),

            Self::LedgerHeaderExtensionV1Ext => {
                gen.into_root_schema_for::<LedgerHeaderExtensionV1Ext>()
            }

            Self::LedgerHeaderExt => gen.into_root_schema_for::<LedgerHeaderExt>(),

            Self::TxSetComponentTxsMaybeDiscountedFee => {
                gen.into_root_schema_for::<TxSetComponentTxsMaybeDiscountedFee>()
            }

            Self::TransactionHistoryEntryExt => {
                gen.into_root_schema_for::<TransactionHistoryEntryExt>()
            }

            Self::TransactionHistoryResultEntryExt => {
                gen.into_root_schema_for::<TransactionHistoryResultEntryExt>()
            }

            Self::LedgerHeaderHistoryEntryExt => {
                gen.into_root_schema_for::<LedgerHeaderHistoryEntryExt>()
            }

            Self::ContractEventV0 => gen.into_root_schema_for::<ContractEventV0>(),

            Self::ContractEventBody => gen.into_root_schema_for::<ContractEventBody>(),

            Self::PeerAddressIp => gen.into_root_schema_for::<PeerAddressIp>(),

            Self::AuthenticatedMessageV0 => gen.into_root_schema_for::<AuthenticatedMessageV0>(),

            Self::MuxedAccountMed25519 => gen.into_root_schema_for::<MuxedAccountMed25519>(),

            Self::RevokeSponsorshipOpSigner => {
                gen.into_root_schema_for::<RevokeSponsorshipOpSigner>()
            }

            Self::ContractIdPreimageFromAddress => {
                gen.into_root_schema_for::<ContractIdPreimageFromAddress>()
            }

            Self::OperationBody => gen.into_root_schema_for::<OperationBody>(),

            Self::HashIdPreimageOperationId => {
                gen.into_root_schema_for::<HashIdPreimageOperationId>()
            }

            Self::HashIdPreimageRevokeId => gen.into_root_schema_for::<HashIdPreimageRevokeId>(),

            Self::HashIdPreimageContractId => {
                gen.into_root_schema_for::<HashIdPreimageContractId>()
            }

            Self::HashIdPreimageSorobanAuthorization => {
                gen.into_root_schema_for::<HashIdPreimageSorobanAuthorization>()
            }

            Self::SorobanTransactionDataExt => {
                gen.into_root_schema_for::<SorobanTransactionDataExt>()
            }

            Self::TransactionV0Ext => gen.into_root_schema_for::<TransactionV0Ext>(),

            Self::TransactionExt => gen.into_root_schema_for::<TransactionExt>(),

            Self::FeeBumpTransactionInnerTx => {
                gen.into_root_schema_for::<FeeBumpTransactionInnerTx>()
            }

            Self::FeeBumpTransactionExt => gen.into_root_schema_for::<FeeBumpTransactionExt>(),

            Self::TransactionSignaturePayloadTaggedTransaction => {
                gen.into_root_schema_for::<TransactionSignaturePayloadTaggedTransaction>()
            }

            Self::PathPaymentStrictReceiveResultSuccess => {
                gen.into_root_schema_for::<PathPaymentStrictReceiveResultSuccess>()
            }

            Self::PathPaymentStrictSendResultSuccess => {
                gen.into_root_schema_for::<PathPaymentStrictSendResultSuccess>()
            }

            Self::ManageOfferSuccessResultOffer => {
                gen.into_root_schema_for::<ManageOfferSuccessResultOffer>()
            }

            Self::OperationResultTr => gen.into_root_schema_for::<OperationResultTr>(),

            Self::InnerTransactionResultResult => {
                gen.into_root_schema_for::<InnerTransactionResultResult>()
            }

            Self::InnerTransactionResultExt => {
                gen.into_root_schema_for::<InnerTransactionResultExt>()
            }

            Self::TransactionResultResult => gen.into_root_schema_for::<TransactionResultResult>(),

            Self::TransactionResultExt => gen.into_root_schema_for::<TransactionResultExt>(),

            Self::SignerKeyEd25519SignedPayload => {
                gen.into_root_schema_for::<SignerKeyEd25519SignedPayload>()
            }

            Self::Value => gen.into_root_schema_for::<Value>(),

            Self::ScpBallot => gen.into_root_schema_for::<ScpBallot>(),

            Self::ScpStatementType => gen.into_root_schema_for::<ScpStatementType>(),

            Self::ScpNomination => gen.into_root_schema_for::<ScpNomination>(),

            Self::ScpStatement => gen.into_root_schema_for::<ScpStatement>(),

            Self::ScpEnvelope => gen.into_root_schema_for::<ScpEnvelope>(),

            Self::ScpQuorumSet => gen.into_root_schema_for::<ScpQuorumSet>(),

            Self::ConfigSettingContractExecutionLanesV0 => {
                gen.into_root_schema_for::<ConfigSettingContractExecutionLanesV0>()
            }

            Self::ConfigSettingContractComputeV0 => {
                gen.into_root_schema_for::<ConfigSettingContractComputeV0>()
            }

            Self::ConfigSettingContractParallelComputeV0 => {
                gen.into_root_schema_for::<ConfigSettingContractParallelComputeV0>()
            }

            Self::ConfigSettingContractLedgerCostV0 => {
                gen.into_root_schema_for::<ConfigSettingContractLedgerCostV0>()
            }

            Self::ConfigSettingContractLedgerCostExtV0 => {
                gen.into_root_schema_for::<ConfigSettingContractLedgerCostExtV0>()
            }

            Self::ConfigSettingContractHistoricalDataV0 => {
                gen.into_root_schema_for::<ConfigSettingContractHistoricalDataV0>()
            }

            Self::ConfigSettingContractEventsV0 => {
                gen.into_root_schema_for::<ConfigSettingContractEventsV0>()
            }

            Self::ConfigSettingContractBandwidthV0 => {
                gen.into_root_schema_for::<ConfigSettingContractBandwidthV0>()
            }

            Self::ContractCostType => gen.into_root_schema_for::<ContractCostType>(),

            Self::ContractCostParamEntry => gen.into_root_schema_for::<ContractCostParamEntry>(),

            Self::StateArchivalSettings => gen.into_root_schema_for::<StateArchivalSettings>(),

            Self::EvictionIterator => gen.into_root_schema_for::<EvictionIterator>(),

            Self::ConfigSettingScpTiming => gen.into_root_schema_for::<ConfigSettingScpTiming>(),

            Self::ContractCostParams => gen.into_root_schema_for::<ContractCostParams>(),

            Self::ConfigSettingId => gen.into_root_schema_for::<ConfigSettingId>(),

            Self::ConfigSettingEntry => gen.into_root_schema_for::<ConfigSettingEntry>(),

            Self::ScEnvMetaKind => gen.into_root_schema_for::<ScEnvMetaKind>(),

            Self::ScEnvMetaEntry => gen.into_root_schema_for::<ScEnvMetaEntry>(),

            Self::ScMetaV0 => gen.into_root_schema_for::<ScMetaV0>(),

            Self::ScMetaKind => gen.into_root_schema_for::<ScMetaKind>(),

            Self::ScMetaEntry => gen.into_root_schema_for::<ScMetaEntry>(),

            Self::ScSpecType => gen.into_root_schema_for::<ScSpecType>(),

            Self::ScSpecTypeOption => gen.into_root_schema_for::<ScSpecTypeOption>(),

            Self::ScSpecTypeResult => gen.into_root_schema_for::<ScSpecTypeResult>(),

            Self::ScSpecTypeVec => gen.into_root_schema_for::<ScSpecTypeVec>(),

            Self::ScSpecTypeMap => gen.into_root_schema_for::<ScSpecTypeMap>(),

            Self::ScSpecTypeTuple => gen.into_root_schema_for::<ScSpecTypeTuple>(),

            Self::ScSpecTypeBytesN => gen.into_root_schema_for::<ScSpecTypeBytesN>(),

            Self::ScSpecTypeUdt => gen.into_root_schema_for::<ScSpecTypeUdt>(),

            Self::ScSpecTypeDef => gen.into_root_schema_for::<ScSpecTypeDef>(),

            Self::ScSpecUdtStructFieldV0 => gen.into_root_schema_for::<ScSpecUdtStructFieldV0>(),

            Self::ScSpecUdtStructV0 => gen.into_root_schema_for::<ScSpecUdtStructV0>(),

            Self::ScSpecUdtUnionCaseVoidV0 => {
                gen.into_root_schema_for::<ScSpecUdtUnionCaseVoidV0>()
            }

            Self::ScSpecUdtUnionCaseTupleV0 => {
                gen.into_root_schema_for::<ScSpecUdtUnionCaseTupleV0>()
            }

            Self::ScSpecUdtUnionCaseV0Kind => {
                gen.into_root_schema_for::<ScSpecUdtUnionCaseV0Kind>()
            }

            Self::ScSpecUdtUnionCaseV0 => gen.into_root_schema_for::<ScSpecUdtUnionCaseV0>(),

            Self::ScSpecUdtUnionV0 => gen.into_root_schema_for::<ScSpecUdtUnionV0>(),

            Self::ScSpecUdtEnumCaseV0 => gen.into_root_schema_for::<ScSpecUdtEnumCaseV0>(),

            Self::ScSpecUdtEnumV0 => gen.into_root_schema_for::<ScSpecUdtEnumV0>(),

            Self::ScSpecUdtErrorEnumCaseV0 => {
                gen.into_root_schema_for::<ScSpecUdtErrorEnumCaseV0>()
            }

            Self::ScSpecUdtErrorEnumV0 => gen.into_root_schema_for::<ScSpecUdtErrorEnumV0>(),

            Self::ScSpecFunctionInputV0 => gen.into_root_schema_for::<ScSpecFunctionInputV0>(),

            Self::ScSpecFunctionV0 => gen.into_root_schema_for::<ScSpecFunctionV0>(),

            Self::ScSpecEventParamLocationV0 => {
                gen.into_root_schema_for::<ScSpecEventParamLocationV0>()
            }

            Self::ScSpecEventParamV0 => gen.into_root_schema_for::<ScSpecEventParamV0>(),

            Self::ScSpecEventDataFormat => gen.into_root_schema_for::<ScSpecEventDataFormat>(),

            Self::ScSpecEventV0 => gen.into_root_schema_for::<ScSpecEventV0>(),

            Self::ScSpecEntryKind => gen.into_root_schema_for::<ScSpecEntryKind>(),

            Self::ScSpecEntry => gen.into_root_schema_for::<ScSpecEntry>(),

            Self::ScValType => gen.into_root_schema_for::<ScValType>(),

            Self::ScErrorType => gen.into_root_schema_for::<ScErrorType>(),

            Self::ScErrorCode => gen.into_root_schema_for::<ScErrorCode>(),

            Self::ScError => gen.into_root_schema_for::<ScError>(),

            Self::UInt128Parts => gen.into_root_schema_for::<UInt128Parts>(),

            Self::Int128Parts => gen.into_root_schema_for::<Int128Parts>(),

            Self::UInt256Parts => gen.into_root_schema_for::<UInt256Parts>(),

            Self::Int256Parts => gen.into_root_schema_for::<Int256Parts>(),

            Self::ContractExecutableType => gen.into_root_schema_for::<ContractExecutableType>(),

            Self::ContractExecutable => gen.into_root_schema_for::<ContractExecutable>(),

            Self::ScAddressType => gen.into_root_schema_for::<ScAddressType>(),

            Self::MuxedEd25519Account => gen.into_root_schema_for::<MuxedEd25519Account>(),

            Self::ScAddress => gen.into_root_schema_for::<ScAddress>(),

            Self::ScVec => gen.into_root_schema_for::<ScVec>(),

            Self::ScMap => gen.into_root_schema_for::<ScMap>(),

            Self::ScBytes => gen.into_root_schema_for::<ScBytes>(),

            Self::ScString => gen.into_root_schema_for::<ScString>(),

            Self::ScSymbol => gen.into_root_schema_for::<ScSymbol>(),

            Self::ScNonceKey => gen.into_root_schema_for::<ScNonceKey>(),

            Self::ScContractInstance => gen.into_root_schema_for::<ScContractInstance>(),

            Self::ScVal => gen.into_root_schema_for::<ScVal>(),

            Self::ScMapEntry => gen.into_root_schema_for::<ScMapEntry>(),

            Self::LedgerCloseMetaBatch => gen.into_root_schema_for::<LedgerCloseMetaBatch>(),

            Self::StoredTransactionSet => gen.into_root_schema_for::<StoredTransactionSet>(),

            Self::StoredDebugTransactionSet => {
                gen.into_root_schema_for::<StoredDebugTransactionSet>()
            }

            Self::PersistedScpStateV0 => gen.into_root_schema_for::<PersistedScpStateV0>(),

            Self::PersistedScpStateV1 => gen.into_root_schema_for::<PersistedScpStateV1>(),

            Self::PersistedScpState => gen.into_root_schema_for::<PersistedScpState>(),

            Self::Thresholds => gen.into_root_schema_for::<Thresholds>(),

            Self::String32 => gen.into_root_schema_for::<String32>(),

            Self::String64 => gen.into_root_schema_for::<String64>(),

            Self::SequenceNumber => gen.into_root_schema_for::<SequenceNumber>(),

            Self::DataValue => gen.into_root_schema_for::<DataValue>(),

            Self::AssetCode4 => gen.into_root_schema_for::<AssetCode4>(),

            Self::AssetCode12 => gen.into_root_schema_for::<AssetCode12>(),

            Self::AssetType => gen.into_root_schema_for::<AssetType>(),

            Self::AssetCode => gen.into_root_schema_for::<AssetCode>(),

            Self::AlphaNum4 => gen.into_root_schema_for::<AlphaNum4>(),

            Self::AlphaNum12 => gen.into_root_schema_for::<AlphaNum12>(),

            Self::Asset => gen.into_root_schema_for::<Asset>(),

            Self::Price => gen.into_root_schema_for::<Price>(),

            Self::Liabilities => gen.into_root_schema_for::<Liabilities>(),

            Self::ThresholdIndexes => gen.into_root_schema_for::<ThresholdIndexes>(),

            Self::LedgerEntryType => gen.into_root_schema_for::<LedgerEntryType>(),

            Self::Signer => gen.into_root_schema_for::<Signer>(),

            Self::AccountFlags => gen.into_root_schema_for::<AccountFlags>(),

            Self::SponsorshipDescriptor => gen.into_root_schema_for::<SponsorshipDescriptor>(),

            Self::AccountEntryExtensionV3 => gen.into_root_schema_for::<AccountEntryExtensionV3>(),

            Self::AccountEntryExtensionV2 => gen.into_root_schema_for::<AccountEntryExtensionV2>(),

            Self::AccountEntryExtensionV1 => gen.into_root_schema_for::<AccountEntryExtensionV1>(),

            Self::AccountEntry => gen.into_root_schema_for::<AccountEntry>(),

            Self::TrustLineFlags => gen.into_root_schema_for::<TrustLineFlags>(),

            Self::LiquidityPoolType => gen.into_root_schema_for::<LiquidityPoolType>(),

            Self::TrustLineAsset => gen.into_root_schema_for::<TrustLineAsset>(),

            Self::TrustLineEntryExtensionV2 => {
                gen.into_root_schema_for::<TrustLineEntryExtensionV2>()
            }

            Self::TrustLineEntry => gen.into_root_schema_for::<TrustLineEntry>(),

            Self::OfferEntryFlags => gen.into_root_schema_for::<OfferEntryFlags>(),

            Self::OfferEntry => gen.into_root_schema_for::<OfferEntry>(),

            Self::DataEntry => gen.into_root_schema_for::<DataEntry>(),

            Self::ClaimPredicateType => gen.into_root_schema_for::<ClaimPredicateType>(),

            Self::ClaimPredicate => gen.into_root_schema_for::<ClaimPredicate>(),

            Self::ClaimantType => gen.into_root_schema_for::<ClaimantType>(),

            Self::Claimant => gen.into_root_schema_for::<Claimant>(),

            Self::ClaimableBalanceFlags => gen.into_root_schema_for::<ClaimableBalanceFlags>(),

            Self::ClaimableBalanceEntryExtensionV1 => {
                gen.into_root_schema_for::<ClaimableBalanceEntryExtensionV1>()
            }

            Self::ClaimableBalanceEntry => gen.into_root_schema_for::<ClaimableBalanceEntry>(),

            Self::LiquidityPoolConstantProductParameters => {
                gen.into_root_schema_for::<LiquidityPoolConstantProductParameters>()
            }

            Self::LiquidityPoolEntry => gen.into_root_schema_for::<LiquidityPoolEntry>(),

            Self::ContractDataDurability => gen.into_root_schema_for::<ContractDataDurability>(),

            Self::ContractDataEntry => gen.into_root_schema_for::<ContractDataEntry>(),

            Self::ContractCodeCostInputs => gen.into_root_schema_for::<ContractCodeCostInputs>(),

            Self::ContractCodeEntry => gen.into_root_schema_for::<ContractCodeEntry>(),

            Self::TtlEntry => gen.into_root_schema_for::<TtlEntry>(),

            Self::LedgerEntryExtensionV1 => gen.into_root_schema_for::<LedgerEntryExtensionV1>(),

            Self::LedgerEntry => gen.into_root_schema_for::<LedgerEntry>(),

            Self::LedgerKey => gen.into_root_schema_for::<LedgerKey>(),

            Self::EnvelopeType => gen.into_root_schema_for::<EnvelopeType>(),

            Self::BucketListType => gen.into_root_schema_for::<BucketListType>(),

            Self::BucketEntryType => gen.into_root_schema_for::<BucketEntryType>(),

            Self::HotArchiveBucketEntryType => {
                gen.into_root_schema_for::<HotArchiveBucketEntryType>()
            }

            Self::BucketMetadata => gen.into_root_schema_for::<BucketMetadata>(),

            Self::BucketEntry => gen.into_root_schema_for::<BucketEntry>(),

            Self::HotArchiveBucketEntry => gen.into_root_schema_for::<HotArchiveBucketEntry>(),

            Self::UpgradeType => gen.into_root_schema_for::<UpgradeType>(),

            Self::StellarValueType => gen.into_root_schema_for::<StellarValueType>(),

            Self::LedgerCloseValueSignature => {
                gen.into_root_schema_for::<LedgerCloseValueSignature>()
            }

            Self::StellarValue => gen.into_root_schema_for::<StellarValue>(),

            Self::LedgerHeaderFlags => gen.into_root_schema_for::<LedgerHeaderFlags>(),

            Self::LedgerHeaderExtensionV1 => gen.into_root_schema_for::<LedgerHeaderExtensionV1>(),

            Self::LedgerHeader => gen.into_root_schema_for::<LedgerHeader>(),

            Self::LedgerUpgradeType => gen.into_root_schema_for::<LedgerUpgradeType>(),

            Self::ConfigUpgradeSetKey => gen.into_root_schema_for::<ConfigUpgradeSetKey>(),

            Self::LedgerUpgrade => gen.into_root_schema_for::<LedgerUpgrade>(),

            Self::ConfigUpgradeSet => gen.into_root_schema_for::<ConfigUpgradeSet>(),

            Self::TxSetComponentType => gen.into_root_schema_for::<TxSetComponentType>(),

            Self::DependentTxCluster => gen.into_root_schema_for::<DependentTxCluster>(),

            Self::ParallelTxExecutionStage => {
                gen.into_root_schema_for::<ParallelTxExecutionStage>()
            }

            Self::ParallelTxsComponent => gen.into_root_schema_for::<ParallelTxsComponent>(),

            Self::TxSetComponent => gen.into_root_schema_for::<TxSetComponent>(),

            Self::TransactionPhase => gen.into_root_schema_for::<TransactionPhase>(),

            Self::TransactionSet => gen.into_root_schema_for::<TransactionSet>(),

            Self::TransactionSetV1 => gen.into_root_schema_for::<TransactionSetV1>(),

            Self::GeneralizedTransactionSet => {
                gen.into_root_schema_for::<GeneralizedTransactionSet>()
            }

            Self::TransactionResultPair => gen.into_root_schema_for::<TransactionResultPair>(),

            Self::TransactionResultSet => gen.into_root_schema_for::<TransactionResultSet>(),

            Self::TransactionHistoryEntry => gen.into_root_schema_for::<TransactionHistoryEntry>(),

            Self::TransactionHistoryResultEntry => {
                gen.into_root_schema_for::<TransactionHistoryResultEntry>()
            }

            Self::LedgerHeaderHistoryEntry => {
                gen.into_root_schema_for::<LedgerHeaderHistoryEntry>()
            }

            Self::LedgerScpMessages => gen.into_root_schema_for::<LedgerScpMessages>(),

            Self::ScpHistoryEntryV0 => gen.into_root_schema_for::<ScpHistoryEntryV0>(),

            Self::ScpHistoryEntry => gen.into_root_schema_for::<ScpHistoryEntry>(),

            Self::LedgerEntryChangeType => gen.into_root_schema_for::<LedgerEntryChangeType>(),

            Self::LedgerEntryChange => gen.into_root_schema_for::<LedgerEntryChange>(),

            Self::LedgerEntryChanges => gen.into_root_schema_for::<LedgerEntryChanges>(),

            Self::OperationMeta => gen.into_root_schema_for::<OperationMeta>(),

            Self::TransactionMetaV1 => gen.into_root_schema_for::<TransactionMetaV1>(),

            Self::TransactionMetaV2 => gen.into_root_schema_for::<TransactionMetaV2>(),

            Self::ContractEventType => gen.into_root_schema_for::<ContractEventType>(),

            Self::ContractEvent => gen.into_root_schema_for::<ContractEvent>(),

            Self::DiagnosticEvent => gen.into_root_schema_for::<DiagnosticEvent>(),

            Self::SorobanTransactionMetaExtV1 => {
                gen.into_root_schema_for::<SorobanTransactionMetaExtV1>()
            }

            Self::SorobanTransactionMetaExt => {
                gen.into_root_schema_for::<SorobanTransactionMetaExt>()
            }

            Self::SorobanTransactionMeta => gen.into_root_schema_for::<SorobanTransactionMeta>(),

            Self::TransactionMetaV3 => gen.into_root_schema_for::<TransactionMetaV3>(),

            Self::OperationMetaV2 => gen.into_root_schema_for::<OperationMetaV2>(),

            Self::SorobanTransactionMetaV2 => {
                gen.into_root_schema_for::<SorobanTransactionMetaV2>()
            }

            Self::TransactionEventStage => gen.into_root_schema_for::<TransactionEventStage>(),

            Self::TransactionEvent => gen.into_root_schema_for::<TransactionEvent>(),

            Self::TransactionMetaV4 => gen.into_root_schema_for::<TransactionMetaV4>(),

            Self::InvokeHostFunctionSuccessPreImage => {
                gen.into_root_schema_for::<InvokeHostFunctionSuccessPreImage>()
            }

            Self::TransactionMeta => gen.into_root_schema_for::<TransactionMeta>(),

            Self::TransactionResultMeta => gen.into_root_schema_for::<TransactionResultMeta>(),

            Self::TransactionResultMetaV1 => gen.into_root_schema_for::<TransactionResultMetaV1>(),

            Self::UpgradeEntryMeta => gen.into_root_schema_for::<UpgradeEntryMeta>(),

            Self::LedgerCloseMetaV0 => gen.into_root_schema_for::<LedgerCloseMetaV0>(),

            Self::LedgerCloseMetaExtV1 => gen.into_root_schema_for::<LedgerCloseMetaExtV1>(),

            Self::LedgerCloseMetaExt => gen.into_root_schema_for::<LedgerCloseMetaExt>(),

            Self::LedgerCloseMetaV1 => gen.into_root_schema_for::<LedgerCloseMetaV1>(),

            Self::LedgerCloseMetaV2 => gen.into_root_schema_for::<LedgerCloseMetaV2>(),

            Self::LedgerCloseMeta => gen.into_root_schema_for::<LedgerCloseMeta>(),

            Self::ErrorCode => gen.into_root_schema_for::<ErrorCode>(),

            Self::SError => gen.into_root_schema_for::<SError>(),

            Self::SendMore => gen.into_root_schema_for::<SendMore>(),

            Self::SendMoreExtended => gen.into_root_schema_for::<SendMoreExtended>(),

            Self::AuthCert => gen.into_root_schema_for::<AuthCert>(),

            Self::Hello => gen.into_root_schema_for::<Hello>(),

            Self::Auth => gen.into_root_schema_for::<Auth>(),

            Self::IpAddrType => gen.into_root_schema_for::<IpAddrType>(),

            Self::PeerAddress => gen.into_root_schema_for::<PeerAddress>(),

            Self::MessageType => gen.into_root_schema_for::<MessageType>(),

            Self::DontHave => gen.into_root_schema_for::<DontHave>(),

            Self::SurveyMessageCommandType => {
                gen.into_root_schema_for::<SurveyMessageCommandType>()
            }

            Self::SurveyMessageResponseType => {
                gen.into_root_schema_for::<SurveyMessageResponseType>()
            }

            Self::TimeSlicedSurveyStartCollectingMessage => {
                gen.into_root_schema_for::<TimeSlicedSurveyStartCollectingMessage>()
            }

            Self::SignedTimeSlicedSurveyStartCollectingMessage => {
                gen.into_root_schema_for::<SignedTimeSlicedSurveyStartCollectingMessage>()
            }

            Self::TimeSlicedSurveyStopCollectingMessage => {
                gen.into_root_schema_for::<TimeSlicedSurveyStopCollectingMessage>()
            }

            Self::SignedTimeSlicedSurveyStopCollectingMessage => {
                gen.into_root_schema_for::<SignedTimeSlicedSurveyStopCollectingMessage>()
            }

            Self::SurveyRequestMessage => gen.into_root_schema_for::<SurveyRequestMessage>(),

            Self::TimeSlicedSurveyRequestMessage => {
                gen.into_root_schema_for::<TimeSlicedSurveyRequestMessage>()
            }

            Self::SignedTimeSlicedSurveyRequestMessage => {
                gen.into_root_schema_for::<SignedTimeSlicedSurveyRequestMessage>()
            }

            Self::EncryptedBody => gen.into_root_schema_for::<EncryptedBody>(),

            Self::SurveyResponseMessage => gen.into_root_schema_for::<SurveyResponseMessage>(),

            Self::TimeSlicedSurveyResponseMessage => {
                gen.into_root_schema_for::<TimeSlicedSurveyResponseMessage>()
            }

            Self::SignedTimeSlicedSurveyResponseMessage => {
                gen.into_root_schema_for::<SignedTimeSlicedSurveyResponseMessage>()
            }

            Self::PeerStats => gen.into_root_schema_for::<PeerStats>(),

            Self::TimeSlicedNodeData => gen.into_root_schema_for::<TimeSlicedNodeData>(),

            Self::TimeSlicedPeerData => gen.into_root_schema_for::<TimeSlicedPeerData>(),

            Self::TimeSlicedPeerDataList => gen.into_root_schema_for::<TimeSlicedPeerDataList>(),

            Self::TopologyResponseBodyV2 => gen.into_root_schema_for::<TopologyResponseBodyV2>(),

            Self::SurveyResponseBody => gen.into_root_schema_for::<SurveyResponseBody>(),

            Self::TxAdvertVector => gen.into_root_schema_for::<TxAdvertVector>(),

            Self::FloodAdvert => gen.into_root_schema_for::<FloodAdvert>(),

            Self::TxDemandVector => gen.into_root_schema_for::<TxDemandVector>(),

            Self::FloodDemand => gen.into_root_schema_for::<FloodDemand>(),

            Self::StellarMessage => gen.into_root_schema_for::<StellarMessage>(),

            Self::AuthenticatedMessage => gen.into_root_schema_for::<AuthenticatedMessage>(),

            Self::LiquidityPoolParameters => gen.into_root_schema_for::<LiquidityPoolParameters>(),

            Self::MuxedAccount => gen.into_root_schema_for::<MuxedAccount>(),

            Self::DecoratedSignature => gen.into_root_schema_for::<DecoratedSignature>(),

            Self::OperationType => gen.into_root_schema_for::<OperationType>(),

            Self::CreateAccountOp => gen.into_root_schema_for::<CreateAccountOp>(),

            Self::PaymentOp => gen.into_root_schema_for::<PaymentOp>(),

            Self::PathPaymentStrictReceiveOp => {
                gen.into_root_schema_for::<PathPaymentStrictReceiveOp>()
            }

            Self::PathPaymentStrictSendOp => gen.into_root_schema_for::<PathPaymentStrictSendOp>(),

            Self::ManageSellOfferOp => gen.into_root_schema_for::<ManageSellOfferOp>(),

            Self::ManageBuyOfferOp => gen.into_root_schema_for::<ManageBuyOfferOp>(),

            Self::CreatePassiveSellOfferOp => {
                gen.into_root_schema_for::<CreatePassiveSellOfferOp>()
            }

            Self::SetOptionsOp => gen.into_root_schema_for::<SetOptionsOp>(),

            Self::ChangeTrustAsset => gen.into_root_schema_for::<ChangeTrustAsset>(),

            Self::ChangeTrustOp => gen.into_root_schema_for::<ChangeTrustOp>(),

            Self::AllowTrustOp => gen.into_root_schema_for::<AllowTrustOp>(),

            Self::ManageDataOp => gen.into_root_schema_for::<ManageDataOp>(),

            Self::BumpSequenceOp => gen.into_root_schema_for::<BumpSequenceOp>(),

            Self::CreateClaimableBalanceOp => {
                gen.into_root_schema_for::<CreateClaimableBalanceOp>()
            }

            Self::ClaimClaimableBalanceOp => gen.into_root_schema_for::<ClaimClaimableBalanceOp>(),

            Self::BeginSponsoringFutureReservesOp => {
                gen.into_root_schema_for::<BeginSponsoringFutureReservesOp>()
            }

            Self::RevokeSponsorshipType => gen.into_root_schema_for::<RevokeSponsorshipType>(),

            Self::RevokeSponsorshipOp => gen.into_root_schema_for::<RevokeSponsorshipOp>(),

            Self::ClawbackOp => gen.into_root_schema_for::<ClawbackOp>(),

            Self::ClawbackClaimableBalanceOp => {
                gen.into_root_schema_for::<ClawbackClaimableBalanceOp>()
            }

            Self::SetTrustLineFlagsOp => gen.into_root_schema_for::<SetTrustLineFlagsOp>(),

            Self::LiquidityPoolDepositOp => gen.into_root_schema_for::<LiquidityPoolDepositOp>(),

            Self::LiquidityPoolWithdrawOp => gen.into_root_schema_for::<LiquidityPoolWithdrawOp>(),

            Self::HostFunctionType => gen.into_root_schema_for::<HostFunctionType>(),

            Self::ContractIdPreimageType => gen.into_root_schema_for::<ContractIdPreimageType>(),

            Self::ContractIdPreimage => gen.into_root_schema_for::<ContractIdPreimage>(),

            Self::CreateContractArgs => gen.into_root_schema_for::<CreateContractArgs>(),

            Self::CreateContractArgsV2 => gen.into_root_schema_for::<CreateContractArgsV2>(),

            Self::InvokeContractArgs => gen.into_root_schema_for::<InvokeContractArgs>(),

            Self::HostFunction => gen.into_root_schema_for::<HostFunction>(),

            Self::SorobanAuthorizedFunctionType => {
                gen.into_root_schema_for::<SorobanAuthorizedFunctionType>()
            }

            Self::SorobanAuthorizedFunction => {
                gen.into_root_schema_for::<SorobanAuthorizedFunction>()
            }

            Self::SorobanAuthorizedInvocation => {
                gen.into_root_schema_for::<SorobanAuthorizedInvocation>()
            }

            Self::SorobanAddressCredentials => {
                gen.into_root_schema_for::<SorobanAddressCredentials>()
            }

            Self::SorobanCredentialsType => gen.into_root_schema_for::<SorobanCredentialsType>(),

            Self::SorobanCredentials => gen.into_root_schema_for::<SorobanCredentials>(),

            Self::SorobanAuthorizationEntry => {
                gen.into_root_schema_for::<SorobanAuthorizationEntry>()
            }

            Self::SorobanAuthorizationEntries => {
                gen.into_root_schema_for::<SorobanAuthorizationEntries>()
            }

            Self::InvokeHostFunctionOp => gen.into_root_schema_for::<InvokeHostFunctionOp>(),

            Self::ExtendFootprintTtlOp => gen.into_root_schema_for::<ExtendFootprintTtlOp>(),

            Self::RestoreFootprintOp => gen.into_root_schema_for::<RestoreFootprintOp>(),

            Self::Operation => gen.into_root_schema_for::<Operation>(),

            Self::HashIdPreimage => gen.into_root_schema_for::<HashIdPreimage>(),

            Self::MemoType => gen.into_root_schema_for::<MemoType>(),

            Self::Memo => gen.into_root_schema_for::<Memo>(),

            Self::TimeBounds => gen.into_root_schema_for::<TimeBounds>(),

            Self::LedgerBounds => gen.into_root_schema_for::<LedgerBounds>(),

            Self::PreconditionsV2 => gen.into_root_schema_for::<PreconditionsV2>(),

            Self::PreconditionType => gen.into_root_schema_for::<PreconditionType>(),

            Self::Preconditions => gen.into_root_schema_for::<Preconditions>(),

            Self::LedgerFootprint => gen.into_root_schema_for::<LedgerFootprint>(),

            Self::SorobanResources => gen.into_root_schema_for::<SorobanResources>(),

            Self::SorobanResourcesExtV0 => gen.into_root_schema_for::<SorobanResourcesExtV0>(),

            Self::SorobanTransactionData => gen.into_root_schema_for::<SorobanTransactionData>(),

            Self::TransactionV0 => gen.into_root_schema_for::<TransactionV0>(),

            Self::TransactionV0Envelope => gen.into_root_schema_for::<TransactionV0Envelope>(),

            Self::Transaction => gen.into_root_schema_for::<Transaction>(),

            Self::TransactionV1Envelope => gen.into_root_schema_for::<TransactionV1Envelope>(),

            Self::FeeBumpTransaction => gen.into_root_schema_for::<FeeBumpTransaction>(),

            Self::FeeBumpTransactionEnvelope => {
                gen.into_root_schema_for::<FeeBumpTransactionEnvelope>()
            }

            Self::TransactionEnvelope => gen.into_root_schema_for::<TransactionEnvelope>(),

            Self::TransactionSignaturePayload => {
                gen.into_root_schema_for::<TransactionSignaturePayload>()
            }

            Self::ClaimAtomType => gen.into_root_schema_for::<ClaimAtomType>(),

            Self::ClaimOfferAtomV0 => gen.into_root_schema_for::<ClaimOfferAtomV0>(),

            Self::ClaimOfferAtom => gen.into_root_schema_for::<ClaimOfferAtom>(),

            Self::ClaimLiquidityAtom => gen.into_root_schema_for::<ClaimLiquidityAtom>(),

            Self::ClaimAtom => gen.into_root_schema_for::<ClaimAtom>(),

            Self::CreateAccountResultCode => gen.into_root_schema_for::<CreateAccountResultCode>(),

            Self::CreateAccountResult => gen.into_root_schema_for::<CreateAccountResult>(),

            Self::PaymentResultCode => gen.into_root_schema_for::<PaymentResultCode>(),

            Self::PaymentResult => gen.into_root_schema_for::<PaymentResult>(),

            Self::PathPaymentStrictReceiveResultCode => {
                gen.into_root_schema_for::<PathPaymentStrictReceiveResultCode>()
            }

            Self::SimplePaymentResult => gen.into_root_schema_for::<SimplePaymentResult>(),

            Self::PathPaymentStrictReceiveResult => {
                gen.into_root_schema_for::<PathPaymentStrictReceiveResult>()
            }

            Self::PathPaymentStrictSendResultCode => {
                gen.into_root_schema_for::<PathPaymentStrictSendResultCode>()
            }

            Self::PathPaymentStrictSendResult => {
                gen.into_root_schema_for::<PathPaymentStrictSendResult>()
            }

            Self::ManageSellOfferResultCode => {
                gen.into_root_schema_for::<ManageSellOfferResultCode>()
            }

            Self::ManageOfferEffect => gen.into_root_schema_for::<ManageOfferEffect>(),

            Self::ManageOfferSuccessResult => {
                gen.into_root_schema_for::<ManageOfferSuccessResult>()
            }

            Self::ManageSellOfferResult => gen.into_root_schema_for::<ManageSellOfferResult>(),

            Self::ManageBuyOfferResultCode => {
                gen.into_root_schema_for::<ManageBuyOfferResultCode>()
            }

            Self::ManageBuyOfferResult => gen.into_root_schema_for::<ManageBuyOfferResult>(),

            Self::SetOptionsResultCode => gen.into_root_schema_for::<SetOptionsResultCode>(),

            Self::SetOptionsResult => gen.into_root_schema_for::<SetOptionsResult>(),

            Self::ChangeTrustResultCode => gen.into_root_schema_for::<ChangeTrustResultCode>(),

            Self::ChangeTrustResult => gen.into_root_schema_for::<ChangeTrustResult>(),

            Self::AllowTrustResultCode => gen.into_root_schema_for::<AllowTrustResultCode>(),

            Self::AllowTrustResult => gen.into_root_schema_for::<AllowTrustResult>(),

            Self::AccountMergeResultCode => gen.into_root_schema_for::<AccountMergeResultCode>(),

            Self::AccountMergeResult => gen.into_root_schema_for::<AccountMergeResult>(),

            Self::InflationResultCode => gen.into_root_schema_for::<InflationResultCode>(),

            Self::InflationPayout => gen.into_root_schema_for::<InflationPayout>(),

            Self::InflationResult => gen.into_root_schema_for::<InflationResult>(),

            Self::ManageDataResultCode => gen.into_root_schema_for::<ManageDataResultCode>(),

            Self::ManageDataResult => gen.into_root_schema_for::<ManageDataResult>(),

            Self::BumpSequenceResultCode => gen.into_root_schema_for::<BumpSequenceResultCode>(),

            Self::BumpSequenceResult => gen.into_root_schema_for::<BumpSequenceResult>(),

            Self::CreateClaimableBalanceResultCode => {
                gen.into_root_schema_for::<CreateClaimableBalanceResultCode>()
            }

            Self::CreateClaimableBalanceResult => {
                gen.into_root_schema_for::<CreateClaimableBalanceResult>()
            }

            Self::ClaimClaimableBalanceResultCode => {
                gen.into_root_schema_for::<ClaimClaimableBalanceResultCode>()
            }

            Self::ClaimClaimableBalanceResult => {
                gen.into_root_schema_for::<ClaimClaimableBalanceResult>()
            }

            Self::BeginSponsoringFutureReservesResultCode => {
                gen.into_root_schema_for::<BeginSponsoringFutureReservesResultCode>()
            }

            Self::BeginSponsoringFutureReservesResult => {
                gen.into_root_schema_for::<BeginSponsoringFutureReservesResult>()
            }

            Self::EndSponsoringFutureReservesResultCode => {
                gen.into_root_schema_for::<EndSponsoringFutureReservesResultCode>()
            }

            Self::EndSponsoringFutureReservesResult => {
                gen.into_root_schema_for::<EndSponsoringFutureReservesResult>()
            }

            Self::RevokeSponsorshipResultCode => {
                gen.into_root_schema_for::<RevokeSponsorshipResultCode>()
            }

            Self::RevokeSponsorshipResult => gen.into_root_schema_for::<RevokeSponsorshipResult>(),

            Self::ClawbackResultCode => gen.into_root_schema_for::<ClawbackResultCode>(),

            Self::ClawbackResult => gen.into_root_schema_for::<ClawbackResult>(),

            Self::ClawbackClaimableBalanceResultCode => {
                gen.into_root_schema_for::<ClawbackClaimableBalanceResultCode>()
            }

            Self::ClawbackClaimableBalanceResult => {
                gen.into_root_schema_for::<ClawbackClaimableBalanceResult>()
            }

            Self::SetTrustLineFlagsResultCode => {
                gen.into_root_schema_for::<SetTrustLineFlagsResultCode>()
            }

            Self::SetTrustLineFlagsResult => gen.into_root_schema_for::<SetTrustLineFlagsResult>(),

            Self::LiquidityPoolDepositResultCode => {
                gen.into_root_schema_for::<LiquidityPoolDepositResultCode>()
            }

            Self::LiquidityPoolDepositResult => {
                gen.into_root_schema_for::<LiquidityPoolDepositResult>()
            }

            Self::LiquidityPoolWithdrawResultCode => {
                gen.into_root_schema_for::<LiquidityPoolWithdrawResultCode>()
            }

            Self::LiquidityPoolWithdrawResult => {
                gen.into_root_schema_for::<LiquidityPoolWithdrawResult>()
            }

            Self::InvokeHostFunctionResultCode => {
                gen.into_root_schema_for::<InvokeHostFunctionResultCode>()
            }

            Self::InvokeHostFunctionResult => {
                gen.into_root_schema_for::<InvokeHostFunctionResult>()
            }

            Self::ExtendFootprintTtlResultCode => {
                gen.into_root_schema_for::<ExtendFootprintTtlResultCode>()
            }

            Self::ExtendFootprintTtlResult => {
                gen.into_root_schema_for::<ExtendFootprintTtlResult>()
            }

            Self::RestoreFootprintResultCode => {
                gen.into_root_schema_for::<RestoreFootprintResultCode>()
            }

            Self::RestoreFootprintResult => gen.into_root_schema_for::<RestoreFootprintResult>(),

            Self::OperationResultCode => gen.into_root_schema_for::<OperationResultCode>(),

            Self::OperationResult => gen.into_root_schema_for::<OperationResult>(),

            Self::TransactionResultCode => gen.into_root_schema_for::<TransactionResultCode>(),

            Self::InnerTransactionResult => gen.into_root_schema_for::<InnerTransactionResult>(),

            Self::InnerTransactionResultPair => {
                gen.into_root_schema_for::<InnerTransactionResultPair>()
            }

            Self::TransactionResult => gen.into_root_schema_for::<TransactionResult>(),

            Self::Hash => gen.into_root_schema_for::<Hash>(),

            Self::Uint256 => gen.into_root_schema_for::<Uint256>(),

            Self::Uint32 => gen.into_root_schema_for::<Uint32>(),

            Self::Int32 => gen.into_root_schema_for::<Int32>(),

            Self::Uint64 => gen.into_root_schema_for::<Uint64>(),

            Self::Int64 => gen.into_root_schema_for::<Int64>(),

            Self::TimePoint => gen.into_root_schema_for::<TimePoint>(),

            Self::Duration => gen.into_root_schema_for::<Duration>(),

            Self::ExtensionPoint => gen.into_root_schema_for::<ExtensionPoint>(),

            Self::CryptoKeyType => gen.into_root_schema_for::<CryptoKeyType>(),

            Self::PublicKeyType => gen.into_root_schema_for::<PublicKeyType>(),

            Self::SignerKeyType => gen.into_root_schema_for::<SignerKeyType>(),

            Self::PublicKey => gen.into_root_schema_for::<PublicKey>(),

            Self::SignerKey => gen.into_root_schema_for::<SignerKey>(),

            Self::Signature => gen.into_root_schema_for::<Signature>(),

            Self::SignatureHint => gen.into_root_schema_for::<SignatureHint>(),

            Self::NodeId => gen.into_root_schema_for::<NodeId>(),

            Self::AccountId => gen.into_root_schema_for::<AccountId>(),

            Self::ContractId => gen.into_root_schema_for::<ContractId>(),

            Self::Curve25519Secret => gen.into_root_schema_for::<Curve25519Secret>(),

            Self::Curve25519Public => gen.into_root_schema_for::<Curve25519Public>(),

            Self::HmacSha256Key => gen.into_root_schema_for::<HmacSha256Key>(),

            Self::HmacSha256Mac => gen.into_root_schema_for::<HmacSha256Mac>(),

            Self::ShortHashSeed => gen.into_root_schema_for::<ShortHashSeed>(),

            Self::BinaryFuseFilterType => gen.into_root_schema_for::<BinaryFuseFilterType>(),

            Self::SerializedBinaryFuseFilter => {
                gen.into_root_schema_for::<SerializedBinaryFuseFilter>()
            }

            Self::PoolId => gen.into_root_schema_for::<PoolId>(),

            Self::ClaimableBalanceIdType => gen.into_root_schema_for::<ClaimableBalanceIdType>(),

            Self::ClaimableBalanceId => gen.into_root_schema_for::<ClaimableBalanceId>(),
        }
    }
}

impl Name for TypeVariant {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TypeVariant> for TypeVariant {
    fn variants() -> slice::Iter<'static, TypeVariant> {
        Self::VARIANTS.iter()
    }
}

impl core::str::FromStr for TypeVariant {
    type Err = Error;
    #[allow(clippy::too_many_lines)]
    fn from_str(s: &str) -> Result<Self, Error> {
        match s {
            "ScpStatementPrepare" => Ok(Self::ScpStatementPrepare),

            "ScpStatementConfirm" => Ok(Self::ScpStatementConfirm),

            "ScpStatementExternalize" => Ok(Self::ScpStatementExternalize),

            "ScpStatementPledges" => Ok(Self::ScpStatementPledges),

            "ScEnvMetaEntryInterfaceVersion" => Ok(Self::ScEnvMetaEntryInterfaceVersion),

            "AccountEntryExtensionV2Ext" => Ok(Self::AccountEntryExtensionV2Ext),

            "AccountEntryExtensionV1Ext" => Ok(Self::AccountEntryExtensionV1Ext),

            "AccountEntryExt" => Ok(Self::AccountEntryExt),

            "TrustLineEntryExtensionV2Ext" => Ok(Self::TrustLineEntryExtensionV2Ext),

            "TrustLineEntryV1Ext" => Ok(Self::TrustLineEntryV1Ext),

            "TrustLineEntryV1" => Ok(Self::TrustLineEntryV1),

            "TrustLineEntryExt" => Ok(Self::TrustLineEntryExt),

            "OfferEntryExt" => Ok(Self::OfferEntryExt),

            "DataEntryExt" => Ok(Self::DataEntryExt),

            "ClaimantV0" => Ok(Self::ClaimantV0),

            "ClaimableBalanceEntryExtensionV1Ext" => Ok(Self::ClaimableBalanceEntryExtensionV1Ext),

            "ClaimableBalanceEntryExt" => Ok(Self::ClaimableBalanceEntryExt),

            "LiquidityPoolEntryConstantProduct" => Ok(Self::LiquidityPoolEntryConstantProduct),

            "LiquidityPoolEntryBody" => Ok(Self::LiquidityPoolEntryBody),

            "ContractCodeEntryV1" => Ok(Self::ContractCodeEntryV1),

            "ContractCodeEntryExt" => Ok(Self::ContractCodeEntryExt),

            "LedgerEntryExtensionV1Ext" => Ok(Self::LedgerEntryExtensionV1Ext),

            "LedgerEntryData" => Ok(Self::LedgerEntryData),

            "LedgerEntryExt" => Ok(Self::LedgerEntryExt),

            "LedgerKeyAccount" => Ok(Self::LedgerKeyAccount),

            "LedgerKeyTrustLine" => Ok(Self::LedgerKeyTrustLine),

            "LedgerKeyOffer" => Ok(Self::LedgerKeyOffer),

            "LedgerKeyData" => Ok(Self::LedgerKeyData),

            "LedgerKeyClaimableBalance" => Ok(Self::LedgerKeyClaimableBalance),

            "LedgerKeyLiquidityPool" => Ok(Self::LedgerKeyLiquidityPool),

            "LedgerKeyContractData" => Ok(Self::LedgerKeyContractData),

            "LedgerKeyContractCode" => Ok(Self::LedgerKeyContractCode),

            "LedgerKeyConfigSetting" => Ok(Self::LedgerKeyConfigSetting),

            "LedgerKeyTtl" => Ok(Self::LedgerKeyTtl),

            "BucketMetadataExt" => Ok(Self::BucketMetadataExt),

            "StellarValueExt" => Ok(Self::StellarValueExt),

            "LedgerHeaderExtensionV1Ext" => Ok(Self::LedgerHeaderExtensionV1Ext),

            "LedgerHeaderExt" => Ok(Self::LedgerHeaderExt),

            "TxSetComponentTxsMaybeDiscountedFee" => Ok(Self::TxSetComponentTxsMaybeDiscountedFee),

            "TransactionHistoryEntryExt" => Ok(Self::TransactionHistoryEntryExt),

            "TransactionHistoryResultEntryExt" => Ok(Self::TransactionHistoryResultEntryExt),

            "LedgerHeaderHistoryEntryExt" => Ok(Self::LedgerHeaderHistoryEntryExt),

            "ContractEventV0" => Ok(Self::ContractEventV0),

            "ContractEventBody" => Ok(Self::ContractEventBody),

            "PeerAddressIp" => Ok(Self::PeerAddressIp),

            "AuthenticatedMessageV0" => Ok(Self::AuthenticatedMessageV0),

            "MuxedAccountMed25519" => Ok(Self::MuxedAccountMed25519),

            "RevokeSponsorshipOpSigner" => Ok(Self::RevokeSponsorshipOpSigner),

            "ContractIdPreimageFromAddress" => Ok(Self::ContractIdPreimageFromAddress),

            "OperationBody" => Ok(Self::OperationBody),

            "HashIdPreimageOperationId" => Ok(Self::HashIdPreimageOperationId),

            "HashIdPreimageRevokeId" => Ok(Self::HashIdPreimageRevokeId),

            "HashIdPreimageContractId" => Ok(Self::HashIdPreimageContractId),

            "HashIdPreimageSorobanAuthorization" => Ok(Self::HashIdPreimageSorobanAuthorization),

            "SorobanTransactionDataExt" => Ok(Self::SorobanTransactionDataExt),

            "TransactionV0Ext" => Ok(Self::TransactionV0Ext),

            "TransactionExt" => Ok(Self::TransactionExt),

            "FeeBumpTransactionInnerTx" => Ok(Self::FeeBumpTransactionInnerTx),

            "FeeBumpTransactionExt" => Ok(Self::FeeBumpTransactionExt),

            "TransactionSignaturePayloadTaggedTransaction" => {
                Ok(Self::TransactionSignaturePayloadTaggedTransaction)
            }

            "PathPaymentStrictReceiveResultSuccess" => {
                Ok(Self::PathPaymentStrictReceiveResultSuccess)
            }

            "PathPaymentStrictSendResultSuccess" => Ok(Self::PathPaymentStrictSendResultSuccess),

            "ManageOfferSuccessResultOffer" => Ok(Self::ManageOfferSuccessResultOffer),

            "OperationResultTr" => Ok(Self::OperationResultTr),

            "InnerTransactionResultResult" => Ok(Self::InnerTransactionResultResult),

            "InnerTransactionResultExt" => Ok(Self::InnerTransactionResultExt),

            "TransactionResultResult" => Ok(Self::TransactionResultResult),

            "TransactionResultExt" => Ok(Self::TransactionResultExt),

            "SignerKeyEd25519SignedPayload" => Ok(Self::SignerKeyEd25519SignedPayload),

            "Value" => Ok(Self::Value),

            "ScpBallot" => Ok(Self::ScpBallot),

            "ScpStatementType" => Ok(Self::ScpStatementType),

            "ScpNomination" => Ok(Self::ScpNomination),

            "ScpStatement" => Ok(Self::ScpStatement),

            "ScpEnvelope" => Ok(Self::ScpEnvelope),

            "ScpQuorumSet" => Ok(Self::ScpQuorumSet),

            "ConfigSettingContractExecutionLanesV0" => {
                Ok(Self::ConfigSettingContractExecutionLanesV0)
            }

            "ConfigSettingContractComputeV0" => Ok(Self::ConfigSettingContractComputeV0),

            "ConfigSettingContractParallelComputeV0" => {
                Ok(Self::ConfigSettingContractParallelComputeV0)
            }

            "ConfigSettingContractLedgerCostV0" => Ok(Self::ConfigSettingContractLedgerCostV0),

            "ConfigSettingContractLedgerCostExtV0" => {
                Ok(Self::ConfigSettingContractLedgerCostExtV0)
            }

            "ConfigSettingContractHistoricalDataV0" => {
                Ok(Self::ConfigSettingContractHistoricalDataV0)
            }

            "ConfigSettingContractEventsV0" => Ok(Self::ConfigSettingContractEventsV0),

            "ConfigSettingContractBandwidthV0" => Ok(Self::ConfigSettingContractBandwidthV0),

            "ContractCostType" => Ok(Self::ContractCostType),

            "ContractCostParamEntry" => Ok(Self::ContractCostParamEntry),

            "StateArchivalSettings" => Ok(Self::StateArchivalSettings),

            "EvictionIterator" => Ok(Self::EvictionIterator),

            "ConfigSettingScpTiming" => Ok(Self::ConfigSettingScpTiming),

            "ContractCostParams" => Ok(Self::ContractCostParams),

            "ConfigSettingId" => Ok(Self::ConfigSettingId),

            "ConfigSettingEntry" => Ok(Self::ConfigSettingEntry),

            "ScEnvMetaKind" => Ok(Self::ScEnvMetaKind),

            "ScEnvMetaEntry" => Ok(Self::ScEnvMetaEntry),

            "ScMetaV0" => Ok(Self::ScMetaV0),

            "ScMetaKind" => Ok(Self::ScMetaKind),

            "ScMetaEntry" => Ok(Self::ScMetaEntry),

            "ScSpecType" => Ok(Self::ScSpecType),

            "ScSpecTypeOption" => Ok(Self::ScSpecTypeOption),

            "ScSpecTypeResult" => Ok(Self::ScSpecTypeResult),

            "ScSpecTypeVec" => Ok(Self::ScSpecTypeVec),

            "ScSpecTypeMap" => Ok(Self::ScSpecTypeMap),

            "ScSpecTypeTuple" => Ok(Self::ScSpecTypeTuple),

            "ScSpecTypeBytesN" => Ok(Self::ScSpecTypeBytesN),

            "ScSpecTypeUdt" => Ok(Self::ScSpecTypeUdt),

            "ScSpecTypeDef" => Ok(Self::ScSpecTypeDef),

            "ScSpecUdtStructFieldV0" => Ok(Self::ScSpecUdtStructFieldV0),

            "ScSpecUdtStructV0" => Ok(Self::ScSpecUdtStructV0),

            "ScSpecUdtUnionCaseVoidV0" => Ok(Self::ScSpecUdtUnionCaseVoidV0),

            "ScSpecUdtUnionCaseTupleV0" => Ok(Self::ScSpecUdtUnionCaseTupleV0),

            "ScSpecUdtUnionCaseV0Kind" => Ok(Self::ScSpecUdtUnionCaseV0Kind),

            "ScSpecUdtUnionCaseV0" => Ok(Self::ScSpecUdtUnionCaseV0),

            "ScSpecUdtUnionV0" => Ok(Self::ScSpecUdtUnionV0),

            "ScSpecUdtEnumCaseV0" => Ok(Self::ScSpecUdtEnumCaseV0),

            "ScSpecUdtEnumV0" => Ok(Self::ScSpecUdtEnumV0),

            "ScSpecUdtErrorEnumCaseV0" => Ok(Self::ScSpecUdtErrorEnumCaseV0),

            "ScSpecUdtErrorEnumV0" => Ok(Self::ScSpecUdtErrorEnumV0),

            "ScSpecFunctionInputV0" => Ok(Self::ScSpecFunctionInputV0),

            "ScSpecFunctionV0" => Ok(Self::ScSpecFunctionV0),

            "ScSpecEventParamLocationV0" => Ok(Self::ScSpecEventParamLocationV0),

            "ScSpecEventParamV0" => Ok(Self::ScSpecEventParamV0),

            "ScSpecEventDataFormat" => Ok(Self::ScSpecEventDataFormat),

            "ScSpecEventV0" => Ok(Self::ScSpecEventV0),

            "ScSpecEntryKind" => Ok(Self::ScSpecEntryKind),

            "ScSpecEntry" => Ok(Self::ScSpecEntry),

            "ScValType" => Ok(Self::ScValType),

            "ScErrorType" => Ok(Self::ScErrorType),

            "ScErrorCode" => Ok(Self::ScErrorCode),

            "ScError" => Ok(Self::ScError),

            "UInt128Parts" => Ok(Self::UInt128Parts),

            "Int128Parts" => Ok(Self::Int128Parts),

            "UInt256Parts" => Ok(Self::UInt256Parts),

            "Int256Parts" => Ok(Self::Int256Parts),

            "ContractExecutableType" => Ok(Self::ContractExecutableType),

            "ContractExecutable" => Ok(Self::ContractExecutable),

            "ScAddressType" => Ok(Self::ScAddressType),

            "MuxedEd25519Account" => Ok(Self::MuxedEd25519Account),

            "ScAddress" => Ok(Self::ScAddress),

            "ScVec" => Ok(Self::ScVec),

            "ScMap" => Ok(Self::ScMap),

            "ScBytes" => Ok(Self::ScBytes),

            "ScString" => Ok(Self::ScString),

            "ScSymbol" => Ok(Self::ScSymbol),

            "ScNonceKey" => Ok(Self::ScNonceKey),

            "ScContractInstance" => Ok(Self::ScContractInstance),

            "ScVal" => Ok(Self::ScVal),

            "ScMapEntry" => Ok(Self::ScMapEntry),

            "LedgerCloseMetaBatch" => Ok(Self::LedgerCloseMetaBatch),

            "StoredTransactionSet" => Ok(Self::StoredTransactionSet),

            "StoredDebugTransactionSet" => Ok(Self::StoredDebugTransactionSet),

            "PersistedScpStateV0" => Ok(Self::PersistedScpStateV0),

            "PersistedScpStateV1" => Ok(Self::PersistedScpStateV1),

            "PersistedScpState" => Ok(Self::PersistedScpState),

            "Thresholds" => Ok(Self::Thresholds),

            "String32" => Ok(Self::String32),

            "String64" => Ok(Self::String64),

            "SequenceNumber" => Ok(Self::SequenceNumber),

            "DataValue" => Ok(Self::DataValue),

            "AssetCode4" => Ok(Self::AssetCode4),

            "AssetCode12" => Ok(Self::AssetCode12),

            "AssetType" => Ok(Self::AssetType),

            "AssetCode" => Ok(Self::AssetCode),

            "AlphaNum4" => Ok(Self::AlphaNum4),

            "AlphaNum12" => Ok(Self::AlphaNum12),

            "Asset" => Ok(Self::Asset),

            "Price" => Ok(Self::Price),

            "Liabilities" => Ok(Self::Liabilities),

            "ThresholdIndexes" => Ok(Self::ThresholdIndexes),

            "LedgerEntryType" => Ok(Self::LedgerEntryType),

            "Signer" => Ok(Self::Signer),

            "AccountFlags" => Ok(Self::AccountFlags),

            "SponsorshipDescriptor" => Ok(Self::SponsorshipDescriptor),

            "AccountEntryExtensionV3" => Ok(Self::AccountEntryExtensionV3),

            "AccountEntryExtensionV2" => Ok(Self::AccountEntryExtensionV2),

            "AccountEntryExtensionV1" => Ok(Self::AccountEntryExtensionV1),

            "AccountEntry" => Ok(Self::AccountEntry),

            "TrustLineFlags" => Ok(Self::TrustLineFlags),

            "LiquidityPoolType" => Ok(Self::LiquidityPoolType),

            "TrustLineAsset" => Ok(Self::TrustLineAsset),

            "TrustLineEntryExtensionV2" => Ok(Self::TrustLineEntryExtensionV2),

            "TrustLineEntry" => Ok(Self::TrustLineEntry),

            "OfferEntryFlags" => Ok(Self::OfferEntryFlags),

            "OfferEntry" => Ok(Self::OfferEntry),

            "DataEntry" => Ok(Self::DataEntry),

            "ClaimPredicateType" => Ok(Self::ClaimPredicateType),

            "ClaimPredicate" => Ok(Self::ClaimPredicate),

            "ClaimantType" => Ok(Self::ClaimantType),

            "Claimant" => Ok(Self::Claimant),

            "ClaimableBalanceFlags" => Ok(Self::ClaimableBalanceFlags),

            "ClaimableBalanceEntryExtensionV1" => Ok(Self::ClaimableBalanceEntryExtensionV1),

            "ClaimableBalanceEntry" => Ok(Self::ClaimableBalanceEntry),

            "LiquidityPoolConstantProductParameters" => {
                Ok(Self::LiquidityPoolConstantProductParameters)
            }

            "LiquidityPoolEntry" => Ok(Self::LiquidityPoolEntry),

            "ContractDataDurability" => Ok(Self::ContractDataDurability),

            "ContractDataEntry" => Ok(Self::ContractDataEntry),

            "ContractCodeCostInputs" => Ok(Self::ContractCodeCostInputs),

            "ContractCodeEntry" => Ok(Self::ContractCodeEntry),

            "TtlEntry" => Ok(Self::TtlEntry),

            "LedgerEntryExtensionV1" => Ok(Self::LedgerEntryExtensionV1),

            "LedgerEntry" => Ok(Self::LedgerEntry),

            "LedgerKey" => Ok(Self::LedgerKey),

            "EnvelopeType" => Ok(Self::EnvelopeType),

            "BucketListType" => Ok(Self::BucketListType),

            "BucketEntryType" => Ok(Self::BucketEntryType),

            "HotArchiveBucketEntryType" => Ok(Self::HotArchiveBucketEntryType),

            "BucketMetadata" => Ok(Self::BucketMetadata),

            "BucketEntry" => Ok(Self::BucketEntry),

            "HotArchiveBucketEntry" => Ok(Self::HotArchiveBucketEntry),

            "UpgradeType" => Ok(Self::UpgradeType),

            "StellarValueType" => Ok(Self::StellarValueType),

            "LedgerCloseValueSignature" => Ok(Self::LedgerCloseValueSignature),

            "StellarValue" => Ok(Self::StellarValue),

            "LedgerHeaderFlags" => Ok(Self::LedgerHeaderFlags),

            "LedgerHeaderExtensionV1" => Ok(Self::LedgerHeaderExtensionV1),

            "LedgerHeader" => Ok(Self::LedgerHeader),

            "LedgerUpgradeType" => Ok(Self::LedgerUpgradeType),

            "ConfigUpgradeSetKey" => Ok(Self::ConfigUpgradeSetKey),

            "LedgerUpgrade" => Ok(Self::LedgerUpgrade),

            "ConfigUpgradeSet" => Ok(Self::ConfigUpgradeSet),

            "TxSetComponentType" => Ok(Self::TxSetComponentType),

            "DependentTxCluster" => Ok(Self::DependentTxCluster),

            "ParallelTxExecutionStage" => Ok(Self::ParallelTxExecutionStage),

            "ParallelTxsComponent" => Ok(Self::ParallelTxsComponent),

            "TxSetComponent" => Ok(Self::TxSetComponent),

            "TransactionPhase" => Ok(Self::TransactionPhase),

            "TransactionSet" => Ok(Self::TransactionSet),

            "TransactionSetV1" => Ok(Self::TransactionSetV1),

            "GeneralizedTransactionSet" => Ok(Self::GeneralizedTransactionSet),

            "TransactionResultPair" => Ok(Self::TransactionResultPair),

            "TransactionResultSet" => Ok(Self::TransactionResultSet),

            "TransactionHistoryEntry" => Ok(Self::TransactionHistoryEntry),

            "TransactionHistoryResultEntry" => Ok(Self::TransactionHistoryResultEntry),

            "LedgerHeaderHistoryEntry" => Ok(Self::LedgerHeaderHistoryEntry),

            "LedgerScpMessages" => Ok(Self::LedgerScpMessages),

            "ScpHistoryEntryV0" => Ok(Self::ScpHistoryEntryV0),

            "ScpHistoryEntry" => Ok(Self::ScpHistoryEntry),

            "LedgerEntryChangeType" => Ok(Self::LedgerEntryChangeType),

            "LedgerEntryChange" => Ok(Self::LedgerEntryChange),

            "LedgerEntryChanges" => Ok(Self::LedgerEntryChanges),

            "OperationMeta" => Ok(Self::OperationMeta),

            "TransactionMetaV1" => Ok(Self::TransactionMetaV1),

            "TransactionMetaV2" => Ok(Self::TransactionMetaV2),

            "ContractEventType" => Ok(Self::ContractEventType),

            "ContractEvent" => Ok(Self::ContractEvent),

            "DiagnosticEvent" => Ok(Self::DiagnosticEvent),

            "SorobanTransactionMetaExtV1" => Ok(Self::SorobanTransactionMetaExtV1),

            "SorobanTransactionMetaExt" => Ok(Self::SorobanTransactionMetaExt),

            "SorobanTransactionMeta" => Ok(Self::SorobanTransactionMeta),

            "TransactionMetaV3" => Ok(Self::TransactionMetaV3),

            "OperationMetaV2" => Ok(Self::OperationMetaV2),

            "SorobanTransactionMetaV2" => Ok(Self::SorobanTransactionMetaV2),

            "TransactionEventStage" => Ok(Self::TransactionEventStage),

            "TransactionEvent" => Ok(Self::TransactionEvent),

            "TransactionMetaV4" => Ok(Self::TransactionMetaV4),

            "InvokeHostFunctionSuccessPreImage" => Ok(Self::InvokeHostFunctionSuccessPreImage),

            "TransactionMeta" => Ok(Self::TransactionMeta),

            "TransactionResultMeta" => Ok(Self::TransactionResultMeta),

            "TransactionResultMetaV1" => Ok(Self::TransactionResultMetaV1),

            "UpgradeEntryMeta" => Ok(Self::UpgradeEntryMeta),

            "LedgerCloseMetaV0" => Ok(Self::LedgerCloseMetaV0),

            "LedgerCloseMetaExtV1" => Ok(Self::LedgerCloseMetaExtV1),

            "LedgerCloseMetaExt" => Ok(Self::LedgerCloseMetaExt),

            "LedgerCloseMetaV1" => Ok(Self::LedgerCloseMetaV1),

            "LedgerCloseMetaV2" => Ok(Self::LedgerCloseMetaV2),

            "LedgerCloseMeta" => Ok(Self::LedgerCloseMeta),

            "ErrorCode" => Ok(Self::ErrorCode),

            "SError" => Ok(Self::SError),

            "SendMore" => Ok(Self::SendMore),

            "SendMoreExtended" => Ok(Self::SendMoreExtended),

            "AuthCert" => Ok(Self::AuthCert),

            "Hello" => Ok(Self::Hello),

            "Auth" => Ok(Self::Auth),

            "IpAddrType" => Ok(Self::IpAddrType),

            "PeerAddress" => Ok(Self::PeerAddress),

            "MessageType" => Ok(Self::MessageType),

            "DontHave" => Ok(Self::DontHave),

            "SurveyMessageCommandType" => Ok(Self::SurveyMessageCommandType),

            "SurveyMessageResponseType" => Ok(Self::SurveyMessageResponseType),

            "TimeSlicedSurveyStartCollectingMessage" => {
                Ok(Self::TimeSlicedSurveyStartCollectingMessage)
            }

            "SignedTimeSlicedSurveyStartCollectingMessage" => {
                Ok(Self::SignedTimeSlicedSurveyStartCollectingMessage)
            }

            "TimeSlicedSurveyStopCollectingMessage" => {
                Ok(Self::TimeSlicedSurveyStopCollectingMessage)
            }

            "SignedTimeSlicedSurveyStopCollectingMessage" => {
                Ok(Self::SignedTimeSlicedSurveyStopCollectingMessage)
            }

            "SurveyRequestMessage" => Ok(Self::SurveyRequestMessage),

            "TimeSlicedSurveyRequestMessage" => Ok(Self::TimeSlicedSurveyRequestMessage),

            "SignedTimeSlicedSurveyRequestMessage" => {
                Ok(Self::SignedTimeSlicedSurveyRequestMessage)
            }

            "EncryptedBody" => Ok(Self::EncryptedBody),

            "SurveyResponseMessage" => Ok(Self::SurveyResponseMessage),

            "TimeSlicedSurveyResponseMessage" => Ok(Self::TimeSlicedSurveyResponseMessage),

            "SignedTimeSlicedSurveyResponseMessage" => {
                Ok(Self::SignedTimeSlicedSurveyResponseMessage)
            }

            "PeerStats" => Ok(Self::PeerStats),

            "TimeSlicedNodeData" => Ok(Self::TimeSlicedNodeData),

            "TimeSlicedPeerData" => Ok(Self::TimeSlicedPeerData),

            "TimeSlicedPeerDataList" => Ok(Self::TimeSlicedPeerDataList),

            "TopologyResponseBodyV2" => Ok(Self::TopologyResponseBodyV2),

            "SurveyResponseBody" => Ok(Self::SurveyResponseBody),

            "TxAdvertVector" => Ok(Self::TxAdvertVector),

            "FloodAdvert" => Ok(Self::FloodAdvert),

            "TxDemandVector" => Ok(Self::TxDemandVector),

            "FloodDemand" => Ok(Self::FloodDemand),

            "StellarMessage" => Ok(Self::StellarMessage),

            "AuthenticatedMessage" => Ok(Self::AuthenticatedMessage),

            "LiquidityPoolParameters" => Ok(Self::LiquidityPoolParameters),

            "MuxedAccount" => Ok(Self::MuxedAccount),

            "DecoratedSignature" => Ok(Self::DecoratedSignature),

            "OperationType" => Ok(Self::OperationType),

            "CreateAccountOp" => Ok(Self::CreateAccountOp),

            "PaymentOp" => Ok(Self::PaymentOp),

            "PathPaymentStrictReceiveOp" => Ok(Self::PathPaymentStrictReceiveOp),

            "PathPaymentStrictSendOp" => Ok(Self::PathPaymentStrictSendOp),

            "ManageSellOfferOp" => Ok(Self::ManageSellOfferOp),

            "ManageBuyOfferOp" => Ok(Self::ManageBuyOfferOp),

            "CreatePassiveSellOfferOp" => Ok(Self::CreatePassiveSellOfferOp),

            "SetOptionsOp" => Ok(Self::SetOptionsOp),

            "ChangeTrustAsset" => Ok(Self::ChangeTrustAsset),

            "ChangeTrustOp" => Ok(Self::ChangeTrustOp),

            "AllowTrustOp" => Ok(Self::AllowTrustOp),

            "ManageDataOp" => Ok(Self::ManageDataOp),

            "BumpSequenceOp" => Ok(Self::BumpSequenceOp),

            "CreateClaimableBalanceOp" => Ok(Self::CreateClaimableBalanceOp),

            "ClaimClaimableBalanceOp" => Ok(Self::ClaimClaimableBalanceOp),

            "BeginSponsoringFutureReservesOp" => Ok(Self::BeginSponsoringFutureReservesOp),

            "RevokeSponsorshipType" => Ok(Self::RevokeSponsorshipType),

            "RevokeSponsorshipOp" => Ok(Self::RevokeSponsorshipOp),

            "ClawbackOp" => Ok(Self::ClawbackOp),

            "ClawbackClaimableBalanceOp" => Ok(Self::ClawbackClaimableBalanceOp),

            "SetTrustLineFlagsOp" => Ok(Self::SetTrustLineFlagsOp),

            "LiquidityPoolDepositOp" => Ok(Self::LiquidityPoolDepositOp),

            "LiquidityPoolWithdrawOp" => Ok(Self::LiquidityPoolWithdrawOp),

            "HostFunctionType" => Ok(Self::HostFunctionType),

            "ContractIdPreimageType" => Ok(Self::ContractIdPreimageType),

            "ContractIdPreimage" => Ok(Self::ContractIdPreimage),

            "CreateContractArgs" => Ok(Self::CreateContractArgs),

            "CreateContractArgsV2" => Ok(Self::CreateContractArgsV2),

            "InvokeContractArgs" => Ok(Self::InvokeContractArgs),

            "HostFunction" => Ok(Self::HostFunction),

            "SorobanAuthorizedFunctionType" => Ok(Self::SorobanAuthorizedFunctionType),

            "SorobanAuthorizedFunction" => Ok(Self::SorobanAuthorizedFunction),

            "SorobanAuthorizedInvocation" => Ok(Self::SorobanAuthorizedInvocation),

            "SorobanAddressCredentials" => Ok(Self::SorobanAddressCredentials),

            "SorobanCredentialsType" => Ok(Self::SorobanCredentialsType),

            "SorobanCredentials" => Ok(Self::SorobanCredentials),

            "SorobanAuthorizationEntry" => Ok(Self::SorobanAuthorizationEntry),

            "SorobanAuthorizationEntries" => Ok(Self::SorobanAuthorizationEntries),

            "InvokeHostFunctionOp" => Ok(Self::InvokeHostFunctionOp),

            "ExtendFootprintTtlOp" => Ok(Self::ExtendFootprintTtlOp),

            "RestoreFootprintOp" => Ok(Self::RestoreFootprintOp),

            "Operation" => Ok(Self::Operation),

            "HashIdPreimage" => Ok(Self::HashIdPreimage),

            "MemoType" => Ok(Self::MemoType),

            "Memo" => Ok(Self::Memo),

            "TimeBounds" => Ok(Self::TimeBounds),

            "LedgerBounds" => Ok(Self::LedgerBounds),

            "PreconditionsV2" => Ok(Self::PreconditionsV2),

            "PreconditionType" => Ok(Self::PreconditionType),

            "Preconditions" => Ok(Self::Preconditions),

            "LedgerFootprint" => Ok(Self::LedgerFootprint),

            "SorobanResources" => Ok(Self::SorobanResources),

            "SorobanResourcesExtV0" => Ok(Self::SorobanResourcesExtV0),

            "SorobanTransactionData" => Ok(Self::SorobanTransactionData),

            "TransactionV0" => Ok(Self::TransactionV0),

            "TransactionV0Envelope" => Ok(Self::TransactionV0Envelope),

            "Transaction" => Ok(Self::Transaction),

            "TransactionV1Envelope" => Ok(Self::TransactionV1Envelope),

            "FeeBumpTransaction" => Ok(Self::FeeBumpTransaction),

            "FeeBumpTransactionEnvelope" => Ok(Self::FeeBumpTransactionEnvelope),

            "TransactionEnvelope" => Ok(Self::TransactionEnvelope),

            "TransactionSignaturePayload" => Ok(Self::TransactionSignaturePayload),

            "ClaimAtomType" => Ok(Self::ClaimAtomType),

            "ClaimOfferAtomV0" => Ok(Self::ClaimOfferAtomV0),

            "ClaimOfferAtom" => Ok(Self::ClaimOfferAtom),

            "ClaimLiquidityAtom" => Ok(Self::ClaimLiquidityAtom),

            "ClaimAtom" => Ok(Self::ClaimAtom),

            "CreateAccountResultCode" => Ok(Self::CreateAccountResultCode),

            "CreateAccountResult" => Ok(Self::CreateAccountResult),

            "PaymentResultCode" => Ok(Self::PaymentResultCode),

            "PaymentResult" => Ok(Self::PaymentResult),

            "PathPaymentStrictReceiveResultCode" => Ok(Self::PathPaymentStrictReceiveResultCode),

            "SimplePaymentResult" => Ok(Self::SimplePaymentResult),

            "PathPaymentStrictReceiveResult" => Ok(Self::PathPaymentStrictReceiveResult),

            "PathPaymentStrictSendResultCode" => Ok(Self::PathPaymentStrictSendResultCode),

            "PathPaymentStrictSendResult" => Ok(Self::PathPaymentStrictSendResult),

            "ManageSellOfferResultCode" => Ok(Self::ManageSellOfferResultCode),

            "ManageOfferEffect" => Ok(Self::ManageOfferEffect),

            "ManageOfferSuccessResult" => Ok(Self::ManageOfferSuccessResult),

            "ManageSellOfferResult" => Ok(Self::ManageSellOfferResult),

            "ManageBuyOfferResultCode" => Ok(Self::ManageBuyOfferResultCode),

            "ManageBuyOfferResult" => Ok(Self::ManageBuyOfferResult),

            "SetOptionsResultCode" => Ok(Self::SetOptionsResultCode),

            "SetOptionsResult" => Ok(Self::SetOptionsResult),

            "ChangeTrustResultCode" => Ok(Self::ChangeTrustResultCode),

            "ChangeTrustResult" => Ok(Self::ChangeTrustResult),

            "AllowTrustResultCode" => Ok(Self::AllowTrustResultCode),

            "AllowTrustResult" => Ok(Self::AllowTrustResult),

            "AccountMergeResultCode" => Ok(Self::AccountMergeResultCode),

            "AccountMergeResult" => Ok(Self::AccountMergeResult),

            "InflationResultCode" => Ok(Self::InflationResultCode),

            "InflationPayout" => Ok(Self::InflationPayout),

            "InflationResult" => Ok(Self::InflationResult),

            "ManageDataResultCode" => Ok(Self::ManageDataResultCode),

            "ManageDataResult" => Ok(Self::ManageDataResult),

            "BumpSequenceResultCode" => Ok(Self::BumpSequenceResultCode),

            "BumpSequenceResult" => Ok(Self::BumpSequenceResult),

            "CreateClaimableBalanceResultCode" => Ok(Self::CreateClaimableBalanceResultCode),

            "CreateClaimableBalanceResult" => Ok(Self::CreateClaimableBalanceResult),

            "ClaimClaimableBalanceResultCode" => Ok(Self::ClaimClaimableBalanceResultCode),

            "ClaimClaimableBalanceResult" => Ok(Self::ClaimClaimableBalanceResult),

            "BeginSponsoringFutureReservesResultCode" => {
                Ok(Self::BeginSponsoringFutureReservesResultCode)
            }

            "BeginSponsoringFutureReservesResult" => Ok(Self::BeginSponsoringFutureReservesResult),

            "EndSponsoringFutureReservesResultCode" => {
                Ok(Self::EndSponsoringFutureReservesResultCode)
            }

            "EndSponsoringFutureReservesResult" => Ok(Self::EndSponsoringFutureReservesResult),

            "RevokeSponsorshipResultCode" => Ok(Self::RevokeSponsorshipResultCode),

            "RevokeSponsorshipResult" => Ok(Self::RevokeSponsorshipResult),

            "ClawbackResultCode" => Ok(Self::ClawbackResultCode),

            "ClawbackResult" => Ok(Self::ClawbackResult),

            "ClawbackClaimableBalanceResultCode" => Ok(Self::ClawbackClaimableBalanceResultCode),

            "ClawbackClaimableBalanceResult" => Ok(Self::ClawbackClaimableBalanceResult),

            "SetTrustLineFlagsResultCode" => Ok(Self::SetTrustLineFlagsResultCode),

            "SetTrustLineFlagsResult" => Ok(Self::SetTrustLineFlagsResult),

            "LiquidityPoolDepositResultCode" => Ok(Self::LiquidityPoolDepositResultCode),

            "LiquidityPoolDepositResult" => Ok(Self::LiquidityPoolDepositResult),

            "LiquidityPoolWithdrawResultCode" => Ok(Self::LiquidityPoolWithdrawResultCode),

            "LiquidityPoolWithdrawResult" => Ok(Self::LiquidityPoolWithdrawResult),

            "InvokeHostFunctionResultCode" => Ok(Self::InvokeHostFunctionResultCode),

            "InvokeHostFunctionResult" => Ok(Self::InvokeHostFunctionResult),

            "ExtendFootprintTtlResultCode" => Ok(Self::ExtendFootprintTtlResultCode),

            "ExtendFootprintTtlResult" => Ok(Self::ExtendFootprintTtlResult),

            "RestoreFootprintResultCode" => Ok(Self::RestoreFootprintResultCode),

            "RestoreFootprintResult" => Ok(Self::RestoreFootprintResult),

            "OperationResultCode" => Ok(Self::OperationResultCode),

            "OperationResult" => Ok(Self::OperationResult),

            "TransactionResultCode" => Ok(Self::TransactionResultCode),

            "InnerTransactionResult" => Ok(Self::InnerTransactionResult),

            "InnerTransactionResultPair" => Ok(Self::InnerTransactionResultPair),

            "TransactionResult" => Ok(Self::TransactionResult),

            "Hash" => Ok(Self::Hash),

            "Uint256" => Ok(Self::Uint256),

            "Uint32" => Ok(Self::Uint32),

            "Int32" => Ok(Self::Int32),

            "Uint64" => Ok(Self::Uint64),

            "Int64" => Ok(Self::Int64),

            "TimePoint" => Ok(Self::TimePoint),

            "Duration" => Ok(Self::Duration),

            "ExtensionPoint" => Ok(Self::ExtensionPoint),

            "CryptoKeyType" => Ok(Self::CryptoKeyType),

            "PublicKeyType" => Ok(Self::PublicKeyType),

            "SignerKeyType" => Ok(Self::SignerKeyType),

            "PublicKey" => Ok(Self::PublicKey),

            "SignerKey" => Ok(Self::SignerKey),

            "Signature" => Ok(Self::Signature),

            "SignatureHint" => Ok(Self::SignatureHint),

            "NodeId" => Ok(Self::NodeId),

            "AccountId" => Ok(Self::AccountId),

            "ContractId" => Ok(Self::ContractId),

            "Curve25519Secret" => Ok(Self::Curve25519Secret),

            "Curve25519Public" => Ok(Self::Curve25519Public),

            "HmacSha256Key" => Ok(Self::HmacSha256Key),

            "HmacSha256Mac" => Ok(Self::HmacSha256Mac),

            "ShortHashSeed" => Ok(Self::ShortHashSeed),

            "BinaryFuseFilterType" => Ok(Self::BinaryFuseFilterType),

            "SerializedBinaryFuseFilter" => Ok(Self::SerializedBinaryFuseFilter),

            "PoolId" => Ok(Self::PoolId),

            "ClaimableBalanceIdType" => Ok(Self::ClaimableBalanceIdType),

            "ClaimableBalanceId" => Ok(Self::ClaimableBalanceId),

            _ => Err(Error::Invalid),
        }
    }
}

#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case"),
    serde(untagged)
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub enum Type {
    ScpStatementPrepare(Box<ScpStatementPrepare>),

    ScpStatementConfirm(Box<ScpStatementConfirm>),

    ScpStatementExternalize(Box<ScpStatementExternalize>),

    ScpStatementPledges(Box<ScpStatementPledges>),

    ScEnvMetaEntryInterfaceVersion(Box<ScEnvMetaEntryInterfaceVersion>),

    AccountEntryExtensionV2Ext(Box<AccountEntryExtensionV2Ext>),

    AccountEntryExtensionV1Ext(Box<AccountEntryExtensionV1Ext>),

    AccountEntryExt(Box<AccountEntryExt>),

    TrustLineEntryExtensionV2Ext(Box<TrustLineEntryExtensionV2Ext>),

    TrustLineEntryV1Ext(Box<TrustLineEntryV1Ext>),

    TrustLineEntryV1(Box<TrustLineEntryV1>),

    TrustLineEntryExt(Box<TrustLineEntryExt>),

    OfferEntryExt(Box<OfferEntryExt>),

    DataEntryExt(Box<DataEntryExt>),

    ClaimantV0(Box<ClaimantV0>),

    ClaimableBalanceEntryExtensionV1Ext(Box<ClaimableBalanceEntryExtensionV1Ext>),

    ClaimableBalanceEntryExt(Box<ClaimableBalanceEntryExt>),

    LiquidityPoolEntryConstantProduct(Box<LiquidityPoolEntryConstantProduct>),

    LiquidityPoolEntryBody(Box<LiquidityPoolEntryBody>),

    ContractCodeEntryV1(Box<ContractCodeEntryV1>),

    ContractCodeEntryExt(Box<ContractCodeEntryExt>),

    LedgerEntryExtensionV1Ext(Box<LedgerEntryExtensionV1Ext>),

    LedgerEntryData(Box<LedgerEntryData>),

    LedgerEntryExt(Box<LedgerEntryExt>),

    LedgerKeyAccount(Box<LedgerKeyAccount>),

    LedgerKeyTrustLine(Box<LedgerKeyTrustLine>),

    LedgerKeyOffer(Box<LedgerKeyOffer>),

    LedgerKeyData(Box<LedgerKeyData>),

    LedgerKeyClaimableBalance(Box<LedgerKeyClaimableBalance>),

    LedgerKeyLiquidityPool(Box<LedgerKeyLiquidityPool>),

    LedgerKeyContractData(Box<LedgerKeyContractData>),

    LedgerKeyContractCode(Box<LedgerKeyContractCode>),

    LedgerKeyConfigSetting(Box<LedgerKeyConfigSetting>),

    LedgerKeyTtl(Box<LedgerKeyTtl>),

    BucketMetadataExt(Box<BucketMetadataExt>),

    StellarValueExt(Box<StellarValueExt>),

    LedgerHeaderExtensionV1Ext(Box<LedgerHeaderExtensionV1Ext>),

    LedgerHeaderExt(Box<LedgerHeaderExt>),

    TxSetComponentTxsMaybeDiscountedFee(Box<TxSetComponentTxsMaybeDiscountedFee>),

    TransactionHistoryEntryExt(Box<TransactionHistoryEntryExt>),

    TransactionHistoryResultEntryExt(Box<TransactionHistoryResultEntryExt>),

    LedgerHeaderHistoryEntryExt(Box<LedgerHeaderHistoryEntryExt>),

    ContractEventV0(Box<ContractEventV0>),

    ContractEventBody(Box<ContractEventBody>),

    PeerAddressIp(Box<PeerAddressIp>),

    AuthenticatedMessageV0(Box<AuthenticatedMessageV0>),

    MuxedAccountMed25519(Box<MuxedAccountMed25519>),

    RevokeSponsorshipOpSigner(Box<RevokeSponsorshipOpSigner>),

    ContractIdPreimageFromAddress(Box<ContractIdPreimageFromAddress>),

    OperationBody(Box<OperationBody>),

    HashIdPreimageOperationId(Box<HashIdPreimageOperationId>),

    HashIdPreimageRevokeId(Box<HashIdPreimageRevokeId>),

    HashIdPreimageContractId(Box<HashIdPreimageContractId>),

    HashIdPreimageSorobanAuthorization(Box<HashIdPreimageSorobanAuthorization>),

    SorobanTransactionDataExt(Box<SorobanTransactionDataExt>),

    TransactionV0Ext(Box<TransactionV0Ext>),

    TransactionExt(Box<TransactionExt>),

    FeeBumpTransactionInnerTx(Box<FeeBumpTransactionInnerTx>),

    FeeBumpTransactionExt(Box<FeeBumpTransactionExt>),

    TransactionSignaturePayloadTaggedTransaction(Box<TransactionSignaturePayloadTaggedTransaction>),

    PathPaymentStrictReceiveResultSuccess(Box<PathPaymentStrictReceiveResultSuccess>),

    PathPaymentStrictSendResultSuccess(Box<PathPaymentStrictSendResultSuccess>),

    ManageOfferSuccessResultOffer(Box<ManageOfferSuccessResultOffer>),

    OperationResultTr(Box<OperationResultTr>),

    InnerTransactionResultResult(Box<InnerTransactionResultResult>),

    InnerTransactionResultExt(Box<InnerTransactionResultExt>),

    TransactionResultResult(Box<TransactionResultResult>),

    TransactionResultExt(Box<TransactionResultExt>),

    SignerKeyEd25519SignedPayload(Box<SignerKeyEd25519SignedPayload>),

    Value(Box<Value>),

    ScpBallot(Box<ScpBallot>),

    ScpStatementType(Box<ScpStatementType>),

    ScpNomination(Box<ScpNomination>),

    ScpStatement(Box<ScpStatement>),

    ScpEnvelope(Box<ScpEnvelope>),

    ScpQuorumSet(Box<ScpQuorumSet>),

    ConfigSettingContractExecutionLanesV0(Box<ConfigSettingContractExecutionLanesV0>),

    ConfigSettingContractComputeV0(Box<ConfigSettingContractComputeV0>),

    ConfigSettingContractParallelComputeV0(Box<ConfigSettingContractParallelComputeV0>),

    ConfigSettingContractLedgerCostV0(Box<ConfigSettingContractLedgerCostV0>),

    ConfigSettingContractLedgerCostExtV0(Box<ConfigSettingContractLedgerCostExtV0>),

    ConfigSettingContractHistoricalDataV0(Box<ConfigSettingContractHistoricalDataV0>),

    ConfigSettingContractEventsV0(Box<ConfigSettingContractEventsV0>),

    ConfigSettingContractBandwidthV0(Box<ConfigSettingContractBandwidthV0>),

    ContractCostType(Box<ContractCostType>),

    ContractCostParamEntry(Box<ContractCostParamEntry>),

    StateArchivalSettings(Box<StateArchivalSettings>),

    EvictionIterator(Box<EvictionIterator>),

    ConfigSettingScpTiming(Box<ConfigSettingScpTiming>),

    ContractCostParams(Box<ContractCostParams>),

    ConfigSettingId(Box<ConfigSettingId>),

    ConfigSettingEntry(Box<ConfigSettingEntry>),

    ScEnvMetaKind(Box<ScEnvMetaKind>),

    ScEnvMetaEntry(Box<ScEnvMetaEntry>),

    ScMetaV0(Box<ScMetaV0>),

    ScMetaKind(Box<ScMetaKind>),

    ScMetaEntry(Box<ScMetaEntry>),

    ScSpecType(Box<ScSpecType>),

    ScSpecTypeOption(Box<ScSpecTypeOption>),

    ScSpecTypeResult(Box<ScSpecTypeResult>),

    ScSpecTypeVec(Box<ScSpecTypeVec>),

    ScSpecTypeMap(Box<ScSpecTypeMap>),

    ScSpecTypeTuple(Box<ScSpecTypeTuple>),

    ScSpecTypeBytesN(Box<ScSpecTypeBytesN>),

    ScSpecTypeUdt(Box<ScSpecTypeUdt>),

    ScSpecTypeDef(Box<ScSpecTypeDef>),

    ScSpecUdtStructFieldV0(Box<ScSpecUdtStructFieldV0>),

    ScSpecUdtStructV0(Box<ScSpecUdtStructV0>),

    ScSpecUdtUnionCaseVoidV0(Box<ScSpecUdtUnionCaseVoidV0>),

    ScSpecUdtUnionCaseTupleV0(Box<ScSpecUdtUnionCaseTupleV0>),

    ScSpecUdtUnionCaseV0Kind(Box<ScSpecUdtUnionCaseV0Kind>),

    ScSpecUdtUnionCaseV0(Box<ScSpecUdtUnionCaseV0>),

    ScSpecUdtUnionV0(Box<ScSpecUdtUnionV0>),

    ScSpecUdtEnumCaseV0(Box<ScSpecUdtEnumCaseV0>),

    ScSpecUdtEnumV0(Box<ScSpecUdtEnumV0>),

    ScSpecUdtErrorEnumCaseV0(Box<ScSpecUdtErrorEnumCaseV0>),

    ScSpecUdtErrorEnumV0(Box<ScSpecUdtErrorEnumV0>),

    ScSpecFunctionInputV0(Box<ScSpecFunctionInputV0>),

    ScSpecFunctionV0(Box<ScSpecFunctionV0>),

    ScSpecEventParamLocationV0(Box<ScSpecEventParamLocationV0>),

    ScSpecEventParamV0(Box<ScSpecEventParamV0>),

    ScSpecEventDataFormat(Box<ScSpecEventDataFormat>),

    ScSpecEventV0(Box<ScSpecEventV0>),

    ScSpecEntryKind(Box<ScSpecEntryKind>),

    ScSpecEntry(Box<ScSpecEntry>),

    ScValType(Box<ScValType>),

    ScErrorType(Box<ScErrorType>),

    ScErrorCode(Box<ScErrorCode>),

    ScError(Box<ScError>),

    UInt128Parts(Box<UInt128Parts>),

    Int128Parts(Box<Int128Parts>),

    UInt256Parts(Box<UInt256Parts>),

    Int256Parts(Box<Int256Parts>),

    ContractExecutableType(Box<ContractExecutableType>),

    ContractExecutable(Box<ContractExecutable>),

    ScAddressType(Box<ScAddressType>),

    MuxedEd25519Account(Box<MuxedEd25519Account>),

    ScAddress(Box<ScAddress>),

    ScVec(Box<ScVec>),

    ScMap(Box<ScMap>),

    ScBytes(Box<ScBytes>),

    ScString(Box<ScString>),

    ScSymbol(Box<ScSymbol>),

    ScNonceKey(Box<ScNonceKey>),

    ScContractInstance(Box<ScContractInstance>),

    ScVal(Box<ScVal>),

    ScMapEntry(Box<ScMapEntry>),

    LedgerCloseMetaBatch(Box<LedgerCloseMetaBatch>),

    StoredTransactionSet(Box<StoredTransactionSet>),

    StoredDebugTransactionSet(Box<StoredDebugTransactionSet>),

    PersistedScpStateV0(Box<PersistedScpStateV0>),

    PersistedScpStateV1(Box<PersistedScpStateV1>),

    PersistedScpState(Box<PersistedScpState>),

    Thresholds(Box<Thresholds>),

    String32(Box<String32>),

    String64(Box<String64>),

    SequenceNumber(Box<SequenceNumber>),

    DataValue(Box<DataValue>),

    AssetCode4(Box<AssetCode4>),

    AssetCode12(Box<AssetCode12>),

    AssetType(Box<AssetType>),

    AssetCode(Box<AssetCode>),

    AlphaNum4(Box<AlphaNum4>),

    AlphaNum12(Box<AlphaNum12>),

    Asset(Box<Asset>),

    Price(Box<Price>),

    Liabilities(Box<Liabilities>),

    ThresholdIndexes(Box<ThresholdIndexes>),

    LedgerEntryType(Box<LedgerEntryType>),

    Signer(Box<Signer>),

    AccountFlags(Box<AccountFlags>),

    SponsorshipDescriptor(Box<SponsorshipDescriptor>),

    AccountEntryExtensionV3(Box<AccountEntryExtensionV3>),

    AccountEntryExtensionV2(Box<AccountEntryExtensionV2>),

    AccountEntryExtensionV1(Box<AccountEntryExtensionV1>),

    AccountEntry(Box<AccountEntry>),

    TrustLineFlags(Box<TrustLineFlags>),

    LiquidityPoolType(Box<LiquidityPoolType>),

    TrustLineAsset(Box<TrustLineAsset>),

    TrustLineEntryExtensionV2(Box<TrustLineEntryExtensionV2>),

    TrustLineEntry(Box<TrustLineEntry>),

    OfferEntryFlags(Box<OfferEntryFlags>),

    OfferEntry(Box<OfferEntry>),

    DataEntry(Box<DataEntry>),

    ClaimPredicateType(Box<ClaimPredicateType>),

    ClaimPredicate(Box<ClaimPredicate>),

    ClaimantType(Box<ClaimantType>),

    Claimant(Box<Claimant>),

    ClaimableBalanceFlags(Box<ClaimableBalanceFlags>),

    ClaimableBalanceEntryExtensionV1(Box<ClaimableBalanceEntryExtensionV1>),

    ClaimableBalanceEntry(Box<ClaimableBalanceEntry>),

    LiquidityPoolConstantProductParameters(Box<LiquidityPoolConstantProductParameters>),

    LiquidityPoolEntry(Box<LiquidityPoolEntry>),

    ContractDataDurability(Box<ContractDataDurability>),

    ContractDataEntry(Box<ContractDataEntry>),

    ContractCodeCostInputs(Box<ContractCodeCostInputs>),

    ContractCodeEntry(Box<ContractCodeEntry>),

    TtlEntry(Box<TtlEntry>),

    LedgerEntryExtensionV1(Box<LedgerEntryExtensionV1>),

    LedgerEntry(Box<LedgerEntry>),

    LedgerKey(Box<LedgerKey>),

    EnvelopeType(Box<EnvelopeType>),

    BucketListType(Box<BucketListType>),

    BucketEntryType(Box<BucketEntryType>),

    HotArchiveBucketEntryType(Box<HotArchiveBucketEntryType>),

    BucketMetadata(Box<BucketMetadata>),

    BucketEntry(Box<BucketEntry>),

    HotArchiveBucketEntry(Box<HotArchiveBucketEntry>),

    UpgradeType(Box<UpgradeType>),

    StellarValueType(Box<StellarValueType>),

    LedgerCloseValueSignature(Box<LedgerCloseValueSignature>),

    StellarValue(Box<StellarValue>),

    LedgerHeaderFlags(Box<LedgerHeaderFlags>),

    LedgerHeaderExtensionV1(Box<LedgerHeaderExtensionV1>),

    LedgerHeader(Box<LedgerHeader>),

    LedgerUpgradeType(Box<LedgerUpgradeType>),

    ConfigUpgradeSetKey(Box<ConfigUpgradeSetKey>),

    LedgerUpgrade(Box<LedgerUpgrade>),

    ConfigUpgradeSet(Box<ConfigUpgradeSet>),

    TxSetComponentType(Box<TxSetComponentType>),

    DependentTxCluster(Box<DependentTxCluster>),

    ParallelTxExecutionStage(Box<ParallelTxExecutionStage>),

    ParallelTxsComponent(Box<ParallelTxsComponent>),

    TxSetComponent(Box<TxSetComponent>),

    TransactionPhase(Box<TransactionPhase>),

    TransactionSet(Box<TransactionSet>),

    TransactionSetV1(Box<TransactionSetV1>),

    GeneralizedTransactionSet(Box<GeneralizedTransactionSet>),

    TransactionResultPair(Box<TransactionResultPair>),

    TransactionResultSet(Box<TransactionResultSet>),

    TransactionHistoryEntry(Box<TransactionHistoryEntry>),

    TransactionHistoryResultEntry(Box<TransactionHistoryResultEntry>),

    LedgerHeaderHistoryEntry(Box<LedgerHeaderHistoryEntry>),

    LedgerScpMessages(Box<LedgerScpMessages>),

    ScpHistoryEntryV0(Box<ScpHistoryEntryV0>),

    ScpHistoryEntry(Box<ScpHistoryEntry>),

    LedgerEntryChangeType(Box<LedgerEntryChangeType>),

    LedgerEntryChange(Box<LedgerEntryChange>),

    LedgerEntryChanges(Box<LedgerEntryChanges>),

    OperationMeta(Box<OperationMeta>),

    TransactionMetaV1(Box<TransactionMetaV1>),

    TransactionMetaV2(Box<TransactionMetaV2>),

    ContractEventType(Box<ContractEventType>),

    ContractEvent(Box<ContractEvent>),

    DiagnosticEvent(Box<DiagnosticEvent>),

    SorobanTransactionMetaExtV1(Box<SorobanTransactionMetaExtV1>),

    SorobanTransactionMetaExt(Box<SorobanTransactionMetaExt>),

    SorobanTransactionMeta(Box<SorobanTransactionMeta>),

    TransactionMetaV3(Box<TransactionMetaV3>),

    OperationMetaV2(Box<OperationMetaV2>),

    SorobanTransactionMetaV2(Box<SorobanTransactionMetaV2>),

    TransactionEventStage(Box<TransactionEventStage>),

    TransactionEvent(Box<TransactionEvent>),

    TransactionMetaV4(Box<TransactionMetaV4>),

    InvokeHostFunctionSuccessPreImage(Box<InvokeHostFunctionSuccessPreImage>),

    TransactionMeta(Box<TransactionMeta>),

    TransactionResultMeta(Box<TransactionResultMeta>),

    TransactionResultMetaV1(Box<TransactionResultMetaV1>),

    UpgradeEntryMeta(Box<UpgradeEntryMeta>),

    LedgerCloseMetaV0(Box<LedgerCloseMetaV0>),

    LedgerCloseMetaExtV1(Box<LedgerCloseMetaExtV1>),

    LedgerCloseMetaExt(Box<LedgerCloseMetaExt>),

    LedgerCloseMetaV1(Box<LedgerCloseMetaV1>),

    LedgerCloseMetaV2(Box<LedgerCloseMetaV2>),

    LedgerCloseMeta(Box<LedgerCloseMeta>),

    ErrorCode(Box<ErrorCode>),

    SError(Box<SError>),

    SendMore(Box<SendMore>),

    SendMoreExtended(Box<SendMoreExtended>),

    AuthCert(Box<AuthCert>),

    Hello(Box<Hello>),

    Auth(Box<Auth>),

    IpAddrType(Box<IpAddrType>),

    PeerAddress(Box<PeerAddress>),

    MessageType(Box<MessageType>),

    DontHave(Box<DontHave>),

    SurveyMessageCommandType(Box<SurveyMessageCommandType>),

    SurveyMessageResponseType(Box<SurveyMessageResponseType>),

    TimeSlicedSurveyStartCollectingMessage(Box<TimeSlicedSurveyStartCollectingMessage>),

    SignedTimeSlicedSurveyStartCollectingMessage(Box<SignedTimeSlicedSurveyStartCollectingMessage>),

    TimeSlicedSurveyStopCollectingMessage(Box<TimeSlicedSurveyStopCollectingMessage>),

    SignedTimeSlicedSurveyStopCollectingMessage(Box<SignedTimeSlicedSurveyStopCollectingMessage>),

    SurveyRequestMessage(Box<SurveyRequestMessage>),

    TimeSlicedSurveyRequestMessage(Box<TimeSlicedSurveyRequestMessage>),

    SignedTimeSlicedSurveyRequestMessage(Box<SignedTimeSlicedSurveyRequestMessage>),

    EncryptedBody(Box<EncryptedBody>),

    SurveyResponseMessage(Box<SurveyResponseMessage>),

    TimeSlicedSurveyResponseMessage(Box<TimeSlicedSurveyResponseMessage>),

    SignedTimeSlicedSurveyResponseMessage(Box<SignedTimeSlicedSurveyResponseMessage>),

    PeerStats(Box<PeerStats>),

    TimeSlicedNodeData(Box<TimeSlicedNodeData>),

    TimeSlicedPeerData(Box<TimeSlicedPeerData>),

    TimeSlicedPeerDataList(Box<TimeSlicedPeerDataList>),

    TopologyResponseBodyV2(Box<TopologyResponseBodyV2>),

    SurveyResponseBody(Box<SurveyResponseBody>),

    TxAdvertVector(Box<TxAdvertVector>),

    FloodAdvert(Box<FloodAdvert>),

    TxDemandVector(Box<TxDemandVector>),

    FloodDemand(Box<FloodDemand>),

    StellarMessage(Box<StellarMessage>),

    AuthenticatedMessage(Box<AuthenticatedMessage>),

    LiquidityPoolParameters(Box<LiquidityPoolParameters>),

    MuxedAccount(Box<MuxedAccount>),

    DecoratedSignature(Box<DecoratedSignature>),

    OperationType(Box<OperationType>),

    CreateAccountOp(Box<CreateAccountOp>),

    PaymentOp(Box<PaymentOp>),

    PathPaymentStrictReceiveOp(Box<PathPaymentStrictReceiveOp>),

    PathPaymentStrictSendOp(Box<PathPaymentStrictSendOp>),

    ManageSellOfferOp(Box<ManageSellOfferOp>),

    ManageBuyOfferOp(Box<ManageBuyOfferOp>),

    CreatePassiveSellOfferOp(Box<CreatePassiveSellOfferOp>),

    SetOptionsOp(Box<SetOptionsOp>),

    ChangeTrustAsset(Box<ChangeTrustAsset>),

    ChangeTrustOp(Box<ChangeTrustOp>),

    AllowTrustOp(Box<AllowTrustOp>),

    ManageDataOp(Box<ManageDataOp>),

    BumpSequenceOp(Box<BumpSequenceOp>),

    CreateClaimableBalanceOp(Box<CreateClaimableBalanceOp>),

    ClaimClaimableBalanceOp(Box<ClaimClaimableBalanceOp>),

    BeginSponsoringFutureReservesOp(Box<BeginSponsoringFutureReservesOp>),

    RevokeSponsorshipType(Box<RevokeSponsorshipType>),

    RevokeSponsorshipOp(Box<RevokeSponsorshipOp>),

    ClawbackOp(Box<ClawbackOp>),

    ClawbackClaimableBalanceOp(Box<ClawbackClaimableBalanceOp>),

    SetTrustLineFlagsOp(Box<SetTrustLineFlagsOp>),

    LiquidityPoolDepositOp(Box<LiquidityPoolDepositOp>),

    LiquidityPoolWithdrawOp(Box<LiquidityPoolWithdrawOp>),

    HostFunctionType(Box<HostFunctionType>),

    ContractIdPreimageType(Box<ContractIdPreimageType>),

    ContractIdPreimage(Box<ContractIdPreimage>),

    CreateContractArgs(Box<CreateContractArgs>),

    CreateContractArgsV2(Box<CreateContractArgsV2>),

    InvokeContractArgs(Box<InvokeContractArgs>),

    HostFunction(Box<HostFunction>),

    SorobanAuthorizedFunctionType(Box<SorobanAuthorizedFunctionType>),

    SorobanAuthorizedFunction(Box<SorobanAuthorizedFunction>),

    SorobanAuthorizedInvocation(Box<SorobanAuthorizedInvocation>),

    SorobanAddressCredentials(Box<SorobanAddressCredentials>),

    SorobanCredentialsType(Box<SorobanCredentialsType>),

    SorobanCredentials(Box<SorobanCredentials>),

    SorobanAuthorizationEntry(Box<SorobanAuthorizationEntry>),

    SorobanAuthorizationEntries(Box<SorobanAuthorizationEntries>),

    InvokeHostFunctionOp(Box<InvokeHostFunctionOp>),

    ExtendFootprintTtlOp(Box<ExtendFootprintTtlOp>),

    RestoreFootprintOp(Box<RestoreFootprintOp>),

    Operation(Box<Operation>),

    HashIdPreimage(Box<HashIdPreimage>),

    MemoType(Box<MemoType>),

    Memo(Box<Memo>),

    TimeBounds(Box<TimeBounds>),

    LedgerBounds(Box<LedgerBounds>),

    PreconditionsV2(Box<PreconditionsV2>),

    PreconditionType(Box<PreconditionType>),

    Preconditions(Box<Preconditions>),

    LedgerFootprint(Box<LedgerFootprint>),

    SorobanResources(Box<SorobanResources>),

    SorobanResourcesExtV0(Box<SorobanResourcesExtV0>),

    SorobanTransactionData(Box<SorobanTransactionData>),

    TransactionV0(Box<TransactionV0>),

    TransactionV0Envelope(Box<TransactionV0Envelope>),

    Transaction(Box<Transaction>),

    TransactionV1Envelope(Box<TransactionV1Envelope>),

    FeeBumpTransaction(Box<FeeBumpTransaction>),

    FeeBumpTransactionEnvelope(Box<FeeBumpTransactionEnvelope>),

    TransactionEnvelope(Box<TransactionEnvelope>),

    TransactionSignaturePayload(Box<TransactionSignaturePayload>),

    ClaimAtomType(Box<ClaimAtomType>),

    ClaimOfferAtomV0(Box<ClaimOfferAtomV0>),

    ClaimOfferAtom(Box<ClaimOfferAtom>),

    ClaimLiquidityAtom(Box<ClaimLiquidityAtom>),

    ClaimAtom(Box<ClaimAtom>),

    CreateAccountResultCode(Box<CreateAccountResultCode>),

    CreateAccountResult(Box<CreateAccountResult>),

    PaymentResultCode(Box<PaymentResultCode>),

    PaymentResult(Box<PaymentResult>),

    PathPaymentStrictReceiveResultCode(Box<PathPaymentStrictReceiveResultCode>),

    SimplePaymentResult(Box<SimplePaymentResult>),

    PathPaymentStrictReceiveResult(Box<PathPaymentStrictReceiveResult>),

    PathPaymentStrictSendResultCode(Box<PathPaymentStrictSendResultCode>),

    PathPaymentStrictSendResult(Box<PathPaymentStrictSendResult>),

    ManageSellOfferResultCode(Box<ManageSellOfferResultCode>),

    ManageOfferEffect(Box<ManageOfferEffect>),

    ManageOfferSuccessResult(Box<ManageOfferSuccessResult>),

    ManageSellOfferResult(Box<ManageSellOfferResult>),

    ManageBuyOfferResultCode(Box<ManageBuyOfferResultCode>),

    ManageBuyOfferResult(Box<ManageBuyOfferResult>),

    SetOptionsResultCode(Box<SetOptionsResultCode>),

    SetOptionsResult(Box<SetOptionsResult>),

    ChangeTrustResultCode(Box<ChangeTrustResultCode>),

    ChangeTrustResult(Box<ChangeTrustResult>),

    AllowTrustResultCode(Box<AllowTrustResultCode>),

    AllowTrustResult(Box<AllowTrustResult>),

    AccountMergeResultCode(Box<AccountMergeResultCode>),

    AccountMergeResult(Box<AccountMergeResult>),

    InflationResultCode(Box<InflationResultCode>),

    InflationPayout(Box<InflationPayout>),

    InflationResult(Box<InflationResult>),

    ManageDataResultCode(Box<ManageDataResultCode>),

    ManageDataResult(Box<ManageDataResult>),

    BumpSequenceResultCode(Box<BumpSequenceResultCode>),

    BumpSequenceResult(Box<BumpSequenceResult>),

    CreateClaimableBalanceResultCode(Box<CreateClaimableBalanceResultCode>),

    CreateClaimableBalanceResult(Box<CreateClaimableBalanceResult>),

    ClaimClaimableBalanceResultCode(Box<ClaimClaimableBalanceResultCode>),

    ClaimClaimableBalanceResult(Box<ClaimClaimableBalanceResult>),

    BeginSponsoringFutureReservesResultCode(Box<BeginSponsoringFutureReservesResultCode>),

    BeginSponsoringFutureReservesResult(Box<BeginSponsoringFutureReservesResult>),

    EndSponsoringFutureReservesResultCode(Box<EndSponsoringFutureReservesResultCode>),

    EndSponsoringFutureReservesResult(Box<EndSponsoringFutureReservesResult>),

    RevokeSponsorshipResultCode(Box<RevokeSponsorshipResultCode>),

    RevokeSponsorshipResult(Box<RevokeSponsorshipResult>),

    ClawbackResultCode(Box<ClawbackResultCode>),

    ClawbackResult(Box<ClawbackResult>),

    ClawbackClaimableBalanceResultCode(Box<ClawbackClaimableBalanceResultCode>),

    ClawbackClaimableBalanceResult(Box<ClawbackClaimableBalanceResult>),

    SetTrustLineFlagsResultCode(Box<SetTrustLineFlagsResultCode>),

    SetTrustLineFlagsResult(Box<SetTrustLineFlagsResult>),

    LiquidityPoolDepositResultCode(Box<LiquidityPoolDepositResultCode>),

    LiquidityPoolDepositResult(Box<LiquidityPoolDepositResult>),

    LiquidityPoolWithdrawResultCode(Box<LiquidityPoolWithdrawResultCode>),

    LiquidityPoolWithdrawResult(Box<LiquidityPoolWithdrawResult>),

    InvokeHostFunctionResultCode(Box<InvokeHostFunctionResultCode>),

    InvokeHostFunctionResult(Box<InvokeHostFunctionResult>),

    ExtendFootprintTtlResultCode(Box<ExtendFootprintTtlResultCode>),

    ExtendFootprintTtlResult(Box<ExtendFootprintTtlResult>),

    RestoreFootprintResultCode(Box<RestoreFootprintResultCode>),

    RestoreFootprintResult(Box<RestoreFootprintResult>),

    OperationResultCode(Box<OperationResultCode>),

    OperationResult(Box<OperationResult>),

    TransactionResultCode(Box<TransactionResultCode>),

    InnerTransactionResult(Box<InnerTransactionResult>),

    InnerTransactionResultPair(Box<InnerTransactionResultPair>),

    TransactionResult(Box<TransactionResult>),

    Hash(Box<Hash>),

    Uint256(Box<Uint256>),

    Uint32(Box<Uint32>),

    Int32(Box<Int32>),

    Uint64(Box<Uint64>),

    Int64(Box<Int64>),

    TimePoint(Box<TimePoint>),

    Duration(Box<Duration>),

    ExtensionPoint(Box<ExtensionPoint>),

    CryptoKeyType(Box<CryptoKeyType>),

    PublicKeyType(Box<PublicKeyType>),

    SignerKeyType(Box<SignerKeyType>),

    PublicKey(Box<PublicKey>),

    SignerKey(Box<SignerKey>),

    Signature(Box<Signature>),

    SignatureHint(Box<SignatureHint>),

    NodeId(Box<NodeId>),

    AccountId(Box<AccountId>),

    ContractId(Box<ContractId>),

    Curve25519Secret(Box<Curve25519Secret>),

    Curve25519Public(Box<Curve25519Public>),

    HmacSha256Key(Box<HmacSha256Key>),

    HmacSha256Mac(Box<HmacSha256Mac>),

    ShortHashSeed(Box<ShortHashSeed>),

    BinaryFuseFilterType(Box<BinaryFuseFilterType>),

    SerializedBinaryFuseFilter(Box<SerializedBinaryFuseFilter>),

    PoolId(Box<PoolId>),

    ClaimableBalanceIdType(Box<ClaimableBalanceIdType>),

    ClaimableBalanceId(Box<ClaimableBalanceId>),
}

impl Type {
    pub const VARIANTS: [TypeVariant; 463] = [
        TypeVariant::ScpStatementPrepare,
        TypeVariant::ScpStatementConfirm,
        TypeVariant::ScpStatementExternalize,
        TypeVariant::ScpStatementPledges,
        TypeVariant::ScEnvMetaEntryInterfaceVersion,
        TypeVariant::AccountEntryExtensionV2Ext,
        TypeVariant::AccountEntryExtensionV1Ext,
        TypeVariant::AccountEntryExt,
        TypeVariant::TrustLineEntryExtensionV2Ext,
        TypeVariant::TrustLineEntryV1Ext,
        TypeVariant::TrustLineEntryV1,
        TypeVariant::TrustLineEntryExt,
        TypeVariant::OfferEntryExt,
        TypeVariant::DataEntryExt,
        TypeVariant::ClaimantV0,
        TypeVariant::ClaimableBalanceEntryExtensionV1Ext,
        TypeVariant::ClaimableBalanceEntryExt,
        TypeVariant::LiquidityPoolEntryConstantProduct,
        TypeVariant::LiquidityPoolEntryBody,
        TypeVariant::ContractCodeEntryV1,
        TypeVariant::ContractCodeEntryExt,
        TypeVariant::LedgerEntryExtensionV1Ext,
        TypeVariant::LedgerEntryData,
        TypeVariant::LedgerEntryExt,
        TypeVariant::LedgerKeyAccount,
        TypeVariant::LedgerKeyTrustLine,
        TypeVariant::LedgerKeyOffer,
        TypeVariant::LedgerKeyData,
        TypeVariant::LedgerKeyClaimableBalance,
        TypeVariant::LedgerKeyLiquidityPool,
        TypeVariant::LedgerKeyContractData,
        TypeVariant::LedgerKeyContractCode,
        TypeVariant::LedgerKeyConfigSetting,
        TypeVariant::LedgerKeyTtl,
        TypeVariant::BucketMetadataExt,
        TypeVariant::StellarValueExt,
        TypeVariant::LedgerHeaderExtensionV1Ext,
        TypeVariant::LedgerHeaderExt,
        TypeVariant::TxSetComponentTxsMaybeDiscountedFee,
        TypeVariant::TransactionHistoryEntryExt,
        TypeVariant::TransactionHistoryResultEntryExt,
        TypeVariant::LedgerHeaderHistoryEntryExt,
        TypeVariant::ContractEventV0,
        TypeVariant::ContractEventBody,
        TypeVariant::PeerAddressIp,
        TypeVariant::AuthenticatedMessageV0,
        TypeVariant::MuxedAccountMed25519,
        TypeVariant::RevokeSponsorshipOpSigner,
        TypeVariant::ContractIdPreimageFromAddress,
        TypeVariant::OperationBody,
        TypeVariant::HashIdPreimageOperationId,
        TypeVariant::HashIdPreimageRevokeId,
        TypeVariant::HashIdPreimageContractId,
        TypeVariant::HashIdPreimageSorobanAuthorization,
        TypeVariant::SorobanTransactionDataExt,
        TypeVariant::TransactionV0Ext,
        TypeVariant::TransactionExt,
        TypeVariant::FeeBumpTransactionInnerTx,
        TypeVariant::FeeBumpTransactionExt,
        TypeVariant::TransactionSignaturePayloadTaggedTransaction,
        TypeVariant::PathPaymentStrictReceiveResultSuccess,
        TypeVariant::PathPaymentStrictSendResultSuccess,
        TypeVariant::ManageOfferSuccessResultOffer,
        TypeVariant::OperationResultTr,
        TypeVariant::InnerTransactionResultResult,
        TypeVariant::InnerTransactionResultExt,
        TypeVariant::TransactionResultResult,
        TypeVariant::TransactionResultExt,
        TypeVariant::SignerKeyEd25519SignedPayload,
        TypeVariant::Value,
        TypeVariant::ScpBallot,
        TypeVariant::ScpStatementType,
        TypeVariant::ScpNomination,
        TypeVariant::ScpStatement,
        TypeVariant::ScpEnvelope,
        TypeVariant::ScpQuorumSet,
        TypeVariant::ConfigSettingContractExecutionLanesV0,
        TypeVariant::ConfigSettingContractComputeV0,
        TypeVariant::ConfigSettingContractParallelComputeV0,
        TypeVariant::ConfigSettingContractLedgerCostV0,
        TypeVariant::ConfigSettingContractLedgerCostExtV0,
        TypeVariant::ConfigSettingContractHistoricalDataV0,
        TypeVariant::ConfigSettingContractEventsV0,
        TypeVariant::ConfigSettingContractBandwidthV0,
        TypeVariant::ContractCostType,
        TypeVariant::ContractCostParamEntry,
        TypeVariant::StateArchivalSettings,
        TypeVariant::EvictionIterator,
        TypeVariant::ConfigSettingScpTiming,
        TypeVariant::ContractCostParams,
        TypeVariant::ConfigSettingId,
        TypeVariant::ConfigSettingEntry,
        TypeVariant::ScEnvMetaKind,
        TypeVariant::ScEnvMetaEntry,
        TypeVariant::ScMetaV0,
        TypeVariant::ScMetaKind,
        TypeVariant::ScMetaEntry,
        TypeVariant::ScSpecType,
        TypeVariant::ScSpecTypeOption,
        TypeVariant::ScSpecTypeResult,
        TypeVariant::ScSpecTypeVec,
        TypeVariant::ScSpecTypeMap,
        TypeVariant::ScSpecTypeTuple,
        TypeVariant::ScSpecTypeBytesN,
        TypeVariant::ScSpecTypeUdt,
        TypeVariant::ScSpecTypeDef,
        TypeVariant::ScSpecUdtStructFieldV0,
        TypeVariant::ScSpecUdtStructV0,
        TypeVariant::ScSpecUdtUnionCaseVoidV0,
        TypeVariant::ScSpecUdtUnionCaseTupleV0,
        TypeVariant::ScSpecUdtUnionCaseV0Kind,
        TypeVariant::ScSpecUdtUnionCaseV0,
        TypeVariant::ScSpecUdtUnionV0,
        TypeVariant::ScSpecUdtEnumCaseV0,
        TypeVariant::ScSpecUdtEnumV0,
        TypeVariant::ScSpecUdtErrorEnumCaseV0,
        TypeVariant::ScSpecUdtErrorEnumV0,
        TypeVariant::ScSpecFunctionInputV0,
        TypeVariant::ScSpecFunctionV0,
        TypeVariant::ScSpecEventParamLocationV0,
        TypeVariant::ScSpecEventParamV0,
        TypeVariant::ScSpecEventDataFormat,
        TypeVariant::ScSpecEventV0,
        TypeVariant::ScSpecEntryKind,
        TypeVariant::ScSpecEntry,
        TypeVariant::ScValType,
        TypeVariant::ScErrorType,
        TypeVariant::ScErrorCode,
        TypeVariant::ScError,
        TypeVariant::UInt128Parts,
        TypeVariant::Int128Parts,
        TypeVariant::UInt256Parts,
        TypeVariant::Int256Parts,
        TypeVariant::ContractExecutableType,
        TypeVariant::ContractExecutable,
        TypeVariant::ScAddressType,
        TypeVariant::MuxedEd25519Account,
        TypeVariant::ScAddress,
        TypeVariant::ScVec,
        TypeVariant::ScMap,
        TypeVariant::ScBytes,
        TypeVariant::ScString,
        TypeVariant::ScSymbol,
        TypeVariant::ScNonceKey,
        TypeVariant::ScContractInstance,
        TypeVariant::ScVal,
        TypeVariant::ScMapEntry,
        TypeVariant::LedgerCloseMetaBatch,
        TypeVariant::StoredTransactionSet,
        TypeVariant::StoredDebugTransactionSet,
        TypeVariant::PersistedScpStateV0,
        TypeVariant::PersistedScpStateV1,
        TypeVariant::PersistedScpState,
        TypeVariant::Thresholds,
        TypeVariant::String32,
        TypeVariant::String64,
        TypeVariant::SequenceNumber,
        TypeVariant::DataValue,
        TypeVariant::AssetCode4,
        TypeVariant::AssetCode12,
        TypeVariant::AssetType,
        TypeVariant::AssetCode,
        TypeVariant::AlphaNum4,
        TypeVariant::AlphaNum12,
        TypeVariant::Asset,
        TypeVariant::Price,
        TypeVariant::Liabilities,
        TypeVariant::ThresholdIndexes,
        TypeVariant::LedgerEntryType,
        TypeVariant::Signer,
        TypeVariant::AccountFlags,
        TypeVariant::SponsorshipDescriptor,
        TypeVariant::AccountEntryExtensionV3,
        TypeVariant::AccountEntryExtensionV2,
        TypeVariant::AccountEntryExtensionV1,
        TypeVariant::AccountEntry,
        TypeVariant::TrustLineFlags,
        TypeVariant::LiquidityPoolType,
        TypeVariant::TrustLineAsset,
        TypeVariant::TrustLineEntryExtensionV2,
        TypeVariant::TrustLineEntry,
        TypeVariant::OfferEntryFlags,
        TypeVariant::OfferEntry,
        TypeVariant::DataEntry,
        TypeVariant::ClaimPredicateType,
        TypeVariant::ClaimPredicate,
        TypeVariant::ClaimantType,
        TypeVariant::Claimant,
        TypeVariant::ClaimableBalanceFlags,
        TypeVariant::ClaimableBalanceEntryExtensionV1,
        TypeVariant::ClaimableBalanceEntry,
        TypeVariant::LiquidityPoolConstantProductParameters,
        TypeVariant::LiquidityPoolEntry,
        TypeVariant::ContractDataDurability,
        TypeVariant::ContractDataEntry,
        TypeVariant::ContractCodeCostInputs,
        TypeVariant::ContractCodeEntry,
        TypeVariant::TtlEntry,
        TypeVariant::LedgerEntryExtensionV1,
        TypeVariant::LedgerEntry,
        TypeVariant::LedgerKey,
        TypeVariant::EnvelopeType,
        TypeVariant::BucketListType,
        TypeVariant::BucketEntryType,
        TypeVariant::HotArchiveBucketEntryType,
        TypeVariant::BucketMetadata,
        TypeVariant::BucketEntry,
        TypeVariant::HotArchiveBucketEntry,
        TypeVariant::UpgradeType,
        TypeVariant::StellarValueType,
        TypeVariant::LedgerCloseValueSignature,
        TypeVariant::StellarValue,
        TypeVariant::LedgerHeaderFlags,
        TypeVariant::LedgerHeaderExtensionV1,
        TypeVariant::LedgerHeader,
        TypeVariant::LedgerUpgradeType,
        TypeVariant::ConfigUpgradeSetKey,
        TypeVariant::LedgerUpgrade,
        TypeVariant::ConfigUpgradeSet,
        TypeVariant::TxSetComponentType,
        TypeVariant::DependentTxCluster,
        TypeVariant::ParallelTxExecutionStage,
        TypeVariant::ParallelTxsComponent,
        TypeVariant::TxSetComponent,
        TypeVariant::TransactionPhase,
        TypeVariant::TransactionSet,
        TypeVariant::TransactionSetV1,
        TypeVariant::GeneralizedTransactionSet,
        TypeVariant::TransactionResultPair,
        TypeVariant::TransactionResultSet,
        TypeVariant::TransactionHistoryEntry,
        TypeVariant::TransactionHistoryResultEntry,
        TypeVariant::LedgerHeaderHistoryEntry,
        TypeVariant::LedgerScpMessages,
        TypeVariant::ScpHistoryEntryV0,
        TypeVariant::ScpHistoryEntry,
        TypeVariant::LedgerEntryChangeType,
        TypeVariant::LedgerEntryChange,
        TypeVariant::LedgerEntryChanges,
        TypeVariant::OperationMeta,
        TypeVariant::TransactionMetaV1,
        TypeVariant::TransactionMetaV2,
        TypeVariant::ContractEventType,
        TypeVariant::ContractEvent,
        TypeVariant::DiagnosticEvent,
        TypeVariant::SorobanTransactionMetaExtV1,
        TypeVariant::SorobanTransactionMetaExt,
        TypeVariant::SorobanTransactionMeta,
        TypeVariant::TransactionMetaV3,
        TypeVariant::OperationMetaV2,
        TypeVariant::SorobanTransactionMetaV2,
        TypeVariant::TransactionEventStage,
        TypeVariant::TransactionEvent,
        TypeVariant::TransactionMetaV4,
        TypeVariant::InvokeHostFunctionSuccessPreImage,
        TypeVariant::TransactionMeta,
        TypeVariant::TransactionResultMeta,
        TypeVariant::TransactionResultMetaV1,
        TypeVariant::UpgradeEntryMeta,
        TypeVariant::LedgerCloseMetaV0,
        TypeVariant::LedgerCloseMetaExtV1,
        TypeVariant::LedgerCloseMetaExt,
        TypeVariant::LedgerCloseMetaV1,
        TypeVariant::LedgerCloseMetaV2,
        TypeVariant::LedgerCloseMeta,
        TypeVariant::ErrorCode,
        TypeVariant::SError,
        TypeVariant::SendMore,
        TypeVariant::SendMoreExtended,
        TypeVariant::AuthCert,
        TypeVariant::Hello,
        TypeVariant::Auth,
        TypeVariant::IpAddrType,
        TypeVariant::PeerAddress,
        TypeVariant::MessageType,
        TypeVariant::DontHave,
        TypeVariant::SurveyMessageCommandType,
        TypeVariant::SurveyMessageResponseType,
        TypeVariant::TimeSlicedSurveyStartCollectingMessage,
        TypeVariant::SignedTimeSlicedSurveyStartCollectingMessage,
        TypeVariant::TimeSlicedSurveyStopCollectingMessage,
        TypeVariant::SignedTimeSlicedSurveyStopCollectingMessage,
        TypeVariant::SurveyRequestMessage,
        TypeVariant::TimeSlicedSurveyRequestMessage,
        TypeVariant::SignedTimeSlicedSurveyRequestMessage,
        TypeVariant::EncryptedBody,
        TypeVariant::SurveyResponseMessage,
        TypeVariant::TimeSlicedSurveyResponseMessage,
        TypeVariant::SignedTimeSlicedSurveyResponseMessage,
        TypeVariant::PeerStats,
        TypeVariant::TimeSlicedNodeData,
        TypeVariant::TimeSlicedPeerData,
        TypeVariant::TimeSlicedPeerDataList,
        TypeVariant::TopologyResponseBodyV2,
        TypeVariant::SurveyResponseBody,
        TypeVariant::TxAdvertVector,
        TypeVariant::FloodAdvert,
        TypeVariant::TxDemandVector,
        TypeVariant::FloodDemand,
        TypeVariant::StellarMessage,
        TypeVariant::AuthenticatedMessage,
        TypeVariant::LiquidityPoolParameters,
        TypeVariant::MuxedAccount,
        TypeVariant::DecoratedSignature,
        TypeVariant::OperationType,
        TypeVariant::CreateAccountOp,
        TypeVariant::PaymentOp,
        TypeVariant::PathPaymentStrictReceiveOp,
        TypeVariant::PathPaymentStrictSendOp,
        TypeVariant::ManageSellOfferOp,
        TypeVariant::ManageBuyOfferOp,
        TypeVariant::CreatePassiveSellOfferOp,
        TypeVariant::SetOptionsOp,
        TypeVariant::ChangeTrustAsset,
        TypeVariant::ChangeTrustOp,
        TypeVariant::AllowTrustOp,
        TypeVariant::ManageDataOp,
        TypeVariant::BumpSequenceOp,
        TypeVariant::CreateClaimableBalanceOp,
        TypeVariant::ClaimClaimableBalanceOp,
        TypeVariant::BeginSponsoringFutureReservesOp,
        TypeVariant::RevokeSponsorshipType,
        TypeVariant::RevokeSponsorshipOp,
        TypeVariant::ClawbackOp,
        TypeVariant::ClawbackClaimableBalanceOp,
        TypeVariant::SetTrustLineFlagsOp,
        TypeVariant::LiquidityPoolDepositOp,
        TypeVariant::LiquidityPoolWithdrawOp,
        TypeVariant::HostFunctionType,
        TypeVariant::ContractIdPreimageType,
        TypeVariant::ContractIdPreimage,
        TypeVariant::CreateContractArgs,
        TypeVariant::CreateContractArgsV2,
        TypeVariant::InvokeContractArgs,
        TypeVariant::HostFunction,
        TypeVariant::SorobanAuthorizedFunctionType,
        TypeVariant::SorobanAuthorizedFunction,
        TypeVariant::SorobanAuthorizedInvocation,
        TypeVariant::SorobanAddressCredentials,
        TypeVariant::SorobanCredentialsType,
        TypeVariant::SorobanCredentials,
        TypeVariant::SorobanAuthorizationEntry,
        TypeVariant::SorobanAuthorizationEntries,
        TypeVariant::InvokeHostFunctionOp,
        TypeVariant::ExtendFootprintTtlOp,
        TypeVariant::RestoreFootprintOp,
        TypeVariant::Operation,
        TypeVariant::HashIdPreimage,
        TypeVariant::MemoType,
        TypeVariant::Memo,
        TypeVariant::TimeBounds,
        TypeVariant::LedgerBounds,
        TypeVariant::PreconditionsV2,
        TypeVariant::PreconditionType,
        TypeVariant::Preconditions,
        TypeVariant::LedgerFootprint,
        TypeVariant::SorobanResources,
        TypeVariant::SorobanResourcesExtV0,
        TypeVariant::SorobanTransactionData,
        TypeVariant::TransactionV0,
        TypeVariant::TransactionV0Envelope,
        TypeVariant::Transaction,
        TypeVariant::TransactionV1Envelope,
        TypeVariant::FeeBumpTransaction,
        TypeVariant::FeeBumpTransactionEnvelope,
        TypeVariant::TransactionEnvelope,
        TypeVariant::TransactionSignaturePayload,
        TypeVariant::ClaimAtomType,
        TypeVariant::ClaimOfferAtomV0,
        TypeVariant::ClaimOfferAtom,
        TypeVariant::ClaimLiquidityAtom,
        TypeVariant::ClaimAtom,
        TypeVariant::CreateAccountResultCode,
        TypeVariant::CreateAccountResult,
        TypeVariant::PaymentResultCode,
        TypeVariant::PaymentResult,
        TypeVariant::PathPaymentStrictReceiveResultCode,
        TypeVariant::SimplePaymentResult,
        TypeVariant::PathPaymentStrictReceiveResult,
        TypeVariant::PathPaymentStrictSendResultCode,
        TypeVariant::PathPaymentStrictSendResult,
        TypeVariant::ManageSellOfferResultCode,
        TypeVariant::ManageOfferEffect,
        TypeVariant::ManageOfferSuccessResult,
        TypeVariant::ManageSellOfferResult,
        TypeVariant::ManageBuyOfferResultCode,
        TypeVariant::ManageBuyOfferResult,
        TypeVariant::SetOptionsResultCode,
        TypeVariant::SetOptionsResult,
        TypeVariant::ChangeTrustResultCode,
        TypeVariant::ChangeTrustResult,
        TypeVariant::AllowTrustResultCode,
        TypeVariant::AllowTrustResult,
        TypeVariant::AccountMergeResultCode,
        TypeVariant::AccountMergeResult,
        TypeVariant::InflationResultCode,
        TypeVariant::InflationPayout,
        TypeVariant::InflationResult,
        TypeVariant::ManageDataResultCode,
        TypeVariant::ManageDataResult,
        TypeVariant::BumpSequenceResultCode,
        TypeVariant::BumpSequenceResult,
        TypeVariant::CreateClaimableBalanceResultCode,
        TypeVariant::CreateClaimableBalanceResult,
        TypeVariant::ClaimClaimableBalanceResultCode,
        TypeVariant::ClaimClaimableBalanceResult,
        TypeVariant::BeginSponsoringFutureReservesResultCode,
        TypeVariant::BeginSponsoringFutureReservesResult,
        TypeVariant::EndSponsoringFutureReservesResultCode,
        TypeVariant::EndSponsoringFutureReservesResult,
        TypeVariant::RevokeSponsorshipResultCode,
        TypeVariant::RevokeSponsorshipResult,
        TypeVariant::ClawbackResultCode,
        TypeVariant::ClawbackResult,
        TypeVariant::ClawbackClaimableBalanceResultCode,
        TypeVariant::ClawbackClaimableBalanceResult,
        TypeVariant::SetTrustLineFlagsResultCode,
        TypeVariant::SetTrustLineFlagsResult,
        TypeVariant::LiquidityPoolDepositResultCode,
        TypeVariant::LiquidityPoolDepositResult,
        TypeVariant::LiquidityPoolWithdrawResultCode,
        TypeVariant::LiquidityPoolWithdrawResult,
        TypeVariant::InvokeHostFunctionResultCode,
        TypeVariant::InvokeHostFunctionResult,
        TypeVariant::ExtendFootprintTtlResultCode,
        TypeVariant::ExtendFootprintTtlResult,
        TypeVariant::RestoreFootprintResultCode,
        TypeVariant::RestoreFootprintResult,
        TypeVariant::OperationResultCode,
        TypeVariant::OperationResult,
        TypeVariant::TransactionResultCode,
        TypeVariant::InnerTransactionResult,
        TypeVariant::InnerTransactionResultPair,
        TypeVariant::TransactionResult,
        TypeVariant::Hash,
        TypeVariant::Uint256,
        TypeVariant::Uint32,
        TypeVariant::Int32,
        TypeVariant::Uint64,
        TypeVariant::Int64,
        TypeVariant::TimePoint,
        TypeVariant::Duration,
        TypeVariant::ExtensionPoint,
        TypeVariant::CryptoKeyType,
        TypeVariant::PublicKeyType,
        TypeVariant::SignerKeyType,
        TypeVariant::PublicKey,
        TypeVariant::SignerKey,
        TypeVariant::Signature,
        TypeVariant::SignatureHint,
        TypeVariant::NodeId,
        TypeVariant::AccountId,
        TypeVariant::ContractId,
        TypeVariant::Curve25519Secret,
        TypeVariant::Curve25519Public,
        TypeVariant::HmacSha256Key,
        TypeVariant::HmacSha256Mac,
        TypeVariant::ShortHashSeed,
        TypeVariant::BinaryFuseFilterType,
        TypeVariant::SerializedBinaryFuseFilter,
        TypeVariant::PoolId,
        TypeVariant::ClaimableBalanceIdType,
        TypeVariant::ClaimableBalanceId,
    ];
    pub const VARIANTS_STR: [&'static str; 463] = [
        "ScpStatementPrepare",
        "ScpStatementConfirm",
        "ScpStatementExternalize",
        "ScpStatementPledges",
        "ScEnvMetaEntryInterfaceVersion",
        "AccountEntryExtensionV2Ext",
        "AccountEntryExtensionV1Ext",
        "AccountEntryExt",
        "TrustLineEntryExtensionV2Ext",
        "TrustLineEntryV1Ext",
        "TrustLineEntryV1",
        "TrustLineEntryExt",
        "OfferEntryExt",
        "DataEntryExt",
        "ClaimantV0",
        "ClaimableBalanceEntryExtensionV1Ext",
        "ClaimableBalanceEntryExt",
        "LiquidityPoolEntryConstantProduct",
        "LiquidityPoolEntryBody",
        "ContractCodeEntryV1",
        "ContractCodeEntryExt",
        "LedgerEntryExtensionV1Ext",
        "LedgerEntryData",
        "LedgerEntryExt",
        "LedgerKeyAccount",
        "LedgerKeyTrustLine",
        "LedgerKeyOffer",
        "LedgerKeyData",
        "LedgerKeyClaimableBalance",
        "LedgerKeyLiquidityPool",
        "LedgerKeyContractData",
        "LedgerKeyContractCode",
        "LedgerKeyConfigSetting",
        "LedgerKeyTtl",
        "BucketMetadataExt",
        "StellarValueExt",
        "LedgerHeaderExtensionV1Ext",
        "LedgerHeaderExt",
        "TxSetComponentTxsMaybeDiscountedFee",
        "TransactionHistoryEntryExt",
        "TransactionHistoryResultEntryExt",
        "LedgerHeaderHistoryEntryExt",
        "ContractEventV0",
        "ContractEventBody",
        "PeerAddressIp",
        "AuthenticatedMessageV0",
        "MuxedAccountMed25519",
        "RevokeSponsorshipOpSigner",
        "ContractIdPreimageFromAddress",
        "OperationBody",
        "HashIdPreimageOperationId",
        "HashIdPreimageRevokeId",
        "HashIdPreimageContractId",
        "HashIdPreimageSorobanAuthorization",
        "SorobanTransactionDataExt",
        "TransactionV0Ext",
        "TransactionExt",
        "FeeBumpTransactionInnerTx",
        "FeeBumpTransactionExt",
        "TransactionSignaturePayloadTaggedTransaction",
        "PathPaymentStrictReceiveResultSuccess",
        "PathPaymentStrictSendResultSuccess",
        "ManageOfferSuccessResultOffer",
        "OperationResultTr",
        "InnerTransactionResultResult",
        "InnerTransactionResultExt",
        "TransactionResultResult",
        "TransactionResultExt",
        "SignerKeyEd25519SignedPayload",
        "Value",
        "ScpBallot",
        "ScpStatementType",
        "ScpNomination",
        "ScpStatement",
        "ScpEnvelope",
        "ScpQuorumSet",
        "ConfigSettingContractExecutionLanesV0",
        "ConfigSettingContractComputeV0",
        "ConfigSettingContractParallelComputeV0",
        "ConfigSettingContractLedgerCostV0",
        "ConfigSettingContractLedgerCostExtV0",
        "ConfigSettingContractHistoricalDataV0",
        "ConfigSettingContractEventsV0",
        "ConfigSettingContractBandwidthV0",
        "ContractCostType",
        "ContractCostParamEntry",
        "StateArchivalSettings",
        "EvictionIterator",
        "ConfigSettingScpTiming",
        "ContractCostParams",
        "ConfigSettingId",
        "ConfigSettingEntry",
        "ScEnvMetaKind",
        "ScEnvMetaEntry",
        "ScMetaV0",
        "ScMetaKind",
        "ScMetaEntry",
        "ScSpecType",
        "ScSpecTypeOption",
        "ScSpecTypeResult",
        "ScSpecTypeVec",
        "ScSpecTypeMap",
        "ScSpecTypeTuple",
        "ScSpecTypeBytesN",
        "ScSpecTypeUdt",
        "ScSpecTypeDef",
        "ScSpecUdtStructFieldV0",
        "ScSpecUdtStructV0",
        "ScSpecUdtUnionCaseVoidV0",
        "ScSpecUdtUnionCaseTupleV0",
        "ScSpecUdtUnionCaseV0Kind",
        "ScSpecUdtUnionCaseV0",
        "ScSpecUdtUnionV0",
        "ScSpecUdtEnumCaseV0",
        "ScSpecUdtEnumV0",
        "ScSpecUdtErrorEnumCaseV0",
        "ScSpecUdtErrorEnumV0",
        "ScSpecFunctionInputV0",
        "ScSpecFunctionV0",
        "ScSpecEventParamLocationV0",
        "ScSpecEventParamV0",
        "ScSpecEventDataFormat",
        "ScSpecEventV0",
        "ScSpecEntryKind",
        "ScSpecEntry",
        "ScValType",
        "ScErrorType",
        "ScErrorCode",
        "ScError",
        "UInt128Parts",
        "Int128Parts",
        "UInt256Parts",
        "Int256Parts",
        "ContractExecutableType",
        "ContractExecutable",
        "ScAddressType",
        "MuxedEd25519Account",
        "ScAddress",
        "ScVec",
        "ScMap",
        "ScBytes",
        "ScString",
        "ScSymbol",
        "ScNonceKey",
        "ScContractInstance",
        "ScVal",
        "ScMapEntry",
        "LedgerCloseMetaBatch",
        "StoredTransactionSet",
        "StoredDebugTransactionSet",
        "PersistedScpStateV0",
        "PersistedScpStateV1",
        "PersistedScpState",
        "Thresholds",
        "String32",
        "String64",
        "SequenceNumber",
        "DataValue",
        "AssetCode4",
        "AssetCode12",
        "AssetType",
        "AssetCode",
        "AlphaNum4",
        "AlphaNum12",
        "Asset",
        "Price",
        "Liabilities",
        "ThresholdIndexes",
        "LedgerEntryType",
        "Signer",
        "AccountFlags",
        "SponsorshipDescriptor",
        "AccountEntryExtensionV3",
        "AccountEntryExtensionV2",
        "AccountEntryExtensionV1",
        "AccountEntry",
        "TrustLineFlags",
        "LiquidityPoolType",
        "TrustLineAsset",
        "TrustLineEntryExtensionV2",
        "TrustLineEntry",
        "OfferEntryFlags",
        "OfferEntry",
        "DataEntry",
        "ClaimPredicateType",
        "ClaimPredicate",
        "ClaimantType",
        "Claimant",
        "ClaimableBalanceFlags",
        "ClaimableBalanceEntryExtensionV1",
        "ClaimableBalanceEntry",
        "LiquidityPoolConstantProductParameters",
        "LiquidityPoolEntry",
        "ContractDataDurability",
        "ContractDataEntry",
        "ContractCodeCostInputs",
        "ContractCodeEntry",
        "TtlEntry",
        "LedgerEntryExtensionV1",
        "LedgerEntry",
        "LedgerKey",
        "EnvelopeType",
        "BucketListType",
        "BucketEntryType",
        "HotArchiveBucketEntryType",
        "BucketMetadata",
        "BucketEntry",
        "HotArchiveBucketEntry",
        "UpgradeType",
        "StellarValueType",
        "LedgerCloseValueSignature",
        "StellarValue",
        "LedgerHeaderFlags",
        "LedgerHeaderExtensionV1",
        "LedgerHeader",
        "LedgerUpgradeType",
        "ConfigUpgradeSetKey",
        "LedgerUpgrade",
        "ConfigUpgradeSet",
        "TxSetComponentType",
        "DependentTxCluster",
        "ParallelTxExecutionStage",
        "ParallelTxsComponent",
        "TxSetComponent",
        "TransactionPhase",
        "TransactionSet",
        "TransactionSetV1",
        "GeneralizedTransactionSet",
        "TransactionResultPair",
        "TransactionResultSet",
        "TransactionHistoryEntry",
        "TransactionHistoryResultEntry",
        "LedgerHeaderHistoryEntry",
        "LedgerScpMessages",
        "ScpHistoryEntryV0",
        "ScpHistoryEntry",
        "LedgerEntryChangeType",
        "LedgerEntryChange",
        "LedgerEntryChanges",
        "OperationMeta",
        "TransactionMetaV1",
        "TransactionMetaV2",
        "ContractEventType",
        "ContractEvent",
        "DiagnosticEvent",
        "SorobanTransactionMetaExtV1",
        "SorobanTransactionMetaExt",
        "SorobanTransactionMeta",
        "TransactionMetaV3",
        "OperationMetaV2",
        "SorobanTransactionMetaV2",
        "TransactionEventStage",
        "TransactionEvent",
        "TransactionMetaV4",
        "InvokeHostFunctionSuccessPreImage",
        "TransactionMeta",
        "TransactionResultMeta",
        "TransactionResultMetaV1",
        "UpgradeEntryMeta",
        "LedgerCloseMetaV0",
        "LedgerCloseMetaExtV1",
        "LedgerCloseMetaExt",
        "LedgerCloseMetaV1",
        "LedgerCloseMetaV2",
        "LedgerCloseMeta",
        "ErrorCode",
        "SError",
        "SendMore",
        "SendMoreExtended",
        "AuthCert",
        "Hello",
        "Auth",
        "IpAddrType",
        "PeerAddress",
        "MessageType",
        "DontHave",
        "SurveyMessageCommandType",
        "SurveyMessageResponseType",
        "TimeSlicedSurveyStartCollectingMessage",
        "SignedTimeSlicedSurveyStartCollectingMessage",
        "TimeSlicedSurveyStopCollectingMessage",
        "SignedTimeSlicedSurveyStopCollectingMessage",
        "SurveyRequestMessage",
        "TimeSlicedSurveyRequestMessage",
        "SignedTimeSlicedSurveyRequestMessage",
        "EncryptedBody",
        "SurveyResponseMessage",
        "TimeSlicedSurveyResponseMessage",
        "SignedTimeSlicedSurveyResponseMessage",
        "PeerStats",
        "TimeSlicedNodeData",
        "TimeSlicedPeerData",
        "TimeSlicedPeerDataList",
        "TopologyResponseBodyV2",
        "SurveyResponseBody",
        "TxAdvertVector",
        "FloodAdvert",
        "TxDemandVector",
        "FloodDemand",
        "StellarMessage",
        "AuthenticatedMessage",
        "LiquidityPoolParameters",
        "MuxedAccount",
        "DecoratedSignature",
        "OperationType",
        "CreateAccountOp",
        "PaymentOp",
        "PathPaymentStrictReceiveOp",
        "PathPaymentStrictSendOp",
        "ManageSellOfferOp",
        "ManageBuyOfferOp",
        "CreatePassiveSellOfferOp",
        "SetOptionsOp",
        "ChangeTrustAsset",
        "ChangeTrustOp",
        "AllowTrustOp",
        "ManageDataOp",
        "BumpSequenceOp",
        "CreateClaimableBalanceOp",
        "ClaimClaimableBalanceOp",
        "BeginSponsoringFutureReservesOp",
        "RevokeSponsorshipType",
        "RevokeSponsorshipOp",
        "ClawbackOp",
        "ClawbackClaimableBalanceOp",
        "SetTrustLineFlagsOp",
        "LiquidityPoolDepositOp",
        "LiquidityPoolWithdrawOp",
        "HostFunctionType",
        "ContractIdPreimageType",
        "ContractIdPreimage",
        "CreateContractArgs",
        "CreateContractArgsV2",
        "InvokeContractArgs",
        "HostFunction",
        "SorobanAuthorizedFunctionType",
        "SorobanAuthorizedFunction",
        "SorobanAuthorizedInvocation",
        "SorobanAddressCredentials",
        "SorobanCredentialsType",
        "SorobanCredentials",
        "SorobanAuthorizationEntry",
        "SorobanAuthorizationEntries",
        "InvokeHostFunctionOp",
        "ExtendFootprintTtlOp",
        "RestoreFootprintOp",
        "Operation",
        "HashIdPreimage",
        "MemoType",
        "Memo",
        "TimeBounds",
        "LedgerBounds",
        "PreconditionsV2",
        "PreconditionType",
        "Preconditions",
        "LedgerFootprint",
        "SorobanResources",
        "SorobanResourcesExtV0",
        "SorobanTransactionData",
        "TransactionV0",
        "TransactionV0Envelope",
        "Transaction",
        "TransactionV1Envelope",
        "FeeBumpTransaction",
        "FeeBumpTransactionEnvelope",
        "TransactionEnvelope",
        "TransactionSignaturePayload",
        "ClaimAtomType",
        "ClaimOfferAtomV0",
        "ClaimOfferAtom",
        "ClaimLiquidityAtom",
        "ClaimAtom",
        "CreateAccountResultCode",
        "CreateAccountResult",
        "PaymentResultCode",
        "PaymentResult",
        "PathPaymentStrictReceiveResultCode",
        "SimplePaymentResult",
        "PathPaymentStrictReceiveResult",
        "PathPaymentStrictSendResultCode",
        "PathPaymentStrictSendResult",
        "ManageSellOfferResultCode",
        "ManageOfferEffect",
        "ManageOfferSuccessResult",
        "ManageSellOfferResult",
        "ManageBuyOfferResultCode",
        "ManageBuyOfferResult",
        "SetOptionsResultCode",
        "SetOptionsResult",
        "ChangeTrustResultCode",
        "ChangeTrustResult",
        "AllowTrustResultCode",
        "AllowTrustResult",
        "AccountMergeResultCode",
        "AccountMergeResult",
        "InflationResultCode",
        "InflationPayout",
        "InflationResult",
        "ManageDataResultCode",
        "ManageDataResult",
        "BumpSequenceResultCode",
        "BumpSequenceResult",
        "CreateClaimableBalanceResultCode",
        "CreateClaimableBalanceResult",
        "ClaimClaimableBalanceResultCode",
        "ClaimClaimableBalanceResult",
        "BeginSponsoringFutureReservesResultCode",
        "BeginSponsoringFutureReservesResult",
        "EndSponsoringFutureReservesResultCode",
        "EndSponsoringFutureReservesResult",
        "RevokeSponsorshipResultCode",
        "RevokeSponsorshipResult",
        "ClawbackResultCode",
        "ClawbackResult",
        "ClawbackClaimableBalanceResultCode",
        "ClawbackClaimableBalanceResult",
        "SetTrustLineFlagsResultCode",
        "SetTrustLineFlagsResult",
        "LiquidityPoolDepositResultCode",
        "LiquidityPoolDepositResult",
        "LiquidityPoolWithdrawResultCode",
        "LiquidityPoolWithdrawResult",
        "InvokeHostFunctionResultCode",
        "InvokeHostFunctionResult",
        "ExtendFootprintTtlResultCode",
        "ExtendFootprintTtlResult",
        "RestoreFootprintResultCode",
        "RestoreFootprintResult",
        "OperationResultCode",
        "OperationResult",
        "TransactionResultCode",
        "InnerTransactionResult",
        "InnerTransactionResultPair",
        "TransactionResult",
        "Hash",
        "Uint256",
        "Uint32",
        "Int32",
        "Uint64",
        "Int64",
        "TimePoint",
        "Duration",
        "ExtensionPoint",
        "CryptoKeyType",
        "PublicKeyType",
        "SignerKeyType",
        "PublicKey",
        "SignerKey",
        "Signature",
        "SignatureHint",
        "NodeId",
        "AccountId",
        "ContractId",
        "Curve25519Secret",
        "Curve25519Public",
        "HmacSha256Key",
        "HmacSha256Mac",
        "ShortHashSeed",
        "BinaryFuseFilterType",
        "SerializedBinaryFuseFilter",
        "PoolId",
        "ClaimableBalanceIdType",
        "ClaimableBalanceId",
    ];

    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Result<Self, Error> {
        match v {
            TypeVariant::ScpStatementPrepare => r.with_limited_depth(|r| {
                Ok(Self::ScpStatementPrepare(Box::new(
                    ScpStatementPrepare::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScpStatementConfirm => r.with_limited_depth(|r| {
                Ok(Self::ScpStatementConfirm(Box::new(
                    ScpStatementConfirm::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScpStatementExternalize => r.with_limited_depth(|r| {
                Ok(Self::ScpStatementExternalize(Box::new(
                    ScpStatementExternalize::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScpStatementPledges => r.with_limited_depth(|r| {
                Ok(Self::ScpStatementPledges(Box::new(
                    ScpStatementPledges::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScEnvMetaEntryInterfaceVersion => r.with_limited_depth(|r| {
                Ok(Self::ScEnvMetaEntryInterfaceVersion(Box::new(
                    ScEnvMetaEntryInterfaceVersion::read_xdr(r)?,
                )))
            }),

            TypeVariant::AccountEntryExtensionV2Ext => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExtensionV2Ext(Box::new(
                    AccountEntryExtensionV2Ext::read_xdr(r)?,
                )))
            }),

            TypeVariant::AccountEntryExtensionV1Ext => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExtensionV1Ext(Box::new(
                    AccountEntryExtensionV1Ext::read_xdr(r)?,
                )))
            }),

            TypeVariant::AccountEntryExt => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExt(Box::new(AccountEntryExt::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::TrustLineEntryExtensionV2Ext => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntryExtensionV2Ext(Box::new(
                    TrustLineEntryExtensionV2Ext::read_xdr(r)?,
                )))
            }),

            TypeVariant::TrustLineEntryV1Ext => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntryV1Ext(Box::new(
                    TrustLineEntryV1Ext::read_xdr(r)?,
                )))
            }),

            TypeVariant::TrustLineEntryV1 => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntryV1(Box::new(
                    TrustLineEntryV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::TrustLineEntryExt => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntryExt(Box::new(
                    TrustLineEntryExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::OfferEntryExt => r.with_limited_depth(|r| {
                Ok(Self::OfferEntryExt(Box::new(OfferEntryExt::read_xdr(r)?)))
            }),

            TypeVariant::DataEntryExt => r.with_limited_depth(|r| {
                Ok(Self::DataEntryExt(Box::new(DataEntryExt::read_xdr(r)?)))
            }),

            TypeVariant::ClaimantV0 => {
                r.with_limited_depth(|r| Ok(Self::ClaimantV0(Box::new(ClaimantV0::read_xdr(r)?))))
            }

            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(
                    ClaimableBalanceEntryExtensionV1Ext::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClaimableBalanceEntryExt => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceEntryExt(Box::new(
                    ClaimableBalanceEntryExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::LiquidityPoolEntryConstantProduct => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolEntryConstantProduct(Box::new(
                    LiquidityPoolEntryConstantProduct::read_xdr(r)?,
                )))
            }),

            TypeVariant::LiquidityPoolEntryBody => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolEntryBody(Box::new(
                    LiquidityPoolEntryBody::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractCodeEntryV1 => r.with_limited_depth(|r| {
                Ok(Self::ContractCodeEntryV1(Box::new(
                    ContractCodeEntryV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractCodeEntryExt => r.with_limited_depth(|r| {
                Ok(Self::ContractCodeEntryExt(Box::new(
                    ContractCodeEntryExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerEntryExtensionV1Ext => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryExtensionV1Ext(Box::new(
                    LedgerEntryExtensionV1Ext::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerEntryData => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryData(Box::new(LedgerEntryData::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::LedgerEntryExt => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryExt(Box::new(LedgerEntryExt::read_xdr(r)?)))
            }),

            TypeVariant::LedgerKeyAccount => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyAccount(Box::new(
                    LedgerKeyAccount::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerKeyTrustLine => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyTrustLine(Box::new(
                    LedgerKeyTrustLine::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerKeyOffer => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyOffer(Box::new(LedgerKeyOffer::read_xdr(r)?)))
            }),

            TypeVariant::LedgerKeyData => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyData(Box::new(LedgerKeyData::read_xdr(r)?)))
            }),

            TypeVariant::LedgerKeyClaimableBalance => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyClaimableBalance(Box::new(
                    LedgerKeyClaimableBalance::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerKeyLiquidityPool => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyLiquidityPool(Box::new(
                    LedgerKeyLiquidityPool::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerKeyContractData => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyContractData(Box::new(
                    LedgerKeyContractData::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerKeyContractCode => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyContractCode(Box::new(
                    LedgerKeyContractCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerKeyConfigSetting => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyConfigSetting(Box::new(
                    LedgerKeyConfigSetting::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerKeyTtl => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyTtl(Box::new(LedgerKeyTtl::read_xdr(r)?)))
            }),

            TypeVariant::BucketMetadataExt => r.with_limited_depth(|r| {
                Ok(Self::BucketMetadataExt(Box::new(
                    BucketMetadataExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::StellarValueExt => r.with_limited_depth(|r| {
                Ok(Self::StellarValueExt(Box::new(StellarValueExt::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::LedgerHeaderExtensionV1Ext => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderExtensionV1Ext(Box::new(
                    LedgerHeaderExtensionV1Ext::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerHeaderExt => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderExt(Box::new(LedgerHeaderExt::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => r.with_limited_depth(|r| {
                Ok(Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(
                    TxSetComponentTxsMaybeDiscountedFee::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionHistoryEntryExt => r.with_limited_depth(|r| {
                Ok(Self::TransactionHistoryEntryExt(Box::new(
                    TransactionHistoryEntryExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionHistoryResultEntryExt => r.with_limited_depth(|r| {
                Ok(Self::TransactionHistoryResultEntryExt(Box::new(
                    TransactionHistoryResultEntryExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerHeaderHistoryEntryExt => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderHistoryEntryExt(Box::new(
                    LedgerHeaderHistoryEntryExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractEventV0 => r.with_limited_depth(|r| {
                Ok(Self::ContractEventV0(Box::new(ContractEventV0::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::ContractEventBody => r.with_limited_depth(|r| {
                Ok(Self::ContractEventBody(Box::new(
                    ContractEventBody::read_xdr(r)?,
                )))
            }),

            TypeVariant::PeerAddressIp => r.with_limited_depth(|r| {
                Ok(Self::PeerAddressIp(Box::new(PeerAddressIp::read_xdr(r)?)))
            }),

            TypeVariant::AuthenticatedMessageV0 => r.with_limited_depth(|r| {
                Ok(Self::AuthenticatedMessageV0(Box::new(
                    AuthenticatedMessageV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::MuxedAccountMed25519 => r.with_limited_depth(|r| {
                Ok(Self::MuxedAccountMed25519(Box::new(
                    MuxedAccountMed25519::read_xdr(r)?,
                )))
            }),

            TypeVariant::RevokeSponsorshipOpSigner => r.with_limited_depth(|r| {
                Ok(Self::RevokeSponsorshipOpSigner(Box::new(
                    RevokeSponsorshipOpSigner::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractIdPreimageFromAddress => r.with_limited_depth(|r| {
                Ok(Self::ContractIdPreimageFromAddress(Box::new(
                    ContractIdPreimageFromAddress::read_xdr(r)?,
                )))
            }),

            TypeVariant::OperationBody => r.with_limited_depth(|r| {
                Ok(Self::OperationBody(Box::new(OperationBody::read_xdr(r)?)))
            }),

            TypeVariant::HashIdPreimageOperationId => r.with_limited_depth(|r| {
                Ok(Self::HashIdPreimageOperationId(Box::new(
                    HashIdPreimageOperationId::read_xdr(r)?,
                )))
            }),

            TypeVariant::HashIdPreimageRevokeId => r.with_limited_depth(|r| {
                Ok(Self::HashIdPreimageRevokeId(Box::new(
                    HashIdPreimageRevokeId::read_xdr(r)?,
                )))
            }),

            TypeVariant::HashIdPreimageContractId => r.with_limited_depth(|r| {
                Ok(Self::HashIdPreimageContractId(Box::new(
                    HashIdPreimageContractId::read_xdr(r)?,
                )))
            }),

            TypeVariant::HashIdPreimageSorobanAuthorization => r.with_limited_depth(|r| {
                Ok(Self::HashIdPreimageSorobanAuthorization(Box::new(
                    HashIdPreimageSorobanAuthorization::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanTransactionDataExt => r.with_limited_depth(|r| {
                Ok(Self::SorobanTransactionDataExt(Box::new(
                    SorobanTransactionDataExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionV0Ext => r.with_limited_depth(|r| {
                Ok(Self::TransactionV0Ext(Box::new(
                    TransactionV0Ext::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionExt => r.with_limited_depth(|r| {
                Ok(Self::TransactionExt(Box::new(TransactionExt::read_xdr(r)?)))
            }),

            TypeVariant::FeeBumpTransactionInnerTx => r.with_limited_depth(|r| {
                Ok(Self::FeeBumpTransactionInnerTx(Box::new(
                    FeeBumpTransactionInnerTx::read_xdr(r)?,
                )))
            }),

            TypeVariant::FeeBumpTransactionExt => r.with_limited_depth(|r| {
                Ok(Self::FeeBumpTransactionExt(Box::new(
                    FeeBumpTransactionExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionSignaturePayloadTaggedTransaction => {
                r.with_limited_depth(|r| {
                    Ok(Self::TransactionSignaturePayloadTaggedTransaction(
                        Box::new(TransactionSignaturePayloadTaggedTransaction::read_xdr(r)?),
                    ))
                })
            }

            TypeVariant::PathPaymentStrictReceiveResultSuccess => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictReceiveResultSuccess(Box::new(
                    PathPaymentStrictReceiveResultSuccess::read_xdr(r)?,
                )))
            }),

            TypeVariant::PathPaymentStrictSendResultSuccess => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictSendResultSuccess(Box::new(
                    PathPaymentStrictSendResultSuccess::read_xdr(r)?,
                )))
            }),

            TypeVariant::ManageOfferSuccessResultOffer => r.with_limited_depth(|r| {
                Ok(Self::ManageOfferSuccessResultOffer(Box::new(
                    ManageOfferSuccessResultOffer::read_xdr(r)?,
                )))
            }),

            TypeVariant::OperationResultTr => r.with_limited_depth(|r| {
                Ok(Self::OperationResultTr(Box::new(
                    OperationResultTr::read_xdr(r)?,
                )))
            }),

            TypeVariant::InnerTransactionResultResult => r.with_limited_depth(|r| {
                Ok(Self::InnerTransactionResultResult(Box::new(
                    InnerTransactionResultResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::InnerTransactionResultExt => r.with_limited_depth(|r| {
                Ok(Self::InnerTransactionResultExt(Box::new(
                    InnerTransactionResultExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionResultResult => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultResult(Box::new(
                    TransactionResultResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionResultExt => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultExt(Box::new(
                    TransactionResultExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::SignerKeyEd25519SignedPayload => r.with_limited_depth(|r| {
                Ok(Self::SignerKeyEd25519SignedPayload(Box::new(
                    SignerKeyEd25519SignedPayload::read_xdr(r)?,
                )))
            }),

            TypeVariant::Value => {
                r.with_limited_depth(|r| Ok(Self::Value(Box::new(Value::read_xdr(r)?))))
            }

            TypeVariant::ScpBallot => {
                r.with_limited_depth(|r| Ok(Self::ScpBallot(Box::new(ScpBallot::read_xdr(r)?))))
            }

            TypeVariant::ScpStatementType => r.with_limited_depth(|r| {
                Ok(Self::ScpStatementType(Box::new(
                    ScpStatementType::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScpNomination => r.with_limited_depth(|r| {
                Ok(Self::ScpNomination(Box::new(ScpNomination::read_xdr(r)?)))
            }),

            TypeVariant::ScpStatement => r.with_limited_depth(|r| {
                Ok(Self::ScpStatement(Box::new(ScpStatement::read_xdr(r)?)))
            }),

            TypeVariant::ScpEnvelope => {
                r.with_limited_depth(|r| Ok(Self::ScpEnvelope(Box::new(ScpEnvelope::read_xdr(r)?))))
            }

            TypeVariant::ScpQuorumSet => r.with_limited_depth(|r| {
                Ok(Self::ScpQuorumSet(Box::new(ScpQuorumSet::read_xdr(r)?)))
            }),

            TypeVariant::ConfigSettingContractExecutionLanesV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractExecutionLanesV0(Box::new(
                    ConfigSettingContractExecutionLanesV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ConfigSettingContractComputeV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractComputeV0(Box::new(
                    ConfigSettingContractComputeV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ConfigSettingContractParallelComputeV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractParallelComputeV0(Box::new(
                    ConfigSettingContractParallelComputeV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ConfigSettingContractLedgerCostV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractLedgerCostV0(Box::new(
                    ConfigSettingContractLedgerCostV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ConfigSettingContractLedgerCostExtV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractLedgerCostExtV0(Box::new(
                    ConfigSettingContractLedgerCostExtV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ConfigSettingContractHistoricalDataV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractHistoricalDataV0(Box::new(
                    ConfigSettingContractHistoricalDataV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ConfigSettingContractEventsV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractEventsV0(Box::new(
                    ConfigSettingContractEventsV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ConfigSettingContractBandwidthV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractBandwidthV0(Box::new(
                    ConfigSettingContractBandwidthV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractCostType => r.with_limited_depth(|r| {
                Ok(Self::ContractCostType(Box::new(
                    ContractCostType::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractCostParamEntry => r.with_limited_depth(|r| {
                Ok(Self::ContractCostParamEntry(Box::new(
                    ContractCostParamEntry::read_xdr(r)?,
                )))
            }),

            TypeVariant::StateArchivalSettings => r.with_limited_depth(|r| {
                Ok(Self::StateArchivalSettings(Box::new(
                    StateArchivalSettings::read_xdr(r)?,
                )))
            }),

            TypeVariant::EvictionIterator => r.with_limited_depth(|r| {
                Ok(Self::EvictionIterator(Box::new(
                    EvictionIterator::read_xdr(r)?,
                )))
            }),

            TypeVariant::ConfigSettingScpTiming => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingScpTiming(Box::new(
                    ConfigSettingScpTiming::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractCostParams => r.with_limited_depth(|r| {
                Ok(Self::ContractCostParams(Box::new(
                    ContractCostParams::read_xdr(r)?,
                )))
            }),

            TypeVariant::ConfigSettingId => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingId(Box::new(ConfigSettingId::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::ConfigSettingEntry => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingEntry(Box::new(
                    ConfigSettingEntry::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScEnvMetaKind => r.with_limited_depth(|r| {
                Ok(Self::ScEnvMetaKind(Box::new(ScEnvMetaKind::read_xdr(r)?)))
            }),

            TypeVariant::ScEnvMetaEntry => r.with_limited_depth(|r| {
                Ok(Self::ScEnvMetaEntry(Box::new(ScEnvMetaEntry::read_xdr(r)?)))
            }),

            TypeVariant::ScMetaV0 => {
                r.with_limited_depth(|r| Ok(Self::ScMetaV0(Box::new(ScMetaV0::read_xdr(r)?))))
            }

            TypeVariant::ScMetaKind => {
                r.with_limited_depth(|r| Ok(Self::ScMetaKind(Box::new(ScMetaKind::read_xdr(r)?))))
            }

            TypeVariant::ScMetaEntry => {
                r.with_limited_depth(|r| Ok(Self::ScMetaEntry(Box::new(ScMetaEntry::read_xdr(r)?))))
            }

            TypeVariant::ScSpecType => {
                r.with_limited_depth(|r| Ok(Self::ScSpecType(Box::new(ScSpecType::read_xdr(r)?))))
            }

            TypeVariant::ScSpecTypeOption => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeOption(Box::new(
                    ScSpecTypeOption::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecTypeResult => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeResult(Box::new(
                    ScSpecTypeResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecTypeVec => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeVec(Box::new(ScSpecTypeVec::read_xdr(r)?)))
            }),

            TypeVariant::ScSpecTypeMap => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeMap(Box::new(ScSpecTypeMap::read_xdr(r)?)))
            }),

            TypeVariant::ScSpecTypeTuple => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeTuple(Box::new(ScSpecTypeTuple::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::ScSpecTypeBytesN => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeBytesN(Box::new(
                    ScSpecTypeBytesN::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecTypeUdt => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeUdt(Box::new(ScSpecTypeUdt::read_xdr(r)?)))
            }),

            TypeVariant::ScSpecTypeDef => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeDef(Box::new(ScSpecTypeDef::read_xdr(r)?)))
            }),

            TypeVariant::ScSpecUdtStructFieldV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtStructFieldV0(Box::new(
                    ScSpecUdtStructFieldV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecUdtStructV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtStructV0(Box::new(
                    ScSpecUdtStructV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecUdtUnionCaseVoidV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtUnionCaseVoidV0(Box::new(
                    ScSpecUdtUnionCaseVoidV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecUdtUnionCaseTupleV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtUnionCaseTupleV0(Box::new(
                    ScSpecUdtUnionCaseTupleV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecUdtUnionCaseV0Kind => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtUnionCaseV0Kind(Box::new(
                    ScSpecUdtUnionCaseV0Kind::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecUdtUnionCaseV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtUnionCaseV0(Box::new(
                    ScSpecUdtUnionCaseV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecUdtUnionV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtUnionV0(Box::new(
                    ScSpecUdtUnionV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecUdtEnumCaseV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtEnumCaseV0(Box::new(
                    ScSpecUdtEnumCaseV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecUdtEnumV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtEnumV0(Box::new(ScSpecUdtEnumV0::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::ScSpecUdtErrorEnumCaseV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtErrorEnumCaseV0(Box::new(
                    ScSpecUdtErrorEnumCaseV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecUdtErrorEnumV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtErrorEnumV0(Box::new(
                    ScSpecUdtErrorEnumV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecFunctionInputV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecFunctionInputV0(Box::new(
                    ScSpecFunctionInputV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecFunctionV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecFunctionV0(Box::new(
                    ScSpecFunctionV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecEventParamLocationV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecEventParamLocationV0(Box::new(
                    ScSpecEventParamLocationV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecEventParamV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecEventParamV0(Box::new(
                    ScSpecEventParamV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecEventDataFormat => r.with_limited_depth(|r| {
                Ok(Self::ScSpecEventDataFormat(Box::new(
                    ScSpecEventDataFormat::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScSpecEventV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecEventV0(Box::new(ScSpecEventV0::read_xdr(r)?)))
            }),

            TypeVariant::ScSpecEntryKind => r.with_limited_depth(|r| {
                Ok(Self::ScSpecEntryKind(Box::new(ScSpecEntryKind::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::ScSpecEntry => {
                r.with_limited_depth(|r| Ok(Self::ScSpecEntry(Box::new(ScSpecEntry::read_xdr(r)?))))
            }

            TypeVariant::ScValType => {
                r.with_limited_depth(|r| Ok(Self::ScValType(Box::new(ScValType::read_xdr(r)?))))
            }

            TypeVariant::ScErrorType => {
                r.with_limited_depth(|r| Ok(Self::ScErrorType(Box::new(ScErrorType::read_xdr(r)?))))
            }

            TypeVariant::ScErrorCode => {
                r.with_limited_depth(|r| Ok(Self::ScErrorCode(Box::new(ScErrorCode::read_xdr(r)?))))
            }

            TypeVariant::ScError => {
                r.with_limited_depth(|r| Ok(Self::ScError(Box::new(ScError::read_xdr(r)?))))
            }

            TypeVariant::UInt128Parts => r.with_limited_depth(|r| {
                Ok(Self::UInt128Parts(Box::new(UInt128Parts::read_xdr(r)?)))
            }),

            TypeVariant::Int128Parts => {
                r.with_limited_depth(|r| Ok(Self::Int128Parts(Box::new(Int128Parts::read_xdr(r)?))))
            }

            TypeVariant::UInt256Parts => r.with_limited_depth(|r| {
                Ok(Self::UInt256Parts(Box::new(UInt256Parts::read_xdr(r)?)))
            }),

            TypeVariant::Int256Parts => {
                r.with_limited_depth(|r| Ok(Self::Int256Parts(Box::new(Int256Parts::read_xdr(r)?))))
            }

            TypeVariant::ContractExecutableType => r.with_limited_depth(|r| {
                Ok(Self::ContractExecutableType(Box::new(
                    ContractExecutableType::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractExecutable => r.with_limited_depth(|r| {
                Ok(Self::ContractExecutable(Box::new(
                    ContractExecutable::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScAddressType => r.with_limited_depth(|r| {
                Ok(Self::ScAddressType(Box::new(ScAddressType::read_xdr(r)?)))
            }),

            TypeVariant::MuxedEd25519Account => r.with_limited_depth(|r| {
                Ok(Self::MuxedEd25519Account(Box::new(
                    MuxedEd25519Account::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScAddress => {
                r.with_limited_depth(|r| Ok(Self::ScAddress(Box::new(ScAddress::read_xdr(r)?))))
            }

            TypeVariant::ScVec => {
                r.with_limited_depth(|r| Ok(Self::ScVec(Box::new(ScVec::read_xdr(r)?))))
            }

            TypeVariant::ScMap => {
                r.with_limited_depth(|r| Ok(Self::ScMap(Box::new(ScMap::read_xdr(r)?))))
            }

            TypeVariant::ScBytes => {
                r.with_limited_depth(|r| Ok(Self::ScBytes(Box::new(ScBytes::read_xdr(r)?))))
            }

            TypeVariant::ScString => {
                r.with_limited_depth(|r| Ok(Self::ScString(Box::new(ScString::read_xdr(r)?))))
            }

            TypeVariant::ScSymbol => {
                r.with_limited_depth(|r| Ok(Self::ScSymbol(Box::new(ScSymbol::read_xdr(r)?))))
            }

            TypeVariant::ScNonceKey => {
                r.with_limited_depth(|r| Ok(Self::ScNonceKey(Box::new(ScNonceKey::read_xdr(r)?))))
            }

            TypeVariant::ScContractInstance => r.with_limited_depth(|r| {
                Ok(Self::ScContractInstance(Box::new(
                    ScContractInstance::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScVal => {
                r.with_limited_depth(|r| Ok(Self::ScVal(Box::new(ScVal::read_xdr(r)?))))
            }

            TypeVariant::ScMapEntry => {
                r.with_limited_depth(|r| Ok(Self::ScMapEntry(Box::new(ScMapEntry::read_xdr(r)?))))
            }

            TypeVariant::LedgerCloseMetaBatch => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMetaBatch(Box::new(
                    LedgerCloseMetaBatch::read_xdr(r)?,
                )))
            }),

            TypeVariant::StoredTransactionSet => r.with_limited_depth(|r| {
                Ok(Self::StoredTransactionSet(Box::new(
                    StoredTransactionSet::read_xdr(r)?,
                )))
            }),

            TypeVariant::StoredDebugTransactionSet => r.with_limited_depth(|r| {
                Ok(Self::StoredDebugTransactionSet(Box::new(
                    StoredDebugTransactionSet::read_xdr(r)?,
                )))
            }),

            TypeVariant::PersistedScpStateV0 => r.with_limited_depth(|r| {
                Ok(Self::PersistedScpStateV0(Box::new(
                    PersistedScpStateV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::PersistedScpStateV1 => r.with_limited_depth(|r| {
                Ok(Self::PersistedScpStateV1(Box::new(
                    PersistedScpStateV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::PersistedScpState => r.with_limited_depth(|r| {
                Ok(Self::PersistedScpState(Box::new(
                    PersistedScpState::read_xdr(r)?,
                )))
            }),

            TypeVariant::Thresholds => {
                r.with_limited_depth(|r| Ok(Self::Thresholds(Box::new(Thresholds::read_xdr(r)?))))
            }

            TypeVariant::String32 => {
                r.with_limited_depth(|r| Ok(Self::String32(Box::new(String32::read_xdr(r)?))))
            }

            TypeVariant::String64 => {
                r.with_limited_depth(|r| Ok(Self::String64(Box::new(String64::read_xdr(r)?))))
            }

            TypeVariant::SequenceNumber => r.with_limited_depth(|r| {
                Ok(Self::SequenceNumber(Box::new(SequenceNumber::read_xdr(r)?)))
            }),

            TypeVariant::DataValue => {
                r.with_limited_depth(|r| Ok(Self::DataValue(Box::new(DataValue::read_xdr(r)?))))
            }

            TypeVariant::AssetCode4 => {
                r.with_limited_depth(|r| Ok(Self::AssetCode4(Box::new(AssetCode4::read_xdr(r)?))))
            }

            TypeVariant::AssetCode12 => {
                r.with_limited_depth(|r| Ok(Self::AssetCode12(Box::new(AssetCode12::read_xdr(r)?))))
            }

            TypeVariant::AssetType => {
                r.with_limited_depth(|r| Ok(Self::AssetType(Box::new(AssetType::read_xdr(r)?))))
            }

            TypeVariant::AssetCode => {
                r.with_limited_depth(|r| Ok(Self::AssetCode(Box::new(AssetCode::read_xdr(r)?))))
            }

            TypeVariant::AlphaNum4 => {
                r.with_limited_depth(|r| Ok(Self::AlphaNum4(Box::new(AlphaNum4::read_xdr(r)?))))
            }

            TypeVariant::AlphaNum12 => {
                r.with_limited_depth(|r| Ok(Self::AlphaNum12(Box::new(AlphaNum12::read_xdr(r)?))))
            }

            TypeVariant::Asset => {
                r.with_limited_depth(|r| Ok(Self::Asset(Box::new(Asset::read_xdr(r)?))))
            }

            TypeVariant::Price => {
                r.with_limited_depth(|r| Ok(Self::Price(Box::new(Price::read_xdr(r)?))))
            }

            TypeVariant::Liabilities => {
                r.with_limited_depth(|r| Ok(Self::Liabilities(Box::new(Liabilities::read_xdr(r)?))))
            }

            TypeVariant::ThresholdIndexes => r.with_limited_depth(|r| {
                Ok(Self::ThresholdIndexes(Box::new(
                    ThresholdIndexes::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerEntryType => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryType(Box::new(LedgerEntryType::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::Signer => {
                r.with_limited_depth(|r| Ok(Self::Signer(Box::new(Signer::read_xdr(r)?))))
            }

            TypeVariant::AccountFlags => r.with_limited_depth(|r| {
                Ok(Self::AccountFlags(Box::new(AccountFlags::read_xdr(r)?)))
            }),

            TypeVariant::SponsorshipDescriptor => r.with_limited_depth(|r| {
                Ok(Self::SponsorshipDescriptor(Box::new(
                    SponsorshipDescriptor::read_xdr(r)?,
                )))
            }),

            TypeVariant::AccountEntryExtensionV3 => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExtensionV3(Box::new(
                    AccountEntryExtensionV3::read_xdr(r)?,
                )))
            }),

            TypeVariant::AccountEntryExtensionV2 => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExtensionV2(Box::new(
                    AccountEntryExtensionV2::read_xdr(r)?,
                )))
            }),

            TypeVariant::AccountEntryExtensionV1 => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExtensionV1(Box::new(
                    AccountEntryExtensionV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::AccountEntry => r.with_limited_depth(|r| {
                Ok(Self::AccountEntry(Box::new(AccountEntry::read_xdr(r)?)))
            }),

            TypeVariant::TrustLineFlags => r.with_limited_depth(|r| {
                Ok(Self::TrustLineFlags(Box::new(TrustLineFlags::read_xdr(r)?)))
            }),

            TypeVariant::LiquidityPoolType => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolType(Box::new(
                    LiquidityPoolType::read_xdr(r)?,
                )))
            }),

            TypeVariant::TrustLineAsset => r.with_limited_depth(|r| {
                Ok(Self::TrustLineAsset(Box::new(TrustLineAsset::read_xdr(r)?)))
            }),

            TypeVariant::TrustLineEntryExtensionV2 => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntryExtensionV2(Box::new(
                    TrustLineEntryExtensionV2::read_xdr(r)?,
                )))
            }),

            TypeVariant::TrustLineEntry => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntry(Box::new(TrustLineEntry::read_xdr(r)?)))
            }),

            TypeVariant::OfferEntryFlags => r.with_limited_depth(|r| {
                Ok(Self::OfferEntryFlags(Box::new(OfferEntryFlags::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::OfferEntry => {
                r.with_limited_depth(|r| Ok(Self::OfferEntry(Box::new(OfferEntry::read_xdr(r)?))))
            }

            TypeVariant::DataEntry => {
                r.with_limited_depth(|r| Ok(Self::DataEntry(Box::new(DataEntry::read_xdr(r)?))))
            }

            TypeVariant::ClaimPredicateType => r.with_limited_depth(|r| {
                Ok(Self::ClaimPredicateType(Box::new(
                    ClaimPredicateType::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClaimPredicate => r.with_limited_depth(|r| {
                Ok(Self::ClaimPredicate(Box::new(ClaimPredicate::read_xdr(r)?)))
            }),

            TypeVariant::ClaimantType => r.with_limited_depth(|r| {
                Ok(Self::ClaimantType(Box::new(ClaimantType::read_xdr(r)?)))
            }),

            TypeVariant::Claimant => {
                r.with_limited_depth(|r| Ok(Self::Claimant(Box::new(Claimant::read_xdr(r)?))))
            }

            TypeVariant::ClaimableBalanceFlags => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceFlags(Box::new(
                    ClaimableBalanceFlags::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClaimableBalanceEntryExtensionV1 => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceEntryExtensionV1(Box::new(
                    ClaimableBalanceEntryExtensionV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClaimableBalanceEntry => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceEntry(Box::new(
                    ClaimableBalanceEntry::read_xdr(r)?,
                )))
            }),

            TypeVariant::LiquidityPoolConstantProductParameters => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolConstantProductParameters(Box::new(
                    LiquidityPoolConstantProductParameters::read_xdr(r)?,
                )))
            }),

            TypeVariant::LiquidityPoolEntry => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolEntry(Box::new(
                    LiquidityPoolEntry::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractDataDurability => r.with_limited_depth(|r| {
                Ok(Self::ContractDataDurability(Box::new(
                    ContractDataDurability::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractDataEntry => r.with_limited_depth(|r| {
                Ok(Self::ContractDataEntry(Box::new(
                    ContractDataEntry::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractCodeCostInputs => r.with_limited_depth(|r| {
                Ok(Self::ContractCodeCostInputs(Box::new(
                    ContractCodeCostInputs::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractCodeEntry => r.with_limited_depth(|r| {
                Ok(Self::ContractCodeEntry(Box::new(
                    ContractCodeEntry::read_xdr(r)?,
                )))
            }),

            TypeVariant::TtlEntry => {
                r.with_limited_depth(|r| Ok(Self::TtlEntry(Box::new(TtlEntry::read_xdr(r)?))))
            }

            TypeVariant::LedgerEntryExtensionV1 => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryExtensionV1(Box::new(
                    LedgerEntryExtensionV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerEntry => {
                r.with_limited_depth(|r| Ok(Self::LedgerEntry(Box::new(LedgerEntry::read_xdr(r)?))))
            }

            TypeVariant::LedgerKey => {
                r.with_limited_depth(|r| Ok(Self::LedgerKey(Box::new(LedgerKey::read_xdr(r)?))))
            }

            TypeVariant::EnvelopeType => r.with_limited_depth(|r| {
                Ok(Self::EnvelopeType(Box::new(EnvelopeType::read_xdr(r)?)))
            }),

            TypeVariant::BucketListType => r.with_limited_depth(|r| {
                Ok(Self::BucketListType(Box::new(BucketListType::read_xdr(r)?)))
            }),

            TypeVariant::BucketEntryType => r.with_limited_depth(|r| {
                Ok(Self::BucketEntryType(Box::new(BucketEntryType::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::HotArchiveBucketEntryType => r.with_limited_depth(|r| {
                Ok(Self::HotArchiveBucketEntryType(Box::new(
                    HotArchiveBucketEntryType::read_xdr(r)?,
                )))
            }),

            TypeVariant::BucketMetadata => r.with_limited_depth(|r| {
                Ok(Self::BucketMetadata(Box::new(BucketMetadata::read_xdr(r)?)))
            }),

            TypeVariant::BucketEntry => {
                r.with_limited_depth(|r| Ok(Self::BucketEntry(Box::new(BucketEntry::read_xdr(r)?))))
            }

            TypeVariant::HotArchiveBucketEntry => r.with_limited_depth(|r| {
                Ok(Self::HotArchiveBucketEntry(Box::new(
                    HotArchiveBucketEntry::read_xdr(r)?,
                )))
            }),

            TypeVariant::UpgradeType => {
                r.with_limited_depth(|r| Ok(Self::UpgradeType(Box::new(UpgradeType::read_xdr(r)?))))
            }

            TypeVariant::StellarValueType => r.with_limited_depth(|r| {
                Ok(Self::StellarValueType(Box::new(
                    StellarValueType::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerCloseValueSignature => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseValueSignature(Box::new(
                    LedgerCloseValueSignature::read_xdr(r)?,
                )))
            }),

            TypeVariant::StellarValue => r.with_limited_depth(|r| {
                Ok(Self::StellarValue(Box::new(StellarValue::read_xdr(r)?)))
            }),

            TypeVariant::LedgerHeaderFlags => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderFlags(Box::new(
                    LedgerHeaderFlags::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerHeaderExtensionV1 => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderExtensionV1(Box::new(
                    LedgerHeaderExtensionV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerHeader => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeader(Box::new(LedgerHeader::read_xdr(r)?)))
            }),

            TypeVariant::LedgerUpgradeType => r.with_limited_depth(|r| {
                Ok(Self::LedgerUpgradeType(Box::new(
                    LedgerUpgradeType::read_xdr(r)?,
                )))
            }),

            TypeVariant::ConfigUpgradeSetKey => r.with_limited_depth(|r| {
                Ok(Self::ConfigUpgradeSetKey(Box::new(
                    ConfigUpgradeSetKey::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerUpgrade => r.with_limited_depth(|r| {
                Ok(Self::LedgerUpgrade(Box::new(LedgerUpgrade::read_xdr(r)?)))
            }),

            TypeVariant::ConfigUpgradeSet => r.with_limited_depth(|r| {
                Ok(Self::ConfigUpgradeSet(Box::new(
                    ConfigUpgradeSet::read_xdr(r)?,
                )))
            }),

            TypeVariant::TxSetComponentType => r.with_limited_depth(|r| {
                Ok(Self::TxSetComponentType(Box::new(
                    TxSetComponentType::read_xdr(r)?,
                )))
            }),

            TypeVariant::DependentTxCluster => r.with_limited_depth(|r| {
                Ok(Self::DependentTxCluster(Box::new(
                    DependentTxCluster::read_xdr(r)?,
                )))
            }),

            TypeVariant::ParallelTxExecutionStage => r.with_limited_depth(|r| {
                Ok(Self::ParallelTxExecutionStage(Box::new(
                    ParallelTxExecutionStage::read_xdr(r)?,
                )))
            }),

            TypeVariant::ParallelTxsComponent => r.with_limited_depth(|r| {
                Ok(Self::ParallelTxsComponent(Box::new(
                    ParallelTxsComponent::read_xdr(r)?,
                )))
            }),

            TypeVariant::TxSetComponent => r.with_limited_depth(|r| {
                Ok(Self::TxSetComponent(Box::new(TxSetComponent::read_xdr(r)?)))
            }),

            TypeVariant::TransactionPhase => r.with_limited_depth(|r| {
                Ok(Self::TransactionPhase(Box::new(
                    TransactionPhase::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionSet => r.with_limited_depth(|r| {
                Ok(Self::TransactionSet(Box::new(TransactionSet::read_xdr(r)?)))
            }),

            TypeVariant::TransactionSetV1 => r.with_limited_depth(|r| {
                Ok(Self::TransactionSetV1(Box::new(
                    TransactionSetV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::GeneralizedTransactionSet => r.with_limited_depth(|r| {
                Ok(Self::GeneralizedTransactionSet(Box::new(
                    GeneralizedTransactionSet::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionResultPair => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultPair(Box::new(
                    TransactionResultPair::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionResultSet => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultSet(Box::new(
                    TransactionResultSet::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionHistoryEntry => r.with_limited_depth(|r| {
                Ok(Self::TransactionHistoryEntry(Box::new(
                    TransactionHistoryEntry::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionHistoryResultEntry => r.with_limited_depth(|r| {
                Ok(Self::TransactionHistoryResultEntry(Box::new(
                    TransactionHistoryResultEntry::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerHeaderHistoryEntry => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderHistoryEntry(Box::new(
                    LedgerHeaderHistoryEntry::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerScpMessages => r.with_limited_depth(|r| {
                Ok(Self::LedgerScpMessages(Box::new(
                    LedgerScpMessages::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScpHistoryEntryV0 => r.with_limited_depth(|r| {
                Ok(Self::ScpHistoryEntryV0(Box::new(
                    ScpHistoryEntryV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ScpHistoryEntry => r.with_limited_depth(|r| {
                Ok(Self::ScpHistoryEntry(Box::new(ScpHistoryEntry::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::LedgerEntryChangeType => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryChangeType(Box::new(
                    LedgerEntryChangeType::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerEntryChange => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryChange(Box::new(
                    LedgerEntryChange::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerEntryChanges => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryChanges(Box::new(
                    LedgerEntryChanges::read_xdr(r)?,
                )))
            }),

            TypeVariant::OperationMeta => r.with_limited_depth(|r| {
                Ok(Self::OperationMeta(Box::new(OperationMeta::read_xdr(r)?)))
            }),

            TypeVariant::TransactionMetaV1 => r.with_limited_depth(|r| {
                Ok(Self::TransactionMetaV1(Box::new(
                    TransactionMetaV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionMetaV2 => r.with_limited_depth(|r| {
                Ok(Self::TransactionMetaV2(Box::new(
                    TransactionMetaV2::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractEventType => r.with_limited_depth(|r| {
                Ok(Self::ContractEventType(Box::new(
                    ContractEventType::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractEvent => r.with_limited_depth(|r| {
                Ok(Self::ContractEvent(Box::new(ContractEvent::read_xdr(r)?)))
            }),

            TypeVariant::DiagnosticEvent => r.with_limited_depth(|r| {
                Ok(Self::DiagnosticEvent(Box::new(DiagnosticEvent::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::SorobanTransactionMetaExtV1 => r.with_limited_depth(|r| {
                Ok(Self::SorobanTransactionMetaExtV1(Box::new(
                    SorobanTransactionMetaExtV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanTransactionMetaExt => r.with_limited_depth(|r| {
                Ok(Self::SorobanTransactionMetaExt(Box::new(
                    SorobanTransactionMetaExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanTransactionMeta => r.with_limited_depth(|r| {
                Ok(Self::SorobanTransactionMeta(Box::new(
                    SorobanTransactionMeta::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionMetaV3 => r.with_limited_depth(|r| {
                Ok(Self::TransactionMetaV3(Box::new(
                    TransactionMetaV3::read_xdr(r)?,
                )))
            }),

            TypeVariant::OperationMetaV2 => r.with_limited_depth(|r| {
                Ok(Self::OperationMetaV2(Box::new(OperationMetaV2::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::SorobanTransactionMetaV2 => r.with_limited_depth(|r| {
                Ok(Self::SorobanTransactionMetaV2(Box::new(
                    SorobanTransactionMetaV2::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionEventStage => r.with_limited_depth(|r| {
                Ok(Self::TransactionEventStage(Box::new(
                    TransactionEventStage::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionEvent => r.with_limited_depth(|r| {
                Ok(Self::TransactionEvent(Box::new(
                    TransactionEvent::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionMetaV4 => r.with_limited_depth(|r| {
                Ok(Self::TransactionMetaV4(Box::new(
                    TransactionMetaV4::read_xdr(r)?,
                )))
            }),

            TypeVariant::InvokeHostFunctionSuccessPreImage => r.with_limited_depth(|r| {
                Ok(Self::InvokeHostFunctionSuccessPreImage(Box::new(
                    InvokeHostFunctionSuccessPreImage::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionMeta => r.with_limited_depth(|r| {
                Ok(Self::TransactionMeta(Box::new(TransactionMeta::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::TransactionResultMeta => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultMeta(Box::new(
                    TransactionResultMeta::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionResultMetaV1 => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultMetaV1(Box::new(
                    TransactionResultMetaV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::UpgradeEntryMeta => r.with_limited_depth(|r| {
                Ok(Self::UpgradeEntryMeta(Box::new(
                    UpgradeEntryMeta::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerCloseMetaV0 => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMetaV0(Box::new(
                    LedgerCloseMetaV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerCloseMetaExtV1 => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMetaExtV1(Box::new(
                    LedgerCloseMetaExtV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerCloseMetaExt => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMetaExt(Box::new(
                    LedgerCloseMetaExt::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerCloseMetaV1 => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMetaV1(Box::new(
                    LedgerCloseMetaV1::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerCloseMetaV2 => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMetaV2(Box::new(
                    LedgerCloseMetaV2::read_xdr(r)?,
                )))
            }),

            TypeVariant::LedgerCloseMeta => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMeta(Box::new(LedgerCloseMeta::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::ErrorCode => {
                r.with_limited_depth(|r| Ok(Self::ErrorCode(Box::new(ErrorCode::read_xdr(r)?))))
            }

            TypeVariant::SError => {
                r.with_limited_depth(|r| Ok(Self::SError(Box::new(SError::read_xdr(r)?))))
            }

            TypeVariant::SendMore => {
                r.with_limited_depth(|r| Ok(Self::SendMore(Box::new(SendMore::read_xdr(r)?))))
            }

            TypeVariant::SendMoreExtended => r.with_limited_depth(|r| {
                Ok(Self::SendMoreExtended(Box::new(
                    SendMoreExtended::read_xdr(r)?,
                )))
            }),

            TypeVariant::AuthCert => {
                r.with_limited_depth(|r| Ok(Self::AuthCert(Box::new(AuthCert::read_xdr(r)?))))
            }

            TypeVariant::Hello => {
                r.with_limited_depth(|r| Ok(Self::Hello(Box::new(Hello::read_xdr(r)?))))
            }

            TypeVariant::Auth => {
                r.with_limited_depth(|r| Ok(Self::Auth(Box::new(Auth::read_xdr(r)?))))
            }

            TypeVariant::IpAddrType => {
                r.with_limited_depth(|r| Ok(Self::IpAddrType(Box::new(IpAddrType::read_xdr(r)?))))
            }

            TypeVariant::PeerAddress => {
                r.with_limited_depth(|r| Ok(Self::PeerAddress(Box::new(PeerAddress::read_xdr(r)?))))
            }

            TypeVariant::MessageType => {
                r.with_limited_depth(|r| Ok(Self::MessageType(Box::new(MessageType::read_xdr(r)?))))
            }

            TypeVariant::DontHave => {
                r.with_limited_depth(|r| Ok(Self::DontHave(Box::new(DontHave::read_xdr(r)?))))
            }

            TypeVariant::SurveyMessageCommandType => r.with_limited_depth(|r| {
                Ok(Self::SurveyMessageCommandType(Box::new(
                    SurveyMessageCommandType::read_xdr(r)?,
                )))
            }),

            TypeVariant::SurveyMessageResponseType => r.with_limited_depth(|r| {
                Ok(Self::SurveyMessageResponseType(Box::new(
                    SurveyMessageResponseType::read_xdr(r)?,
                )))
            }),

            TypeVariant::TimeSlicedSurveyStartCollectingMessage => r.with_limited_depth(|r| {
                Ok(Self::TimeSlicedSurveyStartCollectingMessage(Box::new(
                    TimeSlicedSurveyStartCollectingMessage::read_xdr(r)?,
                )))
            }),

            TypeVariant::SignedTimeSlicedSurveyStartCollectingMessage => {
                r.with_limited_depth(|r| {
                    Ok(Self::SignedTimeSlicedSurveyStartCollectingMessage(
                        Box::new(SignedTimeSlicedSurveyStartCollectingMessage::read_xdr(r)?),
                    ))
                })
            }

            TypeVariant::TimeSlicedSurveyStopCollectingMessage => r.with_limited_depth(|r| {
                Ok(Self::TimeSlicedSurveyStopCollectingMessage(Box::new(
                    TimeSlicedSurveyStopCollectingMessage::read_xdr(r)?,
                )))
            }),

            TypeVariant::SignedTimeSlicedSurveyStopCollectingMessage => r.with_limited_depth(|r| {
                Ok(Self::SignedTimeSlicedSurveyStopCollectingMessage(Box::new(
                    SignedTimeSlicedSurveyStopCollectingMessage::read_xdr(r)?,
                )))
            }),

            TypeVariant::SurveyRequestMessage => r.with_limited_depth(|r| {
                Ok(Self::SurveyRequestMessage(Box::new(
                    SurveyRequestMessage::read_xdr(r)?,
                )))
            }),

            TypeVariant::TimeSlicedSurveyRequestMessage => r.with_limited_depth(|r| {
                Ok(Self::TimeSlicedSurveyRequestMessage(Box::new(
                    TimeSlicedSurveyRequestMessage::read_xdr(r)?,
                )))
            }),

            TypeVariant::SignedTimeSlicedSurveyRequestMessage => r.with_limited_depth(|r| {
                Ok(Self::SignedTimeSlicedSurveyRequestMessage(Box::new(
                    SignedTimeSlicedSurveyRequestMessage::read_xdr(r)?,
                )))
            }),

            TypeVariant::EncryptedBody => r.with_limited_depth(|r| {
                Ok(Self::EncryptedBody(Box::new(EncryptedBody::read_xdr(r)?)))
            }),

            TypeVariant::SurveyResponseMessage => r.with_limited_depth(|r| {
                Ok(Self::SurveyResponseMessage(Box::new(
                    SurveyResponseMessage::read_xdr(r)?,
                )))
            }),

            TypeVariant::TimeSlicedSurveyResponseMessage => r.with_limited_depth(|r| {
                Ok(Self::TimeSlicedSurveyResponseMessage(Box::new(
                    TimeSlicedSurveyResponseMessage::read_xdr(r)?,
                )))
            }),

            TypeVariant::SignedTimeSlicedSurveyResponseMessage => r.with_limited_depth(|r| {
                Ok(Self::SignedTimeSlicedSurveyResponseMessage(Box::new(
                    SignedTimeSlicedSurveyResponseMessage::read_xdr(r)?,
                )))
            }),

            TypeVariant::PeerStats => {
                r.with_limited_depth(|r| Ok(Self::PeerStats(Box::new(PeerStats::read_xdr(r)?))))
            }

            TypeVariant::TimeSlicedNodeData => r.with_limited_depth(|r| {
                Ok(Self::TimeSlicedNodeData(Box::new(
                    TimeSlicedNodeData::read_xdr(r)?,
                )))
            }),

            TypeVariant::TimeSlicedPeerData => r.with_limited_depth(|r| {
                Ok(Self::TimeSlicedPeerData(Box::new(
                    TimeSlicedPeerData::read_xdr(r)?,
                )))
            }),

            TypeVariant::TimeSlicedPeerDataList => r.with_limited_depth(|r| {
                Ok(Self::TimeSlicedPeerDataList(Box::new(
                    TimeSlicedPeerDataList::read_xdr(r)?,
                )))
            }),

            TypeVariant::TopologyResponseBodyV2 => r.with_limited_depth(|r| {
                Ok(Self::TopologyResponseBodyV2(Box::new(
                    TopologyResponseBodyV2::read_xdr(r)?,
                )))
            }),

            TypeVariant::SurveyResponseBody => r.with_limited_depth(|r| {
                Ok(Self::SurveyResponseBody(Box::new(
                    SurveyResponseBody::read_xdr(r)?,
                )))
            }),

            TypeVariant::TxAdvertVector => r.with_limited_depth(|r| {
                Ok(Self::TxAdvertVector(Box::new(TxAdvertVector::read_xdr(r)?)))
            }),

            TypeVariant::FloodAdvert => {
                r.with_limited_depth(|r| Ok(Self::FloodAdvert(Box::new(FloodAdvert::read_xdr(r)?))))
            }

            TypeVariant::TxDemandVector => r.with_limited_depth(|r| {
                Ok(Self::TxDemandVector(Box::new(TxDemandVector::read_xdr(r)?)))
            }),

            TypeVariant::FloodDemand => {
                r.with_limited_depth(|r| Ok(Self::FloodDemand(Box::new(FloodDemand::read_xdr(r)?))))
            }

            TypeVariant::StellarMessage => r.with_limited_depth(|r| {
                Ok(Self::StellarMessage(Box::new(StellarMessage::read_xdr(r)?)))
            }),

            TypeVariant::AuthenticatedMessage => r.with_limited_depth(|r| {
                Ok(Self::AuthenticatedMessage(Box::new(
                    AuthenticatedMessage::read_xdr(r)?,
                )))
            }),

            TypeVariant::LiquidityPoolParameters => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolParameters(Box::new(
                    LiquidityPoolParameters::read_xdr(r)?,
                )))
            }),

            TypeVariant::MuxedAccount => r.with_limited_depth(|r| {
                Ok(Self::MuxedAccount(Box::new(MuxedAccount::read_xdr(r)?)))
            }),

            TypeVariant::DecoratedSignature => r.with_limited_depth(|r| {
                Ok(Self::DecoratedSignature(Box::new(
                    DecoratedSignature::read_xdr(r)?,
                )))
            }),

            TypeVariant::OperationType => r.with_limited_depth(|r| {
                Ok(Self::OperationType(Box::new(OperationType::read_xdr(r)?)))
            }),

            TypeVariant::CreateAccountOp => r.with_limited_depth(|r| {
                Ok(Self::CreateAccountOp(Box::new(CreateAccountOp::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::PaymentOp => {
                r.with_limited_depth(|r| Ok(Self::PaymentOp(Box::new(PaymentOp::read_xdr(r)?))))
            }

            TypeVariant::PathPaymentStrictReceiveOp => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictReceiveOp(Box::new(
                    PathPaymentStrictReceiveOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::PathPaymentStrictSendOp => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictSendOp(Box::new(
                    PathPaymentStrictSendOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::ManageSellOfferOp => r.with_limited_depth(|r| {
                Ok(Self::ManageSellOfferOp(Box::new(
                    ManageSellOfferOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::ManageBuyOfferOp => r.with_limited_depth(|r| {
                Ok(Self::ManageBuyOfferOp(Box::new(
                    ManageBuyOfferOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::CreatePassiveSellOfferOp => r.with_limited_depth(|r| {
                Ok(Self::CreatePassiveSellOfferOp(Box::new(
                    CreatePassiveSellOfferOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::SetOptionsOp => r.with_limited_depth(|r| {
                Ok(Self::SetOptionsOp(Box::new(SetOptionsOp::read_xdr(r)?)))
            }),

            TypeVariant::ChangeTrustAsset => r.with_limited_depth(|r| {
                Ok(Self::ChangeTrustAsset(Box::new(
                    ChangeTrustAsset::read_xdr(r)?,
                )))
            }),

            TypeVariant::ChangeTrustOp => r.with_limited_depth(|r| {
                Ok(Self::ChangeTrustOp(Box::new(ChangeTrustOp::read_xdr(r)?)))
            }),

            TypeVariant::AllowTrustOp => r.with_limited_depth(|r| {
                Ok(Self::AllowTrustOp(Box::new(AllowTrustOp::read_xdr(r)?)))
            }),

            TypeVariant::ManageDataOp => r.with_limited_depth(|r| {
                Ok(Self::ManageDataOp(Box::new(ManageDataOp::read_xdr(r)?)))
            }),

            TypeVariant::BumpSequenceOp => r.with_limited_depth(|r| {
                Ok(Self::BumpSequenceOp(Box::new(BumpSequenceOp::read_xdr(r)?)))
            }),

            TypeVariant::CreateClaimableBalanceOp => r.with_limited_depth(|r| {
                Ok(Self::CreateClaimableBalanceOp(Box::new(
                    CreateClaimableBalanceOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClaimClaimableBalanceOp => r.with_limited_depth(|r| {
                Ok(Self::ClaimClaimableBalanceOp(Box::new(
                    ClaimClaimableBalanceOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::BeginSponsoringFutureReservesOp => r.with_limited_depth(|r| {
                Ok(Self::BeginSponsoringFutureReservesOp(Box::new(
                    BeginSponsoringFutureReservesOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::RevokeSponsorshipType => r.with_limited_depth(|r| {
                Ok(Self::RevokeSponsorshipType(Box::new(
                    RevokeSponsorshipType::read_xdr(r)?,
                )))
            }),

            TypeVariant::RevokeSponsorshipOp => r.with_limited_depth(|r| {
                Ok(Self::RevokeSponsorshipOp(Box::new(
                    RevokeSponsorshipOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClawbackOp => {
                r.with_limited_depth(|r| Ok(Self::ClawbackOp(Box::new(ClawbackOp::read_xdr(r)?))))
            }

            TypeVariant::ClawbackClaimableBalanceOp => r.with_limited_depth(|r| {
                Ok(Self::ClawbackClaimableBalanceOp(Box::new(
                    ClawbackClaimableBalanceOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::SetTrustLineFlagsOp => r.with_limited_depth(|r| {
                Ok(Self::SetTrustLineFlagsOp(Box::new(
                    SetTrustLineFlagsOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::LiquidityPoolDepositOp => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolDepositOp(Box::new(
                    LiquidityPoolDepositOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::LiquidityPoolWithdrawOp => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolWithdrawOp(Box::new(
                    LiquidityPoolWithdrawOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::HostFunctionType => r.with_limited_depth(|r| {
                Ok(Self::HostFunctionType(Box::new(
                    HostFunctionType::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractIdPreimageType => r.with_limited_depth(|r| {
                Ok(Self::ContractIdPreimageType(Box::new(
                    ContractIdPreimageType::read_xdr(r)?,
                )))
            }),

            TypeVariant::ContractIdPreimage => r.with_limited_depth(|r| {
                Ok(Self::ContractIdPreimage(Box::new(
                    ContractIdPreimage::read_xdr(r)?,
                )))
            }),

            TypeVariant::CreateContractArgs => r.with_limited_depth(|r| {
                Ok(Self::CreateContractArgs(Box::new(
                    CreateContractArgs::read_xdr(r)?,
                )))
            }),

            TypeVariant::CreateContractArgsV2 => r.with_limited_depth(|r| {
                Ok(Self::CreateContractArgsV2(Box::new(
                    CreateContractArgsV2::read_xdr(r)?,
                )))
            }),

            TypeVariant::InvokeContractArgs => r.with_limited_depth(|r| {
                Ok(Self::InvokeContractArgs(Box::new(
                    InvokeContractArgs::read_xdr(r)?,
                )))
            }),

            TypeVariant::HostFunction => r.with_limited_depth(|r| {
                Ok(Self::HostFunction(Box::new(HostFunction::read_xdr(r)?)))
            }),

            TypeVariant::SorobanAuthorizedFunctionType => r.with_limited_depth(|r| {
                Ok(Self::SorobanAuthorizedFunctionType(Box::new(
                    SorobanAuthorizedFunctionType::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanAuthorizedFunction => r.with_limited_depth(|r| {
                Ok(Self::SorobanAuthorizedFunction(Box::new(
                    SorobanAuthorizedFunction::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanAuthorizedInvocation => r.with_limited_depth(|r| {
                Ok(Self::SorobanAuthorizedInvocation(Box::new(
                    SorobanAuthorizedInvocation::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanAddressCredentials => r.with_limited_depth(|r| {
                Ok(Self::SorobanAddressCredentials(Box::new(
                    SorobanAddressCredentials::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanCredentialsType => r.with_limited_depth(|r| {
                Ok(Self::SorobanCredentialsType(Box::new(
                    SorobanCredentialsType::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanCredentials => r.with_limited_depth(|r| {
                Ok(Self::SorobanCredentials(Box::new(
                    SorobanCredentials::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanAuthorizationEntry => r.with_limited_depth(|r| {
                Ok(Self::SorobanAuthorizationEntry(Box::new(
                    SorobanAuthorizationEntry::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanAuthorizationEntries => r.with_limited_depth(|r| {
                Ok(Self::SorobanAuthorizationEntries(Box::new(
                    SorobanAuthorizationEntries::read_xdr(r)?,
                )))
            }),

            TypeVariant::InvokeHostFunctionOp => r.with_limited_depth(|r| {
                Ok(Self::InvokeHostFunctionOp(Box::new(
                    InvokeHostFunctionOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::ExtendFootprintTtlOp => r.with_limited_depth(|r| {
                Ok(Self::ExtendFootprintTtlOp(Box::new(
                    ExtendFootprintTtlOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::RestoreFootprintOp => r.with_limited_depth(|r| {
                Ok(Self::RestoreFootprintOp(Box::new(
                    RestoreFootprintOp::read_xdr(r)?,
                )))
            }),

            TypeVariant::Operation => {
                r.with_limited_depth(|r| Ok(Self::Operation(Box::new(Operation::read_xdr(r)?))))
            }

            TypeVariant::HashIdPreimage => r.with_limited_depth(|r| {
                Ok(Self::HashIdPreimage(Box::new(HashIdPreimage::read_xdr(r)?)))
            }),

            TypeVariant::MemoType => {
                r.with_limited_depth(|r| Ok(Self::MemoType(Box::new(MemoType::read_xdr(r)?))))
            }

            TypeVariant::Memo => {
                r.with_limited_depth(|r| Ok(Self::Memo(Box::new(Memo::read_xdr(r)?))))
            }

            TypeVariant::TimeBounds => {
                r.with_limited_depth(|r| Ok(Self::TimeBounds(Box::new(TimeBounds::read_xdr(r)?))))
            }

            TypeVariant::LedgerBounds => r.with_limited_depth(|r| {
                Ok(Self::LedgerBounds(Box::new(LedgerBounds::read_xdr(r)?)))
            }),

            TypeVariant::PreconditionsV2 => r.with_limited_depth(|r| {
                Ok(Self::PreconditionsV2(Box::new(PreconditionsV2::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::PreconditionType => r.with_limited_depth(|r| {
                Ok(Self::PreconditionType(Box::new(
                    PreconditionType::read_xdr(r)?,
                )))
            }),

            TypeVariant::Preconditions => r.with_limited_depth(|r| {
                Ok(Self::Preconditions(Box::new(Preconditions::read_xdr(r)?)))
            }),

            TypeVariant::LedgerFootprint => r.with_limited_depth(|r| {
                Ok(Self::LedgerFootprint(Box::new(LedgerFootprint::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::SorobanResources => r.with_limited_depth(|r| {
                Ok(Self::SorobanResources(Box::new(
                    SorobanResources::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanResourcesExtV0 => r.with_limited_depth(|r| {
                Ok(Self::SorobanResourcesExtV0(Box::new(
                    SorobanResourcesExtV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::SorobanTransactionData => r.with_limited_depth(|r| {
                Ok(Self::SorobanTransactionData(Box::new(
                    SorobanTransactionData::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionV0 => r.with_limited_depth(|r| {
                Ok(Self::TransactionV0(Box::new(TransactionV0::read_xdr(r)?)))
            }),

            TypeVariant::TransactionV0Envelope => r.with_limited_depth(|r| {
                Ok(Self::TransactionV0Envelope(Box::new(
                    TransactionV0Envelope::read_xdr(r)?,
                )))
            }),

            TypeVariant::Transaction => {
                r.with_limited_depth(|r| Ok(Self::Transaction(Box::new(Transaction::read_xdr(r)?))))
            }

            TypeVariant::TransactionV1Envelope => r.with_limited_depth(|r| {
                Ok(Self::TransactionV1Envelope(Box::new(
                    TransactionV1Envelope::read_xdr(r)?,
                )))
            }),

            TypeVariant::FeeBumpTransaction => r.with_limited_depth(|r| {
                Ok(Self::FeeBumpTransaction(Box::new(
                    FeeBumpTransaction::read_xdr(r)?,
                )))
            }),

            TypeVariant::FeeBumpTransactionEnvelope => r.with_limited_depth(|r| {
                Ok(Self::FeeBumpTransactionEnvelope(Box::new(
                    FeeBumpTransactionEnvelope::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionEnvelope => r.with_limited_depth(|r| {
                Ok(Self::TransactionEnvelope(Box::new(
                    TransactionEnvelope::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionSignaturePayload => r.with_limited_depth(|r| {
                Ok(Self::TransactionSignaturePayload(Box::new(
                    TransactionSignaturePayload::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClaimAtomType => r.with_limited_depth(|r| {
                Ok(Self::ClaimAtomType(Box::new(ClaimAtomType::read_xdr(r)?)))
            }),

            TypeVariant::ClaimOfferAtomV0 => r.with_limited_depth(|r| {
                Ok(Self::ClaimOfferAtomV0(Box::new(
                    ClaimOfferAtomV0::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClaimOfferAtom => r.with_limited_depth(|r| {
                Ok(Self::ClaimOfferAtom(Box::new(ClaimOfferAtom::read_xdr(r)?)))
            }),

            TypeVariant::ClaimLiquidityAtom => r.with_limited_depth(|r| {
                Ok(Self::ClaimLiquidityAtom(Box::new(
                    ClaimLiquidityAtom::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClaimAtom => {
                r.with_limited_depth(|r| Ok(Self::ClaimAtom(Box::new(ClaimAtom::read_xdr(r)?))))
            }

            TypeVariant::CreateAccountResultCode => r.with_limited_depth(|r| {
                Ok(Self::CreateAccountResultCode(Box::new(
                    CreateAccountResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::CreateAccountResult => r.with_limited_depth(|r| {
                Ok(Self::CreateAccountResult(Box::new(
                    CreateAccountResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::PaymentResultCode => r.with_limited_depth(|r| {
                Ok(Self::PaymentResultCode(Box::new(
                    PaymentResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::PaymentResult => r.with_limited_depth(|r| {
                Ok(Self::PaymentResult(Box::new(PaymentResult::read_xdr(r)?)))
            }),

            TypeVariant::PathPaymentStrictReceiveResultCode => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictReceiveResultCode(Box::new(
                    PathPaymentStrictReceiveResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::SimplePaymentResult => r.with_limited_depth(|r| {
                Ok(Self::SimplePaymentResult(Box::new(
                    SimplePaymentResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::PathPaymentStrictReceiveResult => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictReceiveResult(Box::new(
                    PathPaymentStrictReceiveResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::PathPaymentStrictSendResultCode => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictSendResultCode(Box::new(
                    PathPaymentStrictSendResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::PathPaymentStrictSendResult => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictSendResult(Box::new(
                    PathPaymentStrictSendResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::ManageSellOfferResultCode => r.with_limited_depth(|r| {
                Ok(Self::ManageSellOfferResultCode(Box::new(
                    ManageSellOfferResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::ManageOfferEffect => r.with_limited_depth(|r| {
                Ok(Self::ManageOfferEffect(Box::new(
                    ManageOfferEffect::read_xdr(r)?,
                )))
            }),

            TypeVariant::ManageOfferSuccessResult => r.with_limited_depth(|r| {
                Ok(Self::ManageOfferSuccessResult(Box::new(
                    ManageOfferSuccessResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::ManageSellOfferResult => r.with_limited_depth(|r| {
                Ok(Self::ManageSellOfferResult(Box::new(
                    ManageSellOfferResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::ManageBuyOfferResultCode => r.with_limited_depth(|r| {
                Ok(Self::ManageBuyOfferResultCode(Box::new(
                    ManageBuyOfferResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::ManageBuyOfferResult => r.with_limited_depth(|r| {
                Ok(Self::ManageBuyOfferResult(Box::new(
                    ManageBuyOfferResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::SetOptionsResultCode => r.with_limited_depth(|r| {
                Ok(Self::SetOptionsResultCode(Box::new(
                    SetOptionsResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::SetOptionsResult => r.with_limited_depth(|r| {
                Ok(Self::SetOptionsResult(Box::new(
                    SetOptionsResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::ChangeTrustResultCode => r.with_limited_depth(|r| {
                Ok(Self::ChangeTrustResultCode(Box::new(
                    ChangeTrustResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::ChangeTrustResult => r.with_limited_depth(|r| {
                Ok(Self::ChangeTrustResult(Box::new(
                    ChangeTrustResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::AllowTrustResultCode => r.with_limited_depth(|r| {
                Ok(Self::AllowTrustResultCode(Box::new(
                    AllowTrustResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::AllowTrustResult => r.with_limited_depth(|r| {
                Ok(Self::AllowTrustResult(Box::new(
                    AllowTrustResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::AccountMergeResultCode => r.with_limited_depth(|r| {
                Ok(Self::AccountMergeResultCode(Box::new(
                    AccountMergeResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::AccountMergeResult => r.with_limited_depth(|r| {
                Ok(Self::AccountMergeResult(Box::new(
                    AccountMergeResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::InflationResultCode => r.with_limited_depth(|r| {
                Ok(Self::InflationResultCode(Box::new(
                    InflationResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::InflationPayout => r.with_limited_depth(|r| {
                Ok(Self::InflationPayout(Box::new(InflationPayout::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::InflationResult => r.with_limited_depth(|r| {
                Ok(Self::InflationResult(Box::new(InflationResult::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::ManageDataResultCode => r.with_limited_depth(|r| {
                Ok(Self::ManageDataResultCode(Box::new(
                    ManageDataResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::ManageDataResult => r.with_limited_depth(|r| {
                Ok(Self::ManageDataResult(Box::new(
                    ManageDataResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::BumpSequenceResultCode => r.with_limited_depth(|r| {
                Ok(Self::BumpSequenceResultCode(Box::new(
                    BumpSequenceResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::BumpSequenceResult => r.with_limited_depth(|r| {
                Ok(Self::BumpSequenceResult(Box::new(
                    BumpSequenceResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::CreateClaimableBalanceResultCode => r.with_limited_depth(|r| {
                Ok(Self::CreateClaimableBalanceResultCode(Box::new(
                    CreateClaimableBalanceResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::CreateClaimableBalanceResult => r.with_limited_depth(|r| {
                Ok(Self::CreateClaimableBalanceResult(Box::new(
                    CreateClaimableBalanceResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClaimClaimableBalanceResultCode => r.with_limited_depth(|r| {
                Ok(Self::ClaimClaimableBalanceResultCode(Box::new(
                    ClaimClaimableBalanceResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClaimClaimableBalanceResult => r.with_limited_depth(|r| {
                Ok(Self::ClaimClaimableBalanceResult(Box::new(
                    ClaimClaimableBalanceResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::BeginSponsoringFutureReservesResultCode => r.with_limited_depth(|r| {
                Ok(Self::BeginSponsoringFutureReservesResultCode(Box::new(
                    BeginSponsoringFutureReservesResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::BeginSponsoringFutureReservesResult => r.with_limited_depth(|r| {
                Ok(Self::BeginSponsoringFutureReservesResult(Box::new(
                    BeginSponsoringFutureReservesResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::EndSponsoringFutureReservesResultCode => r.with_limited_depth(|r| {
                Ok(Self::EndSponsoringFutureReservesResultCode(Box::new(
                    EndSponsoringFutureReservesResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::EndSponsoringFutureReservesResult => r.with_limited_depth(|r| {
                Ok(Self::EndSponsoringFutureReservesResult(Box::new(
                    EndSponsoringFutureReservesResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::RevokeSponsorshipResultCode => r.with_limited_depth(|r| {
                Ok(Self::RevokeSponsorshipResultCode(Box::new(
                    RevokeSponsorshipResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::RevokeSponsorshipResult => r.with_limited_depth(|r| {
                Ok(Self::RevokeSponsorshipResult(Box::new(
                    RevokeSponsorshipResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClawbackResultCode => r.with_limited_depth(|r| {
                Ok(Self::ClawbackResultCode(Box::new(
                    ClawbackResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClawbackResult => r.with_limited_depth(|r| {
                Ok(Self::ClawbackResult(Box::new(ClawbackResult::read_xdr(r)?)))
            }),

            TypeVariant::ClawbackClaimableBalanceResultCode => r.with_limited_depth(|r| {
                Ok(Self::ClawbackClaimableBalanceResultCode(Box::new(
                    ClawbackClaimableBalanceResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClawbackClaimableBalanceResult => r.with_limited_depth(|r| {
                Ok(Self::ClawbackClaimableBalanceResult(Box::new(
                    ClawbackClaimableBalanceResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::SetTrustLineFlagsResultCode => r.with_limited_depth(|r| {
                Ok(Self::SetTrustLineFlagsResultCode(Box::new(
                    SetTrustLineFlagsResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::SetTrustLineFlagsResult => r.with_limited_depth(|r| {
                Ok(Self::SetTrustLineFlagsResult(Box::new(
                    SetTrustLineFlagsResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::LiquidityPoolDepositResultCode => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolDepositResultCode(Box::new(
                    LiquidityPoolDepositResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::LiquidityPoolDepositResult => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolDepositResult(Box::new(
                    LiquidityPoolDepositResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::LiquidityPoolWithdrawResultCode => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolWithdrawResultCode(Box::new(
                    LiquidityPoolWithdrawResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::LiquidityPoolWithdrawResult => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolWithdrawResult(Box::new(
                    LiquidityPoolWithdrawResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::InvokeHostFunctionResultCode => r.with_limited_depth(|r| {
                Ok(Self::InvokeHostFunctionResultCode(Box::new(
                    InvokeHostFunctionResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::InvokeHostFunctionResult => r.with_limited_depth(|r| {
                Ok(Self::InvokeHostFunctionResult(Box::new(
                    InvokeHostFunctionResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::ExtendFootprintTtlResultCode => r.with_limited_depth(|r| {
                Ok(Self::ExtendFootprintTtlResultCode(Box::new(
                    ExtendFootprintTtlResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::ExtendFootprintTtlResult => r.with_limited_depth(|r| {
                Ok(Self::ExtendFootprintTtlResult(Box::new(
                    ExtendFootprintTtlResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::RestoreFootprintResultCode => r.with_limited_depth(|r| {
                Ok(Self::RestoreFootprintResultCode(Box::new(
                    RestoreFootprintResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::RestoreFootprintResult => r.with_limited_depth(|r| {
                Ok(Self::RestoreFootprintResult(Box::new(
                    RestoreFootprintResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::OperationResultCode => r.with_limited_depth(|r| {
                Ok(Self::OperationResultCode(Box::new(
                    OperationResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::OperationResult => r.with_limited_depth(|r| {
                Ok(Self::OperationResult(Box::new(OperationResult::read_xdr(
                    r,
                )?)))
            }),

            TypeVariant::TransactionResultCode => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultCode(Box::new(
                    TransactionResultCode::read_xdr(r)?,
                )))
            }),

            TypeVariant::InnerTransactionResult => r.with_limited_depth(|r| {
                Ok(Self::InnerTransactionResult(Box::new(
                    InnerTransactionResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::InnerTransactionResultPair => r.with_limited_depth(|r| {
                Ok(Self::InnerTransactionResultPair(Box::new(
                    InnerTransactionResultPair::read_xdr(r)?,
                )))
            }),

            TypeVariant::TransactionResult => r.with_limited_depth(|r| {
                Ok(Self::TransactionResult(Box::new(
                    TransactionResult::read_xdr(r)?,
                )))
            }),

            TypeVariant::Hash => {
                r.with_limited_depth(|r| Ok(Self::Hash(Box::new(Hash::read_xdr(r)?))))
            }

            TypeVariant::Uint256 => {
                r.with_limited_depth(|r| Ok(Self::Uint256(Box::new(Uint256::read_xdr(r)?))))
            }

            TypeVariant::Uint32 => {
                r.with_limited_depth(|r| Ok(Self::Uint32(Box::new(Uint32::read_xdr(r)?))))
            }

            TypeVariant::Int32 => {
                r.with_limited_depth(|r| Ok(Self::Int32(Box::new(Int32::read_xdr(r)?))))
            }

            TypeVariant::Uint64 => {
                r.with_limited_depth(|r| Ok(Self::Uint64(Box::new(Uint64::read_xdr(r)?))))
            }

            TypeVariant::Int64 => {
                r.with_limited_depth(|r| Ok(Self::Int64(Box::new(Int64::read_xdr(r)?))))
            }

            TypeVariant::TimePoint => {
                r.with_limited_depth(|r| Ok(Self::TimePoint(Box::new(TimePoint::read_xdr(r)?))))
            }

            TypeVariant::Duration => {
                r.with_limited_depth(|r| Ok(Self::Duration(Box::new(Duration::read_xdr(r)?))))
            }

            TypeVariant::ExtensionPoint => r.with_limited_depth(|r| {
                Ok(Self::ExtensionPoint(Box::new(ExtensionPoint::read_xdr(r)?)))
            }),

            TypeVariant::CryptoKeyType => r.with_limited_depth(|r| {
                Ok(Self::CryptoKeyType(Box::new(CryptoKeyType::read_xdr(r)?)))
            }),

            TypeVariant::PublicKeyType => r.with_limited_depth(|r| {
                Ok(Self::PublicKeyType(Box::new(PublicKeyType::read_xdr(r)?)))
            }),

            TypeVariant::SignerKeyType => r.with_limited_depth(|r| {
                Ok(Self::SignerKeyType(Box::new(SignerKeyType::read_xdr(r)?)))
            }),

            TypeVariant::PublicKey => {
                r.with_limited_depth(|r| Ok(Self::PublicKey(Box::new(PublicKey::read_xdr(r)?))))
            }

            TypeVariant::SignerKey => {
                r.with_limited_depth(|r| Ok(Self::SignerKey(Box::new(SignerKey::read_xdr(r)?))))
            }

            TypeVariant::Signature => {
                r.with_limited_depth(|r| Ok(Self::Signature(Box::new(Signature::read_xdr(r)?))))
            }

            TypeVariant::SignatureHint => r.with_limited_depth(|r| {
                Ok(Self::SignatureHint(Box::new(SignatureHint::read_xdr(r)?)))
            }),

            TypeVariant::NodeId => {
                r.with_limited_depth(|r| Ok(Self::NodeId(Box::new(NodeId::read_xdr(r)?))))
            }

            TypeVariant::AccountId => {
                r.with_limited_depth(|r| Ok(Self::AccountId(Box::new(AccountId::read_xdr(r)?))))
            }

            TypeVariant::ContractId => {
                r.with_limited_depth(|r| Ok(Self::ContractId(Box::new(ContractId::read_xdr(r)?))))
            }

            TypeVariant::Curve25519Secret => r.with_limited_depth(|r| {
                Ok(Self::Curve25519Secret(Box::new(
                    Curve25519Secret::read_xdr(r)?,
                )))
            }),

            TypeVariant::Curve25519Public => r.with_limited_depth(|r| {
                Ok(Self::Curve25519Public(Box::new(
                    Curve25519Public::read_xdr(r)?,
                )))
            }),

            TypeVariant::HmacSha256Key => r.with_limited_depth(|r| {
                Ok(Self::HmacSha256Key(Box::new(HmacSha256Key::read_xdr(r)?)))
            }),

            TypeVariant::HmacSha256Mac => r.with_limited_depth(|r| {
                Ok(Self::HmacSha256Mac(Box::new(HmacSha256Mac::read_xdr(r)?)))
            }),

            TypeVariant::ShortHashSeed => r.with_limited_depth(|r| {
                Ok(Self::ShortHashSeed(Box::new(ShortHashSeed::read_xdr(r)?)))
            }),

            TypeVariant::BinaryFuseFilterType => r.with_limited_depth(|r| {
                Ok(Self::BinaryFuseFilterType(Box::new(
                    BinaryFuseFilterType::read_xdr(r)?,
                )))
            }),

            TypeVariant::SerializedBinaryFuseFilter => r.with_limited_depth(|r| {
                Ok(Self::SerializedBinaryFuseFilter(Box::new(
                    SerializedBinaryFuseFilter::read_xdr(r)?,
                )))
            }),

            TypeVariant::PoolId => {
                r.with_limited_depth(|r| Ok(Self::PoolId(Box::new(PoolId::read_xdr(r)?))))
            }

            TypeVariant::ClaimableBalanceIdType => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceIdType(Box::new(
                    ClaimableBalanceIdType::read_xdr(r)?,
                )))
            }),

            TypeVariant::ClaimableBalanceId => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceId(Box::new(
                    ClaimableBalanceId::read_xdr(r)?,
                )))
            }),
        }
    }

    #[cfg(feature = "base64")]
    pub fn read_xdr_base64<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Result<Self, Error> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(
                SkipWhitespace::new(&mut r.inner),
                &base64::engine::general_purpose::STANDARD,
            ),
            r.limits.clone(),
        );
        let t = Self::read_xdr(v, &mut dec)?;
        Ok(t)
    }

    #[cfg(feature = "std")]
    pub fn read_xdr_to_end<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Result<Self, Error> {
        let s = Self::read_xdr(v, r)?;
        // Check that any further reads, such as this read of one byte, read no
        // data, indicating EOF. If a byte is read the data is invalid.
        if r.read(&mut [0u8; 1])? == 0 {
            Ok(s)
        } else {
            Err(Error::Invalid)
        }
    }

    #[cfg(feature = "base64")]
    pub fn read_xdr_base64_to_end<R: Read>(
        v: TypeVariant,
        r: &mut Limited<R>,
    ) -> Result<Self, Error> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(
                SkipWhitespace::new(&mut r.inner),
                &base64::engine::general_purpose::STANDARD,
            ),
            r.limits.clone(),
        );
        let t = Self::read_xdr_to_end(v, &mut dec)?;
        Ok(t)
    }

    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr_iter<R: Read>(
        v: TypeVariant,
        r: &mut Limited<R>,
    ) -> Box<dyn Iterator<Item = Result<Self, Error>> + '_> {
        match v {
            TypeVariant::ScpStatementPrepare => Box::new(
                ReadXdrIter::<_, ScpStatementPrepare>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPrepare(Box::new(t)))),
            ),

            TypeVariant::ScpStatementConfirm => Box::new(
                ReadXdrIter::<_, ScpStatementConfirm>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementConfirm(Box::new(t)))),
            ),

            TypeVariant::ScpStatementExternalize => Box::new(
                ReadXdrIter::<_, ScpStatementExternalize>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementExternalize(Box::new(t)))),
            ),

            TypeVariant::ScpStatementPledges => Box::new(
                ReadXdrIter::<_, ScpStatementPledges>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPledges(Box::new(t)))),
            ),

            TypeVariant::ScEnvMetaEntryInterfaceVersion => Box::new(
                ReadXdrIter::<_, ScEnvMetaEntryInterfaceVersion>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScEnvMetaEntryInterfaceVersion(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV2Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV2Ext(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV1Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV1Ext(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExt => Box::new(
                ReadXdrIter::<_, AccountEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExt(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, TrustLineEntryExtensionV2Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2Ext(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntryV1Ext => Box::new(
                ReadXdrIter::<_, TrustLineEntryV1Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1Ext(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntryV1 => Box::new(
                ReadXdrIter::<_, TrustLineEntryV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntryExt => Box::new(
                ReadXdrIter::<_, TrustLineEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExt(Box::new(t)))),
            ),

            TypeVariant::OfferEntryExt => Box::new(
                ReadXdrIter::<_, OfferEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryExt(Box::new(t)))),
            ),

            TypeVariant::DataEntryExt => Box::new(
                ReadXdrIter::<_, DataEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntryExt(Box::new(t)))),
            ),

            TypeVariant::ClaimantV0 => Box::new(
                ReadXdrIter::<_, ClaimantV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantV0(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExtensionV1Ext>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceEntryExt => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntryExt(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolEntryConstantProduct => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntryConstantProduct>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolEntryConstantProduct(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolEntryBody => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntryBody>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntryBody(Box::new(t)))),
            ),

            TypeVariant::ContractCodeEntryV1 => Box::new(
                ReadXdrIter::<_, ContractCodeEntryV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryV1(Box::new(t)))),
            ),

            TypeVariant::ContractCodeEntryExt => Box::new(
                ReadXdrIter::<_, ContractCodeEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryExt(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, LedgerEntryExtensionV1Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExtensionV1Ext(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryData => Box::new(
                ReadXdrIter::<_, LedgerEntryData>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryData(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryExt => Box::new(
                ReadXdrIter::<_, LedgerEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExt(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyAccount => Box::new(
                ReadXdrIter::<_, LedgerKeyAccount>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyAccount(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyTrustLine => Box::new(
                ReadXdrIter::<_, LedgerKeyTrustLine>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTrustLine(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyOffer => Box::new(
                ReadXdrIter::<_, LedgerKeyOffer>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyOffer(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyData => Box::new(
                ReadXdrIter::<_, LedgerKeyData>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyData(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyClaimableBalance => Box::new(
                ReadXdrIter::<_, LedgerKeyClaimableBalance>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyClaimableBalance(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyLiquidityPool => Box::new(
                ReadXdrIter::<_, LedgerKeyLiquidityPool>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyLiquidityPool(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyContractData => Box::new(
                ReadXdrIter::<_, LedgerKeyContractData>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractData(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyContractCode => Box::new(
                ReadXdrIter::<_, LedgerKeyContractCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractCode(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyConfigSetting => Box::new(
                ReadXdrIter::<_, LedgerKeyConfigSetting>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyConfigSetting(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyTtl => Box::new(
                ReadXdrIter::<_, LedgerKeyTtl>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTtl(Box::new(t)))),
            ),

            TypeVariant::BucketMetadataExt => Box::new(
                ReadXdrIter::<_, BucketMetadataExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadataExt(Box::new(t)))),
            ),

            TypeVariant::StellarValueExt => Box::new(
                ReadXdrIter::<_, StellarValueExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueExt(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderExtensionV1Ext => Box::new(
                ReadXdrIter::<_, LedgerHeaderExtensionV1Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1Ext(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderExt => Box::new(
                ReadXdrIter::<_, LedgerHeaderExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExt(Box::new(t)))),
            ),

            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => Box::new(
                ReadXdrIter::<_, TxSetComponentTxsMaybeDiscountedFee>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(t)))),
            ),

            TypeVariant::TransactionHistoryEntryExt => Box::new(
                ReadXdrIter::<_, TransactionHistoryEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryEntryExt(Box::new(t)))),
            ),

            TypeVariant::TransactionHistoryResultEntryExt => Box::new(
                ReadXdrIter::<_, TransactionHistoryResultEntryExt>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryResultEntryExt(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderHistoryEntryExt => Box::new(
                ReadXdrIter::<_, LedgerHeaderHistoryEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntryExt(Box::new(t)))),
            ),

            TypeVariant::ContractEventV0 => Box::new(
                ReadXdrIter::<_, ContractEventV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventV0(Box::new(t)))),
            ),

            TypeVariant::ContractEventBody => Box::new(
                ReadXdrIter::<_, ContractEventBody>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventBody(Box::new(t)))),
            ),

            TypeVariant::PeerAddressIp => Box::new(
                ReadXdrIter::<_, PeerAddressIp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddressIp(Box::new(t)))),
            ),

            TypeVariant::AuthenticatedMessageV0 => Box::new(
                ReadXdrIter::<_, AuthenticatedMessageV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthenticatedMessageV0(Box::new(t)))),
            ),

            TypeVariant::MuxedAccountMed25519 => Box::new(
                ReadXdrIter::<_, MuxedAccountMed25519>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccountMed25519(Box::new(t)))),
            ),

            TypeVariant::RevokeSponsorshipOpSigner => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipOpSigner>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipOpSigner(Box::new(t)))),
            ),

            TypeVariant::ContractIdPreimageFromAddress => Box::new(
                ReadXdrIter::<_, ContractIdPreimageFromAddress>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractIdPreimageFromAddress(Box::new(t)))),
            ),

            TypeVariant::OperationBody => Box::new(
                ReadXdrIter::<_, OperationBody>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationBody(Box::new(t)))),
            ),

            TypeVariant::HashIdPreimageOperationId => Box::new(
                ReadXdrIter::<_, HashIdPreimageOperationId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageOperationId(Box::new(t)))),
            ),

            TypeVariant::HashIdPreimageRevokeId => Box::new(
                ReadXdrIter::<_, HashIdPreimageRevokeId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageRevokeId(Box::new(t)))),
            ),

            TypeVariant::HashIdPreimageContractId => Box::new(
                ReadXdrIter::<_, HashIdPreimageContractId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageContractId(Box::new(t)))),
            ),

            TypeVariant::HashIdPreimageSorobanAuthorization => Box::new(
                ReadXdrIter::<_, HashIdPreimageSorobanAuthorization>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::HashIdPreimageSorobanAuthorization(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionDataExt => Box::new(
                ReadXdrIter::<_, SorobanTransactionDataExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionDataExt(Box::new(t)))),
            ),

            TypeVariant::TransactionV0Ext => Box::new(
                ReadXdrIter::<_, TransactionV0Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Ext(Box::new(t)))),
            ),

            TypeVariant::TransactionExt => Box::new(
                ReadXdrIter::<_, TransactionExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionExt(Box::new(t)))),
            ),

            TypeVariant::FeeBumpTransactionInnerTx => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionInnerTx>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionInnerTx(Box::new(t)))),
            ),

            TypeVariant::FeeBumpTransactionExt => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionExt(Box::new(t)))),
            ),

            TypeVariant::TransactionSignaturePayloadTaggedTransaction => Box::new(
                ReadXdrIter::<_, TransactionSignaturePayloadTaggedTransaction>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| {
                    r.map(|t| Self::TransactionSignaturePayloadTaggedTransaction(Box::new(t)))
                }),
            ),

            TypeVariant::PathPaymentStrictReceiveResultSuccess => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResultSuccess>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultSuccess(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictSendResultSuccess => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResultSuccess>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendResultSuccess(Box::new(t)))),
            ),

            TypeVariant::ManageOfferSuccessResultOffer => Box::new(
                ReadXdrIter::<_, ManageOfferSuccessResultOffer>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ManageOfferSuccessResultOffer(Box::new(t)))),
            ),

            TypeVariant::OperationResultTr => Box::new(
                ReadXdrIter::<_, OperationResultTr>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultTr(Box::new(t)))),
            ),

            TypeVariant::InnerTransactionResultResult => Box::new(
                ReadXdrIter::<_, InnerTransactionResultResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultResult(Box::new(t)))),
            ),

            TypeVariant::InnerTransactionResultExt => Box::new(
                ReadXdrIter::<_, InnerTransactionResultExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultExt(Box::new(t)))),
            ),

            TypeVariant::TransactionResultResult => Box::new(
                ReadXdrIter::<_, TransactionResultResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultResult(Box::new(t)))),
            ),

            TypeVariant::TransactionResultExt => Box::new(
                ReadXdrIter::<_, TransactionResultExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultExt(Box::new(t)))),
            ),

            TypeVariant::SignerKeyEd25519SignedPayload => Box::new(
                ReadXdrIter::<_, SignerKeyEd25519SignedPayload>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignerKeyEd25519SignedPayload(Box::new(t)))),
            ),

            TypeVariant::Value => Box::new(
                ReadXdrIter::<_, Value>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Value(Box::new(t)))),
            ),

            TypeVariant::ScpBallot => Box::new(
                ReadXdrIter::<_, ScpBallot>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpBallot(Box::new(t)))),
            ),

            TypeVariant::ScpStatementType => Box::new(
                ReadXdrIter::<_, ScpStatementType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementType(Box::new(t)))),
            ),

            TypeVariant::ScpNomination => Box::new(
                ReadXdrIter::<_, ScpNomination>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpNomination(Box::new(t)))),
            ),

            TypeVariant::ScpStatement => Box::new(
                ReadXdrIter::<_, ScpStatement>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatement(Box::new(t)))),
            ),

            TypeVariant::ScpEnvelope => Box::new(
                ReadXdrIter::<_, ScpEnvelope>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpEnvelope(Box::new(t)))),
            ),

            TypeVariant::ScpQuorumSet => Box::new(
                ReadXdrIter::<_, ScpQuorumSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpQuorumSet(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractExecutionLanesV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractExecutionLanesV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractExecutionLanesV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractComputeV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractComputeV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractComputeV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractParallelComputeV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractParallelComputeV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractParallelComputeV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractLedgerCostV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractLedgerCostV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractLedgerCostV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractLedgerCostExtV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractLedgerCostExtV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractLedgerCostExtV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractHistoricalDataV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractHistoricalDataV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractHistoricalDataV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractEventsV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractEventsV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractEventsV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractBandwidthV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractBandwidthV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractBandwidthV0(Box::new(t)))),
            ),

            TypeVariant::ContractCostType => Box::new(
                ReadXdrIter::<_, ContractCostType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostType(Box::new(t)))),
            ),

            TypeVariant::ContractCostParamEntry => Box::new(
                ReadXdrIter::<_, ContractCostParamEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostParamEntry(Box::new(t)))),
            ),

            TypeVariant::StateArchivalSettings => Box::new(
                ReadXdrIter::<_, StateArchivalSettings>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StateArchivalSettings(Box::new(t)))),
            ),

            TypeVariant::EvictionIterator => Box::new(
                ReadXdrIter::<_, EvictionIterator>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EvictionIterator(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingScpTiming => Box::new(
                ReadXdrIter::<_, ConfigSettingScpTiming>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingScpTiming(Box::new(t)))),
            ),

            TypeVariant::ContractCostParams => Box::new(
                ReadXdrIter::<_, ContractCostParams>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostParams(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingId => Box::new(
                ReadXdrIter::<_, ConfigSettingId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingId(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingEntry => Box::new(
                ReadXdrIter::<_, ConfigSettingEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingEntry(Box::new(t)))),
            ),

            TypeVariant::ScEnvMetaKind => Box::new(
                ReadXdrIter::<_, ScEnvMetaKind>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaKind(Box::new(t)))),
            ),

            TypeVariant::ScEnvMetaEntry => Box::new(
                ReadXdrIter::<_, ScEnvMetaEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaEntry(Box::new(t)))),
            ),

            TypeVariant::ScMetaV0 => Box::new(
                ReadXdrIter::<_, ScMetaV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaV0(Box::new(t)))),
            ),

            TypeVariant::ScMetaKind => Box::new(
                ReadXdrIter::<_, ScMetaKind>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaKind(Box::new(t)))),
            ),

            TypeVariant::ScMetaEntry => Box::new(
                ReadXdrIter::<_, ScMetaEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaEntry(Box::new(t)))),
            ),

            TypeVariant::ScSpecType => Box::new(
                ReadXdrIter::<_, ScSpecType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecType(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeOption => Box::new(
                ReadXdrIter::<_, ScSpecTypeOption>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeOption(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeResult => Box::new(
                ReadXdrIter::<_, ScSpecTypeResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeResult(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeVec => Box::new(
                ReadXdrIter::<_, ScSpecTypeVec>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeVec(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeMap => Box::new(
                ReadXdrIter::<_, ScSpecTypeMap>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeMap(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeTuple => Box::new(
                ReadXdrIter::<_, ScSpecTypeTuple>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeTuple(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeBytesN => Box::new(
                ReadXdrIter::<_, ScSpecTypeBytesN>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeBytesN(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeUdt => Box::new(
                ReadXdrIter::<_, ScSpecTypeUdt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeUdt(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeDef => Box::new(
                ReadXdrIter::<_, ScSpecTypeDef>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeDef(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtStructFieldV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtStructFieldV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtStructFieldV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtStructV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtStructV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtStructV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseVoidV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseVoidV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseVoidV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseTupleV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseTupleV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseTupleV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseV0Kind => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseV0Kind>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0Kind(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtUnionV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtEnumCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtEnumCaseV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumCaseV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtEnumV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtEnumV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtErrorEnumCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtErrorEnumCaseV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumCaseV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtErrorEnumV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtErrorEnumV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecFunctionInputV0 => Box::new(
                ReadXdrIter::<_, ScSpecFunctionInputV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionInputV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecFunctionV0 => Box::new(
                ReadXdrIter::<_, ScSpecFunctionV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecEventParamLocationV0 => Box::new(
                ReadXdrIter::<_, ScSpecEventParamLocationV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEventParamLocationV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecEventParamV0 => Box::new(
                ReadXdrIter::<_, ScSpecEventParamV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEventParamV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecEventDataFormat => Box::new(
                ReadXdrIter::<_, ScSpecEventDataFormat>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEventDataFormat(Box::new(t)))),
            ),

            TypeVariant::ScSpecEventV0 => Box::new(
                ReadXdrIter::<_, ScSpecEventV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEventV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecEntryKind => Box::new(
                ReadXdrIter::<_, ScSpecEntryKind>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntryKind(Box::new(t)))),
            ),

            TypeVariant::ScSpecEntry => Box::new(
                ReadXdrIter::<_, ScSpecEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntry(Box::new(t)))),
            ),

            TypeVariant::ScValType => Box::new(
                ReadXdrIter::<_, ScValType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScValType(Box::new(t)))),
            ),

            TypeVariant::ScErrorType => Box::new(
                ReadXdrIter::<_, ScErrorType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorType(Box::new(t)))),
            ),

            TypeVariant::ScErrorCode => Box::new(
                ReadXdrIter::<_, ScErrorCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorCode(Box::new(t)))),
            ),

            TypeVariant::ScError => Box::new(
                ReadXdrIter::<_, ScError>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScError(Box::new(t)))),
            ),

            TypeVariant::UInt128Parts => Box::new(
                ReadXdrIter::<_, UInt128Parts>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt128Parts(Box::new(t)))),
            ),

            TypeVariant::Int128Parts => Box::new(
                ReadXdrIter::<_, Int128Parts>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int128Parts(Box::new(t)))),
            ),

            TypeVariant::UInt256Parts => Box::new(
                ReadXdrIter::<_, UInt256Parts>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt256Parts(Box::new(t)))),
            ),

            TypeVariant::Int256Parts => Box::new(
                ReadXdrIter::<_, Int256Parts>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int256Parts(Box::new(t)))),
            ),

            TypeVariant::ContractExecutableType => Box::new(
                ReadXdrIter::<_, ContractExecutableType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractExecutableType(Box::new(t)))),
            ),

            TypeVariant::ContractExecutable => Box::new(
                ReadXdrIter::<_, ContractExecutable>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractExecutable(Box::new(t)))),
            ),

            TypeVariant::ScAddressType => Box::new(
                ReadXdrIter::<_, ScAddressType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddressType(Box::new(t)))),
            ),

            TypeVariant::MuxedEd25519Account => Box::new(
                ReadXdrIter::<_, MuxedEd25519Account>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedEd25519Account(Box::new(t)))),
            ),

            TypeVariant::ScAddress => Box::new(
                ReadXdrIter::<_, ScAddress>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddress(Box::new(t)))),
            ),

            TypeVariant::ScVec => Box::new(
                ReadXdrIter::<_, ScVec>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVec(Box::new(t)))),
            ),

            TypeVariant::ScMap => Box::new(
                ReadXdrIter::<_, ScMap>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMap(Box::new(t)))),
            ),

            TypeVariant::ScBytes => Box::new(
                ReadXdrIter::<_, ScBytes>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScBytes(Box::new(t)))),
            ),

            TypeVariant::ScString => Box::new(
                ReadXdrIter::<_, ScString>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScString(Box::new(t)))),
            ),

            TypeVariant::ScSymbol => Box::new(
                ReadXdrIter::<_, ScSymbol>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSymbol(Box::new(t)))),
            ),

            TypeVariant::ScNonceKey => Box::new(
                ReadXdrIter::<_, ScNonceKey>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScNonceKey(Box::new(t)))),
            ),

            TypeVariant::ScContractInstance => Box::new(
                ReadXdrIter::<_, ScContractInstance>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScContractInstance(Box::new(t)))),
            ),

            TypeVariant::ScVal => Box::new(
                ReadXdrIter::<_, ScVal>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVal(Box::new(t)))),
            ),

            TypeVariant::ScMapEntry => Box::new(
                ReadXdrIter::<_, ScMapEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMapEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaBatch => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaBatch>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaBatch(Box::new(t)))),
            ),

            TypeVariant::StoredTransactionSet => Box::new(
                ReadXdrIter::<_, StoredTransactionSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StoredTransactionSet(Box::new(t)))),
            ),

            TypeVariant::StoredDebugTransactionSet => Box::new(
                ReadXdrIter::<_, StoredDebugTransactionSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StoredDebugTransactionSet(Box::new(t)))),
            ),

            TypeVariant::PersistedScpStateV0 => Box::new(
                ReadXdrIter::<_, PersistedScpStateV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV0(Box::new(t)))),
            ),

            TypeVariant::PersistedScpStateV1 => Box::new(
                ReadXdrIter::<_, PersistedScpStateV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV1(Box::new(t)))),
            ),

            TypeVariant::PersistedScpState => Box::new(
                ReadXdrIter::<_, PersistedScpState>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpState(Box::new(t)))),
            ),

            TypeVariant::Thresholds => Box::new(
                ReadXdrIter::<_, Thresholds>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Thresholds(Box::new(t)))),
            ),

            TypeVariant::String32 => Box::new(
                ReadXdrIter::<_, String32>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::String32(Box::new(t)))),
            ),

            TypeVariant::String64 => Box::new(
                ReadXdrIter::<_, String64>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::String64(Box::new(t)))),
            ),

            TypeVariant::SequenceNumber => Box::new(
                ReadXdrIter::<_, SequenceNumber>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SequenceNumber(Box::new(t)))),
            ),

            TypeVariant::DataValue => Box::new(
                ReadXdrIter::<_, DataValue>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataValue(Box::new(t)))),
            ),

            TypeVariant::AssetCode4 => Box::new(
                ReadXdrIter::<_, AssetCode4>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode4(Box::new(t)))),
            ),

            TypeVariant::AssetCode12 => Box::new(
                ReadXdrIter::<_, AssetCode12>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode12(Box::new(t)))),
            ),

            TypeVariant::AssetType => Box::new(
                ReadXdrIter::<_, AssetType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetType(Box::new(t)))),
            ),

            TypeVariant::AssetCode => Box::new(
                ReadXdrIter::<_, AssetCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode(Box::new(t)))),
            ),

            TypeVariant::AlphaNum4 => Box::new(
                ReadXdrIter::<_, AlphaNum4>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum4(Box::new(t)))),
            ),

            TypeVariant::AlphaNum12 => Box::new(
                ReadXdrIter::<_, AlphaNum12>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum12(Box::new(t)))),
            ),

            TypeVariant::Asset => Box::new(
                ReadXdrIter::<_, Asset>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Asset(Box::new(t)))),
            ),

            TypeVariant::Price => Box::new(
                ReadXdrIter::<_, Price>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Price(Box::new(t)))),
            ),

            TypeVariant::Liabilities => Box::new(
                ReadXdrIter::<_, Liabilities>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Liabilities(Box::new(t)))),
            ),

            TypeVariant::ThresholdIndexes => Box::new(
                ReadXdrIter::<_, ThresholdIndexes>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ThresholdIndexes(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryType => Box::new(
                ReadXdrIter::<_, LedgerEntryType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryType(Box::new(t)))),
            ),

            TypeVariant::Signer => Box::new(
                ReadXdrIter::<_, Signer>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signer(Box::new(t)))),
            ),

            TypeVariant::AccountFlags => Box::new(
                ReadXdrIter::<_, AccountFlags>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountFlags(Box::new(t)))),
            ),

            TypeVariant::SponsorshipDescriptor => Box::new(
                ReadXdrIter::<_, SponsorshipDescriptor>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SponsorshipDescriptor(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExtensionV3 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV3>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV3(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV2(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV1(Box::new(t)))),
            ),

            TypeVariant::AccountEntry => Box::new(
                ReadXdrIter::<_, AccountEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntry(Box::new(t)))),
            ),

            TypeVariant::TrustLineFlags => Box::new(
                ReadXdrIter::<_, TrustLineFlags>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineFlags(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolType => Box::new(
                ReadXdrIter::<_, LiquidityPoolType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolType(Box::new(t)))),
            ),

            TypeVariant::TrustLineAsset => Box::new(
                ReadXdrIter::<_, TrustLineAsset>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineAsset(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, TrustLineEntryExtensionV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntry => Box::new(
                ReadXdrIter::<_, TrustLineEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntry(Box::new(t)))),
            ),

            TypeVariant::OfferEntryFlags => Box::new(
                ReadXdrIter::<_, OfferEntryFlags>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryFlags(Box::new(t)))),
            ),

            TypeVariant::OfferEntry => Box::new(
                ReadXdrIter::<_, OfferEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntry(Box::new(t)))),
            ),

            TypeVariant::DataEntry => Box::new(
                ReadXdrIter::<_, DataEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntry(Box::new(t)))),
            ),

            TypeVariant::ClaimPredicateType => Box::new(
                ReadXdrIter::<_, ClaimPredicateType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicateType(Box::new(t)))),
            ),

            TypeVariant::ClaimPredicate => Box::new(
                ReadXdrIter::<_, ClaimPredicate>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicate(Box::new(t)))),
            ),

            TypeVariant::ClaimantType => Box::new(
                ReadXdrIter::<_, ClaimantType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantType(Box::new(t)))),
            ),

            TypeVariant::Claimant => Box::new(
                ReadXdrIter::<_, Claimant>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Claimant(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceFlags => Box::new(
                ReadXdrIter::<_, ClaimableBalanceFlags>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceFlags(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExtensionV1>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceEntry => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntry(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolConstantProductParameters => Box::new(
                ReadXdrIter::<_, LiquidityPoolConstantProductParameters>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolConstantProductParameters(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolEntry => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntry(Box::new(t)))),
            ),

            TypeVariant::ContractDataDurability => Box::new(
                ReadXdrIter::<_, ContractDataDurability>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractDataDurability(Box::new(t)))),
            ),

            TypeVariant::ContractDataEntry => Box::new(
                ReadXdrIter::<_, ContractDataEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractDataEntry(Box::new(t)))),
            ),

            TypeVariant::ContractCodeCostInputs => Box::new(
                ReadXdrIter::<_, ContractCodeCostInputs>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeCostInputs(Box::new(t)))),
            ),

            TypeVariant::ContractCodeEntry => Box::new(
                ReadXdrIter::<_, ContractCodeEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntry(Box::new(t)))),
            ),

            TypeVariant::TtlEntry => Box::new(
                ReadXdrIter::<_, TtlEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TtlEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, LedgerEntryExtensionV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExtensionV1(Box::new(t)))),
            ),

            TypeVariant::LedgerEntry => Box::new(
                ReadXdrIter::<_, LedgerEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerKey => Box::new(
                ReadXdrIter::<_, LedgerKey>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKey(Box::new(t)))),
            ),

            TypeVariant::EnvelopeType => Box::new(
                ReadXdrIter::<_, EnvelopeType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EnvelopeType(Box::new(t)))),
            ),

            TypeVariant::BucketListType => Box::new(
                ReadXdrIter::<_, BucketListType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketListType(Box::new(t)))),
            ),

            TypeVariant::BucketEntryType => Box::new(
                ReadXdrIter::<_, BucketEntryType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntryType(Box::new(t)))),
            ),

            TypeVariant::HotArchiveBucketEntryType => Box::new(
                ReadXdrIter::<_, HotArchiveBucketEntryType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HotArchiveBucketEntryType(Box::new(t)))),
            ),

            TypeVariant::BucketMetadata => Box::new(
                ReadXdrIter::<_, BucketMetadata>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadata(Box::new(t)))),
            ),

            TypeVariant::BucketEntry => Box::new(
                ReadXdrIter::<_, BucketEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntry(Box::new(t)))),
            ),

            TypeVariant::HotArchiveBucketEntry => Box::new(
                ReadXdrIter::<_, HotArchiveBucketEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HotArchiveBucketEntry(Box::new(t)))),
            ),

            TypeVariant::UpgradeType => Box::new(
                ReadXdrIter::<_, UpgradeType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeType(Box::new(t)))),
            ),

            TypeVariant::StellarValueType => Box::new(
                ReadXdrIter::<_, StellarValueType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueType(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseValueSignature => Box::new(
                ReadXdrIter::<_, LedgerCloseValueSignature>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseValueSignature(Box::new(t)))),
            ),

            TypeVariant::StellarValue => Box::new(
                ReadXdrIter::<_, StellarValue>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValue(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderFlags => Box::new(
                ReadXdrIter::<_, LedgerHeaderFlags>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderFlags(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderExtensionV1 => Box::new(
                ReadXdrIter::<_, LedgerHeaderExtensionV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1(Box::new(t)))),
            ),

            TypeVariant::LedgerHeader => Box::new(
                ReadXdrIter::<_, LedgerHeader>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeader(Box::new(t)))),
            ),

            TypeVariant::LedgerUpgradeType => Box::new(
                ReadXdrIter::<_, LedgerUpgradeType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgradeType(Box::new(t)))),
            ),

            TypeVariant::ConfigUpgradeSetKey => Box::new(
                ReadXdrIter::<_, ConfigUpgradeSetKey>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSetKey(Box::new(t)))),
            ),

            TypeVariant::LedgerUpgrade => Box::new(
                ReadXdrIter::<_, LedgerUpgrade>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgrade(Box::new(t)))),
            ),

            TypeVariant::ConfigUpgradeSet => Box::new(
                ReadXdrIter::<_, ConfigUpgradeSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSet(Box::new(t)))),
            ),

            TypeVariant::TxSetComponentType => Box::new(
                ReadXdrIter::<_, TxSetComponentType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponentType(Box::new(t)))),
            ),

            TypeVariant::DependentTxCluster => Box::new(
                ReadXdrIter::<_, DependentTxCluster>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DependentTxCluster(Box::new(t)))),
            ),

            TypeVariant::ParallelTxExecutionStage => Box::new(
                ReadXdrIter::<_, ParallelTxExecutionStage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ParallelTxExecutionStage(Box::new(t)))),
            ),

            TypeVariant::ParallelTxsComponent => Box::new(
                ReadXdrIter::<_, ParallelTxsComponent>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ParallelTxsComponent(Box::new(t)))),
            ),

            TypeVariant::TxSetComponent => Box::new(
                ReadXdrIter::<_, TxSetComponent>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponent(Box::new(t)))),
            ),

            TypeVariant::TransactionPhase => Box::new(
                ReadXdrIter::<_, TransactionPhase>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionPhase(Box::new(t)))),
            ),

            TypeVariant::TransactionSet => Box::new(
                ReadXdrIter::<_, TransactionSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSet(Box::new(t)))),
            ),

            TypeVariant::TransactionSetV1 => Box::new(
                ReadXdrIter::<_, TransactionSetV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSetV1(Box::new(t)))),
            ),

            TypeVariant::GeneralizedTransactionSet => Box::new(
                ReadXdrIter::<_, GeneralizedTransactionSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::GeneralizedTransactionSet(Box::new(t)))),
            ),

            TypeVariant::TransactionResultPair => Box::new(
                ReadXdrIter::<_, TransactionResultPair>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultPair(Box::new(t)))),
            ),

            TypeVariant::TransactionResultSet => Box::new(
                ReadXdrIter::<_, TransactionResultSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultSet(Box::new(t)))),
            ),

            TypeVariant::TransactionHistoryEntry => Box::new(
                ReadXdrIter::<_, TransactionHistoryEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryEntry(Box::new(t)))),
            ),

            TypeVariant::TransactionHistoryResultEntry => Box::new(
                ReadXdrIter::<_, TransactionHistoryResultEntry>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryResultEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderHistoryEntry => Box::new(
                ReadXdrIter::<_, LedgerHeaderHistoryEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerScpMessages => Box::new(
                ReadXdrIter::<_, LedgerScpMessages>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerScpMessages(Box::new(t)))),
            ),

            TypeVariant::ScpHistoryEntryV0 => Box::new(
                ReadXdrIter::<_, ScpHistoryEntryV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntryV0(Box::new(t)))),
            ),

            TypeVariant::ScpHistoryEntry => Box::new(
                ReadXdrIter::<_, ScpHistoryEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryChangeType => Box::new(
                ReadXdrIter::<_, LedgerEntryChangeType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChangeType(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryChange => Box::new(
                ReadXdrIter::<_, LedgerEntryChange>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChange(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryChanges => Box::new(
                ReadXdrIter::<_, LedgerEntryChanges>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChanges(Box::new(t)))),
            ),

            TypeVariant::OperationMeta => Box::new(
                ReadXdrIter::<_, OperationMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationMeta(Box::new(t)))),
            ),

            TypeVariant::TransactionMetaV1 => Box::new(
                ReadXdrIter::<_, TransactionMetaV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV1(Box::new(t)))),
            ),

            TypeVariant::TransactionMetaV2 => Box::new(
                ReadXdrIter::<_, TransactionMetaV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV2(Box::new(t)))),
            ),

            TypeVariant::ContractEventType => Box::new(
                ReadXdrIter::<_, ContractEventType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventType(Box::new(t)))),
            ),

            TypeVariant::ContractEvent => Box::new(
                ReadXdrIter::<_, ContractEvent>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEvent(Box::new(t)))),
            ),

            TypeVariant::DiagnosticEvent => Box::new(
                ReadXdrIter::<_, DiagnosticEvent>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DiagnosticEvent(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionMetaExtV1 => Box::new(
                ReadXdrIter::<_, SorobanTransactionMetaExtV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMetaExtV1(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionMetaExt => Box::new(
                ReadXdrIter::<_, SorobanTransactionMetaExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMetaExt(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionMeta => Box::new(
                ReadXdrIter::<_, SorobanTransactionMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMeta(Box::new(t)))),
            ),

            TypeVariant::TransactionMetaV3 => Box::new(
                ReadXdrIter::<_, TransactionMetaV3>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV3(Box::new(t)))),
            ),

            TypeVariant::OperationMetaV2 => Box::new(
                ReadXdrIter::<_, OperationMetaV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationMetaV2(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionMetaV2 => Box::new(
                ReadXdrIter::<_, SorobanTransactionMetaV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMetaV2(Box::new(t)))),
            ),

            TypeVariant::TransactionEventStage => Box::new(
                ReadXdrIter::<_, TransactionEventStage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEventStage(Box::new(t)))),
            ),

            TypeVariant::TransactionEvent => Box::new(
                ReadXdrIter::<_, TransactionEvent>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEvent(Box::new(t)))),
            ),

            TypeVariant::TransactionMetaV4 => Box::new(
                ReadXdrIter::<_, TransactionMetaV4>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV4(Box::new(t)))),
            ),

            TypeVariant::InvokeHostFunctionSuccessPreImage => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionSuccessPreImage>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InvokeHostFunctionSuccessPreImage(Box::new(t)))),
            ),

            TypeVariant::TransactionMeta => Box::new(
                ReadXdrIter::<_, TransactionMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMeta(Box::new(t)))),
            ),

            TypeVariant::TransactionResultMeta => Box::new(
                ReadXdrIter::<_, TransactionResultMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultMeta(Box::new(t)))),
            ),

            TypeVariant::TransactionResultMetaV1 => Box::new(
                ReadXdrIter::<_, TransactionResultMetaV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultMetaV1(Box::new(t)))),
            ),

            TypeVariant::UpgradeEntryMeta => Box::new(
                ReadXdrIter::<_, UpgradeEntryMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeEntryMeta(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaV0 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV0(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaExtV1 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaExtV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExtV1(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaExt => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExt(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaV1 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV1(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaV2 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV2(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMeta => Box::new(
                ReadXdrIter::<_, LedgerCloseMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMeta(Box::new(t)))),
            ),

            TypeVariant::ErrorCode => Box::new(
                ReadXdrIter::<_, ErrorCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ErrorCode(Box::new(t)))),
            ),

            TypeVariant::SError => Box::new(
                ReadXdrIter::<_, SError>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SError(Box::new(t)))),
            ),

            TypeVariant::SendMore => Box::new(
                ReadXdrIter::<_, SendMore>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMore(Box::new(t)))),
            ),

            TypeVariant::SendMoreExtended => Box::new(
                ReadXdrIter::<_, SendMoreExtended>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMoreExtended(Box::new(t)))),
            ),

            TypeVariant::AuthCert => Box::new(
                ReadXdrIter::<_, AuthCert>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthCert(Box::new(t)))),
            ),

            TypeVariant::Hello => Box::new(
                ReadXdrIter::<_, Hello>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hello(Box::new(t)))),
            ),

            TypeVariant::Auth => Box::new(
                ReadXdrIter::<_, Auth>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Auth(Box::new(t)))),
            ),

            TypeVariant::IpAddrType => Box::new(
                ReadXdrIter::<_, IpAddrType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::IpAddrType(Box::new(t)))),
            ),

            TypeVariant::PeerAddress => Box::new(
                ReadXdrIter::<_, PeerAddress>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddress(Box::new(t)))),
            ),

            TypeVariant::MessageType => Box::new(
                ReadXdrIter::<_, MessageType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MessageType(Box::new(t)))),
            ),

            TypeVariant::DontHave => Box::new(
                ReadXdrIter::<_, DontHave>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DontHave(Box::new(t)))),
            ),

            TypeVariant::SurveyMessageCommandType => Box::new(
                ReadXdrIter::<_, SurveyMessageCommandType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyMessageCommandType(Box::new(t)))),
            ),

            TypeVariant::SurveyMessageResponseType => Box::new(
                ReadXdrIter::<_, SurveyMessageResponseType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyMessageResponseType(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedSurveyStartCollectingMessage => Box::new(
                ReadXdrIter::<_, TimeSlicedSurveyStartCollectingMessage>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TimeSlicedSurveyStartCollectingMessage(Box::new(t)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyStartCollectingMessage => Box::new(
                ReadXdrIter::<_, SignedTimeSlicedSurveyStartCollectingMessage>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| {
                    r.map(|t| Self::SignedTimeSlicedSurveyStartCollectingMessage(Box::new(t)))
                }),
            ),

            TypeVariant::TimeSlicedSurveyStopCollectingMessage => Box::new(
                ReadXdrIter::<_, TimeSlicedSurveyStopCollectingMessage>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TimeSlicedSurveyStopCollectingMessage(Box::new(t)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyStopCollectingMessage => Box::new(
                ReadXdrIter::<_, SignedTimeSlicedSurveyStopCollectingMessage>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignedTimeSlicedSurveyStopCollectingMessage(Box::new(t)))),
            ),

            TypeVariant::SurveyRequestMessage => Box::new(
                ReadXdrIter::<_, SurveyRequestMessage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyRequestMessage(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedSurveyRequestMessage => Box::new(
                ReadXdrIter::<_, TimeSlicedSurveyRequestMessage>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TimeSlicedSurveyRequestMessage(Box::new(t)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyRequestMessage => Box::new(
                ReadXdrIter::<_, SignedTimeSlicedSurveyRequestMessage>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignedTimeSlicedSurveyRequestMessage(Box::new(t)))),
            ),

            TypeVariant::EncryptedBody => Box::new(
                ReadXdrIter::<_, EncryptedBody>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EncryptedBody(Box::new(t)))),
            ),

            TypeVariant::SurveyResponseMessage => Box::new(
                ReadXdrIter::<_, SurveyResponseMessage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseMessage(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedSurveyResponseMessage => Box::new(
                ReadXdrIter::<_, TimeSlicedSurveyResponseMessage>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TimeSlicedSurveyResponseMessage(Box::new(t)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyResponseMessage => Box::new(
                ReadXdrIter::<_, SignedTimeSlicedSurveyResponseMessage>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignedTimeSlicedSurveyResponseMessage(Box::new(t)))),
            ),

            TypeVariant::PeerStats => Box::new(
                ReadXdrIter::<_, PeerStats>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerStats(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedNodeData => Box::new(
                ReadXdrIter::<_, TimeSlicedNodeData>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeSlicedNodeData(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedPeerData => Box::new(
                ReadXdrIter::<_, TimeSlicedPeerData>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeSlicedPeerData(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedPeerDataList => Box::new(
                ReadXdrIter::<_, TimeSlicedPeerDataList>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeSlicedPeerDataList(Box::new(t)))),
            ),

            TypeVariant::TopologyResponseBodyV2 => Box::new(
                ReadXdrIter::<_, TopologyResponseBodyV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TopologyResponseBodyV2(Box::new(t)))),
            ),

            TypeVariant::SurveyResponseBody => Box::new(
                ReadXdrIter::<_, SurveyResponseBody>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseBody(Box::new(t)))),
            ),

            TypeVariant::TxAdvertVector => Box::new(
                ReadXdrIter::<_, TxAdvertVector>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxAdvertVector(Box::new(t)))),
            ),

            TypeVariant::FloodAdvert => Box::new(
                ReadXdrIter::<_, FloodAdvert>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodAdvert(Box::new(t)))),
            ),

            TypeVariant::TxDemandVector => Box::new(
                ReadXdrIter::<_, TxDemandVector>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxDemandVector(Box::new(t)))),
            ),

            TypeVariant::FloodDemand => Box::new(
                ReadXdrIter::<_, FloodDemand>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodDemand(Box::new(t)))),
            ),

            TypeVariant::StellarMessage => Box::new(
                ReadXdrIter::<_, StellarMessage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarMessage(Box::new(t)))),
            ),

            TypeVariant::AuthenticatedMessage => Box::new(
                ReadXdrIter::<_, AuthenticatedMessage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthenticatedMessage(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolParameters => Box::new(
                ReadXdrIter::<_, LiquidityPoolParameters>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolParameters(Box::new(t)))),
            ),

            TypeVariant::MuxedAccount => Box::new(
                ReadXdrIter::<_, MuxedAccount>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccount(Box::new(t)))),
            ),

            TypeVariant::DecoratedSignature => Box::new(
                ReadXdrIter::<_, DecoratedSignature>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DecoratedSignature(Box::new(t)))),
            ),

            TypeVariant::OperationType => Box::new(
                ReadXdrIter::<_, OperationType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationType(Box::new(t)))),
            ),

            TypeVariant::CreateAccountOp => Box::new(
                ReadXdrIter::<_, CreateAccountOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountOp(Box::new(t)))),
            ),

            TypeVariant::PaymentOp => Box::new(
                ReadXdrIter::<_, PaymentOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentOp(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictReceiveOp => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictReceiveOp(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictSendOp => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendOp(Box::new(t)))),
            ),

            TypeVariant::ManageSellOfferOp => Box::new(
                ReadXdrIter::<_, ManageSellOfferOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferOp(Box::new(t)))),
            ),

            TypeVariant::ManageBuyOfferOp => Box::new(
                ReadXdrIter::<_, ManageBuyOfferOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferOp(Box::new(t)))),
            ),

            TypeVariant::CreatePassiveSellOfferOp => Box::new(
                ReadXdrIter::<_, CreatePassiveSellOfferOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreatePassiveSellOfferOp(Box::new(t)))),
            ),

            TypeVariant::SetOptionsOp => Box::new(
                ReadXdrIter::<_, SetOptionsOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsOp(Box::new(t)))),
            ),

            TypeVariant::ChangeTrustAsset => Box::new(
                ReadXdrIter::<_, ChangeTrustAsset>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustAsset(Box::new(t)))),
            ),

            TypeVariant::ChangeTrustOp => Box::new(
                ReadXdrIter::<_, ChangeTrustOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustOp(Box::new(t)))),
            ),

            TypeVariant::AllowTrustOp => Box::new(
                ReadXdrIter::<_, AllowTrustOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustOp(Box::new(t)))),
            ),

            TypeVariant::ManageDataOp => Box::new(
                ReadXdrIter::<_, ManageDataOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataOp(Box::new(t)))),
            ),

            TypeVariant::BumpSequenceOp => Box::new(
                ReadXdrIter::<_, BumpSequenceOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceOp(Box::new(t)))),
            ),

            TypeVariant::CreateClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateClaimableBalanceOp(Box::new(t)))),
            ),

            TypeVariant::ClaimClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimClaimableBalanceOp(Box::new(t)))),
            ),

            TypeVariant::BeginSponsoringFutureReservesOp => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesOp>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesOp(Box::new(t)))),
            ),

            TypeVariant::RevokeSponsorshipType => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipType(Box::new(t)))),
            ),

            TypeVariant::RevokeSponsorshipOp => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipOp(Box::new(t)))),
            ),

            TypeVariant::ClawbackOp => Box::new(
                ReadXdrIter::<_, ClawbackOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackOp(Box::new(t)))),
            ),

            TypeVariant::ClawbackClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackClaimableBalanceOp(Box::new(t)))),
            ),

            TypeVariant::SetTrustLineFlagsOp => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsOp(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolDepositOp => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolDepositOp(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolWithdrawOp => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolWithdrawOp(Box::new(t)))),
            ),

            TypeVariant::HostFunctionType => Box::new(
                ReadXdrIter::<_, HostFunctionType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunctionType(Box::new(t)))),
            ),

            TypeVariant::ContractIdPreimageType => Box::new(
                ReadXdrIter::<_, ContractIdPreimageType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimageType(Box::new(t)))),
            ),

            TypeVariant::ContractIdPreimage => Box::new(
                ReadXdrIter::<_, ContractIdPreimage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimage(Box::new(t)))),
            ),

            TypeVariant::CreateContractArgs => Box::new(
                ReadXdrIter::<_, CreateContractArgs>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateContractArgs(Box::new(t)))),
            ),

            TypeVariant::CreateContractArgsV2 => Box::new(
                ReadXdrIter::<_, CreateContractArgsV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateContractArgsV2(Box::new(t)))),
            ),

            TypeVariant::InvokeContractArgs => Box::new(
                ReadXdrIter::<_, InvokeContractArgs>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeContractArgs(Box::new(t)))),
            ),

            TypeVariant::HostFunction => Box::new(
                ReadXdrIter::<_, HostFunction>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunction(Box::new(t)))),
            ),

            TypeVariant::SorobanAuthorizedFunctionType => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedFunctionType>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAuthorizedFunctionType(Box::new(t)))),
            ),

            TypeVariant::SorobanAuthorizedFunction => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedFunction>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizedFunction(Box::new(t)))),
            ),

            TypeVariant::SorobanAuthorizedInvocation => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedInvocation>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizedInvocation(Box::new(t)))),
            ),

            TypeVariant::SorobanAddressCredentials => Box::new(
                ReadXdrIter::<_, SorobanAddressCredentials>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAddressCredentials(Box::new(t)))),
            ),

            TypeVariant::SorobanCredentialsType => Box::new(
                ReadXdrIter::<_, SorobanCredentialsType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanCredentialsType(Box::new(t)))),
            ),

            TypeVariant::SorobanCredentials => Box::new(
                ReadXdrIter::<_, SorobanCredentials>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanCredentials(Box::new(t)))),
            ),

            TypeVariant::SorobanAuthorizationEntry => Box::new(
                ReadXdrIter::<_, SorobanAuthorizationEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizationEntry(Box::new(t)))),
            ),

            TypeVariant::SorobanAuthorizationEntries => Box::new(
                ReadXdrIter::<_, SorobanAuthorizationEntries>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizationEntries(Box::new(t)))),
            ),

            TypeVariant::InvokeHostFunctionOp => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionOp(Box::new(t)))),
            ),

            TypeVariant::ExtendFootprintTtlOp => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlOp(Box::new(t)))),
            ),

            TypeVariant::RestoreFootprintOp => Box::new(
                ReadXdrIter::<_, RestoreFootprintOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintOp(Box::new(t)))),
            ),

            TypeVariant::Operation => Box::new(
                ReadXdrIter::<_, Operation>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Operation(Box::new(t)))),
            ),

            TypeVariant::HashIdPreimage => Box::new(
                ReadXdrIter::<_, HashIdPreimage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimage(Box::new(t)))),
            ),

            TypeVariant::MemoType => Box::new(
                ReadXdrIter::<_, MemoType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MemoType(Box::new(t)))),
            ),

            TypeVariant::Memo => Box::new(
                ReadXdrIter::<_, Memo>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Memo(Box::new(t)))),
            ),

            TypeVariant::TimeBounds => Box::new(
                ReadXdrIter::<_, TimeBounds>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeBounds(Box::new(t)))),
            ),

            TypeVariant::LedgerBounds => Box::new(
                ReadXdrIter::<_, LedgerBounds>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerBounds(Box::new(t)))),
            ),

            TypeVariant::PreconditionsV2 => Box::new(
                ReadXdrIter::<_, PreconditionsV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionsV2(Box::new(t)))),
            ),

            TypeVariant::PreconditionType => Box::new(
                ReadXdrIter::<_, PreconditionType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionType(Box::new(t)))),
            ),

            TypeVariant::Preconditions => Box::new(
                ReadXdrIter::<_, Preconditions>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Preconditions(Box::new(t)))),
            ),

            TypeVariant::LedgerFootprint => Box::new(
                ReadXdrIter::<_, LedgerFootprint>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerFootprint(Box::new(t)))),
            ),

            TypeVariant::SorobanResources => Box::new(
                ReadXdrIter::<_, SorobanResources>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanResources(Box::new(t)))),
            ),

            TypeVariant::SorobanResourcesExtV0 => Box::new(
                ReadXdrIter::<_, SorobanResourcesExtV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanResourcesExtV0(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionData => Box::new(
                ReadXdrIter::<_, SorobanTransactionData>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionData(Box::new(t)))),
            ),

            TypeVariant::TransactionV0 => Box::new(
                ReadXdrIter::<_, TransactionV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0(Box::new(t)))),
            ),

            TypeVariant::TransactionV0Envelope => Box::new(
                ReadXdrIter::<_, TransactionV0Envelope>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Envelope(Box::new(t)))),
            ),

            TypeVariant::Transaction => Box::new(
                ReadXdrIter::<_, Transaction>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Transaction(Box::new(t)))),
            ),

            TypeVariant::TransactionV1Envelope => Box::new(
                ReadXdrIter::<_, TransactionV1Envelope>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV1Envelope(Box::new(t)))),
            ),

            TypeVariant::FeeBumpTransaction => Box::new(
                ReadXdrIter::<_, FeeBumpTransaction>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransaction(Box::new(t)))),
            ),

            TypeVariant::FeeBumpTransactionEnvelope => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionEnvelope>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionEnvelope(Box::new(t)))),
            ),

            TypeVariant::TransactionEnvelope => Box::new(
                ReadXdrIter::<_, TransactionEnvelope>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEnvelope(Box::new(t)))),
            ),

            TypeVariant::TransactionSignaturePayload => Box::new(
                ReadXdrIter::<_, TransactionSignaturePayload>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSignaturePayload(Box::new(t)))),
            ),

            TypeVariant::ClaimAtomType => Box::new(
                ReadXdrIter::<_, ClaimAtomType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtomType(Box::new(t)))),
            ),

            TypeVariant::ClaimOfferAtomV0 => Box::new(
                ReadXdrIter::<_, ClaimOfferAtomV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtomV0(Box::new(t)))),
            ),

            TypeVariant::ClaimOfferAtom => Box::new(
                ReadXdrIter::<_, ClaimOfferAtom>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtom(Box::new(t)))),
            ),

            TypeVariant::ClaimLiquidityAtom => Box::new(
                ReadXdrIter::<_, ClaimLiquidityAtom>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimLiquidityAtom(Box::new(t)))),
            ),

            TypeVariant::ClaimAtom => Box::new(
                ReadXdrIter::<_, ClaimAtom>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtom(Box::new(t)))),
            ),

            TypeVariant::CreateAccountResultCode => Box::new(
                ReadXdrIter::<_, CreateAccountResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountResultCode(Box::new(t)))),
            ),

            TypeVariant::CreateAccountResult => Box::new(
                ReadXdrIter::<_, CreateAccountResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountResult(Box::new(t)))),
            ),

            TypeVariant::PaymentResultCode => Box::new(
                ReadXdrIter::<_, PaymentResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResultCode(Box::new(t)))),
            ),

            TypeVariant::PaymentResult => Box::new(
                ReadXdrIter::<_, PaymentResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResult(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictReceiveResultCode => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultCode(Box::new(t)))),
            ),

            TypeVariant::SimplePaymentResult => Box::new(
                ReadXdrIter::<_, SimplePaymentResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SimplePaymentResult(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictReceiveResult => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResult>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResult(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictSendResultCode => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendResultCode(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictSendResult => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendResult(Box::new(t)))),
            ),

            TypeVariant::ManageSellOfferResultCode => Box::new(
                ReadXdrIter::<_, ManageSellOfferResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferResultCode(Box::new(t)))),
            ),

            TypeVariant::ManageOfferEffect => Box::new(
                ReadXdrIter::<_, ManageOfferEffect>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferEffect(Box::new(t)))),
            ),

            TypeVariant::ManageOfferSuccessResult => Box::new(
                ReadXdrIter::<_, ManageOfferSuccessResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferSuccessResult(Box::new(t)))),
            ),

            TypeVariant::ManageSellOfferResult => Box::new(
                ReadXdrIter::<_, ManageSellOfferResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferResult(Box::new(t)))),
            ),

            TypeVariant::ManageBuyOfferResultCode => Box::new(
                ReadXdrIter::<_, ManageBuyOfferResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferResultCode(Box::new(t)))),
            ),

            TypeVariant::ManageBuyOfferResult => Box::new(
                ReadXdrIter::<_, ManageBuyOfferResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferResult(Box::new(t)))),
            ),

            TypeVariant::SetOptionsResultCode => Box::new(
                ReadXdrIter::<_, SetOptionsResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResultCode(Box::new(t)))),
            ),

            TypeVariant::SetOptionsResult => Box::new(
                ReadXdrIter::<_, SetOptionsResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResult(Box::new(t)))),
            ),

            TypeVariant::ChangeTrustResultCode => Box::new(
                ReadXdrIter::<_, ChangeTrustResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResultCode(Box::new(t)))),
            ),

            TypeVariant::ChangeTrustResult => Box::new(
                ReadXdrIter::<_, ChangeTrustResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResult(Box::new(t)))),
            ),

            TypeVariant::AllowTrustResultCode => Box::new(
                ReadXdrIter::<_, AllowTrustResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResultCode(Box::new(t)))),
            ),

            TypeVariant::AllowTrustResult => Box::new(
                ReadXdrIter::<_, AllowTrustResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResult(Box::new(t)))),
            ),

            TypeVariant::AccountMergeResultCode => Box::new(
                ReadXdrIter::<_, AccountMergeResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountMergeResultCode(Box::new(t)))),
            ),

            TypeVariant::AccountMergeResult => Box::new(
                ReadXdrIter::<_, AccountMergeResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountMergeResult(Box::new(t)))),
            ),

            TypeVariant::InflationResultCode => Box::new(
                ReadXdrIter::<_, InflationResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResultCode(Box::new(t)))),
            ),

            TypeVariant::InflationPayout => Box::new(
                ReadXdrIter::<_, InflationPayout>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationPayout(Box::new(t)))),
            ),

            TypeVariant::InflationResult => Box::new(
                ReadXdrIter::<_, InflationResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResult(Box::new(t)))),
            ),

            TypeVariant::ManageDataResultCode => Box::new(
                ReadXdrIter::<_, ManageDataResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResultCode(Box::new(t)))),
            ),

            TypeVariant::ManageDataResult => Box::new(
                ReadXdrIter::<_, ManageDataResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResult(Box::new(t)))),
            ),

            TypeVariant::BumpSequenceResultCode => Box::new(
                ReadXdrIter::<_, BumpSequenceResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceResultCode(Box::new(t)))),
            ),

            TypeVariant::BumpSequenceResult => Box::new(
                ReadXdrIter::<_, BumpSequenceResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceResult(Box::new(t)))),
            ),

            TypeVariant::CreateClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreateClaimableBalanceResultCode(Box::new(t)))),
            ),

            TypeVariant::CreateClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateClaimableBalanceResult(Box::new(t)))),
            ),

            TypeVariant::ClaimClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimClaimableBalanceResultCode(Box::new(t)))),
            ),

            TypeVariant::ClaimClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimClaimableBalanceResult(Box::new(t)))),
            ),

            TypeVariant::BeginSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResultCode(Box::new(t)))),
            ),

            TypeVariant::BeginSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesResult>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResult(Box::new(t)))),
            ),

            TypeVariant::EndSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, EndSponsoringFutureReservesResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResultCode(Box::new(t)))),
            ),

            TypeVariant::EndSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, EndSponsoringFutureReservesResult>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResult(Box::new(t)))),
            ),

            TypeVariant::RevokeSponsorshipResultCode => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipResultCode(Box::new(t)))),
            ),

            TypeVariant::RevokeSponsorshipResult => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipResult(Box::new(t)))),
            ),

            TypeVariant::ClawbackResultCode => Box::new(
                ReadXdrIter::<_, ClawbackResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResultCode(Box::new(t)))),
            ),

            TypeVariant::ClawbackResult => Box::new(
                ReadXdrIter::<_, ClawbackResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResult(Box::new(t)))),
            ),

            TypeVariant::ClawbackClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResultCode(Box::new(t)))),
            ),

            TypeVariant::ClawbackClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceResult>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResult(Box::new(t)))),
            ),

            TypeVariant::SetTrustLineFlagsResultCode => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsResultCode(Box::new(t)))),
            ),

            TypeVariant::SetTrustLineFlagsResult => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsResult(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolDepositResultCode => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolDepositResultCode(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolDepositResult => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolDepositResult(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolWithdrawResultCode => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResultCode(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolWithdrawResult => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResult(Box::new(t)))),
            ),

            TypeVariant::InvokeHostFunctionResultCode => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionResultCode(Box::new(t)))),
            ),

            TypeVariant::InvokeHostFunctionResult => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionResult(Box::new(t)))),
            ),

            TypeVariant::ExtendFootprintTtlResultCode => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlResultCode(Box::new(t)))),
            ),

            TypeVariant::ExtendFootprintTtlResult => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlResult(Box::new(t)))),
            ),

            TypeVariant::RestoreFootprintResultCode => Box::new(
                ReadXdrIter::<_, RestoreFootprintResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintResultCode(Box::new(t)))),
            ),

            TypeVariant::RestoreFootprintResult => Box::new(
                ReadXdrIter::<_, RestoreFootprintResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintResult(Box::new(t)))),
            ),

            TypeVariant::OperationResultCode => Box::new(
                ReadXdrIter::<_, OperationResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultCode(Box::new(t)))),
            ),

            TypeVariant::OperationResult => Box::new(
                ReadXdrIter::<_, OperationResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResult(Box::new(t)))),
            ),

            TypeVariant::TransactionResultCode => Box::new(
                ReadXdrIter::<_, TransactionResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultCode(Box::new(t)))),
            ),

            TypeVariant::InnerTransactionResult => Box::new(
                ReadXdrIter::<_, InnerTransactionResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResult(Box::new(t)))),
            ),

            TypeVariant::InnerTransactionResultPair => Box::new(
                ReadXdrIter::<_, InnerTransactionResultPair>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultPair(Box::new(t)))),
            ),

            TypeVariant::TransactionResult => Box::new(
                ReadXdrIter::<_, TransactionResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResult(Box::new(t)))),
            ),

            TypeVariant::Hash => Box::new(
                ReadXdrIter::<_, Hash>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hash(Box::new(t)))),
            ),

            TypeVariant::Uint256 => Box::new(
                ReadXdrIter::<_, Uint256>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint256(Box::new(t)))),
            ),

            TypeVariant::Uint32 => Box::new(
                ReadXdrIter::<_, Uint32>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint32(Box::new(t)))),
            ),

            TypeVariant::Int32 => Box::new(
                ReadXdrIter::<_, Int32>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int32(Box::new(t)))),
            ),

            TypeVariant::Uint64 => Box::new(
                ReadXdrIter::<_, Uint64>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint64(Box::new(t)))),
            ),

            TypeVariant::Int64 => Box::new(
                ReadXdrIter::<_, Int64>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int64(Box::new(t)))),
            ),

            TypeVariant::TimePoint => Box::new(
                ReadXdrIter::<_, TimePoint>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimePoint(Box::new(t)))),
            ),

            TypeVariant::Duration => Box::new(
                ReadXdrIter::<_, Duration>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Duration(Box::new(t)))),
            ),

            TypeVariant::ExtensionPoint => Box::new(
                ReadXdrIter::<_, ExtensionPoint>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtensionPoint(Box::new(t)))),
            ),

            TypeVariant::CryptoKeyType => Box::new(
                ReadXdrIter::<_, CryptoKeyType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CryptoKeyType(Box::new(t)))),
            ),

            TypeVariant::PublicKeyType => Box::new(
                ReadXdrIter::<_, PublicKeyType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKeyType(Box::new(t)))),
            ),

            TypeVariant::SignerKeyType => Box::new(
                ReadXdrIter::<_, SignerKeyType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKeyType(Box::new(t)))),
            ),

            TypeVariant::PublicKey => Box::new(
                ReadXdrIter::<_, PublicKey>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKey(Box::new(t)))),
            ),

            TypeVariant::SignerKey => Box::new(
                ReadXdrIter::<_, SignerKey>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKey(Box::new(t)))),
            ),

            TypeVariant::Signature => Box::new(
                ReadXdrIter::<_, Signature>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signature(Box::new(t)))),
            ),

            TypeVariant::SignatureHint => Box::new(
                ReadXdrIter::<_, SignatureHint>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignatureHint(Box::new(t)))),
            ),

            TypeVariant::NodeId => Box::new(
                ReadXdrIter::<_, NodeId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::NodeId(Box::new(t)))),
            ),

            TypeVariant::AccountId => Box::new(
                ReadXdrIter::<_, AccountId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountId(Box::new(t)))),
            ),

            TypeVariant::ContractId => Box::new(
                ReadXdrIter::<_, ContractId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractId(Box::new(t)))),
            ),

            TypeVariant::Curve25519Secret => Box::new(
                ReadXdrIter::<_, Curve25519Secret>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Secret(Box::new(t)))),
            ),

            TypeVariant::Curve25519Public => Box::new(
                ReadXdrIter::<_, Curve25519Public>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Public(Box::new(t)))),
            ),

            TypeVariant::HmacSha256Key => Box::new(
                ReadXdrIter::<_, HmacSha256Key>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Key(Box::new(t)))),
            ),

            TypeVariant::HmacSha256Mac => Box::new(
                ReadXdrIter::<_, HmacSha256Mac>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Mac(Box::new(t)))),
            ),

            TypeVariant::ShortHashSeed => Box::new(
                ReadXdrIter::<_, ShortHashSeed>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ShortHashSeed(Box::new(t)))),
            ),

            TypeVariant::BinaryFuseFilterType => Box::new(
                ReadXdrIter::<_, BinaryFuseFilterType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BinaryFuseFilterType(Box::new(t)))),
            ),

            TypeVariant::SerializedBinaryFuseFilter => Box::new(
                ReadXdrIter::<_, SerializedBinaryFuseFilter>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SerializedBinaryFuseFilter(Box::new(t)))),
            ),

            TypeVariant::PoolId => Box::new(
                ReadXdrIter::<_, PoolId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PoolId(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceIdType => Box::new(
                ReadXdrIter::<_, ClaimableBalanceIdType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceIdType(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceId => Box::new(
                ReadXdrIter::<_, ClaimableBalanceId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceId(Box::new(t)))),
            ),
        }
    }

    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr_framed_iter<R: Read>(
        v: TypeVariant,
        r: &mut Limited<R>,
    ) -> Box<dyn Iterator<Item = Result<Self, Error>> + '_> {
        match v {
            TypeVariant::ScpStatementPrepare => Box::new(
                ReadXdrIter::<_, Frame<ScpStatementPrepare>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPrepare(Box::new(t.0)))),
            ),

            TypeVariant::ScpStatementConfirm => Box::new(
                ReadXdrIter::<_, Frame<ScpStatementConfirm>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementConfirm(Box::new(t.0)))),
            ),

            TypeVariant::ScpStatementExternalize => Box::new(
                ReadXdrIter::<_, Frame<ScpStatementExternalize>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScpStatementExternalize(Box::new(t.0)))),
            ),

            TypeVariant::ScpStatementPledges => Box::new(
                ReadXdrIter::<_, Frame<ScpStatementPledges>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPledges(Box::new(t.0)))),
            ),

            TypeVariant::ScEnvMetaEntryInterfaceVersion => Box::new(
                ReadXdrIter::<_, Frame<ScEnvMetaEntryInterfaceVersion>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScEnvMetaEntryInterfaceVersion(Box::new(t.0)))),
            ),

            TypeVariant::AccountEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExtensionV2Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountEntryExtensionV2Ext(Box::new(t.0)))),
            ),

            TypeVariant::AccountEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExtensionV1Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountEntryExtensionV1Ext(Box::new(t.0)))),
            ),

            TypeVariant::AccountEntryExt => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExt(Box::new(t.0)))),
            ),

            TypeVariant::TrustLineEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntryExtensionV2Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2Ext(Box::new(t.0)))),
            ),

            TypeVariant::TrustLineEntryV1Ext => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntryV1Ext>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1Ext(Box::new(t.0)))),
            ),

            TypeVariant::TrustLineEntryV1 => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntryV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1(Box::new(t.0)))),
            ),

            TypeVariant::TrustLineEntryExt => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExt(Box::new(t.0)))),
            ),

            TypeVariant::OfferEntryExt => Box::new(
                ReadXdrIter::<_, Frame<OfferEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryExt(Box::new(t.0)))),
            ),

            TypeVariant::DataEntryExt => Box::new(
                ReadXdrIter::<_, Frame<DataEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntryExt(Box::new(t.0)))),
            ),

            TypeVariant::ClaimantV0 => Box::new(
                ReadXdrIter::<_, Frame<ClaimantV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantV0(Box::new(t.0)))),
            ),

            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceEntryExtensionV1Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(t.0)))),
            ),

            TypeVariant::ClaimableBalanceEntryExt => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceEntryExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceEntryExt(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolEntryConstantProduct => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolEntryConstantProduct>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolEntryConstantProduct(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolEntryBody => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolEntryBody>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolEntryBody(Box::new(t.0)))),
            ),

            TypeVariant::ContractCodeEntryV1 => Box::new(
                ReadXdrIter::<_, Frame<ContractCodeEntryV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryV1(Box::new(t.0)))),
            ),

            TypeVariant::ContractCodeEntryExt => Box::new(
                ReadXdrIter::<_, Frame<ContractCodeEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryExt(Box::new(t.0)))),
            ),

            TypeVariant::LedgerEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryExtensionV1Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerEntryExtensionV1Ext(Box::new(t.0)))),
            ),

            TypeVariant::LedgerEntryData => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryData>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryData(Box::new(t.0)))),
            ),

            TypeVariant::LedgerEntryExt => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExt(Box::new(t.0)))),
            ),

            TypeVariant::LedgerKeyAccount => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyAccount>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyAccount(Box::new(t.0)))),
            ),

            TypeVariant::LedgerKeyTrustLine => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyTrustLine>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTrustLine(Box::new(t.0)))),
            ),

            TypeVariant::LedgerKeyOffer => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyOffer>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyOffer(Box::new(t.0)))),
            ),

            TypeVariant::LedgerKeyData => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyData>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyData(Box::new(t.0)))),
            ),

            TypeVariant::LedgerKeyClaimableBalance => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyClaimableBalance>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerKeyClaimableBalance(Box::new(t.0)))),
            ),

            TypeVariant::LedgerKeyLiquidityPool => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyLiquidityPool>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerKeyLiquidityPool(Box::new(t.0)))),
            ),

            TypeVariant::LedgerKeyContractData => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyContractData>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractData(Box::new(t.0)))),
            ),

            TypeVariant::LedgerKeyContractCode => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyContractCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractCode(Box::new(t.0)))),
            ),

            TypeVariant::LedgerKeyConfigSetting => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyConfigSetting>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerKeyConfigSetting(Box::new(t.0)))),
            ),

            TypeVariant::LedgerKeyTtl => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyTtl>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTtl(Box::new(t.0)))),
            ),

            TypeVariant::BucketMetadataExt => Box::new(
                ReadXdrIter::<_, Frame<BucketMetadataExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadataExt(Box::new(t.0)))),
            ),

            TypeVariant::StellarValueExt => Box::new(
                ReadXdrIter::<_, Frame<StellarValueExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueExt(Box::new(t.0)))),
            ),

            TypeVariant::LedgerHeaderExtensionV1Ext => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderExtensionV1Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1Ext(Box::new(t.0)))),
            ),

            TypeVariant::LedgerHeaderExt => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExt(Box::new(t.0)))),
            ),

            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => Box::new(
                ReadXdrIter::<_, Frame<TxSetComponentTxsMaybeDiscountedFee>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(t.0)))),
            ),

            TypeVariant::TransactionHistoryEntryExt => Box::new(
                ReadXdrIter::<_, Frame<TransactionHistoryEntryExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryEntryExt(Box::new(t.0)))),
            ),

            TypeVariant::TransactionHistoryResultEntryExt => Box::new(
                ReadXdrIter::<_, Frame<TransactionHistoryResultEntryExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryResultEntryExt(Box::new(t.0)))),
            ),

            TypeVariant::LedgerHeaderHistoryEntryExt => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderHistoryEntryExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntryExt(Box::new(t.0)))),
            ),

            TypeVariant::ContractEventV0 => Box::new(
                ReadXdrIter::<_, Frame<ContractEventV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventV0(Box::new(t.0)))),
            ),

            TypeVariant::ContractEventBody => Box::new(
                ReadXdrIter::<_, Frame<ContractEventBody>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventBody(Box::new(t.0)))),
            ),

            TypeVariant::PeerAddressIp => Box::new(
                ReadXdrIter::<_, Frame<PeerAddressIp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddressIp(Box::new(t.0)))),
            ),

            TypeVariant::AuthenticatedMessageV0 => Box::new(
                ReadXdrIter::<_, Frame<AuthenticatedMessageV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AuthenticatedMessageV0(Box::new(t.0)))),
            ),

            TypeVariant::MuxedAccountMed25519 => Box::new(
                ReadXdrIter::<_, Frame<MuxedAccountMed25519>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccountMed25519(Box::new(t.0)))),
            ),

            TypeVariant::RevokeSponsorshipOpSigner => Box::new(
                ReadXdrIter::<_, Frame<RevokeSponsorshipOpSigner>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::RevokeSponsorshipOpSigner(Box::new(t.0)))),
            ),

            TypeVariant::ContractIdPreimageFromAddress => Box::new(
                ReadXdrIter::<_, Frame<ContractIdPreimageFromAddress>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractIdPreimageFromAddress(Box::new(t.0)))),
            ),

            TypeVariant::OperationBody => Box::new(
                ReadXdrIter::<_, Frame<OperationBody>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationBody(Box::new(t.0)))),
            ),

            TypeVariant::HashIdPreimageOperationId => Box::new(
                ReadXdrIter::<_, Frame<HashIdPreimageOperationId>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::HashIdPreimageOperationId(Box::new(t.0)))),
            ),

            TypeVariant::HashIdPreimageRevokeId => Box::new(
                ReadXdrIter::<_, Frame<HashIdPreimageRevokeId>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::HashIdPreimageRevokeId(Box::new(t.0)))),
            ),

            TypeVariant::HashIdPreimageContractId => Box::new(
                ReadXdrIter::<_, Frame<HashIdPreimageContractId>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::HashIdPreimageContractId(Box::new(t.0)))),
            ),

            TypeVariant::HashIdPreimageSorobanAuthorization => Box::new(
                ReadXdrIter::<_, Frame<HashIdPreimageSorobanAuthorization>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::HashIdPreimageSorobanAuthorization(Box::new(t.0)))),
            ),

            TypeVariant::SorobanTransactionDataExt => Box::new(
                ReadXdrIter::<_, Frame<SorobanTransactionDataExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanTransactionDataExt(Box::new(t.0)))),
            ),

            TypeVariant::TransactionV0Ext => Box::new(
                ReadXdrIter::<_, Frame<TransactionV0Ext>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Ext(Box::new(t.0)))),
            ),

            TypeVariant::TransactionExt => Box::new(
                ReadXdrIter::<_, Frame<TransactionExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionExt(Box::new(t.0)))),
            ),

            TypeVariant::FeeBumpTransactionInnerTx => Box::new(
                ReadXdrIter::<_, Frame<FeeBumpTransactionInnerTx>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::FeeBumpTransactionInnerTx(Box::new(t.0)))),
            ),

            TypeVariant::FeeBumpTransactionExt => Box::new(
                ReadXdrIter::<_, Frame<FeeBumpTransactionExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionExt(Box::new(t.0)))),
            ),

            TypeVariant::TransactionSignaturePayloadTaggedTransaction => Box::new(
                ReadXdrIter::<_, Frame<TransactionSignaturePayloadTaggedTransaction>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| {
                    r.map(|t| Self::TransactionSignaturePayloadTaggedTransaction(Box::new(t.0)))
                }),
            ),

            TypeVariant::PathPaymentStrictReceiveResultSuccess => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictReceiveResultSuccess>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultSuccess(Box::new(t.0)))),
            ),

            TypeVariant::PathPaymentStrictSendResultSuccess => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictSendResultSuccess>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendResultSuccess(Box::new(t.0)))),
            ),

            TypeVariant::ManageOfferSuccessResultOffer => Box::new(
                ReadXdrIter::<_, Frame<ManageOfferSuccessResultOffer>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ManageOfferSuccessResultOffer(Box::new(t.0)))),
            ),

            TypeVariant::OperationResultTr => Box::new(
                ReadXdrIter::<_, Frame<OperationResultTr>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultTr(Box::new(t.0)))),
            ),

            TypeVariant::InnerTransactionResultResult => Box::new(
                ReadXdrIter::<_, Frame<InnerTransactionResultResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InnerTransactionResultResult(Box::new(t.0)))),
            ),

            TypeVariant::InnerTransactionResultExt => Box::new(
                ReadXdrIter::<_, Frame<InnerTransactionResultExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InnerTransactionResultExt(Box::new(t.0)))),
            ),

            TypeVariant::TransactionResultResult => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionResultResult(Box::new(t.0)))),
            ),

            TypeVariant::TransactionResultExt => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultExt(Box::new(t.0)))),
            ),

            TypeVariant::SignerKeyEd25519SignedPayload => Box::new(
                ReadXdrIter::<_, Frame<SignerKeyEd25519SignedPayload>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignerKeyEd25519SignedPayload(Box::new(t.0)))),
            ),

            TypeVariant::Value => Box::new(
                ReadXdrIter::<_, Frame<Value>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Value(Box::new(t.0)))),
            ),

            TypeVariant::ScpBallot => Box::new(
                ReadXdrIter::<_, Frame<ScpBallot>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpBallot(Box::new(t.0)))),
            ),

            TypeVariant::ScpStatementType => Box::new(
                ReadXdrIter::<_, Frame<ScpStatementType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementType(Box::new(t.0)))),
            ),

            TypeVariant::ScpNomination => Box::new(
                ReadXdrIter::<_, Frame<ScpNomination>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpNomination(Box::new(t.0)))),
            ),

            TypeVariant::ScpStatement => Box::new(
                ReadXdrIter::<_, Frame<ScpStatement>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatement(Box::new(t.0)))),
            ),

            TypeVariant::ScpEnvelope => Box::new(
                ReadXdrIter::<_, Frame<ScpEnvelope>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpEnvelope(Box::new(t.0)))),
            ),

            TypeVariant::ScpQuorumSet => Box::new(
                ReadXdrIter::<_, Frame<ScpQuorumSet>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpQuorumSet(Box::new(t.0)))),
            ),

            TypeVariant::ConfigSettingContractExecutionLanesV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractExecutionLanesV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractExecutionLanesV0(Box::new(t.0)))),
            ),

            TypeVariant::ConfigSettingContractComputeV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractComputeV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractComputeV0(Box::new(t.0)))),
            ),

            TypeVariant::ConfigSettingContractParallelComputeV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractParallelComputeV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractParallelComputeV0(Box::new(t.0)))),
            ),

            TypeVariant::ConfigSettingContractLedgerCostV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractLedgerCostV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractLedgerCostV0(Box::new(t.0)))),
            ),

            TypeVariant::ConfigSettingContractLedgerCostExtV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractLedgerCostExtV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractLedgerCostExtV0(Box::new(t.0)))),
            ),

            TypeVariant::ConfigSettingContractHistoricalDataV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractHistoricalDataV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractHistoricalDataV0(Box::new(t.0)))),
            ),

            TypeVariant::ConfigSettingContractEventsV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractEventsV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractEventsV0(Box::new(t.0)))),
            ),

            TypeVariant::ConfigSettingContractBandwidthV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractBandwidthV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractBandwidthV0(Box::new(t.0)))),
            ),

            TypeVariant::ContractCostType => Box::new(
                ReadXdrIter::<_, Frame<ContractCostType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostType(Box::new(t.0)))),
            ),

            TypeVariant::ContractCostParamEntry => Box::new(
                ReadXdrIter::<_, Frame<ContractCostParamEntry>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractCostParamEntry(Box::new(t.0)))),
            ),

            TypeVariant::StateArchivalSettings => Box::new(
                ReadXdrIter::<_, Frame<StateArchivalSettings>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StateArchivalSettings(Box::new(t.0)))),
            ),

            TypeVariant::EvictionIterator => Box::new(
                ReadXdrIter::<_, Frame<EvictionIterator>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EvictionIterator(Box::new(t.0)))),
            ),

            TypeVariant::ConfigSettingScpTiming => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingScpTiming>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingScpTiming(Box::new(t.0)))),
            ),

            TypeVariant::ContractCostParams => Box::new(
                ReadXdrIter::<_, Frame<ContractCostParams>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostParams(Box::new(t.0)))),
            ),

            TypeVariant::ConfigSettingId => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingId>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingId(Box::new(t.0)))),
            ),

            TypeVariant::ConfigSettingEntry => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingEntry(Box::new(t.0)))),
            ),

            TypeVariant::ScEnvMetaKind => Box::new(
                ReadXdrIter::<_, Frame<ScEnvMetaKind>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaKind(Box::new(t.0)))),
            ),

            TypeVariant::ScEnvMetaEntry => Box::new(
                ReadXdrIter::<_, Frame<ScEnvMetaEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaEntry(Box::new(t.0)))),
            ),

            TypeVariant::ScMetaV0 => Box::new(
                ReadXdrIter::<_, Frame<ScMetaV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaV0(Box::new(t.0)))),
            ),

            TypeVariant::ScMetaKind => Box::new(
                ReadXdrIter::<_, Frame<ScMetaKind>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaKind(Box::new(t.0)))),
            ),

            TypeVariant::ScMetaEntry => Box::new(
                ReadXdrIter::<_, Frame<ScMetaEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaEntry(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecType => Box::new(
                ReadXdrIter::<_, Frame<ScSpecType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecType(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecTypeOption => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeOption>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeOption(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecTypeResult => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeResult(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecTypeVec => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeVec>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeVec(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecTypeMap => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeMap>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeMap(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecTypeTuple => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeTuple>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeTuple(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecTypeBytesN => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeBytesN>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeBytesN(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecTypeUdt => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeUdt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeUdt(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecTypeDef => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeDef>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeDef(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecUdtStructFieldV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtStructFieldV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScSpecUdtStructFieldV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecUdtStructV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtStructV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtStructV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseVoidV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtUnionCaseVoidV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseVoidV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseTupleV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtUnionCaseTupleV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseTupleV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseV0Kind => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtUnionCaseV0Kind>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0Kind(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtUnionCaseV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecUdtUnionV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtUnionV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecUdtEnumCaseV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtEnumCaseV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumCaseV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecUdtEnumV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtEnumV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecUdtErrorEnumCaseV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtErrorEnumCaseV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumCaseV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecUdtErrorEnumV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtErrorEnumV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecFunctionInputV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecFunctionInputV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionInputV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecFunctionV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecFunctionV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecEventParamLocationV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecEventParamLocationV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScSpecEventParamLocationV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecEventParamV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecEventParamV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEventParamV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecEventDataFormat => Box::new(
                ReadXdrIter::<_, Frame<ScSpecEventDataFormat>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEventDataFormat(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecEventV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecEventV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEventV0(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecEntryKind => Box::new(
                ReadXdrIter::<_, Frame<ScSpecEntryKind>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntryKind(Box::new(t.0)))),
            ),

            TypeVariant::ScSpecEntry => Box::new(
                ReadXdrIter::<_, Frame<ScSpecEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntry(Box::new(t.0)))),
            ),

            TypeVariant::ScValType => Box::new(
                ReadXdrIter::<_, Frame<ScValType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScValType(Box::new(t.0)))),
            ),

            TypeVariant::ScErrorType => Box::new(
                ReadXdrIter::<_, Frame<ScErrorType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorType(Box::new(t.0)))),
            ),

            TypeVariant::ScErrorCode => Box::new(
                ReadXdrIter::<_, Frame<ScErrorCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorCode(Box::new(t.0)))),
            ),

            TypeVariant::ScError => Box::new(
                ReadXdrIter::<_, Frame<ScError>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScError(Box::new(t.0)))),
            ),

            TypeVariant::UInt128Parts => Box::new(
                ReadXdrIter::<_, Frame<UInt128Parts>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt128Parts(Box::new(t.0)))),
            ),

            TypeVariant::Int128Parts => Box::new(
                ReadXdrIter::<_, Frame<Int128Parts>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int128Parts(Box::new(t.0)))),
            ),

            TypeVariant::UInt256Parts => Box::new(
                ReadXdrIter::<_, Frame<UInt256Parts>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt256Parts(Box::new(t.0)))),
            ),

            TypeVariant::Int256Parts => Box::new(
                ReadXdrIter::<_, Frame<Int256Parts>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int256Parts(Box::new(t.0)))),
            ),

            TypeVariant::ContractExecutableType => Box::new(
                ReadXdrIter::<_, Frame<ContractExecutableType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractExecutableType(Box::new(t.0)))),
            ),

            TypeVariant::ContractExecutable => Box::new(
                ReadXdrIter::<_, Frame<ContractExecutable>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractExecutable(Box::new(t.0)))),
            ),

            TypeVariant::ScAddressType => Box::new(
                ReadXdrIter::<_, Frame<ScAddressType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddressType(Box::new(t.0)))),
            ),

            TypeVariant::MuxedEd25519Account => Box::new(
                ReadXdrIter::<_, Frame<MuxedEd25519Account>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedEd25519Account(Box::new(t.0)))),
            ),

            TypeVariant::ScAddress => Box::new(
                ReadXdrIter::<_, Frame<ScAddress>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddress(Box::new(t.0)))),
            ),

            TypeVariant::ScVec => Box::new(
                ReadXdrIter::<_, Frame<ScVec>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVec(Box::new(t.0)))),
            ),

            TypeVariant::ScMap => Box::new(
                ReadXdrIter::<_, Frame<ScMap>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMap(Box::new(t.0)))),
            ),

            TypeVariant::ScBytes => Box::new(
                ReadXdrIter::<_, Frame<ScBytes>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScBytes(Box::new(t.0)))),
            ),

            TypeVariant::ScString => Box::new(
                ReadXdrIter::<_, Frame<ScString>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScString(Box::new(t.0)))),
            ),

            TypeVariant::ScSymbol => Box::new(
                ReadXdrIter::<_, Frame<ScSymbol>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSymbol(Box::new(t.0)))),
            ),

            TypeVariant::ScNonceKey => Box::new(
                ReadXdrIter::<_, Frame<ScNonceKey>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScNonceKey(Box::new(t.0)))),
            ),

            TypeVariant::ScContractInstance => Box::new(
                ReadXdrIter::<_, Frame<ScContractInstance>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScContractInstance(Box::new(t.0)))),
            ),

            TypeVariant::ScVal => Box::new(
                ReadXdrIter::<_, Frame<ScVal>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVal(Box::new(t.0)))),
            ),

            TypeVariant::ScMapEntry => Box::new(
                ReadXdrIter::<_, Frame<ScMapEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMapEntry(Box::new(t.0)))),
            ),

            TypeVariant::LedgerCloseMetaBatch => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMetaBatch>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaBatch(Box::new(t.0)))),
            ),

            TypeVariant::StoredTransactionSet => Box::new(
                ReadXdrIter::<_, Frame<StoredTransactionSet>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StoredTransactionSet(Box::new(t.0)))),
            ),

            TypeVariant::StoredDebugTransactionSet => Box::new(
                ReadXdrIter::<_, Frame<StoredDebugTransactionSet>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::StoredDebugTransactionSet(Box::new(t.0)))),
            ),

            TypeVariant::PersistedScpStateV0 => Box::new(
                ReadXdrIter::<_, Frame<PersistedScpStateV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV0(Box::new(t.0)))),
            ),

            TypeVariant::PersistedScpStateV1 => Box::new(
                ReadXdrIter::<_, Frame<PersistedScpStateV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV1(Box::new(t.0)))),
            ),

            TypeVariant::PersistedScpState => Box::new(
                ReadXdrIter::<_, Frame<PersistedScpState>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpState(Box::new(t.0)))),
            ),

            TypeVariant::Thresholds => Box::new(
                ReadXdrIter::<_, Frame<Thresholds>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Thresholds(Box::new(t.0)))),
            ),

            TypeVariant::String32 => Box::new(
                ReadXdrIter::<_, Frame<String32>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::String32(Box::new(t.0)))),
            ),

            TypeVariant::String64 => Box::new(
                ReadXdrIter::<_, Frame<String64>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::String64(Box::new(t.0)))),
            ),

            TypeVariant::SequenceNumber => Box::new(
                ReadXdrIter::<_, Frame<SequenceNumber>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SequenceNumber(Box::new(t.0)))),
            ),

            TypeVariant::DataValue => Box::new(
                ReadXdrIter::<_, Frame<DataValue>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataValue(Box::new(t.0)))),
            ),

            TypeVariant::AssetCode4 => Box::new(
                ReadXdrIter::<_, Frame<AssetCode4>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode4(Box::new(t.0)))),
            ),

            TypeVariant::AssetCode12 => Box::new(
                ReadXdrIter::<_, Frame<AssetCode12>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode12(Box::new(t.0)))),
            ),

            TypeVariant::AssetType => Box::new(
                ReadXdrIter::<_, Frame<AssetType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetType(Box::new(t.0)))),
            ),

            TypeVariant::AssetCode => Box::new(
                ReadXdrIter::<_, Frame<AssetCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode(Box::new(t.0)))),
            ),

            TypeVariant::AlphaNum4 => Box::new(
                ReadXdrIter::<_, Frame<AlphaNum4>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum4(Box::new(t.0)))),
            ),

            TypeVariant::AlphaNum12 => Box::new(
                ReadXdrIter::<_, Frame<AlphaNum12>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum12(Box::new(t.0)))),
            ),

            TypeVariant::Asset => Box::new(
                ReadXdrIter::<_, Frame<Asset>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Asset(Box::new(t.0)))),
            ),

            TypeVariant::Price => Box::new(
                ReadXdrIter::<_, Frame<Price>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Price(Box::new(t.0)))),
            ),

            TypeVariant::Liabilities => Box::new(
                ReadXdrIter::<_, Frame<Liabilities>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Liabilities(Box::new(t.0)))),
            ),

            TypeVariant::ThresholdIndexes => Box::new(
                ReadXdrIter::<_, Frame<ThresholdIndexes>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ThresholdIndexes(Box::new(t.0)))),
            ),

            TypeVariant::LedgerEntryType => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryType(Box::new(t.0)))),
            ),

            TypeVariant::Signer => Box::new(
                ReadXdrIter::<_, Frame<Signer>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signer(Box::new(t.0)))),
            ),

            TypeVariant::AccountFlags => Box::new(
                ReadXdrIter::<_, Frame<AccountFlags>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountFlags(Box::new(t.0)))),
            ),

            TypeVariant::SponsorshipDescriptor => Box::new(
                ReadXdrIter::<_, Frame<SponsorshipDescriptor>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SponsorshipDescriptor(Box::new(t.0)))),
            ),

            TypeVariant::AccountEntryExtensionV3 => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExtensionV3>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountEntryExtensionV3(Box::new(t.0)))),
            ),

            TypeVariant::AccountEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExtensionV2>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountEntryExtensionV2(Box::new(t.0)))),
            ),

            TypeVariant::AccountEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExtensionV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountEntryExtensionV1(Box::new(t.0)))),
            ),

            TypeVariant::AccountEntry => Box::new(
                ReadXdrIter::<_, Frame<AccountEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntry(Box::new(t.0)))),
            ),

            TypeVariant::TrustLineFlags => Box::new(
                ReadXdrIter::<_, Frame<TrustLineFlags>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineFlags(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolType => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolType(Box::new(t.0)))),
            ),

            TypeVariant::TrustLineAsset => Box::new(
                ReadXdrIter::<_, Frame<TrustLineAsset>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineAsset(Box::new(t.0)))),
            ),

            TypeVariant::TrustLineEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntryExtensionV2>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2(Box::new(t.0)))),
            ),

            TypeVariant::TrustLineEntry => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntry(Box::new(t.0)))),
            ),

            TypeVariant::OfferEntryFlags => Box::new(
                ReadXdrIter::<_, Frame<OfferEntryFlags>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryFlags(Box::new(t.0)))),
            ),

            TypeVariant::OfferEntry => Box::new(
                ReadXdrIter::<_, Frame<OfferEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntry(Box::new(t.0)))),
            ),

            TypeVariant::DataEntry => Box::new(
                ReadXdrIter::<_, Frame<DataEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntry(Box::new(t.0)))),
            ),

            TypeVariant::ClaimPredicateType => Box::new(
                ReadXdrIter::<_, Frame<ClaimPredicateType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicateType(Box::new(t.0)))),
            ),

            TypeVariant::ClaimPredicate => Box::new(
                ReadXdrIter::<_, Frame<ClaimPredicate>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicate(Box::new(t.0)))),
            ),

            TypeVariant::ClaimantType => Box::new(
                ReadXdrIter::<_, Frame<ClaimantType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantType(Box::new(t.0)))),
            ),

            TypeVariant::Claimant => Box::new(
                ReadXdrIter::<_, Frame<Claimant>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Claimant(Box::new(t.0)))),
            ),

            TypeVariant::ClaimableBalanceFlags => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceFlags>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceFlags(Box::new(t.0)))),
            ),

            TypeVariant::ClaimableBalanceEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceEntryExtensionV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1(Box::new(t.0)))),
            ),

            TypeVariant::ClaimableBalanceEntry => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntry(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolConstantProductParameters => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolConstantProductParameters>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolConstantProductParameters(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolEntry => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntry(Box::new(t.0)))),
            ),

            TypeVariant::ContractDataDurability => Box::new(
                ReadXdrIter::<_, Frame<ContractDataDurability>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractDataDurability(Box::new(t.0)))),
            ),

            TypeVariant::ContractDataEntry => Box::new(
                ReadXdrIter::<_, Frame<ContractDataEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractDataEntry(Box::new(t.0)))),
            ),

            TypeVariant::ContractCodeCostInputs => Box::new(
                ReadXdrIter::<_, Frame<ContractCodeCostInputs>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractCodeCostInputs(Box::new(t.0)))),
            ),

            TypeVariant::ContractCodeEntry => Box::new(
                ReadXdrIter::<_, Frame<ContractCodeEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntry(Box::new(t.0)))),
            ),

            TypeVariant::TtlEntry => Box::new(
                ReadXdrIter::<_, Frame<TtlEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TtlEntry(Box::new(t.0)))),
            ),

            TypeVariant::LedgerEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryExtensionV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerEntryExtensionV1(Box::new(t.0)))),
            ),

            TypeVariant::LedgerEntry => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntry(Box::new(t.0)))),
            ),

            TypeVariant::LedgerKey => Box::new(
                ReadXdrIter::<_, Frame<LedgerKey>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKey(Box::new(t.0)))),
            ),

            TypeVariant::EnvelopeType => Box::new(
                ReadXdrIter::<_, Frame<EnvelopeType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EnvelopeType(Box::new(t.0)))),
            ),

            TypeVariant::BucketListType => Box::new(
                ReadXdrIter::<_, Frame<BucketListType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketListType(Box::new(t.0)))),
            ),

            TypeVariant::BucketEntryType => Box::new(
                ReadXdrIter::<_, Frame<BucketEntryType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntryType(Box::new(t.0)))),
            ),

            TypeVariant::HotArchiveBucketEntryType => Box::new(
                ReadXdrIter::<_, Frame<HotArchiveBucketEntryType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::HotArchiveBucketEntryType(Box::new(t.0)))),
            ),

            TypeVariant::BucketMetadata => Box::new(
                ReadXdrIter::<_, Frame<BucketMetadata>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadata(Box::new(t.0)))),
            ),

            TypeVariant::BucketEntry => Box::new(
                ReadXdrIter::<_, Frame<BucketEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntry(Box::new(t.0)))),
            ),

            TypeVariant::HotArchiveBucketEntry => Box::new(
                ReadXdrIter::<_, Frame<HotArchiveBucketEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HotArchiveBucketEntry(Box::new(t.0)))),
            ),

            TypeVariant::UpgradeType => Box::new(
                ReadXdrIter::<_, Frame<UpgradeType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeType(Box::new(t.0)))),
            ),

            TypeVariant::StellarValueType => Box::new(
                ReadXdrIter::<_, Frame<StellarValueType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueType(Box::new(t.0)))),
            ),

            TypeVariant::LedgerCloseValueSignature => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseValueSignature>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerCloseValueSignature(Box::new(t.0)))),
            ),

            TypeVariant::StellarValue => Box::new(
                ReadXdrIter::<_, Frame<StellarValue>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValue(Box::new(t.0)))),
            ),

            TypeVariant::LedgerHeaderFlags => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderFlags>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderFlags(Box::new(t.0)))),
            ),

            TypeVariant::LedgerHeaderExtensionV1 => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderExtensionV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1(Box::new(t.0)))),
            ),

            TypeVariant::LedgerHeader => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeader>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeader(Box::new(t.0)))),
            ),

            TypeVariant::LedgerUpgradeType => Box::new(
                ReadXdrIter::<_, Frame<LedgerUpgradeType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgradeType(Box::new(t.0)))),
            ),

            TypeVariant::ConfigUpgradeSetKey => Box::new(
                ReadXdrIter::<_, Frame<ConfigUpgradeSetKey>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSetKey(Box::new(t.0)))),
            ),

            TypeVariant::LedgerUpgrade => Box::new(
                ReadXdrIter::<_, Frame<LedgerUpgrade>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgrade(Box::new(t.0)))),
            ),

            TypeVariant::ConfigUpgradeSet => Box::new(
                ReadXdrIter::<_, Frame<ConfigUpgradeSet>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSet(Box::new(t.0)))),
            ),

            TypeVariant::TxSetComponentType => Box::new(
                ReadXdrIter::<_, Frame<TxSetComponentType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponentType(Box::new(t.0)))),
            ),

            TypeVariant::DependentTxCluster => Box::new(
                ReadXdrIter::<_, Frame<DependentTxCluster>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DependentTxCluster(Box::new(t.0)))),
            ),

            TypeVariant::ParallelTxExecutionStage => Box::new(
                ReadXdrIter::<_, Frame<ParallelTxExecutionStage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ParallelTxExecutionStage(Box::new(t.0)))),
            ),

            TypeVariant::ParallelTxsComponent => Box::new(
                ReadXdrIter::<_, Frame<ParallelTxsComponent>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ParallelTxsComponent(Box::new(t.0)))),
            ),

            TypeVariant::TxSetComponent => Box::new(
                ReadXdrIter::<_, Frame<TxSetComponent>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponent(Box::new(t.0)))),
            ),

            TypeVariant::TransactionPhase => Box::new(
                ReadXdrIter::<_, Frame<TransactionPhase>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionPhase(Box::new(t.0)))),
            ),

            TypeVariant::TransactionSet => Box::new(
                ReadXdrIter::<_, Frame<TransactionSet>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSet(Box::new(t.0)))),
            ),

            TypeVariant::TransactionSetV1 => Box::new(
                ReadXdrIter::<_, Frame<TransactionSetV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSetV1(Box::new(t.0)))),
            ),

            TypeVariant::GeneralizedTransactionSet => Box::new(
                ReadXdrIter::<_, Frame<GeneralizedTransactionSet>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::GeneralizedTransactionSet(Box::new(t.0)))),
            ),

            TypeVariant::TransactionResultPair => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultPair>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultPair(Box::new(t.0)))),
            ),

            TypeVariant::TransactionResultSet => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultSet>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultSet(Box::new(t.0)))),
            ),

            TypeVariant::TransactionHistoryEntry => Box::new(
                ReadXdrIter::<_, Frame<TransactionHistoryEntry>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryEntry(Box::new(t.0)))),
            ),

            TypeVariant::TransactionHistoryResultEntry => Box::new(
                ReadXdrIter::<_, Frame<TransactionHistoryResultEntry>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryResultEntry(Box::new(t.0)))),
            ),

            TypeVariant::LedgerHeaderHistoryEntry => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderHistoryEntry>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntry(Box::new(t.0)))),
            ),

            TypeVariant::LedgerScpMessages => Box::new(
                ReadXdrIter::<_, Frame<LedgerScpMessages>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerScpMessages(Box::new(t.0)))),
            ),

            TypeVariant::ScpHistoryEntryV0 => Box::new(
                ReadXdrIter::<_, Frame<ScpHistoryEntryV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntryV0(Box::new(t.0)))),
            ),

            TypeVariant::ScpHistoryEntry => Box::new(
                ReadXdrIter::<_, Frame<ScpHistoryEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntry(Box::new(t.0)))),
            ),

            TypeVariant::LedgerEntryChangeType => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryChangeType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChangeType(Box::new(t.0)))),
            ),

            TypeVariant::LedgerEntryChange => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryChange>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChange(Box::new(t.0)))),
            ),

            TypeVariant::LedgerEntryChanges => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryChanges>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChanges(Box::new(t.0)))),
            ),

            TypeVariant::OperationMeta => Box::new(
                ReadXdrIter::<_, Frame<OperationMeta>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationMeta(Box::new(t.0)))),
            ),

            TypeVariant::TransactionMetaV1 => Box::new(
                ReadXdrIter::<_, Frame<TransactionMetaV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV1(Box::new(t.0)))),
            ),

            TypeVariant::TransactionMetaV2 => Box::new(
                ReadXdrIter::<_, Frame<TransactionMetaV2>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV2(Box::new(t.0)))),
            ),

            TypeVariant::ContractEventType => Box::new(
                ReadXdrIter::<_, Frame<ContractEventType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventType(Box::new(t.0)))),
            ),

            TypeVariant::ContractEvent => Box::new(
                ReadXdrIter::<_, Frame<ContractEvent>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEvent(Box::new(t.0)))),
            ),

            TypeVariant::DiagnosticEvent => Box::new(
                ReadXdrIter::<_, Frame<DiagnosticEvent>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DiagnosticEvent(Box::new(t.0)))),
            ),

            TypeVariant::SorobanTransactionMetaExtV1 => Box::new(
                ReadXdrIter::<_, Frame<SorobanTransactionMetaExtV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanTransactionMetaExtV1(Box::new(t.0)))),
            ),

            TypeVariant::SorobanTransactionMetaExt => Box::new(
                ReadXdrIter::<_, Frame<SorobanTransactionMetaExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanTransactionMetaExt(Box::new(t.0)))),
            ),

            TypeVariant::SorobanTransactionMeta => Box::new(
                ReadXdrIter::<_, Frame<SorobanTransactionMeta>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanTransactionMeta(Box::new(t.0)))),
            ),

            TypeVariant::TransactionMetaV3 => Box::new(
                ReadXdrIter::<_, Frame<TransactionMetaV3>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV3(Box::new(t.0)))),
            ),

            TypeVariant::OperationMetaV2 => Box::new(
                ReadXdrIter::<_, Frame<OperationMetaV2>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationMetaV2(Box::new(t.0)))),
            ),

            TypeVariant::SorobanTransactionMetaV2 => Box::new(
                ReadXdrIter::<_, Frame<SorobanTransactionMetaV2>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanTransactionMetaV2(Box::new(t.0)))),
            ),

            TypeVariant::TransactionEventStage => Box::new(
                ReadXdrIter::<_, Frame<TransactionEventStage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEventStage(Box::new(t.0)))),
            ),

            TypeVariant::TransactionEvent => Box::new(
                ReadXdrIter::<_, Frame<TransactionEvent>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEvent(Box::new(t.0)))),
            ),

            TypeVariant::TransactionMetaV4 => Box::new(
                ReadXdrIter::<_, Frame<TransactionMetaV4>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV4(Box::new(t.0)))),
            ),

            TypeVariant::InvokeHostFunctionSuccessPreImage => Box::new(
                ReadXdrIter::<_, Frame<InvokeHostFunctionSuccessPreImage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InvokeHostFunctionSuccessPreImage(Box::new(t.0)))),
            ),

            TypeVariant::TransactionMeta => Box::new(
                ReadXdrIter::<_, Frame<TransactionMeta>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMeta(Box::new(t.0)))),
            ),

            TypeVariant::TransactionResultMeta => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultMeta>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultMeta(Box::new(t.0)))),
            ),

            TypeVariant::TransactionResultMetaV1 => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultMetaV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionResultMetaV1(Box::new(t.0)))),
            ),

            TypeVariant::UpgradeEntryMeta => Box::new(
                ReadXdrIter::<_, Frame<UpgradeEntryMeta>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeEntryMeta(Box::new(t.0)))),
            ),

            TypeVariant::LedgerCloseMetaV0 => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMetaV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV0(Box::new(t.0)))),
            ),

            TypeVariant::LedgerCloseMetaExtV1 => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMetaExtV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExtV1(Box::new(t.0)))),
            ),

            TypeVariant::LedgerCloseMetaExt => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMetaExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExt(Box::new(t.0)))),
            ),

            TypeVariant::LedgerCloseMetaV1 => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMetaV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV1(Box::new(t.0)))),
            ),

            TypeVariant::LedgerCloseMetaV2 => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMetaV2>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV2(Box::new(t.0)))),
            ),

            TypeVariant::LedgerCloseMeta => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMeta>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMeta(Box::new(t.0)))),
            ),

            TypeVariant::ErrorCode => Box::new(
                ReadXdrIter::<_, Frame<ErrorCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ErrorCode(Box::new(t.0)))),
            ),

            TypeVariant::SError => Box::new(
                ReadXdrIter::<_, Frame<SError>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SError(Box::new(t.0)))),
            ),

            TypeVariant::SendMore => Box::new(
                ReadXdrIter::<_, Frame<SendMore>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMore(Box::new(t.0)))),
            ),

            TypeVariant::SendMoreExtended => Box::new(
                ReadXdrIter::<_, Frame<SendMoreExtended>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMoreExtended(Box::new(t.0)))),
            ),

            TypeVariant::AuthCert => Box::new(
                ReadXdrIter::<_, Frame<AuthCert>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthCert(Box::new(t.0)))),
            ),

            TypeVariant::Hello => Box::new(
                ReadXdrIter::<_, Frame<Hello>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hello(Box::new(t.0)))),
            ),

            TypeVariant::Auth => Box::new(
                ReadXdrIter::<_, Frame<Auth>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Auth(Box::new(t.0)))),
            ),

            TypeVariant::IpAddrType => Box::new(
                ReadXdrIter::<_, Frame<IpAddrType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::IpAddrType(Box::new(t.0)))),
            ),

            TypeVariant::PeerAddress => Box::new(
                ReadXdrIter::<_, Frame<PeerAddress>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddress(Box::new(t.0)))),
            ),

            TypeVariant::MessageType => Box::new(
                ReadXdrIter::<_, Frame<MessageType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MessageType(Box::new(t.0)))),
            ),

            TypeVariant::DontHave => Box::new(
                ReadXdrIter::<_, Frame<DontHave>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DontHave(Box::new(t.0)))),
            ),

            TypeVariant::SurveyMessageCommandType => Box::new(
                ReadXdrIter::<_, Frame<SurveyMessageCommandType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SurveyMessageCommandType(Box::new(t.0)))),
            ),

            TypeVariant::SurveyMessageResponseType => Box::new(
                ReadXdrIter::<_, Frame<SurveyMessageResponseType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SurveyMessageResponseType(Box::new(t.0)))),
            ),

            TypeVariant::TimeSlicedSurveyStartCollectingMessage => Box::new(
                ReadXdrIter::<_, Frame<TimeSlicedSurveyStartCollectingMessage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TimeSlicedSurveyStartCollectingMessage(Box::new(t.0)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyStartCollectingMessage => Box::new(
                ReadXdrIter::<_, Frame<SignedTimeSlicedSurveyStartCollectingMessage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| {
                    r.map(|t| Self::SignedTimeSlicedSurveyStartCollectingMessage(Box::new(t.0)))
                }),
            ),

            TypeVariant::TimeSlicedSurveyStopCollectingMessage => Box::new(
                ReadXdrIter::<_, Frame<TimeSlicedSurveyStopCollectingMessage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TimeSlicedSurveyStopCollectingMessage(Box::new(t.0)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyStopCollectingMessage => Box::new(
                ReadXdrIter::<_, Frame<SignedTimeSlicedSurveyStopCollectingMessage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| {
                    r.map(|t| Self::SignedTimeSlicedSurveyStopCollectingMessage(Box::new(t.0)))
                }),
            ),

            TypeVariant::SurveyRequestMessage => Box::new(
                ReadXdrIter::<_, Frame<SurveyRequestMessage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyRequestMessage(Box::new(t.0)))),
            ),

            TypeVariant::TimeSlicedSurveyRequestMessage => Box::new(
                ReadXdrIter::<_, Frame<TimeSlicedSurveyRequestMessage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TimeSlicedSurveyRequestMessage(Box::new(t.0)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyRequestMessage => Box::new(
                ReadXdrIter::<_, Frame<SignedTimeSlicedSurveyRequestMessage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignedTimeSlicedSurveyRequestMessage(Box::new(t.0)))),
            ),

            TypeVariant::EncryptedBody => Box::new(
                ReadXdrIter::<_, Frame<EncryptedBody>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EncryptedBody(Box::new(t.0)))),
            ),

            TypeVariant::SurveyResponseMessage => Box::new(
                ReadXdrIter::<_, Frame<SurveyResponseMessage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseMessage(Box::new(t.0)))),
            ),

            TypeVariant::TimeSlicedSurveyResponseMessage => Box::new(
                ReadXdrIter::<_, Frame<TimeSlicedSurveyResponseMessage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TimeSlicedSurveyResponseMessage(Box::new(t.0)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyResponseMessage => Box::new(
                ReadXdrIter::<_, Frame<SignedTimeSlicedSurveyResponseMessage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignedTimeSlicedSurveyResponseMessage(Box::new(t.0)))),
            ),

            TypeVariant::PeerStats => Box::new(
                ReadXdrIter::<_, Frame<PeerStats>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerStats(Box::new(t.0)))),
            ),

            TypeVariant::TimeSlicedNodeData => Box::new(
                ReadXdrIter::<_, Frame<TimeSlicedNodeData>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeSlicedNodeData(Box::new(t.0)))),
            ),

            TypeVariant::TimeSlicedPeerData => Box::new(
                ReadXdrIter::<_, Frame<TimeSlicedPeerData>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeSlicedPeerData(Box::new(t.0)))),
            ),

            TypeVariant::TimeSlicedPeerDataList => Box::new(
                ReadXdrIter::<_, Frame<TimeSlicedPeerDataList>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TimeSlicedPeerDataList(Box::new(t.0)))),
            ),

            TypeVariant::TopologyResponseBodyV2 => Box::new(
                ReadXdrIter::<_, Frame<TopologyResponseBodyV2>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TopologyResponseBodyV2(Box::new(t.0)))),
            ),

            TypeVariant::SurveyResponseBody => Box::new(
                ReadXdrIter::<_, Frame<SurveyResponseBody>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseBody(Box::new(t.0)))),
            ),

            TypeVariant::TxAdvertVector => Box::new(
                ReadXdrIter::<_, Frame<TxAdvertVector>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxAdvertVector(Box::new(t.0)))),
            ),

            TypeVariant::FloodAdvert => Box::new(
                ReadXdrIter::<_, Frame<FloodAdvert>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodAdvert(Box::new(t.0)))),
            ),

            TypeVariant::TxDemandVector => Box::new(
                ReadXdrIter::<_, Frame<TxDemandVector>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxDemandVector(Box::new(t.0)))),
            ),

            TypeVariant::FloodDemand => Box::new(
                ReadXdrIter::<_, Frame<FloodDemand>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodDemand(Box::new(t.0)))),
            ),

            TypeVariant::StellarMessage => Box::new(
                ReadXdrIter::<_, Frame<StellarMessage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarMessage(Box::new(t.0)))),
            ),

            TypeVariant::AuthenticatedMessage => Box::new(
                ReadXdrIter::<_, Frame<AuthenticatedMessage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthenticatedMessage(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolParameters => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolParameters>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolParameters(Box::new(t.0)))),
            ),

            TypeVariant::MuxedAccount => Box::new(
                ReadXdrIter::<_, Frame<MuxedAccount>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccount(Box::new(t.0)))),
            ),

            TypeVariant::DecoratedSignature => Box::new(
                ReadXdrIter::<_, Frame<DecoratedSignature>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DecoratedSignature(Box::new(t.0)))),
            ),

            TypeVariant::OperationType => Box::new(
                ReadXdrIter::<_, Frame<OperationType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationType(Box::new(t.0)))),
            ),

            TypeVariant::CreateAccountOp => Box::new(
                ReadXdrIter::<_, Frame<CreateAccountOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountOp(Box::new(t.0)))),
            ),

            TypeVariant::PaymentOp => Box::new(
                ReadXdrIter::<_, Frame<PaymentOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentOp(Box::new(t.0)))),
            ),

            TypeVariant::PathPaymentStrictReceiveOp => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictReceiveOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveOp(Box::new(t.0)))),
            ),

            TypeVariant::PathPaymentStrictSendOp => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictSendOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendOp(Box::new(t.0)))),
            ),

            TypeVariant::ManageSellOfferOp => Box::new(
                ReadXdrIter::<_, Frame<ManageSellOfferOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferOp(Box::new(t.0)))),
            ),

            TypeVariant::ManageBuyOfferOp => Box::new(
                ReadXdrIter::<_, Frame<ManageBuyOfferOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferOp(Box::new(t.0)))),
            ),

            TypeVariant::CreatePassiveSellOfferOp => Box::new(
                ReadXdrIter::<_, Frame<CreatePassiveSellOfferOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreatePassiveSellOfferOp(Box::new(t.0)))),
            ),

            TypeVariant::SetOptionsOp => Box::new(
                ReadXdrIter::<_, Frame<SetOptionsOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsOp(Box::new(t.0)))),
            ),

            TypeVariant::ChangeTrustAsset => Box::new(
                ReadXdrIter::<_, Frame<ChangeTrustAsset>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustAsset(Box::new(t.0)))),
            ),

            TypeVariant::ChangeTrustOp => Box::new(
                ReadXdrIter::<_, Frame<ChangeTrustOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustOp(Box::new(t.0)))),
            ),

            TypeVariant::AllowTrustOp => Box::new(
                ReadXdrIter::<_, Frame<AllowTrustOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustOp(Box::new(t.0)))),
            ),

            TypeVariant::ManageDataOp => Box::new(
                ReadXdrIter::<_, Frame<ManageDataOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataOp(Box::new(t.0)))),
            ),

            TypeVariant::BumpSequenceOp => Box::new(
                ReadXdrIter::<_, Frame<BumpSequenceOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceOp(Box::new(t.0)))),
            ),

            TypeVariant::CreateClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, Frame<CreateClaimableBalanceOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreateClaimableBalanceOp(Box::new(t.0)))),
            ),

            TypeVariant::ClaimClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, Frame<ClaimClaimableBalanceOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimClaimableBalanceOp(Box::new(t.0)))),
            ),

            TypeVariant::BeginSponsoringFutureReservesOp => Box::new(
                ReadXdrIter::<_, Frame<BeginSponsoringFutureReservesOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesOp(Box::new(t.0)))),
            ),

            TypeVariant::RevokeSponsorshipType => Box::new(
                ReadXdrIter::<_, Frame<RevokeSponsorshipType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipType(Box::new(t.0)))),
            ),

            TypeVariant::RevokeSponsorshipOp => Box::new(
                ReadXdrIter::<_, Frame<RevokeSponsorshipOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipOp(Box::new(t.0)))),
            ),

            TypeVariant::ClawbackOp => Box::new(
                ReadXdrIter::<_, Frame<ClawbackOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackOp(Box::new(t.0)))),
            ),

            TypeVariant::ClawbackClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, Frame<ClawbackClaimableBalanceOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClawbackClaimableBalanceOp(Box::new(t.0)))),
            ),

            TypeVariant::SetTrustLineFlagsOp => Box::new(
                ReadXdrIter::<_, Frame<SetTrustLineFlagsOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsOp(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolDepositOp => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolDepositOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolDepositOp(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolWithdrawOp => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolWithdrawOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolWithdrawOp(Box::new(t.0)))),
            ),

            TypeVariant::HostFunctionType => Box::new(
                ReadXdrIter::<_, Frame<HostFunctionType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunctionType(Box::new(t.0)))),
            ),

            TypeVariant::ContractIdPreimageType => Box::new(
                ReadXdrIter::<_, Frame<ContractIdPreimageType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractIdPreimageType(Box::new(t.0)))),
            ),

            TypeVariant::ContractIdPreimage => Box::new(
                ReadXdrIter::<_, Frame<ContractIdPreimage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimage(Box::new(t.0)))),
            ),

            TypeVariant::CreateContractArgs => Box::new(
                ReadXdrIter::<_, Frame<CreateContractArgs>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateContractArgs(Box::new(t.0)))),
            ),

            TypeVariant::CreateContractArgsV2 => Box::new(
                ReadXdrIter::<_, Frame<CreateContractArgsV2>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateContractArgsV2(Box::new(t.0)))),
            ),

            TypeVariant::InvokeContractArgs => Box::new(
                ReadXdrIter::<_, Frame<InvokeContractArgs>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeContractArgs(Box::new(t.0)))),
            ),

            TypeVariant::HostFunction => Box::new(
                ReadXdrIter::<_, Frame<HostFunction>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunction(Box::new(t.0)))),
            ),

            TypeVariant::SorobanAuthorizedFunctionType => Box::new(
                ReadXdrIter::<_, Frame<SorobanAuthorizedFunctionType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAuthorizedFunctionType(Box::new(t.0)))),
            ),

            TypeVariant::SorobanAuthorizedFunction => Box::new(
                ReadXdrIter::<_, Frame<SorobanAuthorizedFunction>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAuthorizedFunction(Box::new(t.0)))),
            ),

            TypeVariant::SorobanAuthorizedInvocation => Box::new(
                ReadXdrIter::<_, Frame<SorobanAuthorizedInvocation>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAuthorizedInvocation(Box::new(t.0)))),
            ),

            TypeVariant::SorobanAddressCredentials => Box::new(
                ReadXdrIter::<_, Frame<SorobanAddressCredentials>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAddressCredentials(Box::new(t.0)))),
            ),

            TypeVariant::SorobanCredentialsType => Box::new(
                ReadXdrIter::<_, Frame<SorobanCredentialsType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanCredentialsType(Box::new(t.0)))),
            ),

            TypeVariant::SorobanCredentials => Box::new(
                ReadXdrIter::<_, Frame<SorobanCredentials>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanCredentials(Box::new(t.0)))),
            ),

            TypeVariant::SorobanAuthorizationEntry => Box::new(
                ReadXdrIter::<_, Frame<SorobanAuthorizationEntry>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAuthorizationEntry(Box::new(t.0)))),
            ),

            TypeVariant::SorobanAuthorizationEntries => Box::new(
                ReadXdrIter::<_, Frame<SorobanAuthorizationEntries>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAuthorizationEntries(Box::new(t.0)))),
            ),

            TypeVariant::InvokeHostFunctionOp => Box::new(
                ReadXdrIter::<_, Frame<InvokeHostFunctionOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionOp(Box::new(t.0)))),
            ),

            TypeVariant::ExtendFootprintTtlOp => Box::new(
                ReadXdrIter::<_, Frame<ExtendFootprintTtlOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlOp(Box::new(t.0)))),
            ),

            TypeVariant::RestoreFootprintOp => Box::new(
                ReadXdrIter::<_, Frame<RestoreFootprintOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintOp(Box::new(t.0)))),
            ),

            TypeVariant::Operation => Box::new(
                ReadXdrIter::<_, Frame<Operation>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Operation(Box::new(t.0)))),
            ),

            TypeVariant::HashIdPreimage => Box::new(
                ReadXdrIter::<_, Frame<HashIdPreimage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimage(Box::new(t.0)))),
            ),

            TypeVariant::MemoType => Box::new(
                ReadXdrIter::<_, Frame<MemoType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MemoType(Box::new(t.0)))),
            ),

            TypeVariant::Memo => Box::new(
                ReadXdrIter::<_, Frame<Memo>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Memo(Box::new(t.0)))),
            ),

            TypeVariant::TimeBounds => Box::new(
                ReadXdrIter::<_, Frame<TimeBounds>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeBounds(Box::new(t.0)))),
            ),

            TypeVariant::LedgerBounds => Box::new(
                ReadXdrIter::<_, Frame<LedgerBounds>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerBounds(Box::new(t.0)))),
            ),

            TypeVariant::PreconditionsV2 => Box::new(
                ReadXdrIter::<_, Frame<PreconditionsV2>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionsV2(Box::new(t.0)))),
            ),

            TypeVariant::PreconditionType => Box::new(
                ReadXdrIter::<_, Frame<PreconditionType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionType(Box::new(t.0)))),
            ),

            TypeVariant::Preconditions => Box::new(
                ReadXdrIter::<_, Frame<Preconditions>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Preconditions(Box::new(t.0)))),
            ),

            TypeVariant::LedgerFootprint => Box::new(
                ReadXdrIter::<_, Frame<LedgerFootprint>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerFootprint(Box::new(t.0)))),
            ),

            TypeVariant::SorobanResources => Box::new(
                ReadXdrIter::<_, Frame<SorobanResources>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanResources(Box::new(t.0)))),
            ),

            TypeVariant::SorobanResourcesExtV0 => Box::new(
                ReadXdrIter::<_, Frame<SorobanResourcesExtV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanResourcesExtV0(Box::new(t.0)))),
            ),

            TypeVariant::SorobanTransactionData => Box::new(
                ReadXdrIter::<_, Frame<SorobanTransactionData>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanTransactionData(Box::new(t.0)))),
            ),

            TypeVariant::TransactionV0 => Box::new(
                ReadXdrIter::<_, Frame<TransactionV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0(Box::new(t.0)))),
            ),

            TypeVariant::TransactionV0Envelope => Box::new(
                ReadXdrIter::<_, Frame<TransactionV0Envelope>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Envelope(Box::new(t.0)))),
            ),

            TypeVariant::Transaction => Box::new(
                ReadXdrIter::<_, Frame<Transaction>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Transaction(Box::new(t.0)))),
            ),

            TypeVariant::TransactionV1Envelope => Box::new(
                ReadXdrIter::<_, Frame<TransactionV1Envelope>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV1Envelope(Box::new(t.0)))),
            ),

            TypeVariant::FeeBumpTransaction => Box::new(
                ReadXdrIter::<_, Frame<FeeBumpTransaction>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransaction(Box::new(t.0)))),
            ),

            TypeVariant::FeeBumpTransactionEnvelope => Box::new(
                ReadXdrIter::<_, Frame<FeeBumpTransactionEnvelope>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::FeeBumpTransactionEnvelope(Box::new(t.0)))),
            ),

            TypeVariant::TransactionEnvelope => Box::new(
                ReadXdrIter::<_, Frame<TransactionEnvelope>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEnvelope(Box::new(t.0)))),
            ),

            TypeVariant::TransactionSignaturePayload => Box::new(
                ReadXdrIter::<_, Frame<TransactionSignaturePayload>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionSignaturePayload(Box::new(t.0)))),
            ),

            TypeVariant::ClaimAtomType => Box::new(
                ReadXdrIter::<_, Frame<ClaimAtomType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtomType(Box::new(t.0)))),
            ),

            TypeVariant::ClaimOfferAtomV0 => Box::new(
                ReadXdrIter::<_, Frame<ClaimOfferAtomV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtomV0(Box::new(t.0)))),
            ),

            TypeVariant::ClaimOfferAtom => Box::new(
                ReadXdrIter::<_, Frame<ClaimOfferAtom>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtom(Box::new(t.0)))),
            ),

            TypeVariant::ClaimLiquidityAtom => Box::new(
                ReadXdrIter::<_, Frame<ClaimLiquidityAtom>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimLiquidityAtom(Box::new(t.0)))),
            ),

            TypeVariant::ClaimAtom => Box::new(
                ReadXdrIter::<_, Frame<ClaimAtom>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtom(Box::new(t.0)))),
            ),

            TypeVariant::CreateAccountResultCode => Box::new(
                ReadXdrIter::<_, Frame<CreateAccountResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreateAccountResultCode(Box::new(t.0)))),
            ),

            TypeVariant::CreateAccountResult => Box::new(
                ReadXdrIter::<_, Frame<CreateAccountResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountResult(Box::new(t.0)))),
            ),

            TypeVariant::PaymentResultCode => Box::new(
                ReadXdrIter::<_, Frame<PaymentResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResultCode(Box::new(t.0)))),
            ),

            TypeVariant::PaymentResult => Box::new(
                ReadXdrIter::<_, Frame<PaymentResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResult(Box::new(t.0)))),
            ),

            TypeVariant::PathPaymentStrictReceiveResultCode => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictReceiveResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultCode(Box::new(t.0)))),
            ),

            TypeVariant::SimplePaymentResult => Box::new(
                ReadXdrIter::<_, Frame<SimplePaymentResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SimplePaymentResult(Box::new(t.0)))),
            ),

            TypeVariant::PathPaymentStrictReceiveResult => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictReceiveResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResult(Box::new(t.0)))),
            ),

            TypeVariant::PathPaymentStrictSendResultCode => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictSendResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendResultCode(Box::new(t.0)))),
            ),

            TypeVariant::PathPaymentStrictSendResult => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictSendResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendResult(Box::new(t.0)))),
            ),

            TypeVariant::ManageSellOfferResultCode => Box::new(
                ReadXdrIter::<_, Frame<ManageSellOfferResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ManageSellOfferResultCode(Box::new(t.0)))),
            ),

            TypeVariant::ManageOfferEffect => Box::new(
                ReadXdrIter::<_, Frame<ManageOfferEffect>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferEffect(Box::new(t.0)))),
            ),

            TypeVariant::ManageOfferSuccessResult => Box::new(
                ReadXdrIter::<_, Frame<ManageOfferSuccessResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ManageOfferSuccessResult(Box::new(t.0)))),
            ),

            TypeVariant::ManageSellOfferResult => Box::new(
                ReadXdrIter::<_, Frame<ManageSellOfferResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferResult(Box::new(t.0)))),
            ),

            TypeVariant::ManageBuyOfferResultCode => Box::new(
                ReadXdrIter::<_, Frame<ManageBuyOfferResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ManageBuyOfferResultCode(Box::new(t.0)))),
            ),

            TypeVariant::ManageBuyOfferResult => Box::new(
                ReadXdrIter::<_, Frame<ManageBuyOfferResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferResult(Box::new(t.0)))),
            ),

            TypeVariant::SetOptionsResultCode => Box::new(
                ReadXdrIter::<_, Frame<SetOptionsResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResultCode(Box::new(t.0)))),
            ),

            TypeVariant::SetOptionsResult => Box::new(
                ReadXdrIter::<_, Frame<SetOptionsResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResult(Box::new(t.0)))),
            ),

            TypeVariant::ChangeTrustResultCode => Box::new(
                ReadXdrIter::<_, Frame<ChangeTrustResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResultCode(Box::new(t.0)))),
            ),

            TypeVariant::ChangeTrustResult => Box::new(
                ReadXdrIter::<_, Frame<ChangeTrustResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResult(Box::new(t.0)))),
            ),

            TypeVariant::AllowTrustResultCode => Box::new(
                ReadXdrIter::<_, Frame<AllowTrustResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResultCode(Box::new(t.0)))),
            ),

            TypeVariant::AllowTrustResult => Box::new(
                ReadXdrIter::<_, Frame<AllowTrustResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResult(Box::new(t.0)))),
            ),

            TypeVariant::AccountMergeResultCode => Box::new(
                ReadXdrIter::<_, Frame<AccountMergeResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountMergeResultCode(Box::new(t.0)))),
            ),

            TypeVariant::AccountMergeResult => Box::new(
                ReadXdrIter::<_, Frame<AccountMergeResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountMergeResult(Box::new(t.0)))),
            ),

            TypeVariant::InflationResultCode => Box::new(
                ReadXdrIter::<_, Frame<InflationResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResultCode(Box::new(t.0)))),
            ),

            TypeVariant::InflationPayout => Box::new(
                ReadXdrIter::<_, Frame<InflationPayout>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationPayout(Box::new(t.0)))),
            ),

            TypeVariant::InflationResult => Box::new(
                ReadXdrIter::<_, Frame<InflationResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResult(Box::new(t.0)))),
            ),

            TypeVariant::ManageDataResultCode => Box::new(
                ReadXdrIter::<_, Frame<ManageDataResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResultCode(Box::new(t.0)))),
            ),

            TypeVariant::ManageDataResult => Box::new(
                ReadXdrIter::<_, Frame<ManageDataResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResult(Box::new(t.0)))),
            ),

            TypeVariant::BumpSequenceResultCode => Box::new(
                ReadXdrIter::<_, Frame<BumpSequenceResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BumpSequenceResultCode(Box::new(t.0)))),
            ),

            TypeVariant::BumpSequenceResult => Box::new(
                ReadXdrIter::<_, Frame<BumpSequenceResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceResult(Box::new(t.0)))),
            ),

            TypeVariant::CreateClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, Frame<CreateClaimableBalanceResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreateClaimableBalanceResultCode(Box::new(t.0)))),
            ),

            TypeVariant::CreateClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, Frame<CreateClaimableBalanceResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreateClaimableBalanceResult(Box::new(t.0)))),
            ),

            TypeVariant::ClaimClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, Frame<ClaimClaimableBalanceResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimClaimableBalanceResultCode(Box::new(t.0)))),
            ),

            TypeVariant::ClaimClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, Frame<ClaimClaimableBalanceResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimClaimableBalanceResult(Box::new(t.0)))),
            ),

            TypeVariant::BeginSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, Frame<BeginSponsoringFutureReservesResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResultCode(Box::new(t.0)))),
            ),

            TypeVariant::BeginSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, Frame<BeginSponsoringFutureReservesResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResult(Box::new(t.0)))),
            ),

            TypeVariant::EndSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, Frame<EndSponsoringFutureReservesResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResultCode(Box::new(t.0)))),
            ),

            TypeVariant::EndSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, Frame<EndSponsoringFutureReservesResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResult(Box::new(t.0)))),
            ),

            TypeVariant::RevokeSponsorshipResultCode => Box::new(
                ReadXdrIter::<_, Frame<RevokeSponsorshipResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::RevokeSponsorshipResultCode(Box::new(t.0)))),
            ),

            TypeVariant::RevokeSponsorshipResult => Box::new(
                ReadXdrIter::<_, Frame<RevokeSponsorshipResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::RevokeSponsorshipResult(Box::new(t.0)))),
            ),

            TypeVariant::ClawbackResultCode => Box::new(
                ReadXdrIter::<_, Frame<ClawbackResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResultCode(Box::new(t.0)))),
            ),

            TypeVariant::ClawbackResult => Box::new(
                ReadXdrIter::<_, Frame<ClawbackResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResult(Box::new(t.0)))),
            ),

            TypeVariant::ClawbackClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, Frame<ClawbackClaimableBalanceResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResultCode(Box::new(t.0)))),
            ),

            TypeVariant::ClawbackClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, Frame<ClawbackClaimableBalanceResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResult(Box::new(t.0)))),
            ),

            TypeVariant::SetTrustLineFlagsResultCode => Box::new(
                ReadXdrIter::<_, Frame<SetTrustLineFlagsResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SetTrustLineFlagsResultCode(Box::new(t.0)))),
            ),

            TypeVariant::SetTrustLineFlagsResult => Box::new(
                ReadXdrIter::<_, Frame<SetTrustLineFlagsResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SetTrustLineFlagsResult(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolDepositResultCode => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolDepositResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolDepositResultCode(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolDepositResult => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolDepositResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolDepositResult(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolWithdrawResultCode => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolWithdrawResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResultCode(Box::new(t.0)))),
            ),

            TypeVariant::LiquidityPoolWithdrawResult => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolWithdrawResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResult(Box::new(t.0)))),
            ),

            TypeVariant::InvokeHostFunctionResultCode => Box::new(
                ReadXdrIter::<_, Frame<InvokeHostFunctionResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InvokeHostFunctionResultCode(Box::new(t.0)))),
            ),

            TypeVariant::InvokeHostFunctionResult => Box::new(
                ReadXdrIter::<_, Frame<InvokeHostFunctionResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InvokeHostFunctionResult(Box::new(t.0)))),
            ),

            TypeVariant::ExtendFootprintTtlResultCode => Box::new(
                ReadXdrIter::<_, Frame<ExtendFootprintTtlResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ExtendFootprintTtlResultCode(Box::new(t.0)))),
            ),

            TypeVariant::ExtendFootprintTtlResult => Box::new(
                ReadXdrIter::<_, Frame<ExtendFootprintTtlResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ExtendFootprintTtlResult(Box::new(t.0)))),
            ),

            TypeVariant::RestoreFootprintResultCode => Box::new(
                ReadXdrIter::<_, Frame<RestoreFootprintResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::RestoreFootprintResultCode(Box::new(t.0)))),
            ),

            TypeVariant::RestoreFootprintResult => Box::new(
                ReadXdrIter::<_, Frame<RestoreFootprintResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::RestoreFootprintResult(Box::new(t.0)))),
            ),

            TypeVariant::OperationResultCode => Box::new(
                ReadXdrIter::<_, Frame<OperationResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultCode(Box::new(t.0)))),
            ),

            TypeVariant::OperationResult => Box::new(
                ReadXdrIter::<_, Frame<OperationResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResult(Box::new(t.0)))),
            ),

            TypeVariant::TransactionResultCode => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultCode(Box::new(t.0)))),
            ),

            TypeVariant::InnerTransactionResult => Box::new(
                ReadXdrIter::<_, Frame<InnerTransactionResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InnerTransactionResult(Box::new(t.0)))),
            ),

            TypeVariant::InnerTransactionResultPair => Box::new(
                ReadXdrIter::<_, Frame<InnerTransactionResultPair>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InnerTransactionResultPair(Box::new(t.0)))),
            ),

            TypeVariant::TransactionResult => Box::new(
                ReadXdrIter::<_, Frame<TransactionResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResult(Box::new(t.0)))),
            ),

            TypeVariant::Hash => Box::new(
                ReadXdrIter::<_, Frame<Hash>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hash(Box::new(t.0)))),
            ),

            TypeVariant::Uint256 => Box::new(
                ReadXdrIter::<_, Frame<Uint256>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint256(Box::new(t.0)))),
            ),

            TypeVariant::Uint32 => Box::new(
                ReadXdrIter::<_, Frame<Uint32>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint32(Box::new(t.0)))),
            ),

            TypeVariant::Int32 => Box::new(
                ReadXdrIter::<_, Frame<Int32>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int32(Box::new(t.0)))),
            ),

            TypeVariant::Uint64 => Box::new(
                ReadXdrIter::<_, Frame<Uint64>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint64(Box::new(t.0)))),
            ),

            TypeVariant::Int64 => Box::new(
                ReadXdrIter::<_, Frame<Int64>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int64(Box::new(t.0)))),
            ),

            TypeVariant::TimePoint => Box::new(
                ReadXdrIter::<_, Frame<TimePoint>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimePoint(Box::new(t.0)))),
            ),

            TypeVariant::Duration => Box::new(
                ReadXdrIter::<_, Frame<Duration>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Duration(Box::new(t.0)))),
            ),

            TypeVariant::ExtensionPoint => Box::new(
                ReadXdrIter::<_, Frame<ExtensionPoint>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtensionPoint(Box::new(t.0)))),
            ),

            TypeVariant::CryptoKeyType => Box::new(
                ReadXdrIter::<_, Frame<CryptoKeyType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CryptoKeyType(Box::new(t.0)))),
            ),

            TypeVariant::PublicKeyType => Box::new(
                ReadXdrIter::<_, Frame<PublicKeyType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKeyType(Box::new(t.0)))),
            ),

            TypeVariant::SignerKeyType => Box::new(
                ReadXdrIter::<_, Frame<SignerKeyType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKeyType(Box::new(t.0)))),
            ),

            TypeVariant::PublicKey => Box::new(
                ReadXdrIter::<_, Frame<PublicKey>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKey(Box::new(t.0)))),
            ),

            TypeVariant::SignerKey => Box::new(
                ReadXdrIter::<_, Frame<SignerKey>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKey(Box::new(t.0)))),
            ),

            TypeVariant::Signature => Box::new(
                ReadXdrIter::<_, Frame<Signature>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signature(Box::new(t.0)))),
            ),

            TypeVariant::SignatureHint => Box::new(
                ReadXdrIter::<_, Frame<SignatureHint>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignatureHint(Box::new(t.0)))),
            ),

            TypeVariant::NodeId => Box::new(
                ReadXdrIter::<_, Frame<NodeId>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::NodeId(Box::new(t.0)))),
            ),

            TypeVariant::AccountId => Box::new(
                ReadXdrIter::<_, Frame<AccountId>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountId(Box::new(t.0)))),
            ),

            TypeVariant::ContractId => Box::new(
                ReadXdrIter::<_, Frame<ContractId>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractId(Box::new(t.0)))),
            ),

            TypeVariant::Curve25519Secret => Box::new(
                ReadXdrIter::<_, Frame<Curve25519Secret>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Secret(Box::new(t.0)))),
            ),

            TypeVariant::Curve25519Public => Box::new(
                ReadXdrIter::<_, Frame<Curve25519Public>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Public(Box::new(t.0)))),
            ),

            TypeVariant::HmacSha256Key => Box::new(
                ReadXdrIter::<_, Frame<HmacSha256Key>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Key(Box::new(t.0)))),
            ),

            TypeVariant::HmacSha256Mac => Box::new(
                ReadXdrIter::<_, Frame<HmacSha256Mac>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Mac(Box::new(t.0)))),
            ),

            TypeVariant::ShortHashSeed => Box::new(
                ReadXdrIter::<_, Frame<ShortHashSeed>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ShortHashSeed(Box::new(t.0)))),
            ),

            TypeVariant::BinaryFuseFilterType => Box::new(
                ReadXdrIter::<_, Frame<BinaryFuseFilterType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BinaryFuseFilterType(Box::new(t.0)))),
            ),

            TypeVariant::SerializedBinaryFuseFilter => Box::new(
                ReadXdrIter::<_, Frame<SerializedBinaryFuseFilter>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SerializedBinaryFuseFilter(Box::new(t.0)))),
            ),

            TypeVariant::PoolId => Box::new(
                ReadXdrIter::<_, Frame<PoolId>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PoolId(Box::new(t.0)))),
            ),

            TypeVariant::ClaimableBalanceIdType => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceIdType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceIdType(Box::new(t.0)))),
            ),

            TypeVariant::ClaimableBalanceId => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceId>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceId(Box::new(t.0)))),
            ),
        }
    }

    #[cfg(feature = "base64")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr_base64_iter<R: Read>(
        v: TypeVariant,
        r: &mut Limited<R>,
    ) -> Box<dyn Iterator<Item = Result<Self, Error>> + '_> {
        let dec = base64::read::DecoderReader::new(
            SkipWhitespace::new(&mut r.inner),
            &base64::engine::general_purpose::STANDARD,
        );
        match v {
            TypeVariant::ScpStatementPrepare => Box::new(
                ReadXdrIter::<_, ScpStatementPrepare>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPrepare(Box::new(t)))),
            ),

            TypeVariant::ScpStatementConfirm => Box::new(
                ReadXdrIter::<_, ScpStatementConfirm>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementConfirm(Box::new(t)))),
            ),

            TypeVariant::ScpStatementExternalize => Box::new(
                ReadXdrIter::<_, ScpStatementExternalize>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementExternalize(Box::new(t)))),
            ),

            TypeVariant::ScpStatementPledges => Box::new(
                ReadXdrIter::<_, ScpStatementPledges>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPledges(Box::new(t)))),
            ),

            TypeVariant::ScEnvMetaEntryInterfaceVersion => Box::new(
                ReadXdrIter::<_, ScEnvMetaEntryInterfaceVersion>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaEntryInterfaceVersion(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV2Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV2Ext(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV1Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV1Ext(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExt => Box::new(
                ReadXdrIter::<_, AccountEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExt(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, TrustLineEntryExtensionV2Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2Ext(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntryV1Ext => Box::new(
                ReadXdrIter::<_, TrustLineEntryV1Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1Ext(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntryV1 => Box::new(
                ReadXdrIter::<_, TrustLineEntryV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntryExt => Box::new(
                ReadXdrIter::<_, TrustLineEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExt(Box::new(t)))),
            ),

            TypeVariant::OfferEntryExt => Box::new(
                ReadXdrIter::<_, OfferEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryExt(Box::new(t)))),
            ),

            TypeVariant::DataEntryExt => Box::new(
                ReadXdrIter::<_, DataEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntryExt(Box::new(t)))),
            ),

            TypeVariant::ClaimantV0 => Box::new(
                ReadXdrIter::<_, ClaimantV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantV0(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExtensionV1Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceEntryExt => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntryExt(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolEntryConstantProduct => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntryConstantProduct>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntryConstantProduct(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolEntryBody => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntryBody>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntryBody(Box::new(t)))),
            ),

            TypeVariant::ContractCodeEntryV1 => Box::new(
                ReadXdrIter::<_, ContractCodeEntryV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryV1(Box::new(t)))),
            ),

            TypeVariant::ContractCodeEntryExt => Box::new(
                ReadXdrIter::<_, ContractCodeEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryExt(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, LedgerEntryExtensionV1Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExtensionV1Ext(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryData => Box::new(
                ReadXdrIter::<_, LedgerEntryData>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryData(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryExt => Box::new(
                ReadXdrIter::<_, LedgerEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExt(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyAccount => Box::new(
                ReadXdrIter::<_, LedgerKeyAccount>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyAccount(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyTrustLine => Box::new(
                ReadXdrIter::<_, LedgerKeyTrustLine>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTrustLine(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyOffer => Box::new(
                ReadXdrIter::<_, LedgerKeyOffer>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyOffer(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyData => Box::new(
                ReadXdrIter::<_, LedgerKeyData>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyData(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyClaimableBalance => Box::new(
                ReadXdrIter::<_, LedgerKeyClaimableBalance>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyClaimableBalance(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyLiquidityPool => Box::new(
                ReadXdrIter::<_, LedgerKeyLiquidityPool>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyLiquidityPool(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyContractData => Box::new(
                ReadXdrIter::<_, LedgerKeyContractData>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractData(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyContractCode => Box::new(
                ReadXdrIter::<_, LedgerKeyContractCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractCode(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyConfigSetting => Box::new(
                ReadXdrIter::<_, LedgerKeyConfigSetting>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyConfigSetting(Box::new(t)))),
            ),

            TypeVariant::LedgerKeyTtl => Box::new(
                ReadXdrIter::<_, LedgerKeyTtl>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTtl(Box::new(t)))),
            ),

            TypeVariant::BucketMetadataExt => Box::new(
                ReadXdrIter::<_, BucketMetadataExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadataExt(Box::new(t)))),
            ),

            TypeVariant::StellarValueExt => Box::new(
                ReadXdrIter::<_, StellarValueExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueExt(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderExtensionV1Ext => Box::new(
                ReadXdrIter::<_, LedgerHeaderExtensionV1Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1Ext(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderExt => Box::new(
                ReadXdrIter::<_, LedgerHeaderExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExt(Box::new(t)))),
            ),

            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => Box::new(
                ReadXdrIter::<_, TxSetComponentTxsMaybeDiscountedFee>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(t)))),
            ),

            TypeVariant::TransactionHistoryEntryExt => Box::new(
                ReadXdrIter::<_, TransactionHistoryEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryEntryExt(Box::new(t)))),
            ),

            TypeVariant::TransactionHistoryResultEntryExt => Box::new(
                ReadXdrIter::<_, TransactionHistoryResultEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryResultEntryExt(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderHistoryEntryExt => Box::new(
                ReadXdrIter::<_, LedgerHeaderHistoryEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntryExt(Box::new(t)))),
            ),

            TypeVariant::ContractEventV0 => Box::new(
                ReadXdrIter::<_, ContractEventV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventV0(Box::new(t)))),
            ),

            TypeVariant::ContractEventBody => Box::new(
                ReadXdrIter::<_, ContractEventBody>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventBody(Box::new(t)))),
            ),

            TypeVariant::PeerAddressIp => Box::new(
                ReadXdrIter::<_, PeerAddressIp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddressIp(Box::new(t)))),
            ),

            TypeVariant::AuthenticatedMessageV0 => Box::new(
                ReadXdrIter::<_, AuthenticatedMessageV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthenticatedMessageV0(Box::new(t)))),
            ),

            TypeVariant::MuxedAccountMed25519 => Box::new(
                ReadXdrIter::<_, MuxedAccountMed25519>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccountMed25519(Box::new(t)))),
            ),

            TypeVariant::RevokeSponsorshipOpSigner => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipOpSigner>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipOpSigner(Box::new(t)))),
            ),

            TypeVariant::ContractIdPreimageFromAddress => Box::new(
                ReadXdrIter::<_, ContractIdPreimageFromAddress>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimageFromAddress(Box::new(t)))),
            ),

            TypeVariant::OperationBody => Box::new(
                ReadXdrIter::<_, OperationBody>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationBody(Box::new(t)))),
            ),

            TypeVariant::HashIdPreimageOperationId => Box::new(
                ReadXdrIter::<_, HashIdPreimageOperationId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageOperationId(Box::new(t)))),
            ),

            TypeVariant::HashIdPreimageRevokeId => Box::new(
                ReadXdrIter::<_, HashIdPreimageRevokeId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageRevokeId(Box::new(t)))),
            ),

            TypeVariant::HashIdPreimageContractId => Box::new(
                ReadXdrIter::<_, HashIdPreimageContractId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageContractId(Box::new(t)))),
            ),

            TypeVariant::HashIdPreimageSorobanAuthorization => Box::new(
                ReadXdrIter::<_, HashIdPreimageSorobanAuthorization>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageSorobanAuthorization(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionDataExt => Box::new(
                ReadXdrIter::<_, SorobanTransactionDataExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionDataExt(Box::new(t)))),
            ),

            TypeVariant::TransactionV0Ext => Box::new(
                ReadXdrIter::<_, TransactionV0Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Ext(Box::new(t)))),
            ),

            TypeVariant::TransactionExt => Box::new(
                ReadXdrIter::<_, TransactionExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionExt(Box::new(t)))),
            ),

            TypeVariant::FeeBumpTransactionInnerTx => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionInnerTx>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionInnerTx(Box::new(t)))),
            ),

            TypeVariant::FeeBumpTransactionExt => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionExt(Box::new(t)))),
            ),

            TypeVariant::TransactionSignaturePayloadTaggedTransaction => Box::new(
                ReadXdrIter::<_, TransactionSignaturePayloadTaggedTransaction>::new(
                    dec,
                    r.limits.clone(),
                )
                .map(|r| {
                    r.map(|t| Self::TransactionSignaturePayloadTaggedTransaction(Box::new(t)))
                }),
            ),

            TypeVariant::PathPaymentStrictReceiveResultSuccess => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResultSuccess>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultSuccess(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictSendResultSuccess => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResultSuccess>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendResultSuccess(Box::new(t)))),
            ),

            TypeVariant::ManageOfferSuccessResultOffer => Box::new(
                ReadXdrIter::<_, ManageOfferSuccessResultOffer>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferSuccessResultOffer(Box::new(t)))),
            ),

            TypeVariant::OperationResultTr => Box::new(
                ReadXdrIter::<_, OperationResultTr>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultTr(Box::new(t)))),
            ),

            TypeVariant::InnerTransactionResultResult => Box::new(
                ReadXdrIter::<_, InnerTransactionResultResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultResult(Box::new(t)))),
            ),

            TypeVariant::InnerTransactionResultExt => Box::new(
                ReadXdrIter::<_, InnerTransactionResultExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultExt(Box::new(t)))),
            ),

            TypeVariant::TransactionResultResult => Box::new(
                ReadXdrIter::<_, TransactionResultResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultResult(Box::new(t)))),
            ),

            TypeVariant::TransactionResultExt => Box::new(
                ReadXdrIter::<_, TransactionResultExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultExt(Box::new(t)))),
            ),

            TypeVariant::SignerKeyEd25519SignedPayload => Box::new(
                ReadXdrIter::<_, SignerKeyEd25519SignedPayload>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKeyEd25519SignedPayload(Box::new(t)))),
            ),

            TypeVariant::Value => Box::new(
                ReadXdrIter::<_, Value>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Value(Box::new(t)))),
            ),

            TypeVariant::ScpBallot => Box::new(
                ReadXdrIter::<_, ScpBallot>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpBallot(Box::new(t)))),
            ),

            TypeVariant::ScpStatementType => Box::new(
                ReadXdrIter::<_, ScpStatementType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementType(Box::new(t)))),
            ),

            TypeVariant::ScpNomination => Box::new(
                ReadXdrIter::<_, ScpNomination>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpNomination(Box::new(t)))),
            ),

            TypeVariant::ScpStatement => Box::new(
                ReadXdrIter::<_, ScpStatement>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatement(Box::new(t)))),
            ),

            TypeVariant::ScpEnvelope => Box::new(
                ReadXdrIter::<_, ScpEnvelope>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpEnvelope(Box::new(t)))),
            ),

            TypeVariant::ScpQuorumSet => Box::new(
                ReadXdrIter::<_, ScpQuorumSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpQuorumSet(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractExecutionLanesV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractExecutionLanesV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractExecutionLanesV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractComputeV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractComputeV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractComputeV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractParallelComputeV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractParallelComputeV0>::new(
                    dec,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractParallelComputeV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractLedgerCostV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractLedgerCostV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractLedgerCostV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractLedgerCostExtV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractLedgerCostExtV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractLedgerCostExtV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractHistoricalDataV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractHistoricalDataV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractHistoricalDataV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractEventsV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractEventsV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractEventsV0(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingContractBandwidthV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractBandwidthV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractBandwidthV0(Box::new(t)))),
            ),

            TypeVariant::ContractCostType => Box::new(
                ReadXdrIter::<_, ContractCostType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostType(Box::new(t)))),
            ),

            TypeVariant::ContractCostParamEntry => Box::new(
                ReadXdrIter::<_, ContractCostParamEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostParamEntry(Box::new(t)))),
            ),

            TypeVariant::StateArchivalSettings => Box::new(
                ReadXdrIter::<_, StateArchivalSettings>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StateArchivalSettings(Box::new(t)))),
            ),

            TypeVariant::EvictionIterator => Box::new(
                ReadXdrIter::<_, EvictionIterator>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::EvictionIterator(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingScpTiming => Box::new(
                ReadXdrIter::<_, ConfigSettingScpTiming>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingScpTiming(Box::new(t)))),
            ),

            TypeVariant::ContractCostParams => Box::new(
                ReadXdrIter::<_, ContractCostParams>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostParams(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingId => Box::new(
                ReadXdrIter::<_, ConfigSettingId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingId(Box::new(t)))),
            ),

            TypeVariant::ConfigSettingEntry => Box::new(
                ReadXdrIter::<_, ConfigSettingEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingEntry(Box::new(t)))),
            ),

            TypeVariant::ScEnvMetaKind => Box::new(
                ReadXdrIter::<_, ScEnvMetaKind>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaKind(Box::new(t)))),
            ),

            TypeVariant::ScEnvMetaEntry => Box::new(
                ReadXdrIter::<_, ScEnvMetaEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaEntry(Box::new(t)))),
            ),

            TypeVariant::ScMetaV0 => Box::new(
                ReadXdrIter::<_, ScMetaV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaV0(Box::new(t)))),
            ),

            TypeVariant::ScMetaKind => Box::new(
                ReadXdrIter::<_, ScMetaKind>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaKind(Box::new(t)))),
            ),

            TypeVariant::ScMetaEntry => Box::new(
                ReadXdrIter::<_, ScMetaEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaEntry(Box::new(t)))),
            ),

            TypeVariant::ScSpecType => Box::new(
                ReadXdrIter::<_, ScSpecType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecType(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeOption => Box::new(
                ReadXdrIter::<_, ScSpecTypeOption>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeOption(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeResult => Box::new(
                ReadXdrIter::<_, ScSpecTypeResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeResult(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeVec => Box::new(
                ReadXdrIter::<_, ScSpecTypeVec>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeVec(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeMap => Box::new(
                ReadXdrIter::<_, ScSpecTypeMap>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeMap(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeTuple => Box::new(
                ReadXdrIter::<_, ScSpecTypeTuple>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeTuple(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeBytesN => Box::new(
                ReadXdrIter::<_, ScSpecTypeBytesN>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeBytesN(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeUdt => Box::new(
                ReadXdrIter::<_, ScSpecTypeUdt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeUdt(Box::new(t)))),
            ),

            TypeVariant::ScSpecTypeDef => Box::new(
                ReadXdrIter::<_, ScSpecTypeDef>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeDef(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtStructFieldV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtStructFieldV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtStructFieldV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtStructV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtStructV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtStructV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseVoidV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseVoidV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseVoidV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseTupleV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseTupleV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseTupleV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseV0Kind => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseV0Kind>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0Kind(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtUnionCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtUnionV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtEnumCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtEnumCaseV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumCaseV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtEnumV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtEnumV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtErrorEnumCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtErrorEnumCaseV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumCaseV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecUdtErrorEnumV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtErrorEnumV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecFunctionInputV0 => Box::new(
                ReadXdrIter::<_, ScSpecFunctionInputV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionInputV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecFunctionV0 => Box::new(
                ReadXdrIter::<_, ScSpecFunctionV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecEventParamLocationV0 => Box::new(
                ReadXdrIter::<_, ScSpecEventParamLocationV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEventParamLocationV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecEventParamV0 => Box::new(
                ReadXdrIter::<_, ScSpecEventParamV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEventParamV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecEventDataFormat => Box::new(
                ReadXdrIter::<_, ScSpecEventDataFormat>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEventDataFormat(Box::new(t)))),
            ),

            TypeVariant::ScSpecEventV0 => Box::new(
                ReadXdrIter::<_, ScSpecEventV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEventV0(Box::new(t)))),
            ),

            TypeVariant::ScSpecEntryKind => Box::new(
                ReadXdrIter::<_, ScSpecEntryKind>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntryKind(Box::new(t)))),
            ),

            TypeVariant::ScSpecEntry => Box::new(
                ReadXdrIter::<_, ScSpecEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntry(Box::new(t)))),
            ),

            TypeVariant::ScValType => Box::new(
                ReadXdrIter::<_, ScValType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScValType(Box::new(t)))),
            ),

            TypeVariant::ScErrorType => Box::new(
                ReadXdrIter::<_, ScErrorType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorType(Box::new(t)))),
            ),

            TypeVariant::ScErrorCode => Box::new(
                ReadXdrIter::<_, ScErrorCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorCode(Box::new(t)))),
            ),

            TypeVariant::ScError => Box::new(
                ReadXdrIter::<_, ScError>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScError(Box::new(t)))),
            ),

            TypeVariant::UInt128Parts => Box::new(
                ReadXdrIter::<_, UInt128Parts>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt128Parts(Box::new(t)))),
            ),

            TypeVariant::Int128Parts => Box::new(
                ReadXdrIter::<_, Int128Parts>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int128Parts(Box::new(t)))),
            ),

            TypeVariant::UInt256Parts => Box::new(
                ReadXdrIter::<_, UInt256Parts>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt256Parts(Box::new(t)))),
            ),

            TypeVariant::Int256Parts => Box::new(
                ReadXdrIter::<_, Int256Parts>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int256Parts(Box::new(t)))),
            ),

            TypeVariant::ContractExecutableType => Box::new(
                ReadXdrIter::<_, ContractExecutableType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractExecutableType(Box::new(t)))),
            ),

            TypeVariant::ContractExecutable => Box::new(
                ReadXdrIter::<_, ContractExecutable>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractExecutable(Box::new(t)))),
            ),

            TypeVariant::ScAddressType => Box::new(
                ReadXdrIter::<_, ScAddressType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddressType(Box::new(t)))),
            ),

            TypeVariant::MuxedEd25519Account => Box::new(
                ReadXdrIter::<_, MuxedEd25519Account>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedEd25519Account(Box::new(t)))),
            ),

            TypeVariant::ScAddress => Box::new(
                ReadXdrIter::<_, ScAddress>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddress(Box::new(t)))),
            ),

            TypeVariant::ScVec => Box::new(
                ReadXdrIter::<_, ScVec>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVec(Box::new(t)))),
            ),

            TypeVariant::ScMap => Box::new(
                ReadXdrIter::<_, ScMap>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMap(Box::new(t)))),
            ),

            TypeVariant::ScBytes => Box::new(
                ReadXdrIter::<_, ScBytes>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScBytes(Box::new(t)))),
            ),

            TypeVariant::ScString => Box::new(
                ReadXdrIter::<_, ScString>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScString(Box::new(t)))),
            ),

            TypeVariant::ScSymbol => Box::new(
                ReadXdrIter::<_, ScSymbol>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSymbol(Box::new(t)))),
            ),

            TypeVariant::ScNonceKey => Box::new(
                ReadXdrIter::<_, ScNonceKey>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScNonceKey(Box::new(t)))),
            ),

            TypeVariant::ScContractInstance => Box::new(
                ReadXdrIter::<_, ScContractInstance>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScContractInstance(Box::new(t)))),
            ),

            TypeVariant::ScVal => Box::new(
                ReadXdrIter::<_, ScVal>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVal(Box::new(t)))),
            ),

            TypeVariant::ScMapEntry => Box::new(
                ReadXdrIter::<_, ScMapEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMapEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaBatch => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaBatch>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaBatch(Box::new(t)))),
            ),

            TypeVariant::StoredTransactionSet => Box::new(
                ReadXdrIter::<_, StoredTransactionSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StoredTransactionSet(Box::new(t)))),
            ),

            TypeVariant::StoredDebugTransactionSet => Box::new(
                ReadXdrIter::<_, StoredDebugTransactionSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StoredDebugTransactionSet(Box::new(t)))),
            ),

            TypeVariant::PersistedScpStateV0 => Box::new(
                ReadXdrIter::<_, PersistedScpStateV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV0(Box::new(t)))),
            ),

            TypeVariant::PersistedScpStateV1 => Box::new(
                ReadXdrIter::<_, PersistedScpStateV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV1(Box::new(t)))),
            ),

            TypeVariant::PersistedScpState => Box::new(
                ReadXdrIter::<_, PersistedScpState>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpState(Box::new(t)))),
            ),

            TypeVariant::Thresholds => Box::new(
                ReadXdrIter::<_, Thresholds>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Thresholds(Box::new(t)))),
            ),

            TypeVariant::String32 => Box::new(
                ReadXdrIter::<_, String32>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::String32(Box::new(t)))),
            ),

            TypeVariant::String64 => Box::new(
                ReadXdrIter::<_, String64>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::String64(Box::new(t)))),
            ),

            TypeVariant::SequenceNumber => Box::new(
                ReadXdrIter::<_, SequenceNumber>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SequenceNumber(Box::new(t)))),
            ),

            TypeVariant::DataValue => Box::new(
                ReadXdrIter::<_, DataValue>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataValue(Box::new(t)))),
            ),

            TypeVariant::AssetCode4 => Box::new(
                ReadXdrIter::<_, AssetCode4>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode4(Box::new(t)))),
            ),

            TypeVariant::AssetCode12 => Box::new(
                ReadXdrIter::<_, AssetCode12>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode12(Box::new(t)))),
            ),

            TypeVariant::AssetType => Box::new(
                ReadXdrIter::<_, AssetType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetType(Box::new(t)))),
            ),

            TypeVariant::AssetCode => Box::new(
                ReadXdrIter::<_, AssetCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode(Box::new(t)))),
            ),

            TypeVariant::AlphaNum4 => Box::new(
                ReadXdrIter::<_, AlphaNum4>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum4(Box::new(t)))),
            ),

            TypeVariant::AlphaNum12 => Box::new(
                ReadXdrIter::<_, AlphaNum12>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum12(Box::new(t)))),
            ),

            TypeVariant::Asset => Box::new(
                ReadXdrIter::<_, Asset>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Asset(Box::new(t)))),
            ),

            TypeVariant::Price => Box::new(
                ReadXdrIter::<_, Price>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Price(Box::new(t)))),
            ),

            TypeVariant::Liabilities => Box::new(
                ReadXdrIter::<_, Liabilities>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Liabilities(Box::new(t)))),
            ),

            TypeVariant::ThresholdIndexes => Box::new(
                ReadXdrIter::<_, ThresholdIndexes>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ThresholdIndexes(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryType => Box::new(
                ReadXdrIter::<_, LedgerEntryType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryType(Box::new(t)))),
            ),

            TypeVariant::Signer => Box::new(
                ReadXdrIter::<_, Signer>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signer(Box::new(t)))),
            ),

            TypeVariant::AccountFlags => Box::new(
                ReadXdrIter::<_, AccountFlags>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountFlags(Box::new(t)))),
            ),

            TypeVariant::SponsorshipDescriptor => Box::new(
                ReadXdrIter::<_, SponsorshipDescriptor>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SponsorshipDescriptor(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExtensionV3 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV3>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV3(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV2(Box::new(t)))),
            ),

            TypeVariant::AccountEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV1(Box::new(t)))),
            ),

            TypeVariant::AccountEntry => Box::new(
                ReadXdrIter::<_, AccountEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntry(Box::new(t)))),
            ),

            TypeVariant::TrustLineFlags => Box::new(
                ReadXdrIter::<_, TrustLineFlags>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineFlags(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolType => Box::new(
                ReadXdrIter::<_, LiquidityPoolType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolType(Box::new(t)))),
            ),

            TypeVariant::TrustLineAsset => Box::new(
                ReadXdrIter::<_, TrustLineAsset>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineAsset(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, TrustLineEntryExtensionV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2(Box::new(t)))),
            ),

            TypeVariant::TrustLineEntry => Box::new(
                ReadXdrIter::<_, TrustLineEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntry(Box::new(t)))),
            ),

            TypeVariant::OfferEntryFlags => Box::new(
                ReadXdrIter::<_, OfferEntryFlags>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryFlags(Box::new(t)))),
            ),

            TypeVariant::OfferEntry => Box::new(
                ReadXdrIter::<_, OfferEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntry(Box::new(t)))),
            ),

            TypeVariant::DataEntry => Box::new(
                ReadXdrIter::<_, DataEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntry(Box::new(t)))),
            ),

            TypeVariant::ClaimPredicateType => Box::new(
                ReadXdrIter::<_, ClaimPredicateType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicateType(Box::new(t)))),
            ),

            TypeVariant::ClaimPredicate => Box::new(
                ReadXdrIter::<_, ClaimPredicate>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicate(Box::new(t)))),
            ),

            TypeVariant::ClaimantType => Box::new(
                ReadXdrIter::<_, ClaimantType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantType(Box::new(t)))),
            ),

            TypeVariant::Claimant => Box::new(
                ReadXdrIter::<_, Claimant>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Claimant(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceFlags => Box::new(
                ReadXdrIter::<_, ClaimableBalanceFlags>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceFlags(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExtensionV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceEntry => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntry(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolConstantProductParameters => Box::new(
                ReadXdrIter::<_, LiquidityPoolConstantProductParameters>::new(
                    dec,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolConstantProductParameters(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolEntry => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntry(Box::new(t)))),
            ),

            TypeVariant::ContractDataDurability => Box::new(
                ReadXdrIter::<_, ContractDataDurability>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractDataDurability(Box::new(t)))),
            ),

            TypeVariant::ContractDataEntry => Box::new(
                ReadXdrIter::<_, ContractDataEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractDataEntry(Box::new(t)))),
            ),

            TypeVariant::ContractCodeCostInputs => Box::new(
                ReadXdrIter::<_, ContractCodeCostInputs>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeCostInputs(Box::new(t)))),
            ),

            TypeVariant::ContractCodeEntry => Box::new(
                ReadXdrIter::<_, ContractCodeEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntry(Box::new(t)))),
            ),

            TypeVariant::TtlEntry => Box::new(
                ReadXdrIter::<_, TtlEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TtlEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, LedgerEntryExtensionV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExtensionV1(Box::new(t)))),
            ),

            TypeVariant::LedgerEntry => Box::new(
                ReadXdrIter::<_, LedgerEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerKey => Box::new(
                ReadXdrIter::<_, LedgerKey>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKey(Box::new(t)))),
            ),

            TypeVariant::EnvelopeType => Box::new(
                ReadXdrIter::<_, EnvelopeType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::EnvelopeType(Box::new(t)))),
            ),

            TypeVariant::BucketListType => Box::new(
                ReadXdrIter::<_, BucketListType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketListType(Box::new(t)))),
            ),

            TypeVariant::BucketEntryType => Box::new(
                ReadXdrIter::<_, BucketEntryType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntryType(Box::new(t)))),
            ),

            TypeVariant::HotArchiveBucketEntryType => Box::new(
                ReadXdrIter::<_, HotArchiveBucketEntryType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HotArchiveBucketEntryType(Box::new(t)))),
            ),

            TypeVariant::BucketMetadata => Box::new(
                ReadXdrIter::<_, BucketMetadata>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadata(Box::new(t)))),
            ),

            TypeVariant::BucketEntry => Box::new(
                ReadXdrIter::<_, BucketEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntry(Box::new(t)))),
            ),

            TypeVariant::HotArchiveBucketEntry => Box::new(
                ReadXdrIter::<_, HotArchiveBucketEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HotArchiveBucketEntry(Box::new(t)))),
            ),

            TypeVariant::UpgradeType => Box::new(
                ReadXdrIter::<_, UpgradeType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeType(Box::new(t)))),
            ),

            TypeVariant::StellarValueType => Box::new(
                ReadXdrIter::<_, StellarValueType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueType(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseValueSignature => Box::new(
                ReadXdrIter::<_, LedgerCloseValueSignature>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseValueSignature(Box::new(t)))),
            ),

            TypeVariant::StellarValue => Box::new(
                ReadXdrIter::<_, StellarValue>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValue(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderFlags => Box::new(
                ReadXdrIter::<_, LedgerHeaderFlags>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderFlags(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderExtensionV1 => Box::new(
                ReadXdrIter::<_, LedgerHeaderExtensionV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1(Box::new(t)))),
            ),

            TypeVariant::LedgerHeader => Box::new(
                ReadXdrIter::<_, LedgerHeader>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeader(Box::new(t)))),
            ),

            TypeVariant::LedgerUpgradeType => Box::new(
                ReadXdrIter::<_, LedgerUpgradeType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgradeType(Box::new(t)))),
            ),

            TypeVariant::ConfigUpgradeSetKey => Box::new(
                ReadXdrIter::<_, ConfigUpgradeSetKey>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSetKey(Box::new(t)))),
            ),

            TypeVariant::LedgerUpgrade => Box::new(
                ReadXdrIter::<_, LedgerUpgrade>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgrade(Box::new(t)))),
            ),

            TypeVariant::ConfigUpgradeSet => Box::new(
                ReadXdrIter::<_, ConfigUpgradeSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSet(Box::new(t)))),
            ),

            TypeVariant::TxSetComponentType => Box::new(
                ReadXdrIter::<_, TxSetComponentType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponentType(Box::new(t)))),
            ),

            TypeVariant::DependentTxCluster => Box::new(
                ReadXdrIter::<_, DependentTxCluster>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DependentTxCluster(Box::new(t)))),
            ),

            TypeVariant::ParallelTxExecutionStage => Box::new(
                ReadXdrIter::<_, ParallelTxExecutionStage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ParallelTxExecutionStage(Box::new(t)))),
            ),

            TypeVariant::ParallelTxsComponent => Box::new(
                ReadXdrIter::<_, ParallelTxsComponent>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ParallelTxsComponent(Box::new(t)))),
            ),

            TypeVariant::TxSetComponent => Box::new(
                ReadXdrIter::<_, TxSetComponent>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponent(Box::new(t)))),
            ),

            TypeVariant::TransactionPhase => Box::new(
                ReadXdrIter::<_, TransactionPhase>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionPhase(Box::new(t)))),
            ),

            TypeVariant::TransactionSet => Box::new(
                ReadXdrIter::<_, TransactionSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSet(Box::new(t)))),
            ),

            TypeVariant::TransactionSetV1 => Box::new(
                ReadXdrIter::<_, TransactionSetV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSetV1(Box::new(t)))),
            ),

            TypeVariant::GeneralizedTransactionSet => Box::new(
                ReadXdrIter::<_, GeneralizedTransactionSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::GeneralizedTransactionSet(Box::new(t)))),
            ),

            TypeVariant::TransactionResultPair => Box::new(
                ReadXdrIter::<_, TransactionResultPair>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultPair(Box::new(t)))),
            ),

            TypeVariant::TransactionResultSet => Box::new(
                ReadXdrIter::<_, TransactionResultSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultSet(Box::new(t)))),
            ),

            TypeVariant::TransactionHistoryEntry => Box::new(
                ReadXdrIter::<_, TransactionHistoryEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryEntry(Box::new(t)))),
            ),

            TypeVariant::TransactionHistoryResultEntry => Box::new(
                ReadXdrIter::<_, TransactionHistoryResultEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryResultEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerHeaderHistoryEntry => Box::new(
                ReadXdrIter::<_, LedgerHeaderHistoryEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerScpMessages => Box::new(
                ReadXdrIter::<_, LedgerScpMessages>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerScpMessages(Box::new(t)))),
            ),

            TypeVariant::ScpHistoryEntryV0 => Box::new(
                ReadXdrIter::<_, ScpHistoryEntryV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntryV0(Box::new(t)))),
            ),

            TypeVariant::ScpHistoryEntry => Box::new(
                ReadXdrIter::<_, ScpHistoryEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntry(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryChangeType => Box::new(
                ReadXdrIter::<_, LedgerEntryChangeType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChangeType(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryChange => Box::new(
                ReadXdrIter::<_, LedgerEntryChange>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChange(Box::new(t)))),
            ),

            TypeVariant::LedgerEntryChanges => Box::new(
                ReadXdrIter::<_, LedgerEntryChanges>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChanges(Box::new(t)))),
            ),

            TypeVariant::OperationMeta => Box::new(
                ReadXdrIter::<_, OperationMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationMeta(Box::new(t)))),
            ),

            TypeVariant::TransactionMetaV1 => Box::new(
                ReadXdrIter::<_, TransactionMetaV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV1(Box::new(t)))),
            ),

            TypeVariant::TransactionMetaV2 => Box::new(
                ReadXdrIter::<_, TransactionMetaV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV2(Box::new(t)))),
            ),

            TypeVariant::ContractEventType => Box::new(
                ReadXdrIter::<_, ContractEventType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventType(Box::new(t)))),
            ),

            TypeVariant::ContractEvent => Box::new(
                ReadXdrIter::<_, ContractEvent>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEvent(Box::new(t)))),
            ),

            TypeVariant::DiagnosticEvent => Box::new(
                ReadXdrIter::<_, DiagnosticEvent>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DiagnosticEvent(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionMetaExtV1 => Box::new(
                ReadXdrIter::<_, SorobanTransactionMetaExtV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMetaExtV1(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionMetaExt => Box::new(
                ReadXdrIter::<_, SorobanTransactionMetaExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMetaExt(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionMeta => Box::new(
                ReadXdrIter::<_, SorobanTransactionMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMeta(Box::new(t)))),
            ),

            TypeVariant::TransactionMetaV3 => Box::new(
                ReadXdrIter::<_, TransactionMetaV3>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV3(Box::new(t)))),
            ),

            TypeVariant::OperationMetaV2 => Box::new(
                ReadXdrIter::<_, OperationMetaV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationMetaV2(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionMetaV2 => Box::new(
                ReadXdrIter::<_, SorobanTransactionMetaV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMetaV2(Box::new(t)))),
            ),

            TypeVariant::TransactionEventStage => Box::new(
                ReadXdrIter::<_, TransactionEventStage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEventStage(Box::new(t)))),
            ),

            TypeVariant::TransactionEvent => Box::new(
                ReadXdrIter::<_, TransactionEvent>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEvent(Box::new(t)))),
            ),

            TypeVariant::TransactionMetaV4 => Box::new(
                ReadXdrIter::<_, TransactionMetaV4>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV4(Box::new(t)))),
            ),

            TypeVariant::InvokeHostFunctionSuccessPreImage => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionSuccessPreImage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionSuccessPreImage(Box::new(t)))),
            ),

            TypeVariant::TransactionMeta => Box::new(
                ReadXdrIter::<_, TransactionMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMeta(Box::new(t)))),
            ),

            TypeVariant::TransactionResultMeta => Box::new(
                ReadXdrIter::<_, TransactionResultMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultMeta(Box::new(t)))),
            ),

            TypeVariant::TransactionResultMetaV1 => Box::new(
                ReadXdrIter::<_, TransactionResultMetaV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultMetaV1(Box::new(t)))),
            ),

            TypeVariant::UpgradeEntryMeta => Box::new(
                ReadXdrIter::<_, UpgradeEntryMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeEntryMeta(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaV0 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV0(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaExtV1 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaExtV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExtV1(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaExt => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExt(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaV1 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV1(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMetaV2 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV2(Box::new(t)))),
            ),

            TypeVariant::LedgerCloseMeta => Box::new(
                ReadXdrIter::<_, LedgerCloseMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMeta(Box::new(t)))),
            ),

            TypeVariant::ErrorCode => Box::new(
                ReadXdrIter::<_, ErrorCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ErrorCode(Box::new(t)))),
            ),

            TypeVariant::SError => Box::new(
                ReadXdrIter::<_, SError>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SError(Box::new(t)))),
            ),

            TypeVariant::SendMore => Box::new(
                ReadXdrIter::<_, SendMore>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMore(Box::new(t)))),
            ),

            TypeVariant::SendMoreExtended => Box::new(
                ReadXdrIter::<_, SendMoreExtended>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMoreExtended(Box::new(t)))),
            ),

            TypeVariant::AuthCert => Box::new(
                ReadXdrIter::<_, AuthCert>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthCert(Box::new(t)))),
            ),

            TypeVariant::Hello => Box::new(
                ReadXdrIter::<_, Hello>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hello(Box::new(t)))),
            ),

            TypeVariant::Auth => Box::new(
                ReadXdrIter::<_, Auth>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Auth(Box::new(t)))),
            ),

            TypeVariant::IpAddrType => Box::new(
                ReadXdrIter::<_, IpAddrType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::IpAddrType(Box::new(t)))),
            ),

            TypeVariant::PeerAddress => Box::new(
                ReadXdrIter::<_, PeerAddress>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddress(Box::new(t)))),
            ),

            TypeVariant::MessageType => Box::new(
                ReadXdrIter::<_, MessageType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::MessageType(Box::new(t)))),
            ),

            TypeVariant::DontHave => Box::new(
                ReadXdrIter::<_, DontHave>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DontHave(Box::new(t)))),
            ),

            TypeVariant::SurveyMessageCommandType => Box::new(
                ReadXdrIter::<_, SurveyMessageCommandType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyMessageCommandType(Box::new(t)))),
            ),

            TypeVariant::SurveyMessageResponseType => Box::new(
                ReadXdrIter::<_, SurveyMessageResponseType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyMessageResponseType(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedSurveyStartCollectingMessage => Box::new(
                ReadXdrIter::<_, TimeSlicedSurveyStartCollectingMessage>::new(
                    dec,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TimeSlicedSurveyStartCollectingMessage(Box::new(t)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyStartCollectingMessage => Box::new(
                ReadXdrIter::<_, SignedTimeSlicedSurveyStartCollectingMessage>::new(
                    dec,
                    r.limits.clone(),
                )
                .map(|r| {
                    r.map(|t| Self::SignedTimeSlicedSurveyStartCollectingMessage(Box::new(t)))
                }),
            ),

            TypeVariant::TimeSlicedSurveyStopCollectingMessage => Box::new(
                ReadXdrIter::<_, TimeSlicedSurveyStopCollectingMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeSlicedSurveyStopCollectingMessage(Box::new(t)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyStopCollectingMessage => Box::new(
                ReadXdrIter::<_, SignedTimeSlicedSurveyStopCollectingMessage>::new(
                    dec,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignedTimeSlicedSurveyStopCollectingMessage(Box::new(t)))),
            ),

            TypeVariant::SurveyRequestMessage => Box::new(
                ReadXdrIter::<_, SurveyRequestMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyRequestMessage(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedSurveyRequestMessage => Box::new(
                ReadXdrIter::<_, TimeSlicedSurveyRequestMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeSlicedSurveyRequestMessage(Box::new(t)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyRequestMessage => Box::new(
                ReadXdrIter::<_, SignedTimeSlicedSurveyRequestMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignedTimeSlicedSurveyRequestMessage(Box::new(t)))),
            ),

            TypeVariant::EncryptedBody => Box::new(
                ReadXdrIter::<_, EncryptedBody>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::EncryptedBody(Box::new(t)))),
            ),

            TypeVariant::SurveyResponseMessage => Box::new(
                ReadXdrIter::<_, SurveyResponseMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseMessage(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedSurveyResponseMessage => Box::new(
                ReadXdrIter::<_, TimeSlicedSurveyResponseMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeSlicedSurveyResponseMessage(Box::new(t)))),
            ),

            TypeVariant::SignedTimeSlicedSurveyResponseMessage => Box::new(
                ReadXdrIter::<_, SignedTimeSlicedSurveyResponseMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignedTimeSlicedSurveyResponseMessage(Box::new(t)))),
            ),

            TypeVariant::PeerStats => Box::new(
                ReadXdrIter::<_, PeerStats>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerStats(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedNodeData => Box::new(
                ReadXdrIter::<_, TimeSlicedNodeData>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeSlicedNodeData(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedPeerData => Box::new(
                ReadXdrIter::<_, TimeSlicedPeerData>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeSlicedPeerData(Box::new(t)))),
            ),

            TypeVariant::TimeSlicedPeerDataList => Box::new(
                ReadXdrIter::<_, TimeSlicedPeerDataList>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeSlicedPeerDataList(Box::new(t)))),
            ),

            TypeVariant::TopologyResponseBodyV2 => Box::new(
                ReadXdrIter::<_, TopologyResponseBodyV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TopologyResponseBodyV2(Box::new(t)))),
            ),

            TypeVariant::SurveyResponseBody => Box::new(
                ReadXdrIter::<_, SurveyResponseBody>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseBody(Box::new(t)))),
            ),

            TypeVariant::TxAdvertVector => Box::new(
                ReadXdrIter::<_, TxAdvertVector>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxAdvertVector(Box::new(t)))),
            ),

            TypeVariant::FloodAdvert => Box::new(
                ReadXdrIter::<_, FloodAdvert>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodAdvert(Box::new(t)))),
            ),

            TypeVariant::TxDemandVector => Box::new(
                ReadXdrIter::<_, TxDemandVector>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxDemandVector(Box::new(t)))),
            ),

            TypeVariant::FloodDemand => Box::new(
                ReadXdrIter::<_, FloodDemand>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodDemand(Box::new(t)))),
            ),

            TypeVariant::StellarMessage => Box::new(
                ReadXdrIter::<_, StellarMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarMessage(Box::new(t)))),
            ),

            TypeVariant::AuthenticatedMessage => Box::new(
                ReadXdrIter::<_, AuthenticatedMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthenticatedMessage(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolParameters => Box::new(
                ReadXdrIter::<_, LiquidityPoolParameters>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolParameters(Box::new(t)))),
            ),

            TypeVariant::MuxedAccount => Box::new(
                ReadXdrIter::<_, MuxedAccount>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccount(Box::new(t)))),
            ),

            TypeVariant::DecoratedSignature => Box::new(
                ReadXdrIter::<_, DecoratedSignature>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DecoratedSignature(Box::new(t)))),
            ),

            TypeVariant::OperationType => Box::new(
                ReadXdrIter::<_, OperationType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationType(Box::new(t)))),
            ),

            TypeVariant::CreateAccountOp => Box::new(
                ReadXdrIter::<_, CreateAccountOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountOp(Box::new(t)))),
            ),

            TypeVariant::PaymentOp => Box::new(
                ReadXdrIter::<_, PaymentOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentOp(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictReceiveOp => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictReceiveOp(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictSendOp => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendOp(Box::new(t)))),
            ),

            TypeVariant::ManageSellOfferOp => Box::new(
                ReadXdrIter::<_, ManageSellOfferOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferOp(Box::new(t)))),
            ),

            TypeVariant::ManageBuyOfferOp => Box::new(
                ReadXdrIter::<_, ManageBuyOfferOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferOp(Box::new(t)))),
            ),

            TypeVariant::CreatePassiveSellOfferOp => Box::new(
                ReadXdrIter::<_, CreatePassiveSellOfferOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreatePassiveSellOfferOp(Box::new(t)))),
            ),

            TypeVariant::SetOptionsOp => Box::new(
                ReadXdrIter::<_, SetOptionsOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsOp(Box::new(t)))),
            ),

            TypeVariant::ChangeTrustAsset => Box::new(
                ReadXdrIter::<_, ChangeTrustAsset>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustAsset(Box::new(t)))),
            ),

            TypeVariant::ChangeTrustOp => Box::new(
                ReadXdrIter::<_, ChangeTrustOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustOp(Box::new(t)))),
            ),

            TypeVariant::AllowTrustOp => Box::new(
                ReadXdrIter::<_, AllowTrustOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustOp(Box::new(t)))),
            ),

            TypeVariant::ManageDataOp => Box::new(
                ReadXdrIter::<_, ManageDataOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataOp(Box::new(t)))),
            ),

            TypeVariant::BumpSequenceOp => Box::new(
                ReadXdrIter::<_, BumpSequenceOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceOp(Box::new(t)))),
            ),

            TypeVariant::CreateClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateClaimableBalanceOp(Box::new(t)))),
            ),

            TypeVariant::ClaimClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimClaimableBalanceOp(Box::new(t)))),
            ),

            TypeVariant::BeginSponsoringFutureReservesOp => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesOp(Box::new(t)))),
            ),

            TypeVariant::RevokeSponsorshipType => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipType(Box::new(t)))),
            ),

            TypeVariant::RevokeSponsorshipOp => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipOp(Box::new(t)))),
            ),

            TypeVariant::ClawbackOp => Box::new(
                ReadXdrIter::<_, ClawbackOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackOp(Box::new(t)))),
            ),

            TypeVariant::ClawbackClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackClaimableBalanceOp(Box::new(t)))),
            ),

            TypeVariant::SetTrustLineFlagsOp => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsOp(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolDepositOp => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolDepositOp(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolWithdrawOp => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolWithdrawOp(Box::new(t)))),
            ),

            TypeVariant::HostFunctionType => Box::new(
                ReadXdrIter::<_, HostFunctionType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunctionType(Box::new(t)))),
            ),

            TypeVariant::ContractIdPreimageType => Box::new(
                ReadXdrIter::<_, ContractIdPreimageType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimageType(Box::new(t)))),
            ),

            TypeVariant::ContractIdPreimage => Box::new(
                ReadXdrIter::<_, ContractIdPreimage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimage(Box::new(t)))),
            ),

            TypeVariant::CreateContractArgs => Box::new(
                ReadXdrIter::<_, CreateContractArgs>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateContractArgs(Box::new(t)))),
            ),

            TypeVariant::CreateContractArgsV2 => Box::new(
                ReadXdrIter::<_, CreateContractArgsV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateContractArgsV2(Box::new(t)))),
            ),

            TypeVariant::InvokeContractArgs => Box::new(
                ReadXdrIter::<_, InvokeContractArgs>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeContractArgs(Box::new(t)))),
            ),

            TypeVariant::HostFunction => Box::new(
                ReadXdrIter::<_, HostFunction>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunction(Box::new(t)))),
            ),

            TypeVariant::SorobanAuthorizedFunctionType => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedFunctionType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizedFunctionType(Box::new(t)))),
            ),

            TypeVariant::SorobanAuthorizedFunction => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedFunction>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizedFunction(Box::new(t)))),
            ),

            TypeVariant::SorobanAuthorizedInvocation => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedInvocation>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizedInvocation(Box::new(t)))),
            ),

            TypeVariant::SorobanAddressCredentials => Box::new(
                ReadXdrIter::<_, SorobanAddressCredentials>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAddressCredentials(Box::new(t)))),
            ),

            TypeVariant::SorobanCredentialsType => Box::new(
                ReadXdrIter::<_, SorobanCredentialsType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanCredentialsType(Box::new(t)))),
            ),

            TypeVariant::SorobanCredentials => Box::new(
                ReadXdrIter::<_, SorobanCredentials>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanCredentials(Box::new(t)))),
            ),

            TypeVariant::SorobanAuthorizationEntry => Box::new(
                ReadXdrIter::<_, SorobanAuthorizationEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizationEntry(Box::new(t)))),
            ),

            TypeVariant::SorobanAuthorizationEntries => Box::new(
                ReadXdrIter::<_, SorobanAuthorizationEntries>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizationEntries(Box::new(t)))),
            ),

            TypeVariant::InvokeHostFunctionOp => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionOp(Box::new(t)))),
            ),

            TypeVariant::ExtendFootprintTtlOp => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlOp(Box::new(t)))),
            ),

            TypeVariant::RestoreFootprintOp => Box::new(
                ReadXdrIter::<_, RestoreFootprintOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintOp(Box::new(t)))),
            ),

            TypeVariant::Operation => Box::new(
                ReadXdrIter::<_, Operation>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Operation(Box::new(t)))),
            ),

            TypeVariant::HashIdPreimage => Box::new(
                ReadXdrIter::<_, HashIdPreimage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimage(Box::new(t)))),
            ),

            TypeVariant::MemoType => Box::new(
                ReadXdrIter::<_, MemoType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::MemoType(Box::new(t)))),
            ),

            TypeVariant::Memo => Box::new(
                ReadXdrIter::<_, Memo>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Memo(Box::new(t)))),
            ),

            TypeVariant::TimeBounds => Box::new(
                ReadXdrIter::<_, TimeBounds>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeBounds(Box::new(t)))),
            ),

            TypeVariant::LedgerBounds => Box::new(
                ReadXdrIter::<_, LedgerBounds>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerBounds(Box::new(t)))),
            ),

            TypeVariant::PreconditionsV2 => Box::new(
                ReadXdrIter::<_, PreconditionsV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionsV2(Box::new(t)))),
            ),

            TypeVariant::PreconditionType => Box::new(
                ReadXdrIter::<_, PreconditionType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionType(Box::new(t)))),
            ),

            TypeVariant::Preconditions => Box::new(
                ReadXdrIter::<_, Preconditions>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Preconditions(Box::new(t)))),
            ),

            TypeVariant::LedgerFootprint => Box::new(
                ReadXdrIter::<_, LedgerFootprint>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerFootprint(Box::new(t)))),
            ),

            TypeVariant::SorobanResources => Box::new(
                ReadXdrIter::<_, SorobanResources>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanResources(Box::new(t)))),
            ),

            TypeVariant::SorobanResourcesExtV0 => Box::new(
                ReadXdrIter::<_, SorobanResourcesExtV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanResourcesExtV0(Box::new(t)))),
            ),

            TypeVariant::SorobanTransactionData => Box::new(
                ReadXdrIter::<_, SorobanTransactionData>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionData(Box::new(t)))),
            ),

            TypeVariant::TransactionV0 => Box::new(
                ReadXdrIter::<_, TransactionV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0(Box::new(t)))),
            ),

            TypeVariant::TransactionV0Envelope => Box::new(
                ReadXdrIter::<_, TransactionV0Envelope>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Envelope(Box::new(t)))),
            ),

            TypeVariant::Transaction => Box::new(
                ReadXdrIter::<_, Transaction>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Transaction(Box::new(t)))),
            ),

            TypeVariant::TransactionV1Envelope => Box::new(
                ReadXdrIter::<_, TransactionV1Envelope>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV1Envelope(Box::new(t)))),
            ),

            TypeVariant::FeeBumpTransaction => Box::new(
                ReadXdrIter::<_, FeeBumpTransaction>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransaction(Box::new(t)))),
            ),

            TypeVariant::FeeBumpTransactionEnvelope => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionEnvelope>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionEnvelope(Box::new(t)))),
            ),

            TypeVariant::TransactionEnvelope => Box::new(
                ReadXdrIter::<_, TransactionEnvelope>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEnvelope(Box::new(t)))),
            ),

            TypeVariant::TransactionSignaturePayload => Box::new(
                ReadXdrIter::<_, TransactionSignaturePayload>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSignaturePayload(Box::new(t)))),
            ),

            TypeVariant::ClaimAtomType => Box::new(
                ReadXdrIter::<_, ClaimAtomType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtomType(Box::new(t)))),
            ),

            TypeVariant::ClaimOfferAtomV0 => Box::new(
                ReadXdrIter::<_, ClaimOfferAtomV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtomV0(Box::new(t)))),
            ),

            TypeVariant::ClaimOfferAtom => Box::new(
                ReadXdrIter::<_, ClaimOfferAtom>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtom(Box::new(t)))),
            ),

            TypeVariant::ClaimLiquidityAtom => Box::new(
                ReadXdrIter::<_, ClaimLiquidityAtom>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimLiquidityAtom(Box::new(t)))),
            ),

            TypeVariant::ClaimAtom => Box::new(
                ReadXdrIter::<_, ClaimAtom>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtom(Box::new(t)))),
            ),

            TypeVariant::CreateAccountResultCode => Box::new(
                ReadXdrIter::<_, CreateAccountResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountResultCode(Box::new(t)))),
            ),

            TypeVariant::CreateAccountResult => Box::new(
                ReadXdrIter::<_, CreateAccountResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountResult(Box::new(t)))),
            ),

            TypeVariant::PaymentResultCode => Box::new(
                ReadXdrIter::<_, PaymentResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResultCode(Box::new(t)))),
            ),

            TypeVariant::PaymentResult => Box::new(
                ReadXdrIter::<_, PaymentResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResult(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictReceiveResultCode => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultCode(Box::new(t)))),
            ),

            TypeVariant::SimplePaymentResult => Box::new(
                ReadXdrIter::<_, SimplePaymentResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SimplePaymentResult(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictReceiveResult => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResult(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictSendResultCode => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendResultCode(Box::new(t)))),
            ),

            TypeVariant::PathPaymentStrictSendResult => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendResult(Box::new(t)))),
            ),

            TypeVariant::ManageSellOfferResultCode => Box::new(
                ReadXdrIter::<_, ManageSellOfferResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferResultCode(Box::new(t)))),
            ),

            TypeVariant::ManageOfferEffect => Box::new(
                ReadXdrIter::<_, ManageOfferEffect>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferEffect(Box::new(t)))),
            ),

            TypeVariant::ManageOfferSuccessResult => Box::new(
                ReadXdrIter::<_, ManageOfferSuccessResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferSuccessResult(Box::new(t)))),
            ),

            TypeVariant::ManageSellOfferResult => Box::new(
                ReadXdrIter::<_, ManageSellOfferResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferResult(Box::new(t)))),
            ),

            TypeVariant::ManageBuyOfferResultCode => Box::new(
                ReadXdrIter::<_, ManageBuyOfferResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferResultCode(Box::new(t)))),
            ),

            TypeVariant::ManageBuyOfferResult => Box::new(
                ReadXdrIter::<_, ManageBuyOfferResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferResult(Box::new(t)))),
            ),

            TypeVariant::SetOptionsResultCode => Box::new(
                ReadXdrIter::<_, SetOptionsResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResultCode(Box::new(t)))),
            ),

            TypeVariant::SetOptionsResult => Box::new(
                ReadXdrIter::<_, SetOptionsResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResult(Box::new(t)))),
            ),

            TypeVariant::ChangeTrustResultCode => Box::new(
                ReadXdrIter::<_, ChangeTrustResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResultCode(Box::new(t)))),
            ),

            TypeVariant::ChangeTrustResult => Box::new(
                ReadXdrIter::<_, ChangeTrustResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResult(Box::new(t)))),
            ),

            TypeVariant::AllowTrustResultCode => Box::new(
                ReadXdrIter::<_, AllowTrustResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResultCode(Box::new(t)))),
            ),

            TypeVariant::AllowTrustResult => Box::new(
                ReadXdrIter::<_, AllowTrustResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResult(Box::new(t)))),
            ),

            TypeVariant::AccountMergeResultCode => Box::new(
                ReadXdrIter::<_, AccountMergeResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountMergeResultCode(Box::new(t)))),
            ),

            TypeVariant::AccountMergeResult => Box::new(
                ReadXdrIter::<_, AccountMergeResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountMergeResult(Box::new(t)))),
            ),

            TypeVariant::InflationResultCode => Box::new(
                ReadXdrIter::<_, InflationResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResultCode(Box::new(t)))),
            ),

            TypeVariant::InflationPayout => Box::new(
                ReadXdrIter::<_, InflationPayout>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationPayout(Box::new(t)))),
            ),

            TypeVariant::InflationResult => Box::new(
                ReadXdrIter::<_, InflationResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResult(Box::new(t)))),
            ),

            TypeVariant::ManageDataResultCode => Box::new(
                ReadXdrIter::<_, ManageDataResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResultCode(Box::new(t)))),
            ),

            TypeVariant::ManageDataResult => Box::new(
                ReadXdrIter::<_, ManageDataResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResult(Box::new(t)))),
            ),

            TypeVariant::BumpSequenceResultCode => Box::new(
                ReadXdrIter::<_, BumpSequenceResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceResultCode(Box::new(t)))),
            ),

            TypeVariant::BumpSequenceResult => Box::new(
                ReadXdrIter::<_, BumpSequenceResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceResult(Box::new(t)))),
            ),

            TypeVariant::CreateClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateClaimableBalanceResultCode(Box::new(t)))),
            ),

            TypeVariant::CreateClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateClaimableBalanceResult(Box::new(t)))),
            ),

            TypeVariant::ClaimClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimClaimableBalanceResultCode(Box::new(t)))),
            ),

            TypeVariant::ClaimClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimClaimableBalanceResult(Box::new(t)))),
            ),

            TypeVariant::BeginSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesResultCode>::new(
                    dec,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResultCode(Box::new(t)))),
            ),

            TypeVariant::BeginSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResult(Box::new(t)))),
            ),

            TypeVariant::EndSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, EndSponsoringFutureReservesResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResultCode(Box::new(t)))),
            ),

            TypeVariant::EndSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, EndSponsoringFutureReservesResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResult(Box::new(t)))),
            ),

            TypeVariant::RevokeSponsorshipResultCode => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipResultCode(Box::new(t)))),
            ),

            TypeVariant::RevokeSponsorshipResult => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipResult(Box::new(t)))),
            ),

            TypeVariant::ClawbackResultCode => Box::new(
                ReadXdrIter::<_, ClawbackResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResultCode(Box::new(t)))),
            ),

            TypeVariant::ClawbackResult => Box::new(
                ReadXdrIter::<_, ClawbackResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResult(Box::new(t)))),
            ),

            TypeVariant::ClawbackClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResultCode(Box::new(t)))),
            ),

            TypeVariant::ClawbackClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResult(Box::new(t)))),
            ),

            TypeVariant::SetTrustLineFlagsResultCode => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsResultCode(Box::new(t)))),
            ),

            TypeVariant::SetTrustLineFlagsResult => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsResult(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolDepositResultCode => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolDepositResultCode(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolDepositResult => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolDepositResult(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolWithdrawResultCode => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResultCode(Box::new(t)))),
            ),

            TypeVariant::LiquidityPoolWithdrawResult => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResult(Box::new(t)))),
            ),

            TypeVariant::InvokeHostFunctionResultCode => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionResultCode(Box::new(t)))),
            ),

            TypeVariant::InvokeHostFunctionResult => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionResult(Box::new(t)))),
            ),

            TypeVariant::ExtendFootprintTtlResultCode => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlResultCode(Box::new(t)))),
            ),

            TypeVariant::ExtendFootprintTtlResult => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlResult(Box::new(t)))),
            ),

            TypeVariant::RestoreFootprintResultCode => Box::new(
                ReadXdrIter::<_, RestoreFootprintResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintResultCode(Box::new(t)))),
            ),

            TypeVariant::RestoreFootprintResult => Box::new(
                ReadXdrIter::<_, RestoreFootprintResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintResult(Box::new(t)))),
            ),

            TypeVariant::OperationResultCode => Box::new(
                ReadXdrIter::<_, OperationResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultCode(Box::new(t)))),
            ),

            TypeVariant::OperationResult => Box::new(
                ReadXdrIter::<_, OperationResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResult(Box::new(t)))),
            ),

            TypeVariant::TransactionResultCode => Box::new(
                ReadXdrIter::<_, TransactionResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultCode(Box::new(t)))),
            ),

            TypeVariant::InnerTransactionResult => Box::new(
                ReadXdrIter::<_, InnerTransactionResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResult(Box::new(t)))),
            ),

            TypeVariant::InnerTransactionResultPair => Box::new(
                ReadXdrIter::<_, InnerTransactionResultPair>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultPair(Box::new(t)))),
            ),

            TypeVariant::TransactionResult => Box::new(
                ReadXdrIter::<_, TransactionResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResult(Box::new(t)))),
            ),

            TypeVariant::Hash => Box::new(
                ReadXdrIter::<_, Hash>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hash(Box::new(t)))),
            ),

            TypeVariant::Uint256 => Box::new(
                ReadXdrIter::<_, Uint256>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint256(Box::new(t)))),
            ),

            TypeVariant::Uint32 => Box::new(
                ReadXdrIter::<_, Uint32>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint32(Box::new(t)))),
            ),

            TypeVariant::Int32 => Box::new(
                ReadXdrIter::<_, Int32>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int32(Box::new(t)))),
            ),

            TypeVariant::Uint64 => Box::new(
                ReadXdrIter::<_, Uint64>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint64(Box::new(t)))),
            ),

            TypeVariant::Int64 => Box::new(
                ReadXdrIter::<_, Int64>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int64(Box::new(t)))),
            ),

            TypeVariant::TimePoint => Box::new(
                ReadXdrIter::<_, TimePoint>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimePoint(Box::new(t)))),
            ),

            TypeVariant::Duration => Box::new(
                ReadXdrIter::<_, Duration>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Duration(Box::new(t)))),
            ),

            TypeVariant::ExtensionPoint => Box::new(
                ReadXdrIter::<_, ExtensionPoint>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtensionPoint(Box::new(t)))),
            ),

            TypeVariant::CryptoKeyType => Box::new(
                ReadXdrIter::<_, CryptoKeyType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CryptoKeyType(Box::new(t)))),
            ),

            TypeVariant::PublicKeyType => Box::new(
                ReadXdrIter::<_, PublicKeyType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKeyType(Box::new(t)))),
            ),

            TypeVariant::SignerKeyType => Box::new(
                ReadXdrIter::<_, SignerKeyType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKeyType(Box::new(t)))),
            ),

            TypeVariant::PublicKey => Box::new(
                ReadXdrIter::<_, PublicKey>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKey(Box::new(t)))),
            ),

            TypeVariant::SignerKey => Box::new(
                ReadXdrIter::<_, SignerKey>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKey(Box::new(t)))),
            ),

            TypeVariant::Signature => Box::new(
                ReadXdrIter::<_, Signature>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signature(Box::new(t)))),
            ),

            TypeVariant::SignatureHint => Box::new(
                ReadXdrIter::<_, SignatureHint>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignatureHint(Box::new(t)))),
            ),

            TypeVariant::NodeId => Box::new(
                ReadXdrIter::<_, NodeId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::NodeId(Box::new(t)))),
            ),

            TypeVariant::AccountId => Box::new(
                ReadXdrIter::<_, AccountId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountId(Box::new(t)))),
            ),

            TypeVariant::ContractId => Box::new(
                ReadXdrIter::<_, ContractId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractId(Box::new(t)))),
            ),

            TypeVariant::Curve25519Secret => Box::new(
                ReadXdrIter::<_, Curve25519Secret>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Secret(Box::new(t)))),
            ),

            TypeVariant::Curve25519Public => Box::new(
                ReadXdrIter::<_, Curve25519Public>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Public(Box::new(t)))),
            ),

            TypeVariant::HmacSha256Key => Box::new(
                ReadXdrIter::<_, HmacSha256Key>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Key(Box::new(t)))),
            ),

            TypeVariant::HmacSha256Mac => Box::new(
                ReadXdrIter::<_, HmacSha256Mac>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Mac(Box::new(t)))),
            ),

            TypeVariant::ShortHashSeed => Box::new(
                ReadXdrIter::<_, ShortHashSeed>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ShortHashSeed(Box::new(t)))),
            ),

            TypeVariant::BinaryFuseFilterType => Box::new(
                ReadXdrIter::<_, BinaryFuseFilterType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BinaryFuseFilterType(Box::new(t)))),
            ),

            TypeVariant::SerializedBinaryFuseFilter => Box::new(
                ReadXdrIter::<_, SerializedBinaryFuseFilter>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SerializedBinaryFuseFilter(Box::new(t)))),
            ),

            TypeVariant::PoolId => Box::new(
                ReadXdrIter::<_, PoolId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PoolId(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceIdType => Box::new(
                ReadXdrIter::<_, ClaimableBalanceIdType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceIdType(Box::new(t)))),
            ),

            TypeVariant::ClaimableBalanceId => Box::new(
                ReadXdrIter::<_, ClaimableBalanceId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceId(Box::new(t)))),
            ),
        }
    }

    #[cfg(feature = "std")]
    pub fn from_xdr<B: AsRef<[u8]>>(
        v: TypeVariant,
        bytes: B,
        limits: Limits,
    ) -> Result<Self, Error> {
        let mut cursor = Limited::new(Cursor::new(bytes.as_ref()), limits);
        let t = Self::read_xdr_to_end(v, &mut cursor)?;
        Ok(t)
    }

    #[cfg(feature = "base64")]
    pub fn from_xdr_base64(
        v: TypeVariant,
        b64: impl AsRef<[u8]>,
        limits: Limits,
    ) -> Result<Self, Error> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(
                SkipWhitespace::new(Cursor::new(b64)),
                &base64::engine::general_purpose::STANDARD,
            ),
            limits,
        );
        let t = Self::read_xdr_to_end(v, &mut dec)?;
        Ok(t)
    }

    #[cfg(all(feature = "std", feature = "serde_json"))]
    #[deprecated(note = "use from_json")]
    pub fn read_json(v: TypeVariant, r: impl Read) -> Result<Self, Error> {
        Self::from_json(v, r)
    }

    #[cfg(all(feature = "std", feature = "serde_json"))]
    #[allow(clippy::too_many_lines)]
    pub fn from_json(v: TypeVariant, r: impl Read) -> Result<Self, Error> {
        match v {
            TypeVariant::ScpStatementPrepare => Ok(Self::ScpStatementPrepare(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScpStatementConfirm => Ok(Self::ScpStatementConfirm(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScpStatementExternalize => Ok(Self::ScpStatementExternalize(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScpStatementPledges => Ok(Self::ScpStatementPledges(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScEnvMetaEntryInterfaceVersion => Ok(
                Self::ScEnvMetaEntryInterfaceVersion(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::AccountEntryExtensionV2Ext => Ok(Self::AccountEntryExtensionV2Ext(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::AccountEntryExtensionV1Ext => Ok(Self::AccountEntryExtensionV1Ext(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::AccountEntryExt => {
                Ok(Self::AccountEntryExt(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TrustLineEntryExtensionV2Ext => Ok(Self::TrustLineEntryExtensionV2Ext(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::TrustLineEntryV1Ext => Ok(Self::TrustLineEntryV1Ext(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TrustLineEntryV1 => Ok(Self::TrustLineEntryV1(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TrustLineEntryExt => Ok(Self::TrustLineEntryExt(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::OfferEntryExt => {
                Ok(Self::OfferEntryExt(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::DataEntryExt => {
                Ok(Self::DataEntryExt(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ClaimantV0 => Ok(Self::ClaimantV0(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => Ok(
                Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ClaimableBalanceEntryExt => Ok(Self::ClaimableBalanceEntryExt(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LiquidityPoolEntryConstantProduct => Ok(
                Self::LiquidityPoolEntryConstantProduct(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::LiquidityPoolEntryBody => Ok(Self::LiquidityPoolEntryBody(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractCodeEntryV1 => Ok(Self::ContractCodeEntryV1(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractCodeEntryExt => Ok(Self::ContractCodeEntryExt(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerEntryExtensionV1Ext => Ok(Self::LedgerEntryExtensionV1Ext(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::LedgerEntryData => {
                Ok(Self::LedgerEntryData(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::LedgerEntryExt => {
                Ok(Self::LedgerEntryExt(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::LedgerKeyAccount => Ok(Self::LedgerKeyAccount(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerKeyTrustLine => Ok(Self::LedgerKeyTrustLine(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerKeyOffer => {
                Ok(Self::LedgerKeyOffer(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::LedgerKeyData => {
                Ok(Self::LedgerKeyData(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::LedgerKeyClaimableBalance => Ok(Self::LedgerKeyClaimableBalance(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::LedgerKeyLiquidityPool => Ok(Self::LedgerKeyLiquidityPool(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerKeyContractData => Ok(Self::LedgerKeyContractData(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerKeyContractCode => Ok(Self::LedgerKeyContractCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerKeyConfigSetting => Ok(Self::LedgerKeyConfigSetting(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerKeyTtl => {
                Ok(Self::LedgerKeyTtl(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::BucketMetadataExt => Ok(Self::BucketMetadataExt(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::StellarValueExt => {
                Ok(Self::StellarValueExt(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::LedgerHeaderExtensionV1Ext => Ok(Self::LedgerHeaderExtensionV1Ext(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::LedgerHeaderExt => {
                Ok(Self::LedgerHeaderExt(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => Ok(
                Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::TransactionHistoryEntryExt => Ok(Self::TransactionHistoryEntryExt(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::TransactionHistoryResultEntryExt => Ok(
                Self::TransactionHistoryResultEntryExt(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::LedgerHeaderHistoryEntryExt => Ok(Self::LedgerHeaderHistoryEntryExt(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::ContractEventV0 => {
                Ok(Self::ContractEventV0(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ContractEventBody => Ok(Self::ContractEventBody(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::PeerAddressIp => {
                Ok(Self::PeerAddressIp(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::AuthenticatedMessageV0 => Ok(Self::AuthenticatedMessageV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::MuxedAccountMed25519 => Ok(Self::MuxedAccountMed25519(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::RevokeSponsorshipOpSigner => Ok(Self::RevokeSponsorshipOpSigner(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::ContractIdPreimageFromAddress => Ok(Self::ContractIdPreimageFromAddress(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::OperationBody => {
                Ok(Self::OperationBody(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::HashIdPreimageOperationId => Ok(Self::HashIdPreimageOperationId(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::HashIdPreimageRevokeId => Ok(Self::HashIdPreimageRevokeId(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::HashIdPreimageContractId => Ok(Self::HashIdPreimageContractId(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::HashIdPreimageSorobanAuthorization => Ok(
                Self::HashIdPreimageSorobanAuthorization(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::SorobanTransactionDataExt => Ok(Self::SorobanTransactionDataExt(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::TransactionV0Ext => Ok(Self::TransactionV0Ext(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionExt => {
                Ok(Self::TransactionExt(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::FeeBumpTransactionInnerTx => Ok(Self::FeeBumpTransactionInnerTx(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::FeeBumpTransactionExt => Ok(Self::FeeBumpTransactionExt(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionSignaturePayloadTaggedTransaction => {
                Ok(Self::TransactionSignaturePayloadTaggedTransaction(
                    Box::new(serde_json::from_reader(r)?),
                ))
            }

            TypeVariant::PathPaymentStrictReceiveResultSuccess => Ok(
                Self::PathPaymentStrictReceiveResultSuccess(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::PathPaymentStrictSendResultSuccess => Ok(
                Self::PathPaymentStrictSendResultSuccess(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ManageOfferSuccessResultOffer => Ok(Self::ManageOfferSuccessResultOffer(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::OperationResultTr => Ok(Self::OperationResultTr(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::InnerTransactionResultResult => Ok(Self::InnerTransactionResultResult(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::InnerTransactionResultExt => Ok(Self::InnerTransactionResultExt(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::TransactionResultResult => Ok(Self::TransactionResultResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionResultExt => Ok(Self::TransactionResultExt(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::SignerKeyEd25519SignedPayload => Ok(Self::SignerKeyEd25519SignedPayload(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::Value => Ok(Self::Value(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScpBallot => Ok(Self::ScpBallot(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScpStatementType => Ok(Self::ScpStatementType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScpNomination => {
                Ok(Self::ScpNomination(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScpStatement => {
                Ok(Self::ScpStatement(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScpEnvelope => {
                Ok(Self::ScpEnvelope(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScpQuorumSet => {
                Ok(Self::ScpQuorumSet(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ConfigSettingContractExecutionLanesV0 => Ok(
                Self::ConfigSettingContractExecutionLanesV0(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ConfigSettingContractComputeV0 => Ok(
                Self::ConfigSettingContractComputeV0(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ConfigSettingContractParallelComputeV0 => Ok(
                Self::ConfigSettingContractParallelComputeV0(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ConfigSettingContractLedgerCostV0 => Ok(
                Self::ConfigSettingContractLedgerCostV0(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ConfigSettingContractLedgerCostExtV0 => Ok(
                Self::ConfigSettingContractLedgerCostExtV0(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ConfigSettingContractHistoricalDataV0 => Ok(
                Self::ConfigSettingContractHistoricalDataV0(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ConfigSettingContractEventsV0 => Ok(Self::ConfigSettingContractEventsV0(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::ConfigSettingContractBandwidthV0 => Ok(
                Self::ConfigSettingContractBandwidthV0(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ContractCostType => Ok(Self::ContractCostType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractCostParamEntry => Ok(Self::ContractCostParamEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::StateArchivalSettings => Ok(Self::StateArchivalSettings(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::EvictionIterator => Ok(Self::EvictionIterator(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ConfigSettingScpTiming => Ok(Self::ConfigSettingScpTiming(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractCostParams => Ok(Self::ContractCostParams(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ConfigSettingId => {
                Ok(Self::ConfigSettingId(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ConfigSettingEntry => Ok(Self::ConfigSettingEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScEnvMetaKind => {
                Ok(Self::ScEnvMetaKind(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScEnvMetaEntry => {
                Ok(Self::ScEnvMetaEntry(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScMetaV0 => Ok(Self::ScMetaV0(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScMetaKind => Ok(Self::ScMetaKind(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScMetaEntry => {
                Ok(Self::ScMetaEntry(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScSpecType => Ok(Self::ScSpecType(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScSpecTypeOption => Ok(Self::ScSpecTypeOption(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecTypeResult => Ok(Self::ScSpecTypeResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecTypeVec => {
                Ok(Self::ScSpecTypeVec(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScSpecTypeMap => {
                Ok(Self::ScSpecTypeMap(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScSpecTypeTuple => {
                Ok(Self::ScSpecTypeTuple(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScSpecTypeBytesN => Ok(Self::ScSpecTypeBytesN(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecTypeUdt => {
                Ok(Self::ScSpecTypeUdt(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScSpecTypeDef => {
                Ok(Self::ScSpecTypeDef(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScSpecUdtStructFieldV0 => Ok(Self::ScSpecUdtStructFieldV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecUdtStructV0 => Ok(Self::ScSpecUdtStructV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecUdtUnionCaseVoidV0 => Ok(Self::ScSpecUdtUnionCaseVoidV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecUdtUnionCaseTupleV0 => Ok(Self::ScSpecUdtUnionCaseTupleV0(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::ScSpecUdtUnionCaseV0Kind => Ok(Self::ScSpecUdtUnionCaseV0Kind(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecUdtUnionCaseV0 => Ok(Self::ScSpecUdtUnionCaseV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecUdtUnionV0 => Ok(Self::ScSpecUdtUnionV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecUdtEnumCaseV0 => Ok(Self::ScSpecUdtEnumCaseV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecUdtEnumV0 => {
                Ok(Self::ScSpecUdtEnumV0(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScSpecUdtErrorEnumCaseV0 => Ok(Self::ScSpecUdtErrorEnumCaseV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecUdtErrorEnumV0 => Ok(Self::ScSpecUdtErrorEnumV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecFunctionInputV0 => Ok(Self::ScSpecFunctionInputV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecFunctionV0 => Ok(Self::ScSpecFunctionV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecEventParamLocationV0 => Ok(Self::ScSpecEventParamLocationV0(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::ScSpecEventParamV0 => Ok(Self::ScSpecEventParamV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecEventDataFormat => Ok(Self::ScSpecEventDataFormat(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScSpecEventV0 => {
                Ok(Self::ScSpecEventV0(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScSpecEntryKind => {
                Ok(Self::ScSpecEntryKind(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScSpecEntry => {
                Ok(Self::ScSpecEntry(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScValType => Ok(Self::ScValType(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScErrorType => {
                Ok(Self::ScErrorType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScErrorCode => {
                Ok(Self::ScErrorCode(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ScError => Ok(Self::ScError(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::UInt128Parts => {
                Ok(Self::UInt128Parts(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::Int128Parts => {
                Ok(Self::Int128Parts(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::UInt256Parts => {
                Ok(Self::UInt256Parts(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::Int256Parts => {
                Ok(Self::Int256Parts(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ContractExecutableType => Ok(Self::ContractExecutableType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractExecutable => Ok(Self::ContractExecutable(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScAddressType => {
                Ok(Self::ScAddressType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::MuxedEd25519Account => Ok(Self::MuxedEd25519Account(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScAddress => Ok(Self::ScAddress(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScVec => Ok(Self::ScVec(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScMap => Ok(Self::ScMap(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScBytes => Ok(Self::ScBytes(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScString => Ok(Self::ScString(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScSymbol => Ok(Self::ScSymbol(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScNonceKey => Ok(Self::ScNonceKey(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScContractInstance => Ok(Self::ScContractInstance(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScVal => Ok(Self::ScVal(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ScMapEntry => Ok(Self::ScMapEntry(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::LedgerCloseMetaBatch => Ok(Self::LedgerCloseMetaBatch(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::StoredTransactionSet => Ok(Self::StoredTransactionSet(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::StoredDebugTransactionSet => Ok(Self::StoredDebugTransactionSet(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::PersistedScpStateV0 => Ok(Self::PersistedScpStateV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::PersistedScpStateV1 => Ok(Self::PersistedScpStateV1(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::PersistedScpState => Ok(Self::PersistedScpState(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::Thresholds => Ok(Self::Thresholds(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::String32 => Ok(Self::String32(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::String64 => Ok(Self::String64(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::SequenceNumber => {
                Ok(Self::SequenceNumber(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::DataValue => Ok(Self::DataValue(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::AssetCode4 => Ok(Self::AssetCode4(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::AssetCode12 => {
                Ok(Self::AssetCode12(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::AssetType => Ok(Self::AssetType(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::AssetCode => Ok(Self::AssetCode(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::AlphaNum4 => Ok(Self::AlphaNum4(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::AlphaNum12 => Ok(Self::AlphaNum12(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Asset => Ok(Self::Asset(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Price => Ok(Self::Price(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Liabilities => {
                Ok(Self::Liabilities(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ThresholdIndexes => Ok(Self::ThresholdIndexes(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerEntryType => {
                Ok(Self::LedgerEntryType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::Signer => Ok(Self::Signer(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::AccountFlags => {
                Ok(Self::AccountFlags(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::SponsorshipDescriptor => Ok(Self::SponsorshipDescriptor(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::AccountEntryExtensionV3 => Ok(Self::AccountEntryExtensionV3(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::AccountEntryExtensionV2 => Ok(Self::AccountEntryExtensionV2(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::AccountEntryExtensionV1 => Ok(Self::AccountEntryExtensionV1(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::AccountEntry => {
                Ok(Self::AccountEntry(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TrustLineFlags => {
                Ok(Self::TrustLineFlags(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::LiquidityPoolType => Ok(Self::LiquidityPoolType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TrustLineAsset => {
                Ok(Self::TrustLineAsset(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TrustLineEntryExtensionV2 => Ok(Self::TrustLineEntryExtensionV2(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::TrustLineEntry => {
                Ok(Self::TrustLineEntry(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::OfferEntryFlags => {
                Ok(Self::OfferEntryFlags(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::OfferEntry => Ok(Self::OfferEntry(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::DataEntry => Ok(Self::DataEntry(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ClaimPredicateType => Ok(Self::ClaimPredicateType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ClaimPredicate => {
                Ok(Self::ClaimPredicate(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ClaimantType => {
                Ok(Self::ClaimantType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::Claimant => Ok(Self::Claimant(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ClaimableBalanceFlags => Ok(Self::ClaimableBalanceFlags(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ClaimableBalanceEntryExtensionV1 => Ok(
                Self::ClaimableBalanceEntryExtensionV1(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ClaimableBalanceEntry => Ok(Self::ClaimableBalanceEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LiquidityPoolConstantProductParameters => Ok(
                Self::LiquidityPoolConstantProductParameters(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::LiquidityPoolEntry => Ok(Self::LiquidityPoolEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractDataDurability => Ok(Self::ContractDataDurability(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractDataEntry => Ok(Self::ContractDataEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractCodeCostInputs => Ok(Self::ContractCodeCostInputs(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractCodeEntry => Ok(Self::ContractCodeEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TtlEntry => Ok(Self::TtlEntry(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::LedgerEntryExtensionV1 => Ok(Self::LedgerEntryExtensionV1(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerEntry => {
                Ok(Self::LedgerEntry(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::LedgerKey => Ok(Self::LedgerKey(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::EnvelopeType => {
                Ok(Self::EnvelopeType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::BucketListType => {
                Ok(Self::BucketListType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::BucketEntryType => {
                Ok(Self::BucketEntryType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::HotArchiveBucketEntryType => Ok(Self::HotArchiveBucketEntryType(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::BucketMetadata => {
                Ok(Self::BucketMetadata(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::BucketEntry => {
                Ok(Self::BucketEntry(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::HotArchiveBucketEntry => Ok(Self::HotArchiveBucketEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::UpgradeType => {
                Ok(Self::UpgradeType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::StellarValueType => Ok(Self::StellarValueType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerCloseValueSignature => Ok(Self::LedgerCloseValueSignature(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::StellarValue => {
                Ok(Self::StellarValue(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::LedgerHeaderFlags => Ok(Self::LedgerHeaderFlags(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerHeaderExtensionV1 => Ok(Self::LedgerHeaderExtensionV1(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerHeader => {
                Ok(Self::LedgerHeader(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::LedgerUpgradeType => Ok(Self::LedgerUpgradeType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ConfigUpgradeSetKey => Ok(Self::ConfigUpgradeSetKey(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerUpgrade => {
                Ok(Self::LedgerUpgrade(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ConfigUpgradeSet => Ok(Self::ConfigUpgradeSet(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TxSetComponentType => Ok(Self::TxSetComponentType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::DependentTxCluster => Ok(Self::DependentTxCluster(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ParallelTxExecutionStage => Ok(Self::ParallelTxExecutionStage(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ParallelTxsComponent => Ok(Self::ParallelTxsComponent(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TxSetComponent => {
                Ok(Self::TxSetComponent(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TransactionPhase => Ok(Self::TransactionPhase(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionSet => {
                Ok(Self::TransactionSet(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TransactionSetV1 => Ok(Self::TransactionSetV1(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::GeneralizedTransactionSet => Ok(Self::GeneralizedTransactionSet(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::TransactionResultPair => Ok(Self::TransactionResultPair(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionResultSet => Ok(Self::TransactionResultSet(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionHistoryEntry => Ok(Self::TransactionHistoryEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionHistoryResultEntry => Ok(Self::TransactionHistoryResultEntry(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::LedgerHeaderHistoryEntry => Ok(Self::LedgerHeaderHistoryEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerScpMessages => Ok(Self::LedgerScpMessages(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScpHistoryEntryV0 => Ok(Self::ScpHistoryEntryV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ScpHistoryEntry => {
                Ok(Self::ScpHistoryEntry(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::LedgerEntryChangeType => Ok(Self::LedgerEntryChangeType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerEntryChange => Ok(Self::LedgerEntryChange(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerEntryChanges => Ok(Self::LedgerEntryChanges(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::OperationMeta => {
                Ok(Self::OperationMeta(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TransactionMetaV1 => Ok(Self::TransactionMetaV1(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionMetaV2 => Ok(Self::TransactionMetaV2(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractEventType => Ok(Self::ContractEventType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractEvent => {
                Ok(Self::ContractEvent(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::DiagnosticEvent => {
                Ok(Self::DiagnosticEvent(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::SorobanTransactionMetaExtV1 => Ok(Self::SorobanTransactionMetaExtV1(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::SorobanTransactionMetaExt => Ok(Self::SorobanTransactionMetaExt(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::SorobanTransactionMeta => Ok(Self::SorobanTransactionMeta(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionMetaV3 => Ok(Self::TransactionMetaV3(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::OperationMetaV2 => {
                Ok(Self::OperationMetaV2(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::SorobanTransactionMetaV2 => Ok(Self::SorobanTransactionMetaV2(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionEventStage => Ok(Self::TransactionEventStage(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionEvent => Ok(Self::TransactionEvent(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionMetaV4 => Ok(Self::TransactionMetaV4(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::InvokeHostFunctionSuccessPreImage => Ok(
                Self::InvokeHostFunctionSuccessPreImage(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::TransactionMeta => {
                Ok(Self::TransactionMeta(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TransactionResultMeta => Ok(Self::TransactionResultMeta(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionResultMetaV1 => Ok(Self::TransactionResultMetaV1(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::UpgradeEntryMeta => Ok(Self::UpgradeEntryMeta(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerCloseMetaV0 => Ok(Self::LedgerCloseMetaV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerCloseMetaExtV1 => Ok(Self::LedgerCloseMetaExtV1(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerCloseMetaExt => Ok(Self::LedgerCloseMetaExt(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerCloseMetaV1 => Ok(Self::LedgerCloseMetaV1(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerCloseMetaV2 => Ok(Self::LedgerCloseMetaV2(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LedgerCloseMeta => {
                Ok(Self::LedgerCloseMeta(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ErrorCode => Ok(Self::ErrorCode(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::SError => Ok(Self::SError(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::SendMore => Ok(Self::SendMore(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::SendMoreExtended => Ok(Self::SendMoreExtended(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::AuthCert => Ok(Self::AuthCert(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Hello => Ok(Self::Hello(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Auth => Ok(Self::Auth(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::IpAddrType => Ok(Self::IpAddrType(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::PeerAddress => {
                Ok(Self::PeerAddress(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::MessageType => {
                Ok(Self::MessageType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::DontHave => Ok(Self::DontHave(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::SurveyMessageCommandType => Ok(Self::SurveyMessageCommandType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::SurveyMessageResponseType => Ok(Self::SurveyMessageResponseType(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::TimeSlicedSurveyStartCollectingMessage => Ok(
                Self::TimeSlicedSurveyStartCollectingMessage(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::SignedTimeSlicedSurveyStartCollectingMessage => {
                Ok(Self::SignedTimeSlicedSurveyStartCollectingMessage(
                    Box::new(serde_json::from_reader(r)?),
                ))
            }

            TypeVariant::TimeSlicedSurveyStopCollectingMessage => Ok(
                Self::TimeSlicedSurveyStopCollectingMessage(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::SignedTimeSlicedSurveyStopCollectingMessage => {
                Ok(Self::SignedTimeSlicedSurveyStopCollectingMessage(Box::new(
                    serde_json::from_reader(r)?,
                )))
            }

            TypeVariant::SurveyRequestMessage => Ok(Self::SurveyRequestMessage(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TimeSlicedSurveyRequestMessage => Ok(
                Self::TimeSlicedSurveyRequestMessage(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::SignedTimeSlicedSurveyRequestMessage => Ok(
                Self::SignedTimeSlicedSurveyRequestMessage(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::EncryptedBody => {
                Ok(Self::EncryptedBody(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::SurveyResponseMessage => Ok(Self::SurveyResponseMessage(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TimeSlicedSurveyResponseMessage => Ok(
                Self::TimeSlicedSurveyResponseMessage(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::SignedTimeSlicedSurveyResponseMessage => Ok(
                Self::SignedTimeSlicedSurveyResponseMessage(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::PeerStats => Ok(Self::PeerStats(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::TimeSlicedNodeData => Ok(Self::TimeSlicedNodeData(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TimeSlicedPeerData => Ok(Self::TimeSlicedPeerData(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TimeSlicedPeerDataList => Ok(Self::TimeSlicedPeerDataList(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TopologyResponseBodyV2 => Ok(Self::TopologyResponseBodyV2(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::SurveyResponseBody => Ok(Self::SurveyResponseBody(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TxAdvertVector => {
                Ok(Self::TxAdvertVector(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::FloodAdvert => {
                Ok(Self::FloodAdvert(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TxDemandVector => {
                Ok(Self::TxDemandVector(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::FloodDemand => {
                Ok(Self::FloodDemand(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::StellarMessage => {
                Ok(Self::StellarMessage(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::AuthenticatedMessage => Ok(Self::AuthenticatedMessage(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LiquidityPoolParameters => Ok(Self::LiquidityPoolParameters(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::MuxedAccount => {
                Ok(Self::MuxedAccount(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::DecoratedSignature => Ok(Self::DecoratedSignature(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::OperationType => {
                Ok(Self::OperationType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::CreateAccountOp => {
                Ok(Self::CreateAccountOp(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::PaymentOp => Ok(Self::PaymentOp(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::PathPaymentStrictReceiveOp => Ok(Self::PathPaymentStrictReceiveOp(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::PathPaymentStrictSendOp => Ok(Self::PathPaymentStrictSendOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ManageSellOfferOp => Ok(Self::ManageSellOfferOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ManageBuyOfferOp => Ok(Self::ManageBuyOfferOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::CreatePassiveSellOfferOp => Ok(Self::CreatePassiveSellOfferOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::SetOptionsOp => {
                Ok(Self::SetOptionsOp(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ChangeTrustAsset => Ok(Self::ChangeTrustAsset(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ChangeTrustOp => {
                Ok(Self::ChangeTrustOp(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::AllowTrustOp => {
                Ok(Self::AllowTrustOp(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ManageDataOp => {
                Ok(Self::ManageDataOp(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::BumpSequenceOp => {
                Ok(Self::BumpSequenceOp(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::CreateClaimableBalanceOp => Ok(Self::CreateClaimableBalanceOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ClaimClaimableBalanceOp => Ok(Self::ClaimClaimableBalanceOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::BeginSponsoringFutureReservesOp => Ok(
                Self::BeginSponsoringFutureReservesOp(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::RevokeSponsorshipType => Ok(Self::RevokeSponsorshipType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::RevokeSponsorshipOp => Ok(Self::RevokeSponsorshipOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ClawbackOp => Ok(Self::ClawbackOp(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ClawbackClaimableBalanceOp => Ok(Self::ClawbackClaimableBalanceOp(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::SetTrustLineFlagsOp => Ok(Self::SetTrustLineFlagsOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LiquidityPoolDepositOp => Ok(Self::LiquidityPoolDepositOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LiquidityPoolWithdrawOp => Ok(Self::LiquidityPoolWithdrawOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::HostFunctionType => Ok(Self::HostFunctionType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractIdPreimageType => Ok(Self::ContractIdPreimageType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ContractIdPreimage => Ok(Self::ContractIdPreimage(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::CreateContractArgs => Ok(Self::CreateContractArgs(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::CreateContractArgsV2 => Ok(Self::CreateContractArgsV2(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::InvokeContractArgs => Ok(Self::InvokeContractArgs(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::HostFunction => {
                Ok(Self::HostFunction(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::SorobanAuthorizedFunctionType => Ok(Self::SorobanAuthorizedFunctionType(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::SorobanAuthorizedFunction => Ok(Self::SorobanAuthorizedFunction(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::SorobanAuthorizedInvocation => Ok(Self::SorobanAuthorizedInvocation(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::SorobanAddressCredentials => Ok(Self::SorobanAddressCredentials(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::SorobanCredentialsType => Ok(Self::SorobanCredentialsType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::SorobanCredentials => Ok(Self::SorobanCredentials(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::SorobanAuthorizationEntry => Ok(Self::SorobanAuthorizationEntry(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::SorobanAuthorizationEntries => Ok(Self::SorobanAuthorizationEntries(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::InvokeHostFunctionOp => Ok(Self::InvokeHostFunctionOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ExtendFootprintTtlOp => Ok(Self::ExtendFootprintTtlOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::RestoreFootprintOp => Ok(Self::RestoreFootprintOp(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::Operation => Ok(Self::Operation(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::HashIdPreimage => {
                Ok(Self::HashIdPreimage(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::MemoType => Ok(Self::MemoType(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Memo => Ok(Self::Memo(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::TimeBounds => Ok(Self::TimeBounds(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::LedgerBounds => {
                Ok(Self::LedgerBounds(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::PreconditionsV2 => {
                Ok(Self::PreconditionsV2(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::PreconditionType => Ok(Self::PreconditionType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::Preconditions => {
                Ok(Self::Preconditions(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::LedgerFootprint => {
                Ok(Self::LedgerFootprint(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::SorobanResources => Ok(Self::SorobanResources(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::SorobanResourcesExtV0 => Ok(Self::SorobanResourcesExtV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::SorobanTransactionData => Ok(Self::SorobanTransactionData(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionV0 => {
                Ok(Self::TransactionV0(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TransactionV0Envelope => Ok(Self::TransactionV0Envelope(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::Transaction => {
                Ok(Self::Transaction(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TransactionV1Envelope => Ok(Self::TransactionV1Envelope(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::FeeBumpTransaction => Ok(Self::FeeBumpTransaction(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::FeeBumpTransactionEnvelope => Ok(Self::FeeBumpTransactionEnvelope(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::TransactionEnvelope => Ok(Self::TransactionEnvelope(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::TransactionSignaturePayload => Ok(Self::TransactionSignaturePayload(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::ClaimAtomType => {
                Ok(Self::ClaimAtomType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ClaimOfferAtomV0 => Ok(Self::ClaimOfferAtomV0(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ClaimOfferAtom => {
                Ok(Self::ClaimOfferAtom(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ClaimLiquidityAtom => Ok(Self::ClaimLiquidityAtom(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ClaimAtom => Ok(Self::ClaimAtom(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::CreateAccountResultCode => Ok(Self::CreateAccountResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::CreateAccountResult => Ok(Self::CreateAccountResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::PaymentResultCode => Ok(Self::PaymentResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::PaymentResult => {
                Ok(Self::PaymentResult(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::PathPaymentStrictReceiveResultCode => Ok(
                Self::PathPaymentStrictReceiveResultCode(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::SimplePaymentResult => Ok(Self::SimplePaymentResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::PathPaymentStrictReceiveResult => Ok(
                Self::PathPaymentStrictReceiveResult(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::PathPaymentStrictSendResultCode => Ok(
                Self::PathPaymentStrictSendResultCode(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::PathPaymentStrictSendResult => Ok(Self::PathPaymentStrictSendResult(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::ManageSellOfferResultCode => Ok(Self::ManageSellOfferResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::ManageOfferEffect => Ok(Self::ManageOfferEffect(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ManageOfferSuccessResult => Ok(Self::ManageOfferSuccessResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ManageSellOfferResult => Ok(Self::ManageSellOfferResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ManageBuyOfferResultCode => Ok(Self::ManageBuyOfferResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ManageBuyOfferResult => Ok(Self::ManageBuyOfferResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::SetOptionsResultCode => Ok(Self::SetOptionsResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::SetOptionsResult => Ok(Self::SetOptionsResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ChangeTrustResultCode => Ok(Self::ChangeTrustResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ChangeTrustResult => Ok(Self::ChangeTrustResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::AllowTrustResultCode => Ok(Self::AllowTrustResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::AllowTrustResult => Ok(Self::AllowTrustResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::AccountMergeResultCode => Ok(Self::AccountMergeResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::AccountMergeResult => Ok(Self::AccountMergeResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::InflationResultCode => Ok(Self::InflationResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::InflationPayout => {
                Ok(Self::InflationPayout(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::InflationResult => {
                Ok(Self::InflationResult(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ManageDataResultCode => Ok(Self::ManageDataResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ManageDataResult => Ok(Self::ManageDataResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::BumpSequenceResultCode => Ok(Self::BumpSequenceResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::BumpSequenceResult => Ok(Self::BumpSequenceResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::CreateClaimableBalanceResultCode => Ok(
                Self::CreateClaimableBalanceResultCode(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::CreateClaimableBalanceResult => Ok(Self::CreateClaimableBalanceResult(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::ClaimClaimableBalanceResultCode => Ok(
                Self::ClaimClaimableBalanceResultCode(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ClaimClaimableBalanceResult => Ok(Self::ClaimClaimableBalanceResult(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::BeginSponsoringFutureReservesResultCode => {
                Ok(Self::BeginSponsoringFutureReservesResultCode(Box::new(
                    serde_json::from_reader(r)?,
                )))
            }

            TypeVariant::BeginSponsoringFutureReservesResult => Ok(
                Self::BeginSponsoringFutureReservesResult(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::EndSponsoringFutureReservesResultCode => Ok(
                Self::EndSponsoringFutureReservesResultCode(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::EndSponsoringFutureReservesResult => Ok(
                Self::EndSponsoringFutureReservesResult(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::RevokeSponsorshipResultCode => Ok(Self::RevokeSponsorshipResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::RevokeSponsorshipResult => Ok(Self::RevokeSponsorshipResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ClawbackResultCode => Ok(Self::ClawbackResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ClawbackResult => {
                Ok(Self::ClawbackResult(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ClawbackClaimableBalanceResultCode => Ok(
                Self::ClawbackClaimableBalanceResultCode(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::ClawbackClaimableBalanceResult => Ok(
                Self::ClawbackClaimableBalanceResult(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::SetTrustLineFlagsResultCode => Ok(Self::SetTrustLineFlagsResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::SetTrustLineFlagsResult => Ok(Self::SetTrustLineFlagsResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::LiquidityPoolDepositResultCode => Ok(
                Self::LiquidityPoolDepositResultCode(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::LiquidityPoolDepositResult => Ok(Self::LiquidityPoolDepositResult(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::LiquidityPoolWithdrawResultCode => Ok(
                Self::LiquidityPoolWithdrawResultCode(Box::new(serde_json::from_reader(r)?)),
            ),

            TypeVariant::LiquidityPoolWithdrawResult => Ok(Self::LiquidityPoolWithdrawResult(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::InvokeHostFunctionResultCode => Ok(Self::InvokeHostFunctionResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::InvokeHostFunctionResult => Ok(Self::InvokeHostFunctionResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ExtendFootprintTtlResultCode => Ok(Self::ExtendFootprintTtlResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::ExtendFootprintTtlResult => Ok(Self::ExtendFootprintTtlResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::RestoreFootprintResultCode => Ok(Self::RestoreFootprintResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::RestoreFootprintResult => Ok(Self::RestoreFootprintResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::OperationResultCode => Ok(Self::OperationResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::OperationResult => {
                Ok(Self::OperationResult(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::TransactionResultCode => Ok(Self::TransactionResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::InnerTransactionResult => Ok(Self::InnerTransactionResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::InnerTransactionResultPair => Ok(Self::InnerTransactionResultPair(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::TransactionResult => Ok(Self::TransactionResult(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::Hash => Ok(Self::Hash(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Uint256 => Ok(Self::Uint256(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Uint32 => Ok(Self::Uint32(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Int32 => Ok(Self::Int32(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Uint64 => Ok(Self::Uint64(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Int64 => Ok(Self::Int64(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::TimePoint => Ok(Self::TimePoint(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Duration => Ok(Self::Duration(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ExtensionPoint => {
                Ok(Self::ExtensionPoint(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::CryptoKeyType => {
                Ok(Self::CryptoKeyType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::PublicKeyType => {
                Ok(Self::PublicKeyType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::SignerKeyType => {
                Ok(Self::SignerKeyType(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::PublicKey => Ok(Self::PublicKey(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::SignerKey => Ok(Self::SignerKey(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Signature => Ok(Self::Signature(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::SignatureHint => {
                Ok(Self::SignatureHint(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::NodeId => Ok(Self::NodeId(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::AccountId => Ok(Self::AccountId(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ContractId => Ok(Self::ContractId(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::Curve25519Secret => Ok(Self::Curve25519Secret(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::Curve25519Public => Ok(Self::Curve25519Public(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::HmacSha256Key => {
                Ok(Self::HmacSha256Key(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::HmacSha256Mac => {
                Ok(Self::HmacSha256Mac(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::ShortHashSeed => {
                Ok(Self::ShortHashSeed(Box::new(serde_json::from_reader(r)?)))
            }

            TypeVariant::BinaryFuseFilterType => Ok(Self::BinaryFuseFilterType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::SerializedBinaryFuseFilter => Ok(Self::SerializedBinaryFuseFilter(
                Box::new(serde_json::from_reader(r)?),
            )),

            TypeVariant::PoolId => Ok(Self::PoolId(Box::new(serde_json::from_reader(r)?))),

            TypeVariant::ClaimableBalanceIdType => Ok(Self::ClaimableBalanceIdType(Box::new(
                serde_json::from_reader(r)?,
            ))),

            TypeVariant::ClaimableBalanceId => Ok(Self::ClaimableBalanceId(Box::new(
                serde_json::from_reader(r)?,
            ))),
        }
    }

    #[cfg(all(feature = "std", feature = "serde_json"))]
    #[allow(clippy::too_many_lines)]
    pub fn deserialize_json<'r, R: serde_json::de::Read<'r>>(
        v: TypeVariant,
        r: &mut serde_json::de::Deserializer<R>,
    ) -> Result<Self, Error> {
        match v {
            TypeVariant::ScpStatementPrepare => Ok(Self::ScpStatementPrepare(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScpStatementConfirm => Ok(Self::ScpStatementConfirm(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScpStatementExternalize => Ok(Self::ScpStatementExternalize(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScpStatementPledges => Ok(Self::ScpStatementPledges(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScEnvMetaEntryInterfaceVersion => {
                Ok(Self::ScEnvMetaEntryInterfaceVersion(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::AccountEntryExtensionV2Ext => Ok(Self::AccountEntryExtensionV2Ext(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::AccountEntryExtensionV1Ext => Ok(Self::AccountEntryExtensionV1Ext(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::AccountEntryExt => Ok(Self::AccountEntryExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TrustLineEntryExtensionV2Ext => Ok(Self::TrustLineEntryExtensionV2Ext(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::TrustLineEntryV1Ext => Ok(Self::TrustLineEntryV1Ext(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TrustLineEntryV1 => Ok(Self::TrustLineEntryV1(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TrustLineEntryExt => Ok(Self::TrustLineEntryExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::OfferEntryExt => Ok(Self::OfferEntryExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::DataEntryExt => Ok(Self::DataEntryExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimantV0 => Ok(Self::ClaimantV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => {
                Ok(Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ClaimableBalanceEntryExt => Ok(Self::ClaimableBalanceEntryExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LiquidityPoolEntryConstantProduct => {
                Ok(Self::LiquidityPoolEntryConstantProduct(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::LiquidityPoolEntryBody => Ok(Self::LiquidityPoolEntryBody(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractCodeEntryV1 => Ok(Self::ContractCodeEntryV1(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractCodeEntryExt => Ok(Self::ContractCodeEntryExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerEntryExtensionV1Ext => Ok(Self::LedgerEntryExtensionV1Ext(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::LedgerEntryData => Ok(Self::LedgerEntryData(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerEntryExt => Ok(Self::LedgerEntryExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerKeyAccount => Ok(Self::LedgerKeyAccount(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerKeyTrustLine => Ok(Self::LedgerKeyTrustLine(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerKeyOffer => Ok(Self::LedgerKeyOffer(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerKeyData => Ok(Self::LedgerKeyData(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerKeyClaimableBalance => Ok(Self::LedgerKeyClaimableBalance(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::LedgerKeyLiquidityPool => Ok(Self::LedgerKeyLiquidityPool(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerKeyContractData => Ok(Self::LedgerKeyContractData(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerKeyContractCode => Ok(Self::LedgerKeyContractCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerKeyConfigSetting => Ok(Self::LedgerKeyConfigSetting(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerKeyTtl => Ok(Self::LedgerKeyTtl(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::BucketMetadataExt => Ok(Self::BucketMetadataExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::StellarValueExt => Ok(Self::StellarValueExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerHeaderExtensionV1Ext => Ok(Self::LedgerHeaderExtensionV1Ext(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::LedgerHeaderExt => Ok(Self::LedgerHeaderExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => {
                Ok(Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::TransactionHistoryEntryExt => Ok(Self::TransactionHistoryEntryExt(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::TransactionHistoryResultEntryExt => {
                Ok(Self::TransactionHistoryResultEntryExt(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::LedgerHeaderHistoryEntryExt => Ok(Self::LedgerHeaderHistoryEntryExt(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::ContractEventV0 => Ok(Self::ContractEventV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractEventBody => Ok(Self::ContractEventBody(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PeerAddressIp => Ok(Self::PeerAddressIp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AuthenticatedMessageV0 => Ok(Self::AuthenticatedMessageV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::MuxedAccountMed25519 => Ok(Self::MuxedAccountMed25519(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::RevokeSponsorshipOpSigner => Ok(Self::RevokeSponsorshipOpSigner(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::ContractIdPreimageFromAddress => Ok(Self::ContractIdPreimageFromAddress(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::OperationBody => Ok(Self::OperationBody(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::HashIdPreimageOperationId => Ok(Self::HashIdPreimageOperationId(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::HashIdPreimageRevokeId => Ok(Self::HashIdPreimageRevokeId(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::HashIdPreimageContractId => Ok(Self::HashIdPreimageContractId(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::HashIdPreimageSorobanAuthorization => {
                Ok(Self::HashIdPreimageSorobanAuthorization(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::SorobanTransactionDataExt => Ok(Self::SorobanTransactionDataExt(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::TransactionV0Ext => Ok(Self::TransactionV0Ext(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionExt => Ok(Self::TransactionExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::FeeBumpTransactionInnerTx => Ok(Self::FeeBumpTransactionInnerTx(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::FeeBumpTransactionExt => Ok(Self::FeeBumpTransactionExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionSignaturePayloadTaggedTransaction => {
                Ok(Self::TransactionSignaturePayloadTaggedTransaction(
                    Box::new(serde::de::Deserialize::deserialize(r)?),
                ))
            }

            TypeVariant::PathPaymentStrictReceiveResultSuccess => {
                Ok(Self::PathPaymentStrictReceiveResultSuccess(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::PathPaymentStrictSendResultSuccess => {
                Ok(Self::PathPaymentStrictSendResultSuccess(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ManageOfferSuccessResultOffer => Ok(Self::ManageOfferSuccessResultOffer(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::OperationResultTr => Ok(Self::OperationResultTr(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::InnerTransactionResultResult => Ok(Self::InnerTransactionResultResult(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::InnerTransactionResultExt => Ok(Self::InnerTransactionResultExt(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::TransactionResultResult => Ok(Self::TransactionResultResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionResultExt => Ok(Self::TransactionResultExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SignerKeyEd25519SignedPayload => Ok(Self::SignerKeyEd25519SignedPayload(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::Value => Ok(Self::Value(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::ScpBallot => Ok(Self::ScpBallot(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScpStatementType => Ok(Self::ScpStatementType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScpNomination => Ok(Self::ScpNomination(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScpStatement => Ok(Self::ScpStatement(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScpEnvelope => Ok(Self::ScpEnvelope(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScpQuorumSet => Ok(Self::ScpQuorumSet(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ConfigSettingContractExecutionLanesV0 => {
                Ok(Self::ConfigSettingContractExecutionLanesV0(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ConfigSettingContractComputeV0 => {
                Ok(Self::ConfigSettingContractComputeV0(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ConfigSettingContractParallelComputeV0 => {
                Ok(Self::ConfigSettingContractParallelComputeV0(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ConfigSettingContractLedgerCostV0 => {
                Ok(Self::ConfigSettingContractLedgerCostV0(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ConfigSettingContractLedgerCostExtV0 => {
                Ok(Self::ConfigSettingContractLedgerCostExtV0(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ConfigSettingContractHistoricalDataV0 => {
                Ok(Self::ConfigSettingContractHistoricalDataV0(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ConfigSettingContractEventsV0 => Ok(Self::ConfigSettingContractEventsV0(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::ConfigSettingContractBandwidthV0 => {
                Ok(Self::ConfigSettingContractBandwidthV0(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ContractCostType => Ok(Self::ContractCostType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractCostParamEntry => Ok(Self::ContractCostParamEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::StateArchivalSettings => Ok(Self::StateArchivalSettings(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::EvictionIterator => Ok(Self::EvictionIterator(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ConfigSettingScpTiming => Ok(Self::ConfigSettingScpTiming(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractCostParams => Ok(Self::ContractCostParams(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ConfigSettingId => Ok(Self::ConfigSettingId(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ConfigSettingEntry => Ok(Self::ConfigSettingEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScEnvMetaKind => Ok(Self::ScEnvMetaKind(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScEnvMetaEntry => Ok(Self::ScEnvMetaEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScMetaV0 => Ok(Self::ScMetaV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScMetaKind => Ok(Self::ScMetaKind(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScMetaEntry => Ok(Self::ScMetaEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecType => Ok(Self::ScSpecType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecTypeOption => Ok(Self::ScSpecTypeOption(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecTypeResult => Ok(Self::ScSpecTypeResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecTypeVec => Ok(Self::ScSpecTypeVec(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecTypeMap => Ok(Self::ScSpecTypeMap(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecTypeTuple => Ok(Self::ScSpecTypeTuple(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecTypeBytesN => Ok(Self::ScSpecTypeBytesN(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecTypeUdt => Ok(Self::ScSpecTypeUdt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecTypeDef => Ok(Self::ScSpecTypeDef(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecUdtStructFieldV0 => Ok(Self::ScSpecUdtStructFieldV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecUdtStructV0 => Ok(Self::ScSpecUdtStructV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecUdtUnionCaseVoidV0 => Ok(Self::ScSpecUdtUnionCaseVoidV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecUdtUnionCaseTupleV0 => Ok(Self::ScSpecUdtUnionCaseTupleV0(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::ScSpecUdtUnionCaseV0Kind => Ok(Self::ScSpecUdtUnionCaseV0Kind(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecUdtUnionCaseV0 => Ok(Self::ScSpecUdtUnionCaseV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecUdtUnionV0 => Ok(Self::ScSpecUdtUnionV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecUdtEnumCaseV0 => Ok(Self::ScSpecUdtEnumCaseV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecUdtEnumV0 => Ok(Self::ScSpecUdtEnumV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecUdtErrorEnumCaseV0 => Ok(Self::ScSpecUdtErrorEnumCaseV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecUdtErrorEnumV0 => Ok(Self::ScSpecUdtErrorEnumV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecFunctionInputV0 => Ok(Self::ScSpecFunctionInputV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecFunctionV0 => Ok(Self::ScSpecFunctionV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecEventParamLocationV0 => Ok(Self::ScSpecEventParamLocationV0(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::ScSpecEventParamV0 => Ok(Self::ScSpecEventParamV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecEventDataFormat => Ok(Self::ScSpecEventDataFormat(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecEventV0 => Ok(Self::ScSpecEventV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecEntryKind => Ok(Self::ScSpecEntryKind(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSpecEntry => Ok(Self::ScSpecEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScValType => Ok(Self::ScValType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScErrorType => Ok(Self::ScErrorType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScErrorCode => Ok(Self::ScErrorCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScError => Ok(Self::ScError(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::UInt128Parts => Ok(Self::UInt128Parts(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Int128Parts => Ok(Self::Int128Parts(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::UInt256Parts => Ok(Self::UInt256Parts(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Int256Parts => Ok(Self::Int256Parts(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractExecutableType => Ok(Self::ContractExecutableType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractExecutable => Ok(Self::ContractExecutable(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScAddressType => Ok(Self::ScAddressType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::MuxedEd25519Account => Ok(Self::MuxedEd25519Account(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScAddress => Ok(Self::ScAddress(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScVec => Ok(Self::ScVec(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::ScMap => Ok(Self::ScMap(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::ScBytes => Ok(Self::ScBytes(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScString => Ok(Self::ScString(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScSymbol => Ok(Self::ScSymbol(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScNonceKey => Ok(Self::ScNonceKey(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScContractInstance => Ok(Self::ScContractInstance(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScVal => Ok(Self::ScVal(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::ScMapEntry => Ok(Self::ScMapEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerCloseMetaBatch => Ok(Self::LedgerCloseMetaBatch(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::StoredTransactionSet => Ok(Self::StoredTransactionSet(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::StoredDebugTransactionSet => Ok(Self::StoredDebugTransactionSet(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::PersistedScpStateV0 => Ok(Self::PersistedScpStateV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PersistedScpStateV1 => Ok(Self::PersistedScpStateV1(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PersistedScpState => Ok(Self::PersistedScpState(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Thresholds => Ok(Self::Thresholds(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::String32 => Ok(Self::String32(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::String64 => Ok(Self::String64(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SequenceNumber => Ok(Self::SequenceNumber(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::DataValue => Ok(Self::DataValue(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AssetCode4 => Ok(Self::AssetCode4(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AssetCode12 => Ok(Self::AssetCode12(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AssetType => Ok(Self::AssetType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AssetCode => Ok(Self::AssetCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AlphaNum4 => Ok(Self::AlphaNum4(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AlphaNum12 => Ok(Self::AlphaNum12(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Asset => Ok(Self::Asset(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::Price => Ok(Self::Price(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::Liabilities => Ok(Self::Liabilities(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ThresholdIndexes => Ok(Self::ThresholdIndexes(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerEntryType => Ok(Self::LedgerEntryType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Signer => Ok(Self::Signer(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::AccountFlags => Ok(Self::AccountFlags(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SponsorshipDescriptor => Ok(Self::SponsorshipDescriptor(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AccountEntryExtensionV3 => Ok(Self::AccountEntryExtensionV3(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AccountEntryExtensionV2 => Ok(Self::AccountEntryExtensionV2(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AccountEntryExtensionV1 => Ok(Self::AccountEntryExtensionV1(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AccountEntry => Ok(Self::AccountEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TrustLineFlags => Ok(Self::TrustLineFlags(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LiquidityPoolType => Ok(Self::LiquidityPoolType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TrustLineAsset => Ok(Self::TrustLineAsset(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TrustLineEntryExtensionV2 => Ok(Self::TrustLineEntryExtensionV2(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::TrustLineEntry => Ok(Self::TrustLineEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::OfferEntryFlags => Ok(Self::OfferEntryFlags(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::OfferEntry => Ok(Self::OfferEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::DataEntry => Ok(Self::DataEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimPredicateType => Ok(Self::ClaimPredicateType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimPredicate => Ok(Self::ClaimPredicate(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimantType => Ok(Self::ClaimantType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Claimant => Ok(Self::Claimant(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimableBalanceFlags => Ok(Self::ClaimableBalanceFlags(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimableBalanceEntryExtensionV1 => {
                Ok(Self::ClaimableBalanceEntryExtensionV1(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ClaimableBalanceEntry => Ok(Self::ClaimableBalanceEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LiquidityPoolConstantProductParameters => {
                Ok(Self::LiquidityPoolConstantProductParameters(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::LiquidityPoolEntry => Ok(Self::LiquidityPoolEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractDataDurability => Ok(Self::ContractDataDurability(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractDataEntry => Ok(Self::ContractDataEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractCodeCostInputs => Ok(Self::ContractCodeCostInputs(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractCodeEntry => Ok(Self::ContractCodeEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TtlEntry => Ok(Self::TtlEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerEntryExtensionV1 => Ok(Self::LedgerEntryExtensionV1(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerEntry => Ok(Self::LedgerEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerKey => Ok(Self::LedgerKey(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::EnvelopeType => Ok(Self::EnvelopeType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::BucketListType => Ok(Self::BucketListType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::BucketEntryType => Ok(Self::BucketEntryType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::HotArchiveBucketEntryType => Ok(Self::HotArchiveBucketEntryType(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::BucketMetadata => Ok(Self::BucketMetadata(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::BucketEntry => Ok(Self::BucketEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::HotArchiveBucketEntry => Ok(Self::HotArchiveBucketEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::UpgradeType => Ok(Self::UpgradeType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::StellarValueType => Ok(Self::StellarValueType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerCloseValueSignature => Ok(Self::LedgerCloseValueSignature(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::StellarValue => Ok(Self::StellarValue(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerHeaderFlags => Ok(Self::LedgerHeaderFlags(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerHeaderExtensionV1 => Ok(Self::LedgerHeaderExtensionV1(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerHeader => Ok(Self::LedgerHeader(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerUpgradeType => Ok(Self::LedgerUpgradeType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ConfigUpgradeSetKey => Ok(Self::ConfigUpgradeSetKey(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerUpgrade => Ok(Self::LedgerUpgrade(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ConfigUpgradeSet => Ok(Self::ConfigUpgradeSet(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TxSetComponentType => Ok(Self::TxSetComponentType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::DependentTxCluster => Ok(Self::DependentTxCluster(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ParallelTxExecutionStage => Ok(Self::ParallelTxExecutionStage(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ParallelTxsComponent => Ok(Self::ParallelTxsComponent(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TxSetComponent => Ok(Self::TxSetComponent(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionPhase => Ok(Self::TransactionPhase(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionSet => Ok(Self::TransactionSet(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionSetV1 => Ok(Self::TransactionSetV1(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::GeneralizedTransactionSet => Ok(Self::GeneralizedTransactionSet(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::TransactionResultPair => Ok(Self::TransactionResultPair(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionResultSet => Ok(Self::TransactionResultSet(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionHistoryEntry => Ok(Self::TransactionHistoryEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionHistoryResultEntry => Ok(Self::TransactionHistoryResultEntry(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::LedgerHeaderHistoryEntry => Ok(Self::LedgerHeaderHistoryEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerScpMessages => Ok(Self::LedgerScpMessages(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScpHistoryEntryV0 => Ok(Self::ScpHistoryEntryV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ScpHistoryEntry => Ok(Self::ScpHistoryEntry(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerEntryChangeType => Ok(Self::LedgerEntryChangeType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerEntryChange => Ok(Self::LedgerEntryChange(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerEntryChanges => Ok(Self::LedgerEntryChanges(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::OperationMeta => Ok(Self::OperationMeta(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionMetaV1 => Ok(Self::TransactionMetaV1(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionMetaV2 => Ok(Self::TransactionMetaV2(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractEventType => Ok(Self::ContractEventType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractEvent => Ok(Self::ContractEvent(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::DiagnosticEvent => Ok(Self::DiagnosticEvent(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SorobanTransactionMetaExtV1 => Ok(Self::SorobanTransactionMetaExtV1(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::SorobanTransactionMetaExt => Ok(Self::SorobanTransactionMetaExt(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::SorobanTransactionMeta => Ok(Self::SorobanTransactionMeta(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionMetaV3 => Ok(Self::TransactionMetaV3(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::OperationMetaV2 => Ok(Self::OperationMetaV2(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SorobanTransactionMetaV2 => Ok(Self::SorobanTransactionMetaV2(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionEventStage => Ok(Self::TransactionEventStage(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionEvent => Ok(Self::TransactionEvent(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionMetaV4 => Ok(Self::TransactionMetaV4(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::InvokeHostFunctionSuccessPreImage => {
                Ok(Self::InvokeHostFunctionSuccessPreImage(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::TransactionMeta => Ok(Self::TransactionMeta(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionResultMeta => Ok(Self::TransactionResultMeta(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionResultMetaV1 => Ok(Self::TransactionResultMetaV1(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::UpgradeEntryMeta => Ok(Self::UpgradeEntryMeta(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerCloseMetaV0 => Ok(Self::LedgerCloseMetaV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerCloseMetaExtV1 => Ok(Self::LedgerCloseMetaExtV1(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerCloseMetaExt => Ok(Self::LedgerCloseMetaExt(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerCloseMetaV1 => Ok(Self::LedgerCloseMetaV1(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerCloseMetaV2 => Ok(Self::LedgerCloseMetaV2(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerCloseMeta => Ok(Self::LedgerCloseMeta(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ErrorCode => Ok(Self::ErrorCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SError => Ok(Self::SError(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::SendMore => Ok(Self::SendMore(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SendMoreExtended => Ok(Self::SendMoreExtended(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AuthCert => Ok(Self::AuthCert(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Hello => Ok(Self::Hello(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::Auth => Ok(Self::Auth(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::IpAddrType => Ok(Self::IpAddrType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PeerAddress => Ok(Self::PeerAddress(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::MessageType => Ok(Self::MessageType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::DontHave => Ok(Self::DontHave(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SurveyMessageCommandType => Ok(Self::SurveyMessageCommandType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SurveyMessageResponseType => Ok(Self::SurveyMessageResponseType(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::TimeSlicedSurveyStartCollectingMessage => {
                Ok(Self::TimeSlicedSurveyStartCollectingMessage(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::SignedTimeSlicedSurveyStartCollectingMessage => {
                Ok(Self::SignedTimeSlicedSurveyStartCollectingMessage(
                    Box::new(serde::de::Deserialize::deserialize(r)?),
                ))
            }

            TypeVariant::TimeSlicedSurveyStopCollectingMessage => {
                Ok(Self::TimeSlicedSurveyStopCollectingMessage(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::SignedTimeSlicedSurveyStopCollectingMessage => {
                Ok(Self::SignedTimeSlicedSurveyStopCollectingMessage(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::SurveyRequestMessage => Ok(Self::SurveyRequestMessage(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TimeSlicedSurveyRequestMessage => {
                Ok(Self::TimeSlicedSurveyRequestMessage(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::SignedTimeSlicedSurveyRequestMessage => {
                Ok(Self::SignedTimeSlicedSurveyRequestMessage(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::EncryptedBody => Ok(Self::EncryptedBody(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SurveyResponseMessage => Ok(Self::SurveyResponseMessage(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TimeSlicedSurveyResponseMessage => {
                Ok(Self::TimeSlicedSurveyResponseMessage(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::SignedTimeSlicedSurveyResponseMessage => {
                Ok(Self::SignedTimeSlicedSurveyResponseMessage(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::PeerStats => Ok(Self::PeerStats(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TimeSlicedNodeData => Ok(Self::TimeSlicedNodeData(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TimeSlicedPeerData => Ok(Self::TimeSlicedPeerData(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TimeSlicedPeerDataList => Ok(Self::TimeSlicedPeerDataList(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TopologyResponseBodyV2 => Ok(Self::TopologyResponseBodyV2(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SurveyResponseBody => Ok(Self::SurveyResponseBody(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TxAdvertVector => Ok(Self::TxAdvertVector(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::FloodAdvert => Ok(Self::FloodAdvert(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TxDemandVector => Ok(Self::TxDemandVector(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::FloodDemand => Ok(Self::FloodDemand(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::StellarMessage => Ok(Self::StellarMessage(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AuthenticatedMessage => Ok(Self::AuthenticatedMessage(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LiquidityPoolParameters => Ok(Self::LiquidityPoolParameters(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::MuxedAccount => Ok(Self::MuxedAccount(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::DecoratedSignature => Ok(Self::DecoratedSignature(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::OperationType => Ok(Self::OperationType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::CreateAccountOp => Ok(Self::CreateAccountOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PaymentOp => Ok(Self::PaymentOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PathPaymentStrictReceiveOp => Ok(Self::PathPaymentStrictReceiveOp(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::PathPaymentStrictSendOp => Ok(Self::PathPaymentStrictSendOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ManageSellOfferOp => Ok(Self::ManageSellOfferOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ManageBuyOfferOp => Ok(Self::ManageBuyOfferOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::CreatePassiveSellOfferOp => Ok(Self::CreatePassiveSellOfferOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SetOptionsOp => Ok(Self::SetOptionsOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ChangeTrustAsset => Ok(Self::ChangeTrustAsset(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ChangeTrustOp => Ok(Self::ChangeTrustOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AllowTrustOp => Ok(Self::AllowTrustOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ManageDataOp => Ok(Self::ManageDataOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::BumpSequenceOp => Ok(Self::BumpSequenceOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::CreateClaimableBalanceOp => Ok(Self::CreateClaimableBalanceOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimClaimableBalanceOp => Ok(Self::ClaimClaimableBalanceOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::BeginSponsoringFutureReservesOp => {
                Ok(Self::BeginSponsoringFutureReservesOp(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::RevokeSponsorshipType => Ok(Self::RevokeSponsorshipType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::RevokeSponsorshipOp => Ok(Self::RevokeSponsorshipOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClawbackOp => Ok(Self::ClawbackOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClawbackClaimableBalanceOp => Ok(Self::ClawbackClaimableBalanceOp(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::SetTrustLineFlagsOp => Ok(Self::SetTrustLineFlagsOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LiquidityPoolDepositOp => Ok(Self::LiquidityPoolDepositOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LiquidityPoolWithdrawOp => Ok(Self::LiquidityPoolWithdrawOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::HostFunctionType => Ok(Self::HostFunctionType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractIdPreimageType => Ok(Self::ContractIdPreimageType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractIdPreimage => Ok(Self::ContractIdPreimage(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::CreateContractArgs => Ok(Self::CreateContractArgs(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::CreateContractArgsV2 => Ok(Self::CreateContractArgsV2(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::InvokeContractArgs => Ok(Self::InvokeContractArgs(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::HostFunction => Ok(Self::HostFunction(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SorobanAuthorizedFunctionType => Ok(Self::SorobanAuthorizedFunctionType(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::SorobanAuthorizedFunction => Ok(Self::SorobanAuthorizedFunction(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::SorobanAuthorizedInvocation => Ok(Self::SorobanAuthorizedInvocation(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::SorobanAddressCredentials => Ok(Self::SorobanAddressCredentials(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::SorobanCredentialsType => Ok(Self::SorobanCredentialsType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SorobanCredentials => Ok(Self::SorobanCredentials(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SorobanAuthorizationEntry => Ok(Self::SorobanAuthorizationEntry(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::SorobanAuthorizationEntries => Ok(Self::SorobanAuthorizationEntries(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::InvokeHostFunctionOp => Ok(Self::InvokeHostFunctionOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ExtendFootprintTtlOp => Ok(Self::ExtendFootprintTtlOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::RestoreFootprintOp => Ok(Self::RestoreFootprintOp(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Operation => Ok(Self::Operation(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::HashIdPreimage => Ok(Self::HashIdPreimage(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::MemoType => Ok(Self::MemoType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Memo => Ok(Self::Memo(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::TimeBounds => Ok(Self::TimeBounds(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerBounds => Ok(Self::LedgerBounds(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PreconditionsV2 => Ok(Self::PreconditionsV2(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PreconditionType => Ok(Self::PreconditionType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Preconditions => Ok(Self::Preconditions(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LedgerFootprint => Ok(Self::LedgerFootprint(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SorobanResources => Ok(Self::SorobanResources(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SorobanResourcesExtV0 => Ok(Self::SorobanResourcesExtV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SorobanTransactionData => Ok(Self::SorobanTransactionData(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionV0 => Ok(Self::TransactionV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionV0Envelope => Ok(Self::TransactionV0Envelope(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Transaction => Ok(Self::Transaction(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionV1Envelope => Ok(Self::TransactionV1Envelope(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::FeeBumpTransaction => Ok(Self::FeeBumpTransaction(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::FeeBumpTransactionEnvelope => Ok(Self::FeeBumpTransactionEnvelope(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::TransactionEnvelope => Ok(Self::TransactionEnvelope(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionSignaturePayload => Ok(Self::TransactionSignaturePayload(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::ClaimAtomType => Ok(Self::ClaimAtomType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimOfferAtomV0 => Ok(Self::ClaimOfferAtomV0(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimOfferAtom => Ok(Self::ClaimOfferAtom(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimLiquidityAtom => Ok(Self::ClaimLiquidityAtom(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimAtom => Ok(Self::ClaimAtom(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::CreateAccountResultCode => Ok(Self::CreateAccountResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::CreateAccountResult => Ok(Self::CreateAccountResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PaymentResultCode => Ok(Self::PaymentResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PaymentResult => Ok(Self::PaymentResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PathPaymentStrictReceiveResultCode => {
                Ok(Self::PathPaymentStrictReceiveResultCode(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::SimplePaymentResult => Ok(Self::SimplePaymentResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PathPaymentStrictReceiveResult => {
                Ok(Self::PathPaymentStrictReceiveResult(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::PathPaymentStrictSendResultCode => {
                Ok(Self::PathPaymentStrictSendResultCode(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::PathPaymentStrictSendResult => Ok(Self::PathPaymentStrictSendResult(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::ManageSellOfferResultCode => Ok(Self::ManageSellOfferResultCode(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::ManageOfferEffect => Ok(Self::ManageOfferEffect(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ManageOfferSuccessResult => Ok(Self::ManageOfferSuccessResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ManageSellOfferResult => Ok(Self::ManageSellOfferResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ManageBuyOfferResultCode => Ok(Self::ManageBuyOfferResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ManageBuyOfferResult => Ok(Self::ManageBuyOfferResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SetOptionsResultCode => Ok(Self::SetOptionsResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SetOptionsResult => Ok(Self::SetOptionsResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ChangeTrustResultCode => Ok(Self::ChangeTrustResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ChangeTrustResult => Ok(Self::ChangeTrustResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AllowTrustResultCode => Ok(Self::AllowTrustResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AllowTrustResult => Ok(Self::AllowTrustResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AccountMergeResultCode => Ok(Self::AccountMergeResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::AccountMergeResult => Ok(Self::AccountMergeResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::InflationResultCode => Ok(Self::InflationResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::InflationPayout => Ok(Self::InflationPayout(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::InflationResult => Ok(Self::InflationResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ManageDataResultCode => Ok(Self::ManageDataResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ManageDataResult => Ok(Self::ManageDataResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::BumpSequenceResultCode => Ok(Self::BumpSequenceResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::BumpSequenceResult => Ok(Self::BumpSequenceResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::CreateClaimableBalanceResultCode => {
                Ok(Self::CreateClaimableBalanceResultCode(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::CreateClaimableBalanceResult => Ok(Self::CreateClaimableBalanceResult(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::ClaimClaimableBalanceResultCode => {
                Ok(Self::ClaimClaimableBalanceResultCode(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ClaimClaimableBalanceResult => Ok(Self::ClaimClaimableBalanceResult(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::BeginSponsoringFutureReservesResultCode => {
                Ok(Self::BeginSponsoringFutureReservesResultCode(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::BeginSponsoringFutureReservesResult => {
                Ok(Self::BeginSponsoringFutureReservesResult(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::EndSponsoringFutureReservesResultCode => {
                Ok(Self::EndSponsoringFutureReservesResultCode(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::EndSponsoringFutureReservesResult => {
                Ok(Self::EndSponsoringFutureReservesResult(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::RevokeSponsorshipResultCode => Ok(Self::RevokeSponsorshipResultCode(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::RevokeSponsorshipResult => Ok(Self::RevokeSponsorshipResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClawbackResultCode => Ok(Self::ClawbackResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClawbackResult => Ok(Self::ClawbackResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClawbackClaimableBalanceResultCode => {
                Ok(Self::ClawbackClaimableBalanceResultCode(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::ClawbackClaimableBalanceResult => {
                Ok(Self::ClawbackClaimableBalanceResult(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::SetTrustLineFlagsResultCode => Ok(Self::SetTrustLineFlagsResultCode(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::SetTrustLineFlagsResult => Ok(Self::SetTrustLineFlagsResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::LiquidityPoolDepositResultCode => {
                Ok(Self::LiquidityPoolDepositResultCode(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::LiquidityPoolDepositResult => Ok(Self::LiquidityPoolDepositResult(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::LiquidityPoolWithdrawResultCode => {
                Ok(Self::LiquidityPoolWithdrawResultCode(Box::new(
                    serde::de::Deserialize::deserialize(r)?,
                )))
            }

            TypeVariant::LiquidityPoolWithdrawResult => Ok(Self::LiquidityPoolWithdrawResult(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::InvokeHostFunctionResultCode => Ok(Self::InvokeHostFunctionResultCode(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::InvokeHostFunctionResult => Ok(Self::InvokeHostFunctionResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ExtendFootprintTtlResultCode => Ok(Self::ExtendFootprintTtlResultCode(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::ExtendFootprintTtlResult => Ok(Self::ExtendFootprintTtlResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::RestoreFootprintResultCode => Ok(Self::RestoreFootprintResultCode(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::RestoreFootprintResult => Ok(Self::RestoreFootprintResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::OperationResultCode => Ok(Self::OperationResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::OperationResult => Ok(Self::OperationResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::TransactionResultCode => Ok(Self::TransactionResultCode(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::InnerTransactionResult => Ok(Self::InnerTransactionResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::InnerTransactionResultPair => Ok(Self::InnerTransactionResultPair(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::TransactionResult => Ok(Self::TransactionResult(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Hash => Ok(Self::Hash(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::Uint256 => Ok(Self::Uint256(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Uint32 => Ok(Self::Uint32(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::Int32 => Ok(Self::Int32(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::Uint64 => Ok(Self::Uint64(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::Int64 => Ok(Self::Int64(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::TimePoint => Ok(Self::TimePoint(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Duration => Ok(Self::Duration(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ExtensionPoint => Ok(Self::ExtensionPoint(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::CryptoKeyType => Ok(Self::CryptoKeyType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PublicKeyType => Ok(Self::PublicKeyType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SignerKeyType => Ok(Self::SignerKeyType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::PublicKey => Ok(Self::PublicKey(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SignerKey => Ok(Self::SignerKey(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Signature => Ok(Self::Signature(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SignatureHint => Ok(Self::SignatureHint(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::NodeId => Ok(Self::NodeId(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::AccountId => Ok(Self::AccountId(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ContractId => Ok(Self::ContractId(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Curve25519Secret => Ok(Self::Curve25519Secret(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::Curve25519Public => Ok(Self::Curve25519Public(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::HmacSha256Key => Ok(Self::HmacSha256Key(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::HmacSha256Mac => Ok(Self::HmacSha256Mac(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ShortHashSeed => Ok(Self::ShortHashSeed(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::BinaryFuseFilterType => Ok(Self::BinaryFuseFilterType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::SerializedBinaryFuseFilter => Ok(Self::SerializedBinaryFuseFilter(
                Box::new(serde::de::Deserialize::deserialize(r)?),
            )),

            TypeVariant::PoolId => Ok(Self::PoolId(Box::new(serde::de::Deserialize::deserialize(
                r,
            )?))),

            TypeVariant::ClaimableBalanceIdType => Ok(Self::ClaimableBalanceIdType(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),

            TypeVariant::ClaimableBalanceId => Ok(Self::ClaimableBalanceId(Box::new(
                serde::de::Deserialize::deserialize(r)?,
            ))),
        }
    }

    #[cfg(feature = "arbitrary")]
    #[allow(clippy::too_many_lines)]
    pub fn arbitrary(v: TypeVariant, u: &mut arbitrary::Unstructured<'_>) -> Result<Self, Error> {
        match v {
            TypeVariant::ScpStatementPrepare => Ok(Self::ScpStatementPrepare(Box::new(
                ScpStatementPrepare::arbitrary(u)?,
            ))),

            TypeVariant::ScpStatementConfirm => Ok(Self::ScpStatementConfirm(Box::new(
                ScpStatementConfirm::arbitrary(u)?,
            ))),

            TypeVariant::ScpStatementExternalize => Ok(Self::ScpStatementExternalize(Box::new(
                ScpStatementExternalize::arbitrary(u)?,
            ))),

            TypeVariant::ScpStatementPledges => Ok(Self::ScpStatementPledges(Box::new(
                ScpStatementPledges::arbitrary(u)?,
            ))),

            TypeVariant::ScEnvMetaEntryInterfaceVersion => {
                Ok(Self::ScEnvMetaEntryInterfaceVersion(Box::new(
                    ScEnvMetaEntryInterfaceVersion::arbitrary(u)?,
                )))
            }

            TypeVariant::AccountEntryExtensionV2Ext => Ok(Self::AccountEntryExtensionV2Ext(
                Box::new(AccountEntryExtensionV2Ext::arbitrary(u)?),
            )),

            TypeVariant::AccountEntryExtensionV1Ext => Ok(Self::AccountEntryExtensionV1Ext(
                Box::new(AccountEntryExtensionV1Ext::arbitrary(u)?),
            )),

            TypeVariant::AccountEntryExt => Ok(Self::AccountEntryExt(Box::new(
                AccountEntryExt::arbitrary(u)?,
            ))),

            TypeVariant::TrustLineEntryExtensionV2Ext => Ok(Self::TrustLineEntryExtensionV2Ext(
                Box::new(TrustLineEntryExtensionV2Ext::arbitrary(u)?),
            )),

            TypeVariant::TrustLineEntryV1Ext => Ok(Self::TrustLineEntryV1Ext(Box::new(
                TrustLineEntryV1Ext::arbitrary(u)?,
            ))),

            TypeVariant::TrustLineEntryV1 => Ok(Self::TrustLineEntryV1(Box::new(
                TrustLineEntryV1::arbitrary(u)?,
            ))),

            TypeVariant::TrustLineEntryExt => Ok(Self::TrustLineEntryExt(Box::new(
                TrustLineEntryExt::arbitrary(u)?,
            ))),

            TypeVariant::OfferEntryExt => {
                Ok(Self::OfferEntryExt(Box::new(OfferEntryExt::arbitrary(u)?)))
            }

            TypeVariant::DataEntryExt => {
                Ok(Self::DataEntryExt(Box::new(DataEntryExt::arbitrary(u)?)))
            }

            TypeVariant::ClaimantV0 => Ok(Self::ClaimantV0(Box::new(ClaimantV0::arbitrary(u)?))),

            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => {
                Ok(Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(
                    ClaimableBalanceEntryExtensionV1Ext::arbitrary(u)?,
                )))
            }

            TypeVariant::ClaimableBalanceEntryExt => Ok(Self::ClaimableBalanceEntryExt(Box::new(
                ClaimableBalanceEntryExt::arbitrary(u)?,
            ))),

            TypeVariant::LiquidityPoolEntryConstantProduct => {
                Ok(Self::LiquidityPoolEntryConstantProduct(Box::new(
                    LiquidityPoolEntryConstantProduct::arbitrary(u)?,
                )))
            }

            TypeVariant::LiquidityPoolEntryBody => Ok(Self::LiquidityPoolEntryBody(Box::new(
                LiquidityPoolEntryBody::arbitrary(u)?,
            ))),

            TypeVariant::ContractCodeEntryV1 => Ok(Self::ContractCodeEntryV1(Box::new(
                ContractCodeEntryV1::arbitrary(u)?,
            ))),

            TypeVariant::ContractCodeEntryExt => Ok(Self::ContractCodeEntryExt(Box::new(
                ContractCodeEntryExt::arbitrary(u)?,
            ))),

            TypeVariant::LedgerEntryExtensionV1Ext => Ok(Self::LedgerEntryExtensionV1Ext(
                Box::new(LedgerEntryExtensionV1Ext::arbitrary(u)?),
            )),

            TypeVariant::LedgerEntryData => Ok(Self::LedgerEntryData(Box::new(
                LedgerEntryData::arbitrary(u)?,
            ))),

            TypeVariant::LedgerEntryExt => Ok(Self::LedgerEntryExt(Box::new(
                LedgerEntryExt::arbitrary(u)?,
            ))),

            TypeVariant::LedgerKeyAccount => Ok(Self::LedgerKeyAccount(Box::new(
                LedgerKeyAccount::arbitrary(u)?,
            ))),

            TypeVariant::LedgerKeyTrustLine => Ok(Self::LedgerKeyTrustLine(Box::new(
                LedgerKeyTrustLine::arbitrary(u)?,
            ))),

            TypeVariant::LedgerKeyOffer => Ok(Self::LedgerKeyOffer(Box::new(
                LedgerKeyOffer::arbitrary(u)?,
            ))),

            TypeVariant::LedgerKeyData => {
                Ok(Self::LedgerKeyData(Box::new(LedgerKeyData::arbitrary(u)?)))
            }

            TypeVariant::LedgerKeyClaimableBalance => Ok(Self::LedgerKeyClaimableBalance(
                Box::new(LedgerKeyClaimableBalance::arbitrary(u)?),
            )),

            TypeVariant::LedgerKeyLiquidityPool => Ok(Self::LedgerKeyLiquidityPool(Box::new(
                LedgerKeyLiquidityPool::arbitrary(u)?,
            ))),

            TypeVariant::LedgerKeyContractData => Ok(Self::LedgerKeyContractData(Box::new(
                LedgerKeyContractData::arbitrary(u)?,
            ))),

            TypeVariant::LedgerKeyContractCode => Ok(Self::LedgerKeyContractCode(Box::new(
                LedgerKeyContractCode::arbitrary(u)?,
            ))),

            TypeVariant::LedgerKeyConfigSetting => Ok(Self::LedgerKeyConfigSetting(Box::new(
                LedgerKeyConfigSetting::arbitrary(u)?,
            ))),

            TypeVariant::LedgerKeyTtl => {
                Ok(Self::LedgerKeyTtl(Box::new(LedgerKeyTtl::arbitrary(u)?)))
            }

            TypeVariant::BucketMetadataExt => Ok(Self::BucketMetadataExt(Box::new(
                BucketMetadataExt::arbitrary(u)?,
            ))),

            TypeVariant::StellarValueExt => Ok(Self::StellarValueExt(Box::new(
                StellarValueExt::arbitrary(u)?,
            ))),

            TypeVariant::LedgerHeaderExtensionV1Ext => Ok(Self::LedgerHeaderExtensionV1Ext(
                Box::new(LedgerHeaderExtensionV1Ext::arbitrary(u)?),
            )),

            TypeVariant::LedgerHeaderExt => Ok(Self::LedgerHeaderExt(Box::new(
                LedgerHeaderExt::arbitrary(u)?,
            ))),

            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => {
                Ok(Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(
                    TxSetComponentTxsMaybeDiscountedFee::arbitrary(u)?,
                )))
            }

            TypeVariant::TransactionHistoryEntryExt => Ok(Self::TransactionHistoryEntryExt(
                Box::new(TransactionHistoryEntryExt::arbitrary(u)?),
            )),

            TypeVariant::TransactionHistoryResultEntryExt => {
                Ok(Self::TransactionHistoryResultEntryExt(Box::new(
                    TransactionHistoryResultEntryExt::arbitrary(u)?,
                )))
            }

            TypeVariant::LedgerHeaderHistoryEntryExt => Ok(Self::LedgerHeaderHistoryEntryExt(
                Box::new(LedgerHeaderHistoryEntryExt::arbitrary(u)?),
            )),

            TypeVariant::ContractEventV0 => Ok(Self::ContractEventV0(Box::new(
                ContractEventV0::arbitrary(u)?,
            ))),

            TypeVariant::ContractEventBody => Ok(Self::ContractEventBody(Box::new(
                ContractEventBody::arbitrary(u)?,
            ))),

            TypeVariant::PeerAddressIp => {
                Ok(Self::PeerAddressIp(Box::new(PeerAddressIp::arbitrary(u)?)))
            }

            TypeVariant::AuthenticatedMessageV0 => Ok(Self::AuthenticatedMessageV0(Box::new(
                AuthenticatedMessageV0::arbitrary(u)?,
            ))),

            TypeVariant::MuxedAccountMed25519 => Ok(Self::MuxedAccountMed25519(Box::new(
                MuxedAccountMed25519::arbitrary(u)?,
            ))),

            TypeVariant::RevokeSponsorshipOpSigner => Ok(Self::RevokeSponsorshipOpSigner(
                Box::new(RevokeSponsorshipOpSigner::arbitrary(u)?),
            )),

            TypeVariant::ContractIdPreimageFromAddress => Ok(Self::ContractIdPreimageFromAddress(
                Box::new(ContractIdPreimageFromAddress::arbitrary(u)?),
            )),

            TypeVariant::OperationBody => {
                Ok(Self::OperationBody(Box::new(OperationBody::arbitrary(u)?)))
            }

            TypeVariant::HashIdPreimageOperationId => Ok(Self::HashIdPreimageOperationId(
                Box::new(HashIdPreimageOperationId::arbitrary(u)?),
            )),

            TypeVariant::HashIdPreimageRevokeId => Ok(Self::HashIdPreimageRevokeId(Box::new(
                HashIdPreimageRevokeId::arbitrary(u)?,
            ))),

            TypeVariant::HashIdPreimageContractId => Ok(Self::HashIdPreimageContractId(Box::new(
                HashIdPreimageContractId::arbitrary(u)?,
            ))),

            TypeVariant::HashIdPreimageSorobanAuthorization => {
                Ok(Self::HashIdPreimageSorobanAuthorization(Box::new(
                    HashIdPreimageSorobanAuthorization::arbitrary(u)?,
                )))
            }

            TypeVariant::SorobanTransactionDataExt => Ok(Self::SorobanTransactionDataExt(
                Box::new(SorobanTransactionDataExt::arbitrary(u)?),
            )),

            TypeVariant::TransactionV0Ext => Ok(Self::TransactionV0Ext(Box::new(
                TransactionV0Ext::arbitrary(u)?,
            ))),

            TypeVariant::TransactionExt => Ok(Self::TransactionExt(Box::new(
                TransactionExt::arbitrary(u)?,
            ))),

            TypeVariant::FeeBumpTransactionInnerTx => Ok(Self::FeeBumpTransactionInnerTx(
                Box::new(FeeBumpTransactionInnerTx::arbitrary(u)?),
            )),

            TypeVariant::FeeBumpTransactionExt => Ok(Self::FeeBumpTransactionExt(Box::new(
                FeeBumpTransactionExt::arbitrary(u)?,
            ))),

            TypeVariant::TransactionSignaturePayloadTaggedTransaction => {
                Ok(Self::TransactionSignaturePayloadTaggedTransaction(
                    Box::new(TransactionSignaturePayloadTaggedTransaction::arbitrary(u)?),
                ))
            }

            TypeVariant::PathPaymentStrictReceiveResultSuccess => {
                Ok(Self::PathPaymentStrictReceiveResultSuccess(Box::new(
                    PathPaymentStrictReceiveResultSuccess::arbitrary(u)?,
                )))
            }

            TypeVariant::PathPaymentStrictSendResultSuccess => {
                Ok(Self::PathPaymentStrictSendResultSuccess(Box::new(
                    PathPaymentStrictSendResultSuccess::arbitrary(u)?,
                )))
            }

            TypeVariant::ManageOfferSuccessResultOffer => Ok(Self::ManageOfferSuccessResultOffer(
                Box::new(ManageOfferSuccessResultOffer::arbitrary(u)?),
            )),

            TypeVariant::OperationResultTr => Ok(Self::OperationResultTr(Box::new(
                OperationResultTr::arbitrary(u)?,
            ))),

            TypeVariant::InnerTransactionResultResult => Ok(Self::InnerTransactionResultResult(
                Box::new(InnerTransactionResultResult::arbitrary(u)?),
            )),

            TypeVariant::InnerTransactionResultExt => Ok(Self::InnerTransactionResultExt(
                Box::new(InnerTransactionResultExt::arbitrary(u)?),
            )),

            TypeVariant::TransactionResultResult => Ok(Self::TransactionResultResult(Box::new(
                TransactionResultResult::arbitrary(u)?,
            ))),

            TypeVariant::TransactionResultExt => Ok(Self::TransactionResultExt(Box::new(
                TransactionResultExt::arbitrary(u)?,
            ))),

            TypeVariant::SignerKeyEd25519SignedPayload => Ok(Self::SignerKeyEd25519SignedPayload(
                Box::new(SignerKeyEd25519SignedPayload::arbitrary(u)?),
            )),

            TypeVariant::Value => Ok(Self::Value(Box::new(Value::arbitrary(u)?))),

            TypeVariant::ScpBallot => Ok(Self::ScpBallot(Box::new(ScpBallot::arbitrary(u)?))),

            TypeVariant::ScpStatementType => Ok(Self::ScpStatementType(Box::new(
                ScpStatementType::arbitrary(u)?,
            ))),

            TypeVariant::ScpNomination => {
                Ok(Self::ScpNomination(Box::new(ScpNomination::arbitrary(u)?)))
            }

            TypeVariant::ScpStatement => {
                Ok(Self::ScpStatement(Box::new(ScpStatement::arbitrary(u)?)))
            }

            TypeVariant::ScpEnvelope => Ok(Self::ScpEnvelope(Box::new(ScpEnvelope::arbitrary(u)?))),

            TypeVariant::ScpQuorumSet => {
                Ok(Self::ScpQuorumSet(Box::new(ScpQuorumSet::arbitrary(u)?)))
            }

            TypeVariant::ConfigSettingContractExecutionLanesV0 => {
                Ok(Self::ConfigSettingContractExecutionLanesV0(Box::new(
                    ConfigSettingContractExecutionLanesV0::arbitrary(u)?,
                )))
            }

            TypeVariant::ConfigSettingContractComputeV0 => {
                Ok(Self::ConfigSettingContractComputeV0(Box::new(
                    ConfigSettingContractComputeV0::arbitrary(u)?,
                )))
            }

            TypeVariant::ConfigSettingContractParallelComputeV0 => {
                Ok(Self::ConfigSettingContractParallelComputeV0(Box::new(
                    ConfigSettingContractParallelComputeV0::arbitrary(u)?,
                )))
            }

            TypeVariant::ConfigSettingContractLedgerCostV0 => {
                Ok(Self::ConfigSettingContractLedgerCostV0(Box::new(
                    ConfigSettingContractLedgerCostV0::arbitrary(u)?,
                )))
            }

            TypeVariant::ConfigSettingContractLedgerCostExtV0 => {
                Ok(Self::ConfigSettingContractLedgerCostExtV0(Box::new(
                    ConfigSettingContractLedgerCostExtV0::arbitrary(u)?,
                )))
            }

            TypeVariant::ConfigSettingContractHistoricalDataV0 => {
                Ok(Self::ConfigSettingContractHistoricalDataV0(Box::new(
                    ConfigSettingContractHistoricalDataV0::arbitrary(u)?,
                )))
            }

            TypeVariant::ConfigSettingContractEventsV0 => Ok(Self::ConfigSettingContractEventsV0(
                Box::new(ConfigSettingContractEventsV0::arbitrary(u)?),
            )),

            TypeVariant::ConfigSettingContractBandwidthV0 => {
                Ok(Self::ConfigSettingContractBandwidthV0(Box::new(
                    ConfigSettingContractBandwidthV0::arbitrary(u)?,
                )))
            }

            TypeVariant::ContractCostType => Ok(Self::ContractCostType(Box::new(
                ContractCostType::arbitrary(u)?,
            ))),

            TypeVariant::ContractCostParamEntry => Ok(Self::ContractCostParamEntry(Box::new(
                ContractCostParamEntry::arbitrary(u)?,
            ))),

            TypeVariant::StateArchivalSettings => Ok(Self::StateArchivalSettings(Box::new(
                StateArchivalSettings::arbitrary(u)?,
            ))),

            TypeVariant::EvictionIterator => Ok(Self::EvictionIterator(Box::new(
                EvictionIterator::arbitrary(u)?,
            ))),

            TypeVariant::ConfigSettingScpTiming => Ok(Self::ConfigSettingScpTiming(Box::new(
                ConfigSettingScpTiming::arbitrary(u)?,
            ))),

            TypeVariant::ContractCostParams => Ok(Self::ContractCostParams(Box::new(
                ContractCostParams::arbitrary(u)?,
            ))),

            TypeVariant::ConfigSettingId => Ok(Self::ConfigSettingId(Box::new(
                ConfigSettingId::arbitrary(u)?,
            ))),

            TypeVariant::ConfigSettingEntry => Ok(Self::ConfigSettingEntry(Box::new(
                ConfigSettingEntry::arbitrary(u)?,
            ))),

            TypeVariant::ScEnvMetaKind => {
                Ok(Self::ScEnvMetaKind(Box::new(ScEnvMetaKind::arbitrary(u)?)))
            }

            TypeVariant::ScEnvMetaEntry => Ok(Self::ScEnvMetaEntry(Box::new(
                ScEnvMetaEntry::arbitrary(u)?,
            ))),

            TypeVariant::ScMetaV0 => Ok(Self::ScMetaV0(Box::new(ScMetaV0::arbitrary(u)?))),

            TypeVariant::ScMetaKind => Ok(Self::ScMetaKind(Box::new(ScMetaKind::arbitrary(u)?))),

            TypeVariant::ScMetaEntry => Ok(Self::ScMetaEntry(Box::new(ScMetaEntry::arbitrary(u)?))),

            TypeVariant::ScSpecType => Ok(Self::ScSpecType(Box::new(ScSpecType::arbitrary(u)?))),

            TypeVariant::ScSpecTypeOption => Ok(Self::ScSpecTypeOption(Box::new(
                ScSpecTypeOption::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecTypeResult => Ok(Self::ScSpecTypeResult(Box::new(
                ScSpecTypeResult::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecTypeVec => {
                Ok(Self::ScSpecTypeVec(Box::new(ScSpecTypeVec::arbitrary(u)?)))
            }

            TypeVariant::ScSpecTypeMap => {
                Ok(Self::ScSpecTypeMap(Box::new(ScSpecTypeMap::arbitrary(u)?)))
            }

            TypeVariant::ScSpecTypeTuple => Ok(Self::ScSpecTypeTuple(Box::new(
                ScSpecTypeTuple::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecTypeBytesN => Ok(Self::ScSpecTypeBytesN(Box::new(
                ScSpecTypeBytesN::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecTypeUdt => {
                Ok(Self::ScSpecTypeUdt(Box::new(ScSpecTypeUdt::arbitrary(u)?)))
            }

            TypeVariant::ScSpecTypeDef => {
                Ok(Self::ScSpecTypeDef(Box::new(ScSpecTypeDef::arbitrary(u)?)))
            }

            TypeVariant::ScSpecUdtStructFieldV0 => Ok(Self::ScSpecUdtStructFieldV0(Box::new(
                ScSpecUdtStructFieldV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecUdtStructV0 => Ok(Self::ScSpecUdtStructV0(Box::new(
                ScSpecUdtStructV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecUdtUnionCaseVoidV0 => Ok(Self::ScSpecUdtUnionCaseVoidV0(Box::new(
                ScSpecUdtUnionCaseVoidV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecUdtUnionCaseTupleV0 => Ok(Self::ScSpecUdtUnionCaseTupleV0(
                Box::new(ScSpecUdtUnionCaseTupleV0::arbitrary(u)?),
            )),

            TypeVariant::ScSpecUdtUnionCaseV0Kind => Ok(Self::ScSpecUdtUnionCaseV0Kind(Box::new(
                ScSpecUdtUnionCaseV0Kind::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecUdtUnionCaseV0 => Ok(Self::ScSpecUdtUnionCaseV0(Box::new(
                ScSpecUdtUnionCaseV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecUdtUnionV0 => Ok(Self::ScSpecUdtUnionV0(Box::new(
                ScSpecUdtUnionV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecUdtEnumCaseV0 => Ok(Self::ScSpecUdtEnumCaseV0(Box::new(
                ScSpecUdtEnumCaseV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecUdtEnumV0 => Ok(Self::ScSpecUdtEnumV0(Box::new(
                ScSpecUdtEnumV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecUdtErrorEnumCaseV0 => Ok(Self::ScSpecUdtErrorEnumCaseV0(Box::new(
                ScSpecUdtErrorEnumCaseV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecUdtErrorEnumV0 => Ok(Self::ScSpecUdtErrorEnumV0(Box::new(
                ScSpecUdtErrorEnumV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecFunctionInputV0 => Ok(Self::ScSpecFunctionInputV0(Box::new(
                ScSpecFunctionInputV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecFunctionV0 => Ok(Self::ScSpecFunctionV0(Box::new(
                ScSpecFunctionV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecEventParamLocationV0 => Ok(Self::ScSpecEventParamLocationV0(
                Box::new(ScSpecEventParamLocationV0::arbitrary(u)?),
            )),

            TypeVariant::ScSpecEventParamV0 => Ok(Self::ScSpecEventParamV0(Box::new(
                ScSpecEventParamV0::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecEventDataFormat => Ok(Self::ScSpecEventDataFormat(Box::new(
                ScSpecEventDataFormat::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecEventV0 => {
                Ok(Self::ScSpecEventV0(Box::new(ScSpecEventV0::arbitrary(u)?)))
            }

            TypeVariant::ScSpecEntryKind => Ok(Self::ScSpecEntryKind(Box::new(
                ScSpecEntryKind::arbitrary(u)?,
            ))),

            TypeVariant::ScSpecEntry => Ok(Self::ScSpecEntry(Box::new(ScSpecEntry::arbitrary(u)?))),

            TypeVariant::ScValType => Ok(Self::ScValType(Box::new(ScValType::arbitrary(u)?))),

            TypeVariant::ScErrorType => Ok(Self::ScErrorType(Box::new(ScErrorType::arbitrary(u)?))),

            TypeVariant::ScErrorCode => Ok(Self::ScErrorCode(Box::new(ScErrorCode::arbitrary(u)?))),

            TypeVariant::ScError => Ok(Self::ScError(Box::new(ScError::arbitrary(u)?))),

            TypeVariant::UInt128Parts => {
                Ok(Self::UInt128Parts(Box::new(UInt128Parts::arbitrary(u)?)))
            }

            TypeVariant::Int128Parts => Ok(Self::Int128Parts(Box::new(Int128Parts::arbitrary(u)?))),

            TypeVariant::UInt256Parts => {
                Ok(Self::UInt256Parts(Box::new(UInt256Parts::arbitrary(u)?)))
            }

            TypeVariant::Int256Parts => Ok(Self::Int256Parts(Box::new(Int256Parts::arbitrary(u)?))),

            TypeVariant::ContractExecutableType => Ok(Self::ContractExecutableType(Box::new(
                ContractExecutableType::arbitrary(u)?,
            ))),

            TypeVariant::ContractExecutable => Ok(Self::ContractExecutable(Box::new(
                ContractExecutable::arbitrary(u)?,
            ))),

            TypeVariant::ScAddressType => {
                Ok(Self::ScAddressType(Box::new(ScAddressType::arbitrary(u)?)))
            }

            TypeVariant::MuxedEd25519Account => Ok(Self::MuxedEd25519Account(Box::new(
                MuxedEd25519Account::arbitrary(u)?,
            ))),

            TypeVariant::ScAddress => Ok(Self::ScAddress(Box::new(ScAddress::arbitrary(u)?))),

            TypeVariant::ScVec => Ok(Self::ScVec(Box::new(ScVec::arbitrary(u)?))),

            TypeVariant::ScMap => Ok(Self::ScMap(Box::new(ScMap::arbitrary(u)?))),

            TypeVariant::ScBytes => Ok(Self::ScBytes(Box::new(ScBytes::arbitrary(u)?))),

            TypeVariant::ScString => Ok(Self::ScString(Box::new(ScString::arbitrary(u)?))),

            TypeVariant::ScSymbol => Ok(Self::ScSymbol(Box::new(ScSymbol::arbitrary(u)?))),

            TypeVariant::ScNonceKey => Ok(Self::ScNonceKey(Box::new(ScNonceKey::arbitrary(u)?))),

            TypeVariant::ScContractInstance => Ok(Self::ScContractInstance(Box::new(
                ScContractInstance::arbitrary(u)?,
            ))),

            TypeVariant::ScVal => Ok(Self::ScVal(Box::new(ScVal::arbitrary(u)?))),

            TypeVariant::ScMapEntry => Ok(Self::ScMapEntry(Box::new(ScMapEntry::arbitrary(u)?))),

            TypeVariant::LedgerCloseMetaBatch => Ok(Self::LedgerCloseMetaBatch(Box::new(
                LedgerCloseMetaBatch::arbitrary(u)?,
            ))),

            TypeVariant::StoredTransactionSet => Ok(Self::StoredTransactionSet(Box::new(
                StoredTransactionSet::arbitrary(u)?,
            ))),

            TypeVariant::StoredDebugTransactionSet => Ok(Self::StoredDebugTransactionSet(
                Box::new(StoredDebugTransactionSet::arbitrary(u)?),
            )),

            TypeVariant::PersistedScpStateV0 => Ok(Self::PersistedScpStateV0(Box::new(
                PersistedScpStateV0::arbitrary(u)?,
            ))),

            TypeVariant::PersistedScpStateV1 => Ok(Self::PersistedScpStateV1(Box::new(
                PersistedScpStateV1::arbitrary(u)?,
            ))),

            TypeVariant::PersistedScpState => Ok(Self::PersistedScpState(Box::new(
                PersistedScpState::arbitrary(u)?,
            ))),

            TypeVariant::Thresholds => Ok(Self::Thresholds(Box::new(Thresholds::arbitrary(u)?))),

            TypeVariant::String32 => Ok(Self::String32(Box::new(String32::arbitrary(u)?))),

            TypeVariant::String64 => Ok(Self::String64(Box::new(String64::arbitrary(u)?))),

            TypeVariant::SequenceNumber => Ok(Self::SequenceNumber(Box::new(
                SequenceNumber::arbitrary(u)?,
            ))),

            TypeVariant::DataValue => Ok(Self::DataValue(Box::new(DataValue::arbitrary(u)?))),

            TypeVariant::AssetCode4 => Ok(Self::AssetCode4(Box::new(AssetCode4::arbitrary(u)?))),

            TypeVariant::AssetCode12 => Ok(Self::AssetCode12(Box::new(AssetCode12::arbitrary(u)?))),

            TypeVariant::AssetType => Ok(Self::AssetType(Box::new(AssetType::arbitrary(u)?))),

            TypeVariant::AssetCode => Ok(Self::AssetCode(Box::new(AssetCode::arbitrary(u)?))),

            TypeVariant::AlphaNum4 => Ok(Self::AlphaNum4(Box::new(AlphaNum4::arbitrary(u)?))),

            TypeVariant::AlphaNum12 => Ok(Self::AlphaNum12(Box::new(AlphaNum12::arbitrary(u)?))),

            TypeVariant::Asset => Ok(Self::Asset(Box::new(Asset::arbitrary(u)?))),

            TypeVariant::Price => Ok(Self::Price(Box::new(Price::arbitrary(u)?))),

            TypeVariant::Liabilities => Ok(Self::Liabilities(Box::new(Liabilities::arbitrary(u)?))),

            TypeVariant::ThresholdIndexes => Ok(Self::ThresholdIndexes(Box::new(
                ThresholdIndexes::arbitrary(u)?,
            ))),

            TypeVariant::LedgerEntryType => Ok(Self::LedgerEntryType(Box::new(
                LedgerEntryType::arbitrary(u)?,
            ))),

            TypeVariant::Signer => Ok(Self::Signer(Box::new(Signer::arbitrary(u)?))),

            TypeVariant::AccountFlags => {
                Ok(Self::AccountFlags(Box::new(AccountFlags::arbitrary(u)?)))
            }

            TypeVariant::SponsorshipDescriptor => Ok(Self::SponsorshipDescriptor(Box::new(
                SponsorshipDescriptor::arbitrary(u)?,
            ))),

            TypeVariant::AccountEntryExtensionV3 => Ok(Self::AccountEntryExtensionV3(Box::new(
                AccountEntryExtensionV3::arbitrary(u)?,
            ))),

            TypeVariant::AccountEntryExtensionV2 => Ok(Self::AccountEntryExtensionV2(Box::new(
                AccountEntryExtensionV2::arbitrary(u)?,
            ))),

            TypeVariant::AccountEntryExtensionV1 => Ok(Self::AccountEntryExtensionV1(Box::new(
                AccountEntryExtensionV1::arbitrary(u)?,
            ))),

            TypeVariant::AccountEntry => {
                Ok(Self::AccountEntry(Box::new(AccountEntry::arbitrary(u)?)))
            }

            TypeVariant::TrustLineFlags => Ok(Self::TrustLineFlags(Box::new(
                TrustLineFlags::arbitrary(u)?,
            ))),

            TypeVariant::LiquidityPoolType => Ok(Self::LiquidityPoolType(Box::new(
                LiquidityPoolType::arbitrary(u)?,
            ))),

            TypeVariant::TrustLineAsset => Ok(Self::TrustLineAsset(Box::new(
                TrustLineAsset::arbitrary(u)?,
            ))),

            TypeVariant::TrustLineEntryExtensionV2 => Ok(Self::TrustLineEntryExtensionV2(
                Box::new(TrustLineEntryExtensionV2::arbitrary(u)?),
            )),

            TypeVariant::TrustLineEntry => Ok(Self::TrustLineEntry(Box::new(
                TrustLineEntry::arbitrary(u)?,
            ))),

            TypeVariant::OfferEntryFlags => Ok(Self::OfferEntryFlags(Box::new(
                OfferEntryFlags::arbitrary(u)?,
            ))),

            TypeVariant::OfferEntry => Ok(Self::OfferEntry(Box::new(OfferEntry::arbitrary(u)?))),

            TypeVariant::DataEntry => Ok(Self::DataEntry(Box::new(DataEntry::arbitrary(u)?))),

            TypeVariant::ClaimPredicateType => Ok(Self::ClaimPredicateType(Box::new(
                ClaimPredicateType::arbitrary(u)?,
            ))),

            TypeVariant::ClaimPredicate => Ok(Self::ClaimPredicate(Box::new(
                ClaimPredicate::arbitrary(u)?,
            ))),

            TypeVariant::ClaimantType => {
                Ok(Self::ClaimantType(Box::new(ClaimantType::arbitrary(u)?)))
            }

            TypeVariant::Claimant => Ok(Self::Claimant(Box::new(Claimant::arbitrary(u)?))),

            TypeVariant::ClaimableBalanceFlags => Ok(Self::ClaimableBalanceFlags(Box::new(
                ClaimableBalanceFlags::arbitrary(u)?,
            ))),

            TypeVariant::ClaimableBalanceEntryExtensionV1 => {
                Ok(Self::ClaimableBalanceEntryExtensionV1(Box::new(
                    ClaimableBalanceEntryExtensionV1::arbitrary(u)?,
                )))
            }

            TypeVariant::ClaimableBalanceEntry => Ok(Self::ClaimableBalanceEntry(Box::new(
                ClaimableBalanceEntry::arbitrary(u)?,
            ))),

            TypeVariant::LiquidityPoolConstantProductParameters => {
                Ok(Self::LiquidityPoolConstantProductParameters(Box::new(
                    LiquidityPoolConstantProductParameters::arbitrary(u)?,
                )))
            }

            TypeVariant::LiquidityPoolEntry => Ok(Self::LiquidityPoolEntry(Box::new(
                LiquidityPoolEntry::arbitrary(u)?,
            ))),

            TypeVariant::ContractDataDurability => Ok(Self::ContractDataDurability(Box::new(
                ContractDataDurability::arbitrary(u)?,
            ))),

            TypeVariant::ContractDataEntry => Ok(Self::ContractDataEntry(Box::new(
                ContractDataEntry::arbitrary(u)?,
            ))),

            TypeVariant::ContractCodeCostInputs => Ok(Self::ContractCodeCostInputs(Box::new(
                ContractCodeCostInputs::arbitrary(u)?,
            ))),

            TypeVariant::ContractCodeEntry => Ok(Self::ContractCodeEntry(Box::new(
                ContractCodeEntry::arbitrary(u)?,
            ))),

            TypeVariant::TtlEntry => Ok(Self::TtlEntry(Box::new(TtlEntry::arbitrary(u)?))),

            TypeVariant::LedgerEntryExtensionV1 => Ok(Self::LedgerEntryExtensionV1(Box::new(
                LedgerEntryExtensionV1::arbitrary(u)?,
            ))),

            TypeVariant::LedgerEntry => Ok(Self::LedgerEntry(Box::new(LedgerEntry::arbitrary(u)?))),

            TypeVariant::LedgerKey => Ok(Self::LedgerKey(Box::new(LedgerKey::arbitrary(u)?))),

            TypeVariant::EnvelopeType => {
                Ok(Self::EnvelopeType(Box::new(EnvelopeType::arbitrary(u)?)))
            }

            TypeVariant::BucketListType => Ok(Self::BucketListType(Box::new(
                BucketListType::arbitrary(u)?,
            ))),

            TypeVariant::BucketEntryType => Ok(Self::BucketEntryType(Box::new(
                BucketEntryType::arbitrary(u)?,
            ))),

            TypeVariant::HotArchiveBucketEntryType => Ok(Self::HotArchiveBucketEntryType(
                Box::new(HotArchiveBucketEntryType::arbitrary(u)?),
            )),

            TypeVariant::BucketMetadata => Ok(Self::BucketMetadata(Box::new(
                BucketMetadata::arbitrary(u)?,
            ))),

            TypeVariant::BucketEntry => Ok(Self::BucketEntry(Box::new(BucketEntry::arbitrary(u)?))),

            TypeVariant::HotArchiveBucketEntry => Ok(Self::HotArchiveBucketEntry(Box::new(
                HotArchiveBucketEntry::arbitrary(u)?,
            ))),

            TypeVariant::UpgradeType => Ok(Self::UpgradeType(Box::new(UpgradeType::arbitrary(u)?))),

            TypeVariant::StellarValueType => Ok(Self::StellarValueType(Box::new(
                StellarValueType::arbitrary(u)?,
            ))),

            TypeVariant::LedgerCloseValueSignature => Ok(Self::LedgerCloseValueSignature(
                Box::new(LedgerCloseValueSignature::arbitrary(u)?),
            )),

            TypeVariant::StellarValue => {
                Ok(Self::StellarValue(Box::new(StellarValue::arbitrary(u)?)))
            }

            TypeVariant::LedgerHeaderFlags => Ok(Self::LedgerHeaderFlags(Box::new(
                LedgerHeaderFlags::arbitrary(u)?,
            ))),

            TypeVariant::LedgerHeaderExtensionV1 => Ok(Self::LedgerHeaderExtensionV1(Box::new(
                LedgerHeaderExtensionV1::arbitrary(u)?,
            ))),

            TypeVariant::LedgerHeader => {
                Ok(Self::LedgerHeader(Box::new(LedgerHeader::arbitrary(u)?)))
            }

            TypeVariant::LedgerUpgradeType => Ok(Self::LedgerUpgradeType(Box::new(
                LedgerUpgradeType::arbitrary(u)?,
            ))),

            TypeVariant::ConfigUpgradeSetKey => Ok(Self::ConfigUpgradeSetKey(Box::new(
                ConfigUpgradeSetKey::arbitrary(u)?,
            ))),

            TypeVariant::LedgerUpgrade => {
                Ok(Self::LedgerUpgrade(Box::new(LedgerUpgrade::arbitrary(u)?)))
            }

            TypeVariant::ConfigUpgradeSet => Ok(Self::ConfigUpgradeSet(Box::new(
                ConfigUpgradeSet::arbitrary(u)?,
            ))),

            TypeVariant::TxSetComponentType => Ok(Self::TxSetComponentType(Box::new(
                TxSetComponentType::arbitrary(u)?,
            ))),

            TypeVariant::DependentTxCluster => Ok(Self::DependentTxCluster(Box::new(
                DependentTxCluster::arbitrary(u)?,
            ))),

            TypeVariant::ParallelTxExecutionStage => Ok(Self::ParallelTxExecutionStage(Box::new(
                ParallelTxExecutionStage::arbitrary(u)?,
            ))),

            TypeVariant::ParallelTxsComponent => Ok(Self::ParallelTxsComponent(Box::new(
                ParallelTxsComponent::arbitrary(u)?,
            ))),

            TypeVariant::TxSetComponent => Ok(Self::TxSetComponent(Box::new(
                TxSetComponent::arbitrary(u)?,
            ))),

            TypeVariant::TransactionPhase => Ok(Self::TransactionPhase(Box::new(
                TransactionPhase::arbitrary(u)?,
            ))),

            TypeVariant::TransactionSet => Ok(Self::TransactionSet(Box::new(
                TransactionSet::arbitrary(u)?,
            ))),

            TypeVariant::TransactionSetV1 => Ok(Self::TransactionSetV1(Box::new(
                TransactionSetV1::arbitrary(u)?,
            ))),

            TypeVariant::GeneralizedTransactionSet => Ok(Self::GeneralizedTransactionSet(
                Box::new(GeneralizedTransactionSet::arbitrary(u)?),
            )),

            TypeVariant::TransactionResultPair => Ok(Self::TransactionResultPair(Box::new(
                TransactionResultPair::arbitrary(u)?,
            ))),

            TypeVariant::TransactionResultSet => Ok(Self::TransactionResultSet(Box::new(
                TransactionResultSet::arbitrary(u)?,
            ))),

            TypeVariant::TransactionHistoryEntry => Ok(Self::TransactionHistoryEntry(Box::new(
                TransactionHistoryEntry::arbitrary(u)?,
            ))),

            TypeVariant::TransactionHistoryResultEntry => Ok(Self::TransactionHistoryResultEntry(
                Box::new(TransactionHistoryResultEntry::arbitrary(u)?),
            )),

            TypeVariant::LedgerHeaderHistoryEntry => Ok(Self::LedgerHeaderHistoryEntry(Box::new(
                LedgerHeaderHistoryEntry::arbitrary(u)?,
            ))),

            TypeVariant::LedgerScpMessages => Ok(Self::LedgerScpMessages(Box::new(
                LedgerScpMessages::arbitrary(u)?,
            ))),

            TypeVariant::ScpHistoryEntryV0 => Ok(Self::ScpHistoryEntryV0(Box::new(
                ScpHistoryEntryV0::arbitrary(u)?,
            ))),

            TypeVariant::ScpHistoryEntry => Ok(Self::ScpHistoryEntry(Box::new(
                ScpHistoryEntry::arbitrary(u)?,
            ))),

            TypeVariant::LedgerEntryChangeType => Ok(Self::LedgerEntryChangeType(Box::new(
                LedgerEntryChangeType::arbitrary(u)?,
            ))),

            TypeVariant::LedgerEntryChange => Ok(Self::LedgerEntryChange(Box::new(
                LedgerEntryChange::arbitrary(u)?,
            ))),

            TypeVariant::LedgerEntryChanges => Ok(Self::LedgerEntryChanges(Box::new(
                LedgerEntryChanges::arbitrary(u)?,
            ))),

            TypeVariant::OperationMeta => {
                Ok(Self::OperationMeta(Box::new(OperationMeta::arbitrary(u)?)))
            }

            TypeVariant::TransactionMetaV1 => Ok(Self::TransactionMetaV1(Box::new(
                TransactionMetaV1::arbitrary(u)?,
            ))),

            TypeVariant::TransactionMetaV2 => Ok(Self::TransactionMetaV2(Box::new(
                TransactionMetaV2::arbitrary(u)?,
            ))),

            TypeVariant::ContractEventType => Ok(Self::ContractEventType(Box::new(
                ContractEventType::arbitrary(u)?,
            ))),

            TypeVariant::ContractEvent => {
                Ok(Self::ContractEvent(Box::new(ContractEvent::arbitrary(u)?)))
            }

            TypeVariant::DiagnosticEvent => Ok(Self::DiagnosticEvent(Box::new(
                DiagnosticEvent::arbitrary(u)?,
            ))),

            TypeVariant::SorobanTransactionMetaExtV1 => Ok(Self::SorobanTransactionMetaExtV1(
                Box::new(SorobanTransactionMetaExtV1::arbitrary(u)?),
            )),

            TypeVariant::SorobanTransactionMetaExt => Ok(Self::SorobanTransactionMetaExt(
                Box::new(SorobanTransactionMetaExt::arbitrary(u)?),
            )),

            TypeVariant::SorobanTransactionMeta => Ok(Self::SorobanTransactionMeta(Box::new(
                SorobanTransactionMeta::arbitrary(u)?,
            ))),

            TypeVariant::TransactionMetaV3 => Ok(Self::TransactionMetaV3(Box::new(
                TransactionMetaV3::arbitrary(u)?,
            ))),

            TypeVariant::OperationMetaV2 => Ok(Self::OperationMetaV2(Box::new(
                OperationMetaV2::arbitrary(u)?,
            ))),

            TypeVariant::SorobanTransactionMetaV2 => Ok(Self::SorobanTransactionMetaV2(Box::new(
                SorobanTransactionMetaV2::arbitrary(u)?,
            ))),

            TypeVariant::TransactionEventStage => Ok(Self::TransactionEventStage(Box::new(
                TransactionEventStage::arbitrary(u)?,
            ))),

            TypeVariant::TransactionEvent => Ok(Self::TransactionEvent(Box::new(
                TransactionEvent::arbitrary(u)?,
            ))),

            TypeVariant::TransactionMetaV4 => Ok(Self::TransactionMetaV4(Box::new(
                TransactionMetaV4::arbitrary(u)?,
            ))),

            TypeVariant::InvokeHostFunctionSuccessPreImage => {
                Ok(Self::InvokeHostFunctionSuccessPreImage(Box::new(
                    InvokeHostFunctionSuccessPreImage::arbitrary(u)?,
                )))
            }

            TypeVariant::TransactionMeta => Ok(Self::TransactionMeta(Box::new(
                TransactionMeta::arbitrary(u)?,
            ))),

            TypeVariant::TransactionResultMeta => Ok(Self::TransactionResultMeta(Box::new(
                TransactionResultMeta::arbitrary(u)?,
            ))),

            TypeVariant::TransactionResultMetaV1 => Ok(Self::TransactionResultMetaV1(Box::new(
                TransactionResultMetaV1::arbitrary(u)?,
            ))),

            TypeVariant::UpgradeEntryMeta => Ok(Self::UpgradeEntryMeta(Box::new(
                UpgradeEntryMeta::arbitrary(u)?,
            ))),

            TypeVariant::LedgerCloseMetaV0 => Ok(Self::LedgerCloseMetaV0(Box::new(
                LedgerCloseMetaV0::arbitrary(u)?,
            ))),

            TypeVariant::LedgerCloseMetaExtV1 => Ok(Self::LedgerCloseMetaExtV1(Box::new(
                LedgerCloseMetaExtV1::arbitrary(u)?,
            ))),

            TypeVariant::LedgerCloseMetaExt => Ok(Self::LedgerCloseMetaExt(Box::new(
                LedgerCloseMetaExt::arbitrary(u)?,
            ))),

            TypeVariant::LedgerCloseMetaV1 => Ok(Self::LedgerCloseMetaV1(Box::new(
                LedgerCloseMetaV1::arbitrary(u)?,
            ))),

            TypeVariant::LedgerCloseMetaV2 => Ok(Self::LedgerCloseMetaV2(Box::new(
                LedgerCloseMetaV2::arbitrary(u)?,
            ))),

            TypeVariant::LedgerCloseMeta => Ok(Self::LedgerCloseMeta(Box::new(
                LedgerCloseMeta::arbitrary(u)?,
            ))),

            TypeVariant::ErrorCode => Ok(Self::ErrorCode(Box::new(ErrorCode::arbitrary(u)?))),

            TypeVariant::SError => Ok(Self::SError(Box::new(SError::arbitrary(u)?))),

            TypeVariant::SendMore => Ok(Self::SendMore(Box::new(SendMore::arbitrary(u)?))),

            TypeVariant::SendMoreExtended => Ok(Self::SendMoreExtended(Box::new(
                SendMoreExtended::arbitrary(u)?,
            ))),

            TypeVariant::AuthCert => Ok(Self::AuthCert(Box::new(AuthCert::arbitrary(u)?))),

            TypeVariant::Hello => Ok(Self::Hello(Box::new(Hello::arbitrary(u)?))),

            TypeVariant::Auth => Ok(Self::Auth(Box::new(Auth::arbitrary(u)?))),

            TypeVariant::IpAddrType => Ok(Self::IpAddrType(Box::new(IpAddrType::arbitrary(u)?))),

            TypeVariant::PeerAddress => Ok(Self::PeerAddress(Box::new(PeerAddress::arbitrary(u)?))),

            TypeVariant::MessageType => Ok(Self::MessageType(Box::new(MessageType::arbitrary(u)?))),

            TypeVariant::DontHave => Ok(Self::DontHave(Box::new(DontHave::arbitrary(u)?))),

            TypeVariant::SurveyMessageCommandType => Ok(Self::SurveyMessageCommandType(Box::new(
                SurveyMessageCommandType::arbitrary(u)?,
            ))),

            TypeVariant::SurveyMessageResponseType => Ok(Self::SurveyMessageResponseType(
                Box::new(SurveyMessageResponseType::arbitrary(u)?),
            )),

            TypeVariant::TimeSlicedSurveyStartCollectingMessage => {
                Ok(Self::TimeSlicedSurveyStartCollectingMessage(Box::new(
                    TimeSlicedSurveyStartCollectingMessage::arbitrary(u)?,
                )))
            }

            TypeVariant::SignedTimeSlicedSurveyStartCollectingMessage => {
                Ok(Self::SignedTimeSlicedSurveyStartCollectingMessage(
                    Box::new(SignedTimeSlicedSurveyStartCollectingMessage::arbitrary(u)?),
                ))
            }

            TypeVariant::TimeSlicedSurveyStopCollectingMessage => {
                Ok(Self::TimeSlicedSurveyStopCollectingMessage(Box::new(
                    TimeSlicedSurveyStopCollectingMessage::arbitrary(u)?,
                )))
            }

            TypeVariant::SignedTimeSlicedSurveyStopCollectingMessage => {
                Ok(Self::SignedTimeSlicedSurveyStopCollectingMessage(Box::new(
                    SignedTimeSlicedSurveyStopCollectingMessage::arbitrary(u)?,
                )))
            }

            TypeVariant::SurveyRequestMessage => Ok(Self::SurveyRequestMessage(Box::new(
                SurveyRequestMessage::arbitrary(u)?,
            ))),

            TypeVariant::TimeSlicedSurveyRequestMessage => {
                Ok(Self::TimeSlicedSurveyRequestMessage(Box::new(
                    TimeSlicedSurveyRequestMessage::arbitrary(u)?,
                )))
            }

            TypeVariant::SignedTimeSlicedSurveyRequestMessage => {
                Ok(Self::SignedTimeSlicedSurveyRequestMessage(Box::new(
                    SignedTimeSlicedSurveyRequestMessage::arbitrary(u)?,
                )))
            }

            TypeVariant::EncryptedBody => {
                Ok(Self::EncryptedBody(Box::new(EncryptedBody::arbitrary(u)?)))
            }

            TypeVariant::SurveyResponseMessage => Ok(Self::SurveyResponseMessage(Box::new(
                SurveyResponseMessage::arbitrary(u)?,
            ))),

            TypeVariant::TimeSlicedSurveyResponseMessage => {
                Ok(Self::TimeSlicedSurveyResponseMessage(Box::new(
                    TimeSlicedSurveyResponseMessage::arbitrary(u)?,
                )))
            }

            TypeVariant::SignedTimeSlicedSurveyResponseMessage => {
                Ok(Self::SignedTimeSlicedSurveyResponseMessage(Box::new(
                    SignedTimeSlicedSurveyResponseMessage::arbitrary(u)?,
                )))
            }

            TypeVariant::PeerStats => Ok(Self::PeerStats(Box::new(PeerStats::arbitrary(u)?))),

            TypeVariant::TimeSlicedNodeData => Ok(Self::TimeSlicedNodeData(Box::new(
                TimeSlicedNodeData::arbitrary(u)?,
            ))),

            TypeVariant::TimeSlicedPeerData => Ok(Self::TimeSlicedPeerData(Box::new(
                TimeSlicedPeerData::arbitrary(u)?,
            ))),

            TypeVariant::TimeSlicedPeerDataList => Ok(Self::TimeSlicedPeerDataList(Box::new(
                TimeSlicedPeerDataList::arbitrary(u)?,
            ))),

            TypeVariant::TopologyResponseBodyV2 => Ok(Self::TopologyResponseBodyV2(Box::new(
                TopologyResponseBodyV2::arbitrary(u)?,
            ))),

            TypeVariant::SurveyResponseBody => Ok(Self::SurveyResponseBody(Box::new(
                SurveyResponseBody::arbitrary(u)?,
            ))),

            TypeVariant::TxAdvertVector => Ok(Self::TxAdvertVector(Box::new(
                TxAdvertVector::arbitrary(u)?,
            ))),

            TypeVariant::FloodAdvert => Ok(Self::FloodAdvert(Box::new(FloodAdvert::arbitrary(u)?))),

            TypeVariant::TxDemandVector => Ok(Self::TxDemandVector(Box::new(
                TxDemandVector::arbitrary(u)?,
            ))),

            TypeVariant::FloodDemand => Ok(Self::FloodDemand(Box::new(FloodDemand::arbitrary(u)?))),

            TypeVariant::StellarMessage => Ok(Self::StellarMessage(Box::new(
                StellarMessage::arbitrary(u)?,
            ))),

            TypeVariant::AuthenticatedMessage => Ok(Self::AuthenticatedMessage(Box::new(
                AuthenticatedMessage::arbitrary(u)?,
            ))),

            TypeVariant::LiquidityPoolParameters => Ok(Self::LiquidityPoolParameters(Box::new(
                LiquidityPoolParameters::arbitrary(u)?,
            ))),

            TypeVariant::MuxedAccount => {
                Ok(Self::MuxedAccount(Box::new(MuxedAccount::arbitrary(u)?)))
            }

            TypeVariant::DecoratedSignature => Ok(Self::DecoratedSignature(Box::new(
                DecoratedSignature::arbitrary(u)?,
            ))),

            TypeVariant::OperationType => {
                Ok(Self::OperationType(Box::new(OperationType::arbitrary(u)?)))
            }

            TypeVariant::CreateAccountOp => Ok(Self::CreateAccountOp(Box::new(
                CreateAccountOp::arbitrary(u)?,
            ))),

            TypeVariant::PaymentOp => Ok(Self::PaymentOp(Box::new(PaymentOp::arbitrary(u)?))),

            TypeVariant::PathPaymentStrictReceiveOp => Ok(Self::PathPaymentStrictReceiveOp(
                Box::new(PathPaymentStrictReceiveOp::arbitrary(u)?),
            )),

            TypeVariant::PathPaymentStrictSendOp => Ok(Self::PathPaymentStrictSendOp(Box::new(
                PathPaymentStrictSendOp::arbitrary(u)?,
            ))),

            TypeVariant::ManageSellOfferOp => Ok(Self::ManageSellOfferOp(Box::new(
                ManageSellOfferOp::arbitrary(u)?,
            ))),

            TypeVariant::ManageBuyOfferOp => Ok(Self::ManageBuyOfferOp(Box::new(
                ManageBuyOfferOp::arbitrary(u)?,
            ))),

            TypeVariant::CreatePassiveSellOfferOp => Ok(Self::CreatePassiveSellOfferOp(Box::new(
                CreatePassiveSellOfferOp::arbitrary(u)?,
            ))),

            TypeVariant::SetOptionsOp => {
                Ok(Self::SetOptionsOp(Box::new(SetOptionsOp::arbitrary(u)?)))
            }

            TypeVariant::ChangeTrustAsset => Ok(Self::ChangeTrustAsset(Box::new(
                ChangeTrustAsset::arbitrary(u)?,
            ))),

            TypeVariant::ChangeTrustOp => {
                Ok(Self::ChangeTrustOp(Box::new(ChangeTrustOp::arbitrary(u)?)))
            }

            TypeVariant::AllowTrustOp => {
                Ok(Self::AllowTrustOp(Box::new(AllowTrustOp::arbitrary(u)?)))
            }

            TypeVariant::ManageDataOp => {
                Ok(Self::ManageDataOp(Box::new(ManageDataOp::arbitrary(u)?)))
            }

            TypeVariant::BumpSequenceOp => Ok(Self::BumpSequenceOp(Box::new(
                BumpSequenceOp::arbitrary(u)?,
            ))),

            TypeVariant::CreateClaimableBalanceOp => Ok(Self::CreateClaimableBalanceOp(Box::new(
                CreateClaimableBalanceOp::arbitrary(u)?,
            ))),

            TypeVariant::ClaimClaimableBalanceOp => Ok(Self::ClaimClaimableBalanceOp(Box::new(
                ClaimClaimableBalanceOp::arbitrary(u)?,
            ))),

            TypeVariant::BeginSponsoringFutureReservesOp => {
                Ok(Self::BeginSponsoringFutureReservesOp(Box::new(
                    BeginSponsoringFutureReservesOp::arbitrary(u)?,
                )))
            }

            TypeVariant::RevokeSponsorshipType => Ok(Self::RevokeSponsorshipType(Box::new(
                RevokeSponsorshipType::arbitrary(u)?,
            ))),

            TypeVariant::RevokeSponsorshipOp => Ok(Self::RevokeSponsorshipOp(Box::new(
                RevokeSponsorshipOp::arbitrary(u)?,
            ))),

            TypeVariant::ClawbackOp => Ok(Self::ClawbackOp(Box::new(ClawbackOp::arbitrary(u)?))),

            TypeVariant::ClawbackClaimableBalanceOp => Ok(Self::ClawbackClaimableBalanceOp(
                Box::new(ClawbackClaimableBalanceOp::arbitrary(u)?),
            )),

            TypeVariant::SetTrustLineFlagsOp => Ok(Self::SetTrustLineFlagsOp(Box::new(
                SetTrustLineFlagsOp::arbitrary(u)?,
            ))),

            TypeVariant::LiquidityPoolDepositOp => Ok(Self::LiquidityPoolDepositOp(Box::new(
                LiquidityPoolDepositOp::arbitrary(u)?,
            ))),

            TypeVariant::LiquidityPoolWithdrawOp => Ok(Self::LiquidityPoolWithdrawOp(Box::new(
                LiquidityPoolWithdrawOp::arbitrary(u)?,
            ))),

            TypeVariant::HostFunctionType => Ok(Self::HostFunctionType(Box::new(
                HostFunctionType::arbitrary(u)?,
            ))),

            TypeVariant::ContractIdPreimageType => Ok(Self::ContractIdPreimageType(Box::new(
                ContractIdPreimageType::arbitrary(u)?,
            ))),

            TypeVariant::ContractIdPreimage => Ok(Self::ContractIdPreimage(Box::new(
                ContractIdPreimage::arbitrary(u)?,
            ))),

            TypeVariant::CreateContractArgs => Ok(Self::CreateContractArgs(Box::new(
                CreateContractArgs::arbitrary(u)?,
            ))),

            TypeVariant::CreateContractArgsV2 => Ok(Self::CreateContractArgsV2(Box::new(
                CreateContractArgsV2::arbitrary(u)?,
            ))),

            TypeVariant::InvokeContractArgs => Ok(Self::InvokeContractArgs(Box::new(
                InvokeContractArgs::arbitrary(u)?,
            ))),

            TypeVariant::HostFunction => {
                Ok(Self::HostFunction(Box::new(HostFunction::arbitrary(u)?)))
            }

            TypeVariant::SorobanAuthorizedFunctionType => Ok(Self::SorobanAuthorizedFunctionType(
                Box::new(SorobanAuthorizedFunctionType::arbitrary(u)?),
            )),

            TypeVariant::SorobanAuthorizedFunction => Ok(Self::SorobanAuthorizedFunction(
                Box::new(SorobanAuthorizedFunction::arbitrary(u)?),
            )),

            TypeVariant::SorobanAuthorizedInvocation => Ok(Self::SorobanAuthorizedInvocation(
                Box::new(SorobanAuthorizedInvocation::arbitrary(u)?),
            )),

            TypeVariant::SorobanAddressCredentials => Ok(Self::SorobanAddressCredentials(
                Box::new(SorobanAddressCredentials::arbitrary(u)?),
            )),

            TypeVariant::SorobanCredentialsType => Ok(Self::SorobanCredentialsType(Box::new(
                SorobanCredentialsType::arbitrary(u)?,
            ))),

            TypeVariant::SorobanCredentials => Ok(Self::SorobanCredentials(Box::new(
                SorobanCredentials::arbitrary(u)?,
            ))),

            TypeVariant::SorobanAuthorizationEntry => Ok(Self::SorobanAuthorizationEntry(
                Box::new(SorobanAuthorizationEntry::arbitrary(u)?),
            )),

            TypeVariant::SorobanAuthorizationEntries => Ok(Self::SorobanAuthorizationEntries(
                Box::new(SorobanAuthorizationEntries::arbitrary(u)?),
            )),

            TypeVariant::InvokeHostFunctionOp => Ok(Self::InvokeHostFunctionOp(Box::new(
                InvokeHostFunctionOp::arbitrary(u)?,
            ))),

            TypeVariant::ExtendFootprintTtlOp => Ok(Self::ExtendFootprintTtlOp(Box::new(
                ExtendFootprintTtlOp::arbitrary(u)?,
            ))),

            TypeVariant::RestoreFootprintOp => Ok(Self::RestoreFootprintOp(Box::new(
                RestoreFootprintOp::arbitrary(u)?,
            ))),

            TypeVariant::Operation => Ok(Self::Operation(Box::new(Operation::arbitrary(u)?))),

            TypeVariant::HashIdPreimage => Ok(Self::HashIdPreimage(Box::new(
                HashIdPreimage::arbitrary(u)?,
            ))),

            TypeVariant::MemoType => Ok(Self::MemoType(Box::new(MemoType::arbitrary(u)?))),

            TypeVariant::Memo => Ok(Self::Memo(Box::new(Memo::arbitrary(u)?))),

            TypeVariant::TimeBounds => Ok(Self::TimeBounds(Box::new(TimeBounds::arbitrary(u)?))),

            TypeVariant::LedgerBounds => {
                Ok(Self::LedgerBounds(Box::new(LedgerBounds::arbitrary(u)?)))
            }

            TypeVariant::PreconditionsV2 => Ok(Self::PreconditionsV2(Box::new(
                PreconditionsV2::arbitrary(u)?,
            ))),

            TypeVariant::PreconditionType => Ok(Self::PreconditionType(Box::new(
                PreconditionType::arbitrary(u)?,
            ))),

            TypeVariant::Preconditions => {
                Ok(Self::Preconditions(Box::new(Preconditions::arbitrary(u)?)))
            }

            TypeVariant::LedgerFootprint => Ok(Self::LedgerFootprint(Box::new(
                LedgerFootprint::arbitrary(u)?,
            ))),

            TypeVariant::SorobanResources => Ok(Self::SorobanResources(Box::new(
                SorobanResources::arbitrary(u)?,
            ))),

            TypeVariant::SorobanResourcesExtV0 => Ok(Self::SorobanResourcesExtV0(Box::new(
                SorobanResourcesExtV0::arbitrary(u)?,
            ))),

            TypeVariant::SorobanTransactionData => Ok(Self::SorobanTransactionData(Box::new(
                SorobanTransactionData::arbitrary(u)?,
            ))),

            TypeVariant::TransactionV0 => {
                Ok(Self::TransactionV0(Box::new(TransactionV0::arbitrary(u)?)))
            }

            TypeVariant::TransactionV0Envelope => Ok(Self::TransactionV0Envelope(Box::new(
                TransactionV0Envelope::arbitrary(u)?,
            ))),

            TypeVariant::Transaction => Ok(Self::Transaction(Box::new(Transaction::arbitrary(u)?))),

            TypeVariant::TransactionV1Envelope => Ok(Self::TransactionV1Envelope(Box::new(
                TransactionV1Envelope::arbitrary(u)?,
            ))),

            TypeVariant::FeeBumpTransaction => Ok(Self::FeeBumpTransaction(Box::new(
                FeeBumpTransaction::arbitrary(u)?,
            ))),

            TypeVariant::FeeBumpTransactionEnvelope => Ok(Self::FeeBumpTransactionEnvelope(
                Box::new(FeeBumpTransactionEnvelope::arbitrary(u)?),
            )),

            TypeVariant::TransactionEnvelope => Ok(Self::TransactionEnvelope(Box::new(
                TransactionEnvelope::arbitrary(u)?,
            ))),

            TypeVariant::TransactionSignaturePayload => Ok(Self::TransactionSignaturePayload(
                Box::new(TransactionSignaturePayload::arbitrary(u)?),
            )),

            TypeVariant::ClaimAtomType => {
                Ok(Self::ClaimAtomType(Box::new(ClaimAtomType::arbitrary(u)?)))
            }

            TypeVariant::ClaimOfferAtomV0 => Ok(Self::ClaimOfferAtomV0(Box::new(
                ClaimOfferAtomV0::arbitrary(u)?,
            ))),

            TypeVariant::ClaimOfferAtom => Ok(Self::ClaimOfferAtom(Box::new(
                ClaimOfferAtom::arbitrary(u)?,
            ))),

            TypeVariant::ClaimLiquidityAtom => Ok(Self::ClaimLiquidityAtom(Box::new(
                ClaimLiquidityAtom::arbitrary(u)?,
            ))),

            TypeVariant::ClaimAtom => Ok(Self::ClaimAtom(Box::new(ClaimAtom::arbitrary(u)?))),

            TypeVariant::CreateAccountResultCode => Ok(Self::CreateAccountResultCode(Box::new(
                CreateAccountResultCode::arbitrary(u)?,
            ))),

            TypeVariant::CreateAccountResult => Ok(Self::CreateAccountResult(Box::new(
                CreateAccountResult::arbitrary(u)?,
            ))),

            TypeVariant::PaymentResultCode => Ok(Self::PaymentResultCode(Box::new(
                PaymentResultCode::arbitrary(u)?,
            ))),

            TypeVariant::PaymentResult => {
                Ok(Self::PaymentResult(Box::new(PaymentResult::arbitrary(u)?)))
            }

            TypeVariant::PathPaymentStrictReceiveResultCode => {
                Ok(Self::PathPaymentStrictReceiveResultCode(Box::new(
                    PathPaymentStrictReceiveResultCode::arbitrary(u)?,
                )))
            }

            TypeVariant::SimplePaymentResult => Ok(Self::SimplePaymentResult(Box::new(
                SimplePaymentResult::arbitrary(u)?,
            ))),

            TypeVariant::PathPaymentStrictReceiveResult => {
                Ok(Self::PathPaymentStrictReceiveResult(Box::new(
                    PathPaymentStrictReceiveResult::arbitrary(u)?,
                )))
            }

            TypeVariant::PathPaymentStrictSendResultCode => {
                Ok(Self::PathPaymentStrictSendResultCode(Box::new(
                    PathPaymentStrictSendResultCode::arbitrary(u)?,
                )))
            }

            TypeVariant::PathPaymentStrictSendResult => Ok(Self::PathPaymentStrictSendResult(
                Box::new(PathPaymentStrictSendResult::arbitrary(u)?),
            )),

            TypeVariant::ManageSellOfferResultCode => Ok(Self::ManageSellOfferResultCode(
                Box::new(ManageSellOfferResultCode::arbitrary(u)?),
            )),

            TypeVariant::ManageOfferEffect => Ok(Self::ManageOfferEffect(Box::new(
                ManageOfferEffect::arbitrary(u)?,
            ))),

            TypeVariant::ManageOfferSuccessResult => Ok(Self::ManageOfferSuccessResult(Box::new(
                ManageOfferSuccessResult::arbitrary(u)?,
            ))),

            TypeVariant::ManageSellOfferResult => Ok(Self::ManageSellOfferResult(Box::new(
                ManageSellOfferResult::arbitrary(u)?,
            ))),

            TypeVariant::ManageBuyOfferResultCode => Ok(Self::ManageBuyOfferResultCode(Box::new(
                ManageBuyOfferResultCode::arbitrary(u)?,
            ))),

            TypeVariant::ManageBuyOfferResult => Ok(Self::ManageBuyOfferResult(Box::new(
                ManageBuyOfferResult::arbitrary(u)?,
            ))),

            TypeVariant::SetOptionsResultCode => Ok(Self::SetOptionsResultCode(Box::new(
                SetOptionsResultCode::arbitrary(u)?,
            ))),

            TypeVariant::SetOptionsResult => Ok(Self::SetOptionsResult(Box::new(
                SetOptionsResult::arbitrary(u)?,
            ))),

            TypeVariant::ChangeTrustResultCode => Ok(Self::ChangeTrustResultCode(Box::new(
                ChangeTrustResultCode::arbitrary(u)?,
            ))),

            TypeVariant::ChangeTrustResult => Ok(Self::ChangeTrustResult(Box::new(
                ChangeTrustResult::arbitrary(u)?,
            ))),

            TypeVariant::AllowTrustResultCode => Ok(Self::AllowTrustResultCode(Box::new(
                AllowTrustResultCode::arbitrary(u)?,
            ))),

            TypeVariant::AllowTrustResult => Ok(Self::AllowTrustResult(Box::new(
                AllowTrustResult::arbitrary(u)?,
            ))),

            TypeVariant::AccountMergeResultCode => Ok(Self::AccountMergeResultCode(Box::new(
                AccountMergeResultCode::arbitrary(u)?,
            ))),

            TypeVariant::AccountMergeResult => Ok(Self::AccountMergeResult(Box::new(
                AccountMergeResult::arbitrary(u)?,
            ))),

            TypeVariant::InflationResultCode => Ok(Self::InflationResultCode(Box::new(
                InflationResultCode::arbitrary(u)?,
            ))),

            TypeVariant::InflationPayout => Ok(Self::InflationPayout(Box::new(
                InflationPayout::arbitrary(u)?,
            ))),

            TypeVariant::InflationResult => Ok(Self::InflationResult(Box::new(
                InflationResult::arbitrary(u)?,
            ))),

            TypeVariant::ManageDataResultCode => Ok(Self::ManageDataResultCode(Box::new(
                ManageDataResultCode::arbitrary(u)?,
            ))),

            TypeVariant::ManageDataResult => Ok(Self::ManageDataResult(Box::new(
                ManageDataResult::arbitrary(u)?,
            ))),

            TypeVariant::BumpSequenceResultCode => Ok(Self::BumpSequenceResultCode(Box::new(
                BumpSequenceResultCode::arbitrary(u)?,
            ))),

            TypeVariant::BumpSequenceResult => Ok(Self::BumpSequenceResult(Box::new(
                BumpSequenceResult::arbitrary(u)?,
            ))),

            TypeVariant::CreateClaimableBalanceResultCode => {
                Ok(Self::CreateClaimableBalanceResultCode(Box::new(
                    CreateClaimableBalanceResultCode::arbitrary(u)?,
                )))
            }

            TypeVariant::CreateClaimableBalanceResult => Ok(Self::CreateClaimableBalanceResult(
                Box::new(CreateClaimableBalanceResult::arbitrary(u)?),
            )),

            TypeVariant::ClaimClaimableBalanceResultCode => {
                Ok(Self::ClaimClaimableBalanceResultCode(Box::new(
                    ClaimClaimableBalanceResultCode::arbitrary(u)?,
                )))
            }

            TypeVariant::ClaimClaimableBalanceResult => Ok(Self::ClaimClaimableBalanceResult(
                Box::new(ClaimClaimableBalanceResult::arbitrary(u)?),
            )),

            TypeVariant::BeginSponsoringFutureReservesResultCode => {
                Ok(Self::BeginSponsoringFutureReservesResultCode(Box::new(
                    BeginSponsoringFutureReservesResultCode::arbitrary(u)?,
                )))
            }

            TypeVariant::BeginSponsoringFutureReservesResult => {
                Ok(Self::BeginSponsoringFutureReservesResult(Box::new(
                    BeginSponsoringFutureReservesResult::arbitrary(u)?,
                )))
            }

            TypeVariant::EndSponsoringFutureReservesResultCode => {
                Ok(Self::EndSponsoringFutureReservesResultCode(Box::new(
                    EndSponsoringFutureReservesResultCode::arbitrary(u)?,
                )))
            }

            TypeVariant::EndSponsoringFutureReservesResult => {
                Ok(Self::EndSponsoringFutureReservesResult(Box::new(
                    EndSponsoringFutureReservesResult::arbitrary(u)?,
                )))
            }

            TypeVariant::RevokeSponsorshipResultCode => Ok(Self::RevokeSponsorshipResultCode(
                Box::new(RevokeSponsorshipResultCode::arbitrary(u)?),
            )),

            TypeVariant::RevokeSponsorshipResult => Ok(Self::RevokeSponsorshipResult(Box::new(
                RevokeSponsorshipResult::arbitrary(u)?,
            ))),

            TypeVariant::ClawbackResultCode => Ok(Self::ClawbackResultCode(Box::new(
                ClawbackResultCode::arbitrary(u)?,
            ))),

            TypeVariant::ClawbackResult => Ok(Self::ClawbackResult(Box::new(
                ClawbackResult::arbitrary(u)?,
            ))),

            TypeVariant::ClawbackClaimableBalanceResultCode => {
                Ok(Self::ClawbackClaimableBalanceResultCode(Box::new(
                    ClawbackClaimableBalanceResultCode::arbitrary(u)?,
                )))
            }

            TypeVariant::ClawbackClaimableBalanceResult => {
                Ok(Self::ClawbackClaimableBalanceResult(Box::new(
                    ClawbackClaimableBalanceResult::arbitrary(u)?,
                )))
            }

            TypeVariant::SetTrustLineFlagsResultCode => Ok(Self::SetTrustLineFlagsResultCode(
                Box::new(SetTrustLineFlagsResultCode::arbitrary(u)?),
            )),

            TypeVariant::SetTrustLineFlagsResult => Ok(Self::SetTrustLineFlagsResult(Box::new(
                SetTrustLineFlagsResult::arbitrary(u)?,
            ))),

            TypeVariant::LiquidityPoolDepositResultCode => {
                Ok(Self::LiquidityPoolDepositResultCode(Box::new(
                    LiquidityPoolDepositResultCode::arbitrary(u)?,
                )))
            }

            TypeVariant::LiquidityPoolDepositResult => Ok(Self::LiquidityPoolDepositResult(
                Box::new(LiquidityPoolDepositResult::arbitrary(u)?),
            )),

            TypeVariant::LiquidityPoolWithdrawResultCode => {
                Ok(Self::LiquidityPoolWithdrawResultCode(Box::new(
                    LiquidityPoolWithdrawResultCode::arbitrary(u)?,
                )))
            }

            TypeVariant::LiquidityPoolWithdrawResult => Ok(Self::LiquidityPoolWithdrawResult(
                Box::new(LiquidityPoolWithdrawResult::arbitrary(u)?),
            )),

            TypeVariant::InvokeHostFunctionResultCode => Ok(Self::InvokeHostFunctionResultCode(
                Box::new(InvokeHostFunctionResultCode::arbitrary(u)?),
            )),

            TypeVariant::InvokeHostFunctionResult => Ok(Self::InvokeHostFunctionResult(Box::new(
                InvokeHostFunctionResult::arbitrary(u)?,
            ))),

            TypeVariant::ExtendFootprintTtlResultCode => Ok(Self::ExtendFootprintTtlResultCode(
                Box::new(ExtendFootprintTtlResultCode::arbitrary(u)?),
            )),

            TypeVariant::ExtendFootprintTtlResult => Ok(Self::ExtendFootprintTtlResult(Box::new(
                ExtendFootprintTtlResult::arbitrary(u)?,
            ))),

            TypeVariant::RestoreFootprintResultCode => Ok(Self::RestoreFootprintResultCode(
                Box::new(RestoreFootprintResultCode::arbitrary(u)?),
            )),

            TypeVariant::RestoreFootprintResult => Ok(Self::RestoreFootprintResult(Box::new(
                RestoreFootprintResult::arbitrary(u)?,
            ))),

            TypeVariant::OperationResultCode => Ok(Self::OperationResultCode(Box::new(
                OperationResultCode::arbitrary(u)?,
            ))),

            TypeVariant::OperationResult => Ok(Self::OperationResult(Box::new(
                OperationResult::arbitrary(u)?,
            ))),

            TypeVariant::TransactionResultCode => Ok(Self::TransactionResultCode(Box::new(
                TransactionResultCode::arbitrary(u)?,
            ))),

            TypeVariant::InnerTransactionResult => Ok(Self::InnerTransactionResult(Box::new(
                InnerTransactionResult::arbitrary(u)?,
            ))),

            TypeVariant::InnerTransactionResultPair => Ok(Self::InnerTransactionResultPair(
                Box::new(InnerTransactionResultPair::arbitrary(u)?),
            )),

            TypeVariant::TransactionResult => Ok(Self::TransactionResult(Box::new(
                TransactionResult::arbitrary(u)?,
            ))),

            TypeVariant::Hash => Ok(Self::Hash(Box::new(Hash::arbitrary(u)?))),

            TypeVariant::Uint256 => Ok(Self::Uint256(Box::new(Uint256::arbitrary(u)?))),

            TypeVariant::Uint32 => Ok(Self::Uint32(Box::new(Uint32::arbitrary(u)?))),

            TypeVariant::Int32 => Ok(Self::Int32(Box::new(Int32::arbitrary(u)?))),

            TypeVariant::Uint64 => Ok(Self::Uint64(Box::new(Uint64::arbitrary(u)?))),

            TypeVariant::Int64 => Ok(Self::Int64(Box::new(Int64::arbitrary(u)?))),

            TypeVariant::TimePoint => Ok(Self::TimePoint(Box::new(TimePoint::arbitrary(u)?))),

            TypeVariant::Duration => Ok(Self::Duration(Box::new(Duration::arbitrary(u)?))),

            TypeVariant::ExtensionPoint => Ok(Self::ExtensionPoint(Box::new(
                ExtensionPoint::arbitrary(u)?,
            ))),

            TypeVariant::CryptoKeyType => {
                Ok(Self::CryptoKeyType(Box::new(CryptoKeyType::arbitrary(u)?)))
            }

            TypeVariant::PublicKeyType => {
                Ok(Self::PublicKeyType(Box::new(PublicKeyType::arbitrary(u)?)))
            }

            TypeVariant::SignerKeyType => {
                Ok(Self::SignerKeyType(Box::new(SignerKeyType::arbitrary(u)?)))
            }

            TypeVariant::PublicKey => Ok(Self::PublicKey(Box::new(PublicKey::arbitrary(u)?))),

            TypeVariant::SignerKey => Ok(Self::SignerKey(Box::new(SignerKey::arbitrary(u)?))),

            TypeVariant::Signature => Ok(Self::Signature(Box::new(Signature::arbitrary(u)?))),

            TypeVariant::SignatureHint => {
                Ok(Self::SignatureHint(Box::new(SignatureHint::arbitrary(u)?)))
            }

            TypeVariant::NodeId => Ok(Self::NodeId(Box::new(NodeId::arbitrary(u)?))),

            TypeVariant::AccountId => Ok(Self::AccountId(Box::new(AccountId::arbitrary(u)?))),

            TypeVariant::ContractId => Ok(Self::ContractId(Box::new(ContractId::arbitrary(u)?))),

            TypeVariant::Curve25519Secret => Ok(Self::Curve25519Secret(Box::new(
                Curve25519Secret::arbitrary(u)?,
            ))),

            TypeVariant::Curve25519Public => Ok(Self::Curve25519Public(Box::new(
                Curve25519Public::arbitrary(u)?,
            ))),

            TypeVariant::HmacSha256Key => {
                Ok(Self::HmacSha256Key(Box::new(HmacSha256Key::arbitrary(u)?)))
            }

            TypeVariant::HmacSha256Mac => {
                Ok(Self::HmacSha256Mac(Box::new(HmacSha256Mac::arbitrary(u)?)))
            }

            TypeVariant::ShortHashSeed => {
                Ok(Self::ShortHashSeed(Box::new(ShortHashSeed::arbitrary(u)?)))
            }

            TypeVariant::BinaryFuseFilterType => Ok(Self::BinaryFuseFilterType(Box::new(
                BinaryFuseFilterType::arbitrary(u)?,
            ))),

            TypeVariant::SerializedBinaryFuseFilter => Ok(Self::SerializedBinaryFuseFilter(
                Box::new(SerializedBinaryFuseFilter::arbitrary(u)?),
            )),

            TypeVariant::PoolId => Ok(Self::PoolId(Box::new(PoolId::arbitrary(u)?))),

            TypeVariant::ClaimableBalanceIdType => Ok(Self::ClaimableBalanceIdType(Box::new(
                ClaimableBalanceIdType::arbitrary(u)?,
            ))),

            TypeVariant::ClaimableBalanceId => Ok(Self::ClaimableBalanceId(Box::new(
                ClaimableBalanceId::arbitrary(u)?,
            ))),
        }
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub fn default(v: TypeVariant) -> Self {
        match v {
            TypeVariant::ScpStatementPrepare => Self::ScpStatementPrepare(Box::default()),

            TypeVariant::ScpStatementConfirm => Self::ScpStatementConfirm(Box::default()),

            TypeVariant::ScpStatementExternalize => Self::ScpStatementExternalize(Box::default()),

            TypeVariant::ScpStatementPledges => Self::ScpStatementPledges(Box::default()),

            TypeVariant::ScEnvMetaEntryInterfaceVersion => {
                Self::ScEnvMetaEntryInterfaceVersion(Box::default())
            }

            TypeVariant::AccountEntryExtensionV2Ext => {
                Self::AccountEntryExtensionV2Ext(Box::default())
            }

            TypeVariant::AccountEntryExtensionV1Ext => {
                Self::AccountEntryExtensionV1Ext(Box::default())
            }

            TypeVariant::AccountEntryExt => Self::AccountEntryExt(Box::default()),

            TypeVariant::TrustLineEntryExtensionV2Ext => {
                Self::TrustLineEntryExtensionV2Ext(Box::default())
            }

            TypeVariant::TrustLineEntryV1Ext => Self::TrustLineEntryV1Ext(Box::default()),

            TypeVariant::TrustLineEntryV1 => Self::TrustLineEntryV1(Box::default()),

            TypeVariant::TrustLineEntryExt => Self::TrustLineEntryExt(Box::default()),

            TypeVariant::OfferEntryExt => Self::OfferEntryExt(Box::default()),

            TypeVariant::DataEntryExt => Self::DataEntryExt(Box::default()),

            TypeVariant::ClaimantV0 => Self::ClaimantV0(Box::default()),

            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => {
                Self::ClaimableBalanceEntryExtensionV1Ext(Box::default())
            }

            TypeVariant::ClaimableBalanceEntryExt => Self::ClaimableBalanceEntryExt(Box::default()),

            TypeVariant::LiquidityPoolEntryConstantProduct => {
                Self::LiquidityPoolEntryConstantProduct(Box::default())
            }

            TypeVariant::LiquidityPoolEntryBody => Self::LiquidityPoolEntryBody(Box::default()),

            TypeVariant::ContractCodeEntryV1 => Self::ContractCodeEntryV1(Box::default()),

            TypeVariant::ContractCodeEntryExt => Self::ContractCodeEntryExt(Box::default()),

            TypeVariant::LedgerEntryExtensionV1Ext => {
                Self::LedgerEntryExtensionV1Ext(Box::default())
            }

            TypeVariant::LedgerEntryData => Self::LedgerEntryData(Box::default()),

            TypeVariant::LedgerEntryExt => Self::LedgerEntryExt(Box::default()),

            TypeVariant::LedgerKeyAccount => Self::LedgerKeyAccount(Box::default()),

            TypeVariant::LedgerKeyTrustLine => Self::LedgerKeyTrustLine(Box::default()),

            TypeVariant::LedgerKeyOffer => Self::LedgerKeyOffer(Box::default()),

            TypeVariant::LedgerKeyData => Self::LedgerKeyData(Box::default()),

            TypeVariant::LedgerKeyClaimableBalance => {
                Self::LedgerKeyClaimableBalance(Box::default())
            }

            TypeVariant::LedgerKeyLiquidityPool => Self::LedgerKeyLiquidityPool(Box::default()),

            TypeVariant::LedgerKeyContractData => Self::LedgerKeyContractData(Box::default()),

            TypeVariant::LedgerKeyContractCode => Self::LedgerKeyContractCode(Box::default()),

            TypeVariant::LedgerKeyConfigSetting => Self::LedgerKeyConfigSetting(Box::default()),

            TypeVariant::LedgerKeyTtl => Self::LedgerKeyTtl(Box::default()),

            TypeVariant::BucketMetadataExt => Self::BucketMetadataExt(Box::default()),

            TypeVariant::StellarValueExt => Self::StellarValueExt(Box::default()),

            TypeVariant::LedgerHeaderExtensionV1Ext => {
                Self::LedgerHeaderExtensionV1Ext(Box::default())
            }

            TypeVariant::LedgerHeaderExt => Self::LedgerHeaderExt(Box::default()),

            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => {
                Self::TxSetComponentTxsMaybeDiscountedFee(Box::default())
            }

            TypeVariant::TransactionHistoryEntryExt => {
                Self::TransactionHistoryEntryExt(Box::default())
            }

            TypeVariant::TransactionHistoryResultEntryExt => {
                Self::TransactionHistoryResultEntryExt(Box::default())
            }

            TypeVariant::LedgerHeaderHistoryEntryExt => {
                Self::LedgerHeaderHistoryEntryExt(Box::default())
            }

            TypeVariant::ContractEventV0 => Self::ContractEventV0(Box::default()),

            TypeVariant::ContractEventBody => Self::ContractEventBody(Box::default()),

            TypeVariant::PeerAddressIp => Self::PeerAddressIp(Box::default()),

            TypeVariant::AuthenticatedMessageV0 => Self::AuthenticatedMessageV0(Box::default()),

            TypeVariant::MuxedAccountMed25519 => Self::MuxedAccountMed25519(Box::default()),

            TypeVariant::RevokeSponsorshipOpSigner => {
                Self::RevokeSponsorshipOpSigner(Box::default())
            }

            TypeVariant::ContractIdPreimageFromAddress => {
                Self::ContractIdPreimageFromAddress(Box::default())
            }

            TypeVariant::OperationBody => Self::OperationBody(Box::default()),

            TypeVariant::HashIdPreimageOperationId => {
                Self::HashIdPreimageOperationId(Box::default())
            }

            TypeVariant::HashIdPreimageRevokeId => Self::HashIdPreimageRevokeId(Box::default()),

            TypeVariant::HashIdPreimageContractId => Self::HashIdPreimageContractId(Box::default()),

            TypeVariant::HashIdPreimageSorobanAuthorization => {
                Self::HashIdPreimageSorobanAuthorization(Box::default())
            }

            TypeVariant::SorobanTransactionDataExt => {
                Self::SorobanTransactionDataExt(Box::default())
            }

            TypeVariant::TransactionV0Ext => Self::TransactionV0Ext(Box::default()),

            TypeVariant::TransactionExt => Self::TransactionExt(Box::default()),

            TypeVariant::FeeBumpTransactionInnerTx => {
                Self::FeeBumpTransactionInnerTx(Box::default())
            }

            TypeVariant::FeeBumpTransactionExt => Self::FeeBumpTransactionExt(Box::default()),

            TypeVariant::TransactionSignaturePayloadTaggedTransaction => {
                Self::TransactionSignaturePayloadTaggedTransaction(Box::default())
            }

            TypeVariant::PathPaymentStrictReceiveResultSuccess => {
                Self::PathPaymentStrictReceiveResultSuccess(Box::default())
            }

            TypeVariant::PathPaymentStrictSendResultSuccess => {
                Self::PathPaymentStrictSendResultSuccess(Box::default())
            }

            TypeVariant::ManageOfferSuccessResultOffer => {
                Self::ManageOfferSuccessResultOffer(Box::default())
            }

            TypeVariant::OperationResultTr => Self::OperationResultTr(Box::default()),

            TypeVariant::InnerTransactionResultResult => {
                Self::InnerTransactionResultResult(Box::default())
            }

            TypeVariant::InnerTransactionResultExt => {
                Self::InnerTransactionResultExt(Box::default())
            }

            TypeVariant::TransactionResultResult => Self::TransactionResultResult(Box::default()),

            TypeVariant::TransactionResultExt => Self::TransactionResultExt(Box::default()),

            TypeVariant::SignerKeyEd25519SignedPayload => {
                Self::SignerKeyEd25519SignedPayload(Box::default())
            }

            TypeVariant::Value => Self::Value(Box::default()),

            TypeVariant::ScpBallot => Self::ScpBallot(Box::default()),

            TypeVariant::ScpStatementType => Self::ScpStatementType(Box::default()),

            TypeVariant::ScpNomination => Self::ScpNomination(Box::default()),

            TypeVariant::ScpStatement => Self::ScpStatement(Box::default()),

            TypeVariant::ScpEnvelope => Self::ScpEnvelope(Box::default()),

            TypeVariant::ScpQuorumSet => Self::ScpQuorumSet(Box::default()),

            TypeVariant::ConfigSettingContractExecutionLanesV0 => {
                Self::ConfigSettingContractExecutionLanesV0(Box::default())
            }

            TypeVariant::ConfigSettingContractComputeV0 => {
                Self::ConfigSettingContractComputeV0(Box::default())
            }

            TypeVariant::ConfigSettingContractParallelComputeV0 => {
                Self::ConfigSettingContractParallelComputeV0(Box::default())
            }

            TypeVariant::ConfigSettingContractLedgerCostV0 => {
                Self::ConfigSettingContractLedgerCostV0(Box::default())
            }

            TypeVariant::ConfigSettingContractLedgerCostExtV0 => {
                Self::ConfigSettingContractLedgerCostExtV0(Box::default())
            }

            TypeVariant::ConfigSettingContractHistoricalDataV0 => {
                Self::ConfigSettingContractHistoricalDataV0(Box::default())
            }

            TypeVariant::ConfigSettingContractEventsV0 => {
                Self::ConfigSettingContractEventsV0(Box::default())
            }

            TypeVariant::ConfigSettingContractBandwidthV0 => {
                Self::ConfigSettingContractBandwidthV0(Box::default())
            }

            TypeVariant::ContractCostType => Self::ContractCostType(Box::default()),

            TypeVariant::ContractCostParamEntry => Self::ContractCostParamEntry(Box::default()),

            TypeVariant::StateArchivalSettings => Self::StateArchivalSettings(Box::default()),

            TypeVariant::EvictionIterator => Self::EvictionIterator(Box::default()),

            TypeVariant::ConfigSettingScpTiming => Self::ConfigSettingScpTiming(Box::default()),

            TypeVariant::ContractCostParams => Self::ContractCostParams(Box::default()),

            TypeVariant::ConfigSettingId => Self::ConfigSettingId(Box::default()),

            TypeVariant::ConfigSettingEntry => Self::ConfigSettingEntry(Box::default()),

            TypeVariant::ScEnvMetaKind => Self::ScEnvMetaKind(Box::default()),

            TypeVariant::ScEnvMetaEntry => Self::ScEnvMetaEntry(Box::default()),

            TypeVariant::ScMetaV0 => Self::ScMetaV0(Box::default()),

            TypeVariant::ScMetaKind => Self::ScMetaKind(Box::default()),

            TypeVariant::ScMetaEntry => Self::ScMetaEntry(Box::default()),

            TypeVariant::ScSpecType => Self::ScSpecType(Box::default()),

            TypeVariant::ScSpecTypeOption => Self::ScSpecTypeOption(Box::default()),

            TypeVariant::ScSpecTypeResult => Self::ScSpecTypeResult(Box::default()),

            TypeVariant::ScSpecTypeVec => Self::ScSpecTypeVec(Box::default()),

            TypeVariant::ScSpecTypeMap => Self::ScSpecTypeMap(Box::default()),

            TypeVariant::ScSpecTypeTuple => Self::ScSpecTypeTuple(Box::default()),

            TypeVariant::ScSpecTypeBytesN => Self::ScSpecTypeBytesN(Box::default()),

            TypeVariant::ScSpecTypeUdt => Self::ScSpecTypeUdt(Box::default()),

            TypeVariant::ScSpecTypeDef => Self::ScSpecTypeDef(Box::default()),

            TypeVariant::ScSpecUdtStructFieldV0 => Self::ScSpecUdtStructFieldV0(Box::default()),

            TypeVariant::ScSpecUdtStructV0 => Self::ScSpecUdtStructV0(Box::default()),

            TypeVariant::ScSpecUdtUnionCaseVoidV0 => Self::ScSpecUdtUnionCaseVoidV0(Box::default()),

            TypeVariant::ScSpecUdtUnionCaseTupleV0 => {
                Self::ScSpecUdtUnionCaseTupleV0(Box::default())
            }

            TypeVariant::ScSpecUdtUnionCaseV0Kind => Self::ScSpecUdtUnionCaseV0Kind(Box::default()),

            TypeVariant::ScSpecUdtUnionCaseV0 => Self::ScSpecUdtUnionCaseV0(Box::default()),

            TypeVariant::ScSpecUdtUnionV0 => Self::ScSpecUdtUnionV0(Box::default()),

            TypeVariant::ScSpecUdtEnumCaseV0 => Self::ScSpecUdtEnumCaseV0(Box::default()),

            TypeVariant::ScSpecUdtEnumV0 => Self::ScSpecUdtEnumV0(Box::default()),

            TypeVariant::ScSpecUdtErrorEnumCaseV0 => Self::ScSpecUdtErrorEnumCaseV0(Box::default()),

            TypeVariant::ScSpecUdtErrorEnumV0 => Self::ScSpecUdtErrorEnumV0(Box::default()),

            TypeVariant::ScSpecFunctionInputV0 => Self::ScSpecFunctionInputV0(Box::default()),

            TypeVariant::ScSpecFunctionV0 => Self::ScSpecFunctionV0(Box::default()),

            TypeVariant::ScSpecEventParamLocationV0 => {
                Self::ScSpecEventParamLocationV0(Box::default())
            }

            TypeVariant::ScSpecEventParamV0 => Self::ScSpecEventParamV0(Box::default()),

            TypeVariant::ScSpecEventDataFormat => Self::ScSpecEventDataFormat(Box::default()),

            TypeVariant::ScSpecEventV0 => Self::ScSpecEventV0(Box::default()),

            TypeVariant::ScSpecEntryKind => Self::ScSpecEntryKind(Box::default()),

            TypeVariant::ScSpecEntry => Self::ScSpecEntry(Box::default()),

            TypeVariant::ScValType => Self::ScValType(Box::default()),

            TypeVariant::ScErrorType => Self::ScErrorType(Box::default()),

            TypeVariant::ScErrorCode => Self::ScErrorCode(Box::default()),

            TypeVariant::ScError => Self::ScError(Box::default()),

            TypeVariant::UInt128Parts => Self::UInt128Parts(Box::default()),

            TypeVariant::Int128Parts => Self::Int128Parts(Box::default()),

            TypeVariant::UInt256Parts => Self::UInt256Parts(Box::default()),

            TypeVariant::Int256Parts => Self::Int256Parts(Box::default()),

            TypeVariant::ContractExecutableType => Self::ContractExecutableType(Box::default()),

            TypeVariant::ContractExecutable => Self::ContractExecutable(Box::default()),

            TypeVariant::ScAddressType => Self::ScAddressType(Box::default()),

            TypeVariant::MuxedEd25519Account => Self::MuxedEd25519Account(Box::default()),

            TypeVariant::ScAddress => Self::ScAddress(Box::default()),

            TypeVariant::ScVec => Self::ScVec(Box::default()),

            TypeVariant::ScMap => Self::ScMap(Box::default()),

            TypeVariant::ScBytes => Self::ScBytes(Box::default()),

            TypeVariant::ScString => Self::ScString(Box::default()),

            TypeVariant::ScSymbol => Self::ScSymbol(Box::default()),

            TypeVariant::ScNonceKey => Self::ScNonceKey(Box::default()),

            TypeVariant::ScContractInstance => Self::ScContractInstance(Box::default()),

            TypeVariant::ScVal => Self::ScVal(Box::default()),

            TypeVariant::ScMapEntry => Self::ScMapEntry(Box::default()),

            TypeVariant::LedgerCloseMetaBatch => Self::LedgerCloseMetaBatch(Box::default()),

            TypeVariant::StoredTransactionSet => Self::StoredTransactionSet(Box::default()),

            TypeVariant::StoredDebugTransactionSet => {
                Self::StoredDebugTransactionSet(Box::default())
            }

            TypeVariant::PersistedScpStateV0 => Self::PersistedScpStateV0(Box::default()),

            TypeVariant::PersistedScpStateV1 => Self::PersistedScpStateV1(Box::default()),

            TypeVariant::PersistedScpState => Self::PersistedScpState(Box::default()),

            TypeVariant::Thresholds => Self::Thresholds(Box::default()),

            TypeVariant::String32 => Self::String32(Box::default()),

            TypeVariant::String64 => Self::String64(Box::default()),

            TypeVariant::SequenceNumber => Self::SequenceNumber(Box::default()),

            TypeVariant::DataValue => Self::DataValue(Box::default()),

            TypeVariant::AssetCode4 => Self::AssetCode4(Box::default()),

            TypeVariant::AssetCode12 => Self::AssetCode12(Box::default()),

            TypeVariant::AssetType => Self::AssetType(Box::default()),

            TypeVariant::AssetCode => Self::AssetCode(Box::default()),

            TypeVariant::AlphaNum4 => Self::AlphaNum4(Box::default()),

            TypeVariant::AlphaNum12 => Self::AlphaNum12(Box::default()),

            TypeVariant::Asset => Self::Asset(Box::default()),

            TypeVariant::Price => Self::Price(Box::default()),

            TypeVariant::Liabilities => Self::Liabilities(Box::default()),

            TypeVariant::ThresholdIndexes => Self::ThresholdIndexes(Box::default()),

            TypeVariant::LedgerEntryType => Self::LedgerEntryType(Box::default()),

            TypeVariant::Signer => Self::Signer(Box::default()),

            TypeVariant::AccountFlags => Self::AccountFlags(Box::default()),

            TypeVariant::SponsorshipDescriptor => Self::SponsorshipDescriptor(Box::default()),

            TypeVariant::AccountEntryExtensionV3 => Self::AccountEntryExtensionV3(Box::default()),

            TypeVariant::AccountEntryExtensionV2 => Self::AccountEntryExtensionV2(Box::default()),

            TypeVariant::AccountEntryExtensionV1 => Self::AccountEntryExtensionV1(Box::default()),

            TypeVariant::AccountEntry => Self::AccountEntry(Box::default()),

            TypeVariant::TrustLineFlags => Self::TrustLineFlags(Box::default()),

            TypeVariant::LiquidityPoolType => Self::LiquidityPoolType(Box::default()),

            TypeVariant::TrustLineAsset => Self::TrustLineAsset(Box::default()),

            TypeVariant::TrustLineEntryExtensionV2 => {
                Self::TrustLineEntryExtensionV2(Box::default())
            }

            TypeVariant::TrustLineEntry => Self::TrustLineEntry(Box::default()),

            TypeVariant::OfferEntryFlags => Self::OfferEntryFlags(Box::default()),

            TypeVariant::OfferEntry => Self::OfferEntry(Box::default()),

            TypeVariant::DataEntry => Self::DataEntry(Box::default()),

            TypeVariant::ClaimPredicateType => Self::ClaimPredicateType(Box::default()),

            TypeVariant::ClaimPredicate => Self::ClaimPredicate(Box::default()),

            TypeVariant::ClaimantType => Self::ClaimantType(Box::default()),

            TypeVariant::Claimant => Self::Claimant(Box::default()),

            TypeVariant::ClaimableBalanceFlags => Self::ClaimableBalanceFlags(Box::default()),

            TypeVariant::ClaimableBalanceEntryExtensionV1 => {
                Self::ClaimableBalanceEntryExtensionV1(Box::default())
            }

            TypeVariant::ClaimableBalanceEntry => Self::ClaimableBalanceEntry(Box::default()),

            TypeVariant::LiquidityPoolConstantProductParameters => {
                Self::LiquidityPoolConstantProductParameters(Box::default())
            }

            TypeVariant::LiquidityPoolEntry => Self::LiquidityPoolEntry(Box::default()),

            TypeVariant::ContractDataDurability => Self::ContractDataDurability(Box::default()),

            TypeVariant::ContractDataEntry => Self::ContractDataEntry(Box::default()),

            TypeVariant::ContractCodeCostInputs => Self::ContractCodeCostInputs(Box::default()),

            TypeVariant::ContractCodeEntry => Self::ContractCodeEntry(Box::default()),

            TypeVariant::TtlEntry => Self::TtlEntry(Box::default()),

            TypeVariant::LedgerEntryExtensionV1 => Self::LedgerEntryExtensionV1(Box::default()),

            TypeVariant::LedgerEntry => Self::LedgerEntry(Box::default()),

            TypeVariant::LedgerKey => Self::LedgerKey(Box::default()),

            TypeVariant::EnvelopeType => Self::EnvelopeType(Box::default()),

            TypeVariant::BucketListType => Self::BucketListType(Box::default()),

            TypeVariant::BucketEntryType => Self::BucketEntryType(Box::default()),

            TypeVariant::HotArchiveBucketEntryType => {
                Self::HotArchiveBucketEntryType(Box::default())
            }

            TypeVariant::BucketMetadata => Self::BucketMetadata(Box::default()),

            TypeVariant::BucketEntry => Self::BucketEntry(Box::default()),

            TypeVariant::HotArchiveBucketEntry => Self::HotArchiveBucketEntry(Box::default()),

            TypeVariant::UpgradeType => Self::UpgradeType(Box::default()),

            TypeVariant::StellarValueType => Self::StellarValueType(Box::default()),

            TypeVariant::LedgerCloseValueSignature => {
                Self::LedgerCloseValueSignature(Box::default())
            }

            TypeVariant::StellarValue => Self::StellarValue(Box::default()),

            TypeVariant::LedgerHeaderFlags => Self::LedgerHeaderFlags(Box::default()),

            TypeVariant::LedgerHeaderExtensionV1 => Self::LedgerHeaderExtensionV1(Box::default()),

            TypeVariant::LedgerHeader => Self::LedgerHeader(Box::default()),

            TypeVariant::LedgerUpgradeType => Self::LedgerUpgradeType(Box::default()),

            TypeVariant::ConfigUpgradeSetKey => Self::ConfigUpgradeSetKey(Box::default()),

            TypeVariant::LedgerUpgrade => Self::LedgerUpgrade(Box::default()),

            TypeVariant::ConfigUpgradeSet => Self::ConfigUpgradeSet(Box::default()),

            TypeVariant::TxSetComponentType => Self::TxSetComponentType(Box::default()),

            TypeVariant::DependentTxCluster => Self::DependentTxCluster(Box::default()),

            TypeVariant::ParallelTxExecutionStage => Self::ParallelTxExecutionStage(Box::default()),

            TypeVariant::ParallelTxsComponent => Self::ParallelTxsComponent(Box::default()),

            TypeVariant::TxSetComponent => Self::TxSetComponent(Box::default()),

            TypeVariant::TransactionPhase => Self::TransactionPhase(Box::default()),

            TypeVariant::TransactionSet => Self::TransactionSet(Box::default()),

            TypeVariant::TransactionSetV1 => Self::TransactionSetV1(Box::default()),

            TypeVariant::GeneralizedTransactionSet => {
                Self::GeneralizedTransactionSet(Box::default())
            }

            TypeVariant::TransactionResultPair => Self::TransactionResultPair(Box::default()),

            TypeVariant::TransactionResultSet => Self::TransactionResultSet(Box::default()),

            TypeVariant::TransactionHistoryEntry => Self::TransactionHistoryEntry(Box::default()),

            TypeVariant::TransactionHistoryResultEntry => {
                Self::TransactionHistoryResultEntry(Box::default())
            }

            TypeVariant::LedgerHeaderHistoryEntry => Self::LedgerHeaderHistoryEntry(Box::default()),

            TypeVariant::LedgerScpMessages => Self::LedgerScpMessages(Box::default()),

            TypeVariant::ScpHistoryEntryV0 => Self::ScpHistoryEntryV0(Box::default()),

            TypeVariant::ScpHistoryEntry => Self::ScpHistoryEntry(Box::default()),

            TypeVariant::LedgerEntryChangeType => Self::LedgerEntryChangeType(Box::default()),

            TypeVariant::LedgerEntryChange => Self::LedgerEntryChange(Box::default()),

            TypeVariant::LedgerEntryChanges => Self::LedgerEntryChanges(Box::default()),

            TypeVariant::OperationMeta => Self::OperationMeta(Box::default()),

            TypeVariant::TransactionMetaV1 => Self::TransactionMetaV1(Box::default()),

            TypeVariant::TransactionMetaV2 => Self::TransactionMetaV2(Box::default()),

            TypeVariant::ContractEventType => Self::ContractEventType(Box::default()),

            TypeVariant::ContractEvent => Self::ContractEvent(Box::default()),

            TypeVariant::DiagnosticEvent => Self::DiagnosticEvent(Box::default()),

            TypeVariant::SorobanTransactionMetaExtV1 => {
                Self::SorobanTransactionMetaExtV1(Box::default())
            }

            TypeVariant::SorobanTransactionMetaExt => {
                Self::SorobanTransactionMetaExt(Box::default())
            }

            TypeVariant::SorobanTransactionMeta => Self::SorobanTransactionMeta(Box::default()),

            TypeVariant::TransactionMetaV3 => Self::TransactionMetaV3(Box::default()),

            TypeVariant::OperationMetaV2 => Self::OperationMetaV2(Box::default()),

            TypeVariant::SorobanTransactionMetaV2 => Self::SorobanTransactionMetaV2(Box::default()),

            TypeVariant::TransactionEventStage => Self::TransactionEventStage(Box::default()),

            TypeVariant::TransactionEvent => Self::TransactionEvent(Box::default()),

            TypeVariant::TransactionMetaV4 => Self::TransactionMetaV4(Box::default()),

            TypeVariant::InvokeHostFunctionSuccessPreImage => {
                Self::InvokeHostFunctionSuccessPreImage(Box::default())
            }

            TypeVariant::TransactionMeta => Self::TransactionMeta(Box::default()),

            TypeVariant::TransactionResultMeta => Self::TransactionResultMeta(Box::default()),

            TypeVariant::TransactionResultMetaV1 => Self::TransactionResultMetaV1(Box::default()),

            TypeVariant::UpgradeEntryMeta => Self::UpgradeEntryMeta(Box::default()),

            TypeVariant::LedgerCloseMetaV0 => Self::LedgerCloseMetaV0(Box::default()),

            TypeVariant::LedgerCloseMetaExtV1 => Self::LedgerCloseMetaExtV1(Box::default()),

            TypeVariant::LedgerCloseMetaExt => Self::LedgerCloseMetaExt(Box::default()),

            TypeVariant::LedgerCloseMetaV1 => Self::LedgerCloseMetaV1(Box::default()),

            TypeVariant::LedgerCloseMetaV2 => Self::LedgerCloseMetaV2(Box::default()),

            TypeVariant::LedgerCloseMeta => Self::LedgerCloseMeta(Box::default()),

            TypeVariant::ErrorCode => Self::ErrorCode(Box::default()),

            TypeVariant::SError => Self::SError(Box::default()),

            TypeVariant::SendMore => Self::SendMore(Box::default()),

            TypeVariant::SendMoreExtended => Self::SendMoreExtended(Box::default()),

            TypeVariant::AuthCert => Self::AuthCert(Box::default()),

            TypeVariant::Hello => Self::Hello(Box::default()),

            TypeVariant::Auth => Self::Auth(Box::default()),

            TypeVariant::IpAddrType => Self::IpAddrType(Box::default()),

            TypeVariant::PeerAddress => Self::PeerAddress(Box::default()),

            TypeVariant::MessageType => Self::MessageType(Box::default()),

            TypeVariant::DontHave => Self::DontHave(Box::default()),

            TypeVariant::SurveyMessageCommandType => Self::SurveyMessageCommandType(Box::default()),

            TypeVariant::SurveyMessageResponseType => {
                Self::SurveyMessageResponseType(Box::default())
            }

            TypeVariant::TimeSlicedSurveyStartCollectingMessage => {
                Self::TimeSlicedSurveyStartCollectingMessage(Box::default())
            }

            TypeVariant::SignedTimeSlicedSurveyStartCollectingMessage => {
                Self::SignedTimeSlicedSurveyStartCollectingMessage(Box::default())
            }

            TypeVariant::TimeSlicedSurveyStopCollectingMessage => {
                Self::TimeSlicedSurveyStopCollectingMessage(Box::default())
            }

            TypeVariant::SignedTimeSlicedSurveyStopCollectingMessage => {
                Self::SignedTimeSlicedSurveyStopCollectingMessage(Box::default())
            }

            TypeVariant::SurveyRequestMessage => Self::SurveyRequestMessage(Box::default()),

            TypeVariant::TimeSlicedSurveyRequestMessage => {
                Self::TimeSlicedSurveyRequestMessage(Box::default())
            }

            TypeVariant::SignedTimeSlicedSurveyRequestMessage => {
                Self::SignedTimeSlicedSurveyRequestMessage(Box::default())
            }

            TypeVariant::EncryptedBody => Self::EncryptedBody(Box::default()),

            TypeVariant::SurveyResponseMessage => Self::SurveyResponseMessage(Box::default()),

            TypeVariant::TimeSlicedSurveyResponseMessage => {
                Self::TimeSlicedSurveyResponseMessage(Box::default())
            }

            TypeVariant::SignedTimeSlicedSurveyResponseMessage => {
                Self::SignedTimeSlicedSurveyResponseMessage(Box::default())
            }

            TypeVariant::PeerStats => Self::PeerStats(Box::default()),

            TypeVariant::TimeSlicedNodeData => Self::TimeSlicedNodeData(Box::default()),

            TypeVariant::TimeSlicedPeerData => Self::TimeSlicedPeerData(Box::default()),

            TypeVariant::TimeSlicedPeerDataList => Self::TimeSlicedPeerDataList(Box::default()),

            TypeVariant::TopologyResponseBodyV2 => Self::TopologyResponseBodyV2(Box::default()),

            TypeVariant::SurveyResponseBody => Self::SurveyResponseBody(Box::default()),

            TypeVariant::TxAdvertVector => Self::TxAdvertVector(Box::default()),

            TypeVariant::FloodAdvert => Self::FloodAdvert(Box::default()),

            TypeVariant::TxDemandVector => Self::TxDemandVector(Box::default()),

            TypeVariant::FloodDemand => Self::FloodDemand(Box::default()),

            TypeVariant::StellarMessage => Self::StellarMessage(Box::default()),

            TypeVariant::AuthenticatedMessage => Self::AuthenticatedMessage(Box::default()),

            TypeVariant::LiquidityPoolParameters => Self::LiquidityPoolParameters(Box::default()),

            TypeVariant::MuxedAccount => Self::MuxedAccount(Box::default()),

            TypeVariant::DecoratedSignature => Self::DecoratedSignature(Box::default()),

            TypeVariant::OperationType => Self::OperationType(Box::default()),

            TypeVariant::CreateAccountOp => Self::CreateAccountOp(Box::default()),

            TypeVariant::PaymentOp => Self::PaymentOp(Box::default()),

            TypeVariant::PathPaymentStrictReceiveOp => {
                Self::PathPaymentStrictReceiveOp(Box::default())
            }

            TypeVariant::PathPaymentStrictSendOp => Self::PathPaymentStrictSendOp(Box::default()),

            TypeVariant::ManageSellOfferOp => Self::ManageSellOfferOp(Box::default()),

            TypeVariant::ManageBuyOfferOp => Self::ManageBuyOfferOp(Box::default()),

            TypeVariant::CreatePassiveSellOfferOp => Self::CreatePassiveSellOfferOp(Box::default()),

            TypeVariant::SetOptionsOp => Self::SetOptionsOp(Box::default()),

            TypeVariant::ChangeTrustAsset => Self::ChangeTrustAsset(Box::default()),

            TypeVariant::ChangeTrustOp => Self::ChangeTrustOp(Box::default()),

            TypeVariant::AllowTrustOp => Self::AllowTrustOp(Box::default()),

            TypeVariant::ManageDataOp => Self::ManageDataOp(Box::default()),

            TypeVariant::BumpSequenceOp => Self::BumpSequenceOp(Box::default()),

            TypeVariant::CreateClaimableBalanceOp => Self::CreateClaimableBalanceOp(Box::default()),

            TypeVariant::ClaimClaimableBalanceOp => Self::ClaimClaimableBalanceOp(Box::default()),

            TypeVariant::BeginSponsoringFutureReservesOp => {
                Self::BeginSponsoringFutureReservesOp(Box::default())
            }

            TypeVariant::RevokeSponsorshipType => Self::RevokeSponsorshipType(Box::default()),

            TypeVariant::RevokeSponsorshipOp => Self::RevokeSponsorshipOp(Box::default()),

            TypeVariant::ClawbackOp => Self::ClawbackOp(Box::default()),

            TypeVariant::ClawbackClaimableBalanceOp => {
                Self::ClawbackClaimableBalanceOp(Box::default())
            }

            TypeVariant::SetTrustLineFlagsOp => Self::SetTrustLineFlagsOp(Box::default()),

            TypeVariant::LiquidityPoolDepositOp => Self::LiquidityPoolDepositOp(Box::default()),

            TypeVariant::LiquidityPoolWithdrawOp => Self::LiquidityPoolWithdrawOp(Box::default()),

            TypeVariant::HostFunctionType => Self::HostFunctionType(Box::default()),

            TypeVariant::ContractIdPreimageType => Self::ContractIdPreimageType(Box::default()),

            TypeVariant::ContractIdPreimage => Self::ContractIdPreimage(Box::default()),

            TypeVariant::CreateContractArgs => Self::CreateContractArgs(Box::default()),

            TypeVariant::CreateContractArgsV2 => Self::CreateContractArgsV2(Box::default()),

            TypeVariant::InvokeContractArgs => Self::InvokeContractArgs(Box::default()),

            TypeVariant::HostFunction => Self::HostFunction(Box::default()),

            TypeVariant::SorobanAuthorizedFunctionType => {
                Self::SorobanAuthorizedFunctionType(Box::default())
            }

            TypeVariant::SorobanAuthorizedFunction => {
                Self::SorobanAuthorizedFunction(Box::default())
            }

            TypeVariant::SorobanAuthorizedInvocation => {
                Self::SorobanAuthorizedInvocation(Box::default())
            }

            TypeVariant::SorobanAddressCredentials => {
                Self::SorobanAddressCredentials(Box::default())
            }

            TypeVariant::SorobanCredentialsType => Self::SorobanCredentialsType(Box::default()),

            TypeVariant::SorobanCredentials => Self::SorobanCredentials(Box::default()),

            TypeVariant::SorobanAuthorizationEntry => {
                Self::SorobanAuthorizationEntry(Box::default())
            }

            TypeVariant::SorobanAuthorizationEntries => {
                Self::SorobanAuthorizationEntries(Box::default())
            }

            TypeVariant::InvokeHostFunctionOp => Self::InvokeHostFunctionOp(Box::default()),

            TypeVariant::ExtendFootprintTtlOp => Self::ExtendFootprintTtlOp(Box::default()),

            TypeVariant::RestoreFootprintOp => Self::RestoreFootprintOp(Box::default()),

            TypeVariant::Operation => Self::Operation(Box::default()),

            TypeVariant::HashIdPreimage => Self::HashIdPreimage(Box::default()),

            TypeVariant::MemoType => Self::MemoType(Box::default()),

            TypeVariant::Memo => Self::Memo(Box::default()),

            TypeVariant::TimeBounds => Self::TimeBounds(Box::default()),

            TypeVariant::LedgerBounds => Self::LedgerBounds(Box::default()),

            TypeVariant::PreconditionsV2 => Self::PreconditionsV2(Box::default()),

            TypeVariant::PreconditionType => Self::PreconditionType(Box::default()),

            TypeVariant::Preconditions => Self::Preconditions(Box::default()),

            TypeVariant::LedgerFootprint => Self::LedgerFootprint(Box::default()),

            TypeVariant::SorobanResources => Self::SorobanResources(Box::default()),

            TypeVariant::SorobanResourcesExtV0 => Self::SorobanResourcesExtV0(Box::default()),

            TypeVariant::SorobanTransactionData => Self::SorobanTransactionData(Box::default()),

            TypeVariant::TransactionV0 => Self::TransactionV0(Box::default()),

            TypeVariant::TransactionV0Envelope => Self::TransactionV0Envelope(Box::default()),

            TypeVariant::Transaction => Self::Transaction(Box::default()),

            TypeVariant::TransactionV1Envelope => Self::TransactionV1Envelope(Box::default()),

            TypeVariant::FeeBumpTransaction => Self::FeeBumpTransaction(Box::default()),

            TypeVariant::FeeBumpTransactionEnvelope => {
                Self::FeeBumpTransactionEnvelope(Box::default())
            }

            TypeVariant::TransactionEnvelope => Self::TransactionEnvelope(Box::default()),

            TypeVariant::TransactionSignaturePayload => {
                Self::TransactionSignaturePayload(Box::default())
            }

            TypeVariant::ClaimAtomType => Self::ClaimAtomType(Box::default()),

            TypeVariant::ClaimOfferAtomV0 => Self::ClaimOfferAtomV0(Box::default()),

            TypeVariant::ClaimOfferAtom => Self::ClaimOfferAtom(Box::default()),

            TypeVariant::ClaimLiquidityAtom => Self::ClaimLiquidityAtom(Box::default()),

            TypeVariant::ClaimAtom => Self::ClaimAtom(Box::default()),

            TypeVariant::CreateAccountResultCode => Self::CreateAccountResultCode(Box::default()),

            TypeVariant::CreateAccountResult => Self::CreateAccountResult(Box::default()),

            TypeVariant::PaymentResultCode => Self::PaymentResultCode(Box::default()),

            TypeVariant::PaymentResult => Self::PaymentResult(Box::default()),

            TypeVariant::PathPaymentStrictReceiveResultCode => {
                Self::PathPaymentStrictReceiveResultCode(Box::default())
            }

            TypeVariant::SimplePaymentResult => Self::SimplePaymentResult(Box::default()),

            TypeVariant::PathPaymentStrictReceiveResult => {
                Self::PathPaymentStrictReceiveResult(Box::default())
            }

            TypeVariant::PathPaymentStrictSendResultCode => {
                Self::PathPaymentStrictSendResultCode(Box::default())
            }

            TypeVariant::PathPaymentStrictSendResult => {
                Self::PathPaymentStrictSendResult(Box::default())
            }

            TypeVariant::ManageSellOfferResultCode => {
                Self::ManageSellOfferResultCode(Box::default())
            }

            TypeVariant::ManageOfferEffect => Self::ManageOfferEffect(Box::default()),

            TypeVariant::ManageOfferSuccessResult => Self::ManageOfferSuccessResult(Box::default()),

            TypeVariant::ManageSellOfferResult => Self::ManageSellOfferResult(Box::default()),

            TypeVariant::ManageBuyOfferResultCode => Self::ManageBuyOfferResultCode(Box::default()),

            TypeVariant::ManageBuyOfferResult => Self::ManageBuyOfferResult(Box::default()),

            TypeVariant::SetOptionsResultCode => Self::SetOptionsResultCode(Box::default()),

            TypeVariant::SetOptionsResult => Self::SetOptionsResult(Box::default()),

            TypeVariant::ChangeTrustResultCode => Self::ChangeTrustResultCode(Box::default()),

            TypeVariant::ChangeTrustResult => Self::ChangeTrustResult(Box::default()),

            TypeVariant::AllowTrustResultCode => Self::AllowTrustResultCode(Box::default()),

            TypeVariant::AllowTrustResult => Self::AllowTrustResult(Box::default()),

            TypeVariant::AccountMergeResultCode => Self::AccountMergeResultCode(Box::default()),

            TypeVariant::AccountMergeResult => Self::AccountMergeResult(Box::default()),

            TypeVariant::InflationResultCode => Self::InflationResultCode(Box::default()),

            TypeVariant::InflationPayout => Self::InflationPayout(Box::default()),

            TypeVariant::InflationResult => Self::InflationResult(Box::default()),

            TypeVariant::ManageDataResultCode => Self::ManageDataResultCode(Box::default()),

            TypeVariant::ManageDataResult => Self::ManageDataResult(Box::default()),

            TypeVariant::BumpSequenceResultCode => Self::BumpSequenceResultCode(Box::default()),

            TypeVariant::BumpSequenceResult => Self::BumpSequenceResult(Box::default()),

            TypeVariant::CreateClaimableBalanceResultCode => {
                Self::CreateClaimableBalanceResultCode(Box::default())
            }

            TypeVariant::CreateClaimableBalanceResult => {
                Self::CreateClaimableBalanceResult(Box::default())
            }

            TypeVariant::ClaimClaimableBalanceResultCode => {
                Self::ClaimClaimableBalanceResultCode(Box::default())
            }

            TypeVariant::ClaimClaimableBalanceResult => {
                Self::ClaimClaimableBalanceResult(Box::default())
            }

            TypeVariant::BeginSponsoringFutureReservesResultCode => {
                Self::BeginSponsoringFutureReservesResultCode(Box::default())
            }

            TypeVariant::BeginSponsoringFutureReservesResult => {
                Self::BeginSponsoringFutureReservesResult(Box::default())
            }

            TypeVariant::EndSponsoringFutureReservesResultCode => {
                Self::EndSponsoringFutureReservesResultCode(Box::default())
            }

            TypeVariant::EndSponsoringFutureReservesResult => {
                Self::EndSponsoringFutureReservesResult(Box::default())
            }

            TypeVariant::RevokeSponsorshipResultCode => {
                Self::RevokeSponsorshipResultCode(Box::default())
            }

            TypeVariant::RevokeSponsorshipResult => Self::RevokeSponsorshipResult(Box::default()),

            TypeVariant::ClawbackResultCode => Self::ClawbackResultCode(Box::default()),

            TypeVariant::ClawbackResult => Self::ClawbackResult(Box::default()),

            TypeVariant::ClawbackClaimableBalanceResultCode => {
                Self::ClawbackClaimableBalanceResultCode(Box::default())
            }

            TypeVariant::ClawbackClaimableBalanceResult => {
                Self::ClawbackClaimableBalanceResult(Box::default())
            }

            TypeVariant::SetTrustLineFlagsResultCode => {
                Self::SetTrustLineFlagsResultCode(Box::default())
            }

            TypeVariant::SetTrustLineFlagsResult => Self::SetTrustLineFlagsResult(Box::default()),

            TypeVariant::LiquidityPoolDepositResultCode => {
                Self::LiquidityPoolDepositResultCode(Box::default())
            }

            TypeVariant::LiquidityPoolDepositResult => {
                Self::LiquidityPoolDepositResult(Box::default())
            }

            TypeVariant::LiquidityPoolWithdrawResultCode => {
                Self::LiquidityPoolWithdrawResultCode(Box::default())
            }

            TypeVariant::LiquidityPoolWithdrawResult => {
                Self::LiquidityPoolWithdrawResult(Box::default())
            }

            TypeVariant::InvokeHostFunctionResultCode => {
                Self::InvokeHostFunctionResultCode(Box::default())
            }

            TypeVariant::InvokeHostFunctionResult => Self::InvokeHostFunctionResult(Box::default()),

            TypeVariant::ExtendFootprintTtlResultCode => {
                Self::ExtendFootprintTtlResultCode(Box::default())
            }

            TypeVariant::ExtendFootprintTtlResult => Self::ExtendFootprintTtlResult(Box::default()),

            TypeVariant::RestoreFootprintResultCode => {
                Self::RestoreFootprintResultCode(Box::default())
            }

            TypeVariant::RestoreFootprintResult => Self::RestoreFootprintResult(Box::default()),

            TypeVariant::OperationResultCode => Self::OperationResultCode(Box::default()),

            TypeVariant::OperationResult => Self::OperationResult(Box::default()),

            TypeVariant::TransactionResultCode => Self::TransactionResultCode(Box::default()),

            TypeVariant::InnerTransactionResult => Self::InnerTransactionResult(Box::default()),

            TypeVariant::InnerTransactionResultPair => {
                Self::InnerTransactionResultPair(Box::default())
            }

            TypeVariant::TransactionResult => Self::TransactionResult(Box::default()),

            TypeVariant::Hash => Self::Hash(Box::default()),

            TypeVariant::Uint256 => Self::Uint256(Box::default()),

            TypeVariant::Uint32 => Self::Uint32(Box::default()),

            TypeVariant::Int32 => Self::Int32(Box::default()),

            TypeVariant::Uint64 => Self::Uint64(Box::default()),

            TypeVariant::Int64 => Self::Int64(Box::default()),

            TypeVariant::TimePoint => Self::TimePoint(Box::default()),

            TypeVariant::Duration => Self::Duration(Box::default()),

            TypeVariant::ExtensionPoint => Self::ExtensionPoint(Box::default()),

            TypeVariant::CryptoKeyType => Self::CryptoKeyType(Box::default()),

            TypeVariant::PublicKeyType => Self::PublicKeyType(Box::default()),

            TypeVariant::SignerKeyType => Self::SignerKeyType(Box::default()),

            TypeVariant::PublicKey => Self::PublicKey(Box::default()),

            TypeVariant::SignerKey => Self::SignerKey(Box::default()),

            TypeVariant::Signature => Self::Signature(Box::default()),

            TypeVariant::SignatureHint => Self::SignatureHint(Box::default()),

            TypeVariant::NodeId => Self::NodeId(Box::default()),

            TypeVariant::AccountId => Self::AccountId(Box::default()),

            TypeVariant::ContractId => Self::ContractId(Box::default()),

            TypeVariant::Curve25519Secret => Self::Curve25519Secret(Box::default()),

            TypeVariant::Curve25519Public => Self::Curve25519Public(Box::default()),

            TypeVariant::HmacSha256Key => Self::HmacSha256Key(Box::default()),

            TypeVariant::HmacSha256Mac => Self::HmacSha256Mac(Box::default()),

            TypeVariant::ShortHashSeed => Self::ShortHashSeed(Box::default()),

            TypeVariant::BinaryFuseFilterType => Self::BinaryFuseFilterType(Box::default()),

            TypeVariant::SerializedBinaryFuseFilter => {
                Self::SerializedBinaryFuseFilter(Box::default())
            }

            TypeVariant::PoolId => Self::PoolId(Box::default()),

            TypeVariant::ClaimableBalanceIdType => Self::ClaimableBalanceIdType(Box::default()),

            TypeVariant::ClaimableBalanceId => Self::ClaimableBalanceId(Box::default()),
        }
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub fn value(&self) -> &dyn core::any::Any {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ScpStatementPrepare(ref v) => v.as_ref(),

            Self::ScpStatementConfirm(ref v) => v.as_ref(),

            Self::ScpStatementExternalize(ref v) => v.as_ref(),

            Self::ScpStatementPledges(ref v) => v.as_ref(),

            Self::ScEnvMetaEntryInterfaceVersion(ref v) => v.as_ref(),

            Self::AccountEntryExtensionV2Ext(ref v) => v.as_ref(),

            Self::AccountEntryExtensionV1Ext(ref v) => v.as_ref(),

            Self::AccountEntryExt(ref v) => v.as_ref(),

            Self::TrustLineEntryExtensionV2Ext(ref v) => v.as_ref(),

            Self::TrustLineEntryV1Ext(ref v) => v.as_ref(),

            Self::TrustLineEntryV1(ref v) => v.as_ref(),

            Self::TrustLineEntryExt(ref v) => v.as_ref(),

            Self::OfferEntryExt(ref v) => v.as_ref(),

            Self::DataEntryExt(ref v) => v.as_ref(),

            Self::ClaimantV0(ref v) => v.as_ref(),

            Self::ClaimableBalanceEntryExtensionV1Ext(ref v) => v.as_ref(),

            Self::ClaimableBalanceEntryExt(ref v) => v.as_ref(),

            Self::LiquidityPoolEntryConstantProduct(ref v) => v.as_ref(),

            Self::LiquidityPoolEntryBody(ref v) => v.as_ref(),

            Self::ContractCodeEntryV1(ref v) => v.as_ref(),

            Self::ContractCodeEntryExt(ref v) => v.as_ref(),

            Self::LedgerEntryExtensionV1Ext(ref v) => v.as_ref(),

            Self::LedgerEntryData(ref v) => v.as_ref(),

            Self::LedgerEntryExt(ref v) => v.as_ref(),

            Self::LedgerKeyAccount(ref v) => v.as_ref(),

            Self::LedgerKeyTrustLine(ref v) => v.as_ref(),

            Self::LedgerKeyOffer(ref v) => v.as_ref(),

            Self::LedgerKeyData(ref v) => v.as_ref(),

            Self::LedgerKeyClaimableBalance(ref v) => v.as_ref(),

            Self::LedgerKeyLiquidityPool(ref v) => v.as_ref(),

            Self::LedgerKeyContractData(ref v) => v.as_ref(),

            Self::LedgerKeyContractCode(ref v) => v.as_ref(),

            Self::LedgerKeyConfigSetting(ref v) => v.as_ref(),

            Self::LedgerKeyTtl(ref v) => v.as_ref(),

            Self::BucketMetadataExt(ref v) => v.as_ref(),

            Self::StellarValueExt(ref v) => v.as_ref(),

            Self::LedgerHeaderExtensionV1Ext(ref v) => v.as_ref(),

            Self::LedgerHeaderExt(ref v) => v.as_ref(),

            Self::TxSetComponentTxsMaybeDiscountedFee(ref v) => v.as_ref(),

            Self::TransactionHistoryEntryExt(ref v) => v.as_ref(),

            Self::TransactionHistoryResultEntryExt(ref v) => v.as_ref(),

            Self::LedgerHeaderHistoryEntryExt(ref v) => v.as_ref(),

            Self::ContractEventV0(ref v) => v.as_ref(),

            Self::ContractEventBody(ref v) => v.as_ref(),

            Self::PeerAddressIp(ref v) => v.as_ref(),

            Self::AuthenticatedMessageV0(ref v) => v.as_ref(),

            Self::MuxedAccountMed25519(ref v) => v.as_ref(),

            Self::RevokeSponsorshipOpSigner(ref v) => v.as_ref(),

            Self::ContractIdPreimageFromAddress(ref v) => v.as_ref(),

            Self::OperationBody(ref v) => v.as_ref(),

            Self::HashIdPreimageOperationId(ref v) => v.as_ref(),

            Self::HashIdPreimageRevokeId(ref v) => v.as_ref(),

            Self::HashIdPreimageContractId(ref v) => v.as_ref(),

            Self::HashIdPreimageSorobanAuthorization(ref v) => v.as_ref(),

            Self::SorobanTransactionDataExt(ref v) => v.as_ref(),

            Self::TransactionV0Ext(ref v) => v.as_ref(),

            Self::TransactionExt(ref v) => v.as_ref(),

            Self::FeeBumpTransactionInnerTx(ref v) => v.as_ref(),

            Self::FeeBumpTransactionExt(ref v) => v.as_ref(),

            Self::TransactionSignaturePayloadTaggedTransaction(ref v) => v.as_ref(),

            Self::PathPaymentStrictReceiveResultSuccess(ref v) => v.as_ref(),

            Self::PathPaymentStrictSendResultSuccess(ref v) => v.as_ref(),

            Self::ManageOfferSuccessResultOffer(ref v) => v.as_ref(),

            Self::OperationResultTr(ref v) => v.as_ref(),

            Self::InnerTransactionResultResult(ref v) => v.as_ref(),

            Self::InnerTransactionResultExt(ref v) => v.as_ref(),

            Self::TransactionResultResult(ref v) => v.as_ref(),

            Self::TransactionResultExt(ref v) => v.as_ref(),

            Self::SignerKeyEd25519SignedPayload(ref v) => v.as_ref(),

            Self::Value(ref v) => v.as_ref(),

            Self::ScpBallot(ref v) => v.as_ref(),

            Self::ScpStatementType(ref v) => v.as_ref(),

            Self::ScpNomination(ref v) => v.as_ref(),

            Self::ScpStatement(ref v) => v.as_ref(),

            Self::ScpEnvelope(ref v) => v.as_ref(),

            Self::ScpQuorumSet(ref v) => v.as_ref(),

            Self::ConfigSettingContractExecutionLanesV0(ref v) => v.as_ref(),

            Self::ConfigSettingContractComputeV0(ref v) => v.as_ref(),

            Self::ConfigSettingContractParallelComputeV0(ref v) => v.as_ref(),

            Self::ConfigSettingContractLedgerCostV0(ref v) => v.as_ref(),

            Self::ConfigSettingContractLedgerCostExtV0(ref v) => v.as_ref(),

            Self::ConfigSettingContractHistoricalDataV0(ref v) => v.as_ref(),

            Self::ConfigSettingContractEventsV0(ref v) => v.as_ref(),

            Self::ConfigSettingContractBandwidthV0(ref v) => v.as_ref(),

            Self::ContractCostType(ref v) => v.as_ref(),

            Self::ContractCostParamEntry(ref v) => v.as_ref(),

            Self::StateArchivalSettings(ref v) => v.as_ref(),

            Self::EvictionIterator(ref v) => v.as_ref(),

            Self::ConfigSettingScpTiming(ref v) => v.as_ref(),

            Self::ContractCostParams(ref v) => v.as_ref(),

            Self::ConfigSettingId(ref v) => v.as_ref(),

            Self::ConfigSettingEntry(ref v) => v.as_ref(),

            Self::ScEnvMetaKind(ref v) => v.as_ref(),

            Self::ScEnvMetaEntry(ref v) => v.as_ref(),

            Self::ScMetaV0(ref v) => v.as_ref(),

            Self::ScMetaKind(ref v) => v.as_ref(),

            Self::ScMetaEntry(ref v) => v.as_ref(),

            Self::ScSpecType(ref v) => v.as_ref(),

            Self::ScSpecTypeOption(ref v) => v.as_ref(),

            Self::ScSpecTypeResult(ref v) => v.as_ref(),

            Self::ScSpecTypeVec(ref v) => v.as_ref(),

            Self::ScSpecTypeMap(ref v) => v.as_ref(),

            Self::ScSpecTypeTuple(ref v) => v.as_ref(),

            Self::ScSpecTypeBytesN(ref v) => v.as_ref(),

            Self::ScSpecTypeUdt(ref v) => v.as_ref(),

            Self::ScSpecTypeDef(ref v) => v.as_ref(),

            Self::ScSpecUdtStructFieldV0(ref v) => v.as_ref(),

            Self::ScSpecUdtStructV0(ref v) => v.as_ref(),

            Self::ScSpecUdtUnionCaseVoidV0(ref v) => v.as_ref(),

            Self::ScSpecUdtUnionCaseTupleV0(ref v) => v.as_ref(),

            Self::ScSpecUdtUnionCaseV0Kind(ref v) => v.as_ref(),

            Self::ScSpecUdtUnionCaseV0(ref v) => v.as_ref(),

            Self::ScSpecUdtUnionV0(ref v) => v.as_ref(),

            Self::ScSpecUdtEnumCaseV0(ref v) => v.as_ref(),

            Self::ScSpecUdtEnumV0(ref v) => v.as_ref(),

            Self::ScSpecUdtErrorEnumCaseV0(ref v) => v.as_ref(),

            Self::ScSpecUdtErrorEnumV0(ref v) => v.as_ref(),

            Self::ScSpecFunctionInputV0(ref v) => v.as_ref(),

            Self::ScSpecFunctionV0(ref v) => v.as_ref(),

            Self::ScSpecEventParamLocationV0(ref v) => v.as_ref(),

            Self::ScSpecEventParamV0(ref v) => v.as_ref(),

            Self::ScSpecEventDataFormat(ref v) => v.as_ref(),

            Self::ScSpecEventV0(ref v) => v.as_ref(),

            Self::ScSpecEntryKind(ref v) => v.as_ref(),

            Self::ScSpecEntry(ref v) => v.as_ref(),

            Self::ScValType(ref v) => v.as_ref(),

            Self::ScErrorType(ref v) => v.as_ref(),

            Self::ScErrorCode(ref v) => v.as_ref(),

            Self::ScError(ref v) => v.as_ref(),

            Self::UInt128Parts(ref v) => v.as_ref(),

            Self::Int128Parts(ref v) => v.as_ref(),

            Self::UInt256Parts(ref v) => v.as_ref(),

            Self::Int256Parts(ref v) => v.as_ref(),

            Self::ContractExecutableType(ref v) => v.as_ref(),

            Self::ContractExecutable(ref v) => v.as_ref(),

            Self::ScAddressType(ref v) => v.as_ref(),

            Self::MuxedEd25519Account(ref v) => v.as_ref(),

            Self::ScAddress(ref v) => v.as_ref(),

            Self::ScVec(ref v) => v.as_ref(),

            Self::ScMap(ref v) => v.as_ref(),

            Self::ScBytes(ref v) => v.as_ref(),

            Self::ScString(ref v) => v.as_ref(),

            Self::ScSymbol(ref v) => v.as_ref(),

            Self::ScNonceKey(ref v) => v.as_ref(),

            Self::ScContractInstance(ref v) => v.as_ref(),

            Self::ScVal(ref v) => v.as_ref(),

            Self::ScMapEntry(ref v) => v.as_ref(),

            Self::LedgerCloseMetaBatch(ref v) => v.as_ref(),

            Self::StoredTransactionSet(ref v) => v.as_ref(),

            Self::StoredDebugTransactionSet(ref v) => v.as_ref(),

            Self::PersistedScpStateV0(ref v) => v.as_ref(),

            Self::PersistedScpStateV1(ref v) => v.as_ref(),

            Self::PersistedScpState(ref v) => v.as_ref(),

            Self::Thresholds(ref v) => v.as_ref(),

            Self::String32(ref v) => v.as_ref(),

            Self::String64(ref v) => v.as_ref(),

            Self::SequenceNumber(ref v) => v.as_ref(),

            Self::DataValue(ref v) => v.as_ref(),

            Self::AssetCode4(ref v) => v.as_ref(),

            Self::AssetCode12(ref v) => v.as_ref(),

            Self::AssetType(ref v) => v.as_ref(),

            Self::AssetCode(ref v) => v.as_ref(),

            Self::AlphaNum4(ref v) => v.as_ref(),

            Self::AlphaNum12(ref v) => v.as_ref(),

            Self::Asset(ref v) => v.as_ref(),

            Self::Price(ref v) => v.as_ref(),

            Self::Liabilities(ref v) => v.as_ref(),

            Self::ThresholdIndexes(ref v) => v.as_ref(),

            Self::LedgerEntryType(ref v) => v.as_ref(),

            Self::Signer(ref v) => v.as_ref(),

            Self::AccountFlags(ref v) => v.as_ref(),

            Self::SponsorshipDescriptor(ref v) => v.as_ref(),

            Self::AccountEntryExtensionV3(ref v) => v.as_ref(),

            Self::AccountEntryExtensionV2(ref v) => v.as_ref(),

            Self::AccountEntryExtensionV1(ref v) => v.as_ref(),

            Self::AccountEntry(ref v) => v.as_ref(),

            Self::TrustLineFlags(ref v) => v.as_ref(),

            Self::LiquidityPoolType(ref v) => v.as_ref(),

            Self::TrustLineAsset(ref v) => v.as_ref(),

            Self::TrustLineEntryExtensionV2(ref v) => v.as_ref(),

            Self::TrustLineEntry(ref v) => v.as_ref(),

            Self::OfferEntryFlags(ref v) => v.as_ref(),

            Self::OfferEntry(ref v) => v.as_ref(),

            Self::DataEntry(ref v) => v.as_ref(),

            Self::ClaimPredicateType(ref v) => v.as_ref(),

            Self::ClaimPredicate(ref v) => v.as_ref(),

            Self::ClaimantType(ref v) => v.as_ref(),

            Self::Claimant(ref v) => v.as_ref(),

            Self::ClaimableBalanceFlags(ref v) => v.as_ref(),

            Self::ClaimableBalanceEntryExtensionV1(ref v) => v.as_ref(),

            Self::ClaimableBalanceEntry(ref v) => v.as_ref(),

            Self::LiquidityPoolConstantProductParameters(ref v) => v.as_ref(),

            Self::LiquidityPoolEntry(ref v) => v.as_ref(),

            Self::ContractDataDurability(ref v) => v.as_ref(),

            Self::ContractDataEntry(ref v) => v.as_ref(),

            Self::ContractCodeCostInputs(ref v) => v.as_ref(),

            Self::ContractCodeEntry(ref v) => v.as_ref(),

            Self::TtlEntry(ref v) => v.as_ref(),

            Self::LedgerEntryExtensionV1(ref v) => v.as_ref(),

            Self::LedgerEntry(ref v) => v.as_ref(),

            Self::LedgerKey(ref v) => v.as_ref(),

            Self::EnvelopeType(ref v) => v.as_ref(),

            Self::BucketListType(ref v) => v.as_ref(),

            Self::BucketEntryType(ref v) => v.as_ref(),

            Self::HotArchiveBucketEntryType(ref v) => v.as_ref(),

            Self::BucketMetadata(ref v) => v.as_ref(),

            Self::BucketEntry(ref v) => v.as_ref(),

            Self::HotArchiveBucketEntry(ref v) => v.as_ref(),

            Self::UpgradeType(ref v) => v.as_ref(),

            Self::StellarValueType(ref v) => v.as_ref(),

            Self::LedgerCloseValueSignature(ref v) => v.as_ref(),

            Self::StellarValue(ref v) => v.as_ref(),

            Self::LedgerHeaderFlags(ref v) => v.as_ref(),

            Self::LedgerHeaderExtensionV1(ref v) => v.as_ref(),

            Self::LedgerHeader(ref v) => v.as_ref(),

            Self::LedgerUpgradeType(ref v) => v.as_ref(),

            Self::ConfigUpgradeSetKey(ref v) => v.as_ref(),

            Self::LedgerUpgrade(ref v) => v.as_ref(),

            Self::ConfigUpgradeSet(ref v) => v.as_ref(),

            Self::TxSetComponentType(ref v) => v.as_ref(),

            Self::DependentTxCluster(ref v) => v.as_ref(),

            Self::ParallelTxExecutionStage(ref v) => v.as_ref(),

            Self::ParallelTxsComponent(ref v) => v.as_ref(),

            Self::TxSetComponent(ref v) => v.as_ref(),

            Self::TransactionPhase(ref v) => v.as_ref(),

            Self::TransactionSet(ref v) => v.as_ref(),

            Self::TransactionSetV1(ref v) => v.as_ref(),

            Self::GeneralizedTransactionSet(ref v) => v.as_ref(),

            Self::TransactionResultPair(ref v) => v.as_ref(),

            Self::TransactionResultSet(ref v) => v.as_ref(),

            Self::TransactionHistoryEntry(ref v) => v.as_ref(),

            Self::TransactionHistoryResultEntry(ref v) => v.as_ref(),

            Self::LedgerHeaderHistoryEntry(ref v) => v.as_ref(),

            Self::LedgerScpMessages(ref v) => v.as_ref(),

            Self::ScpHistoryEntryV0(ref v) => v.as_ref(),

            Self::ScpHistoryEntry(ref v) => v.as_ref(),

            Self::LedgerEntryChangeType(ref v) => v.as_ref(),

            Self::LedgerEntryChange(ref v) => v.as_ref(),

            Self::LedgerEntryChanges(ref v) => v.as_ref(),

            Self::OperationMeta(ref v) => v.as_ref(),

            Self::TransactionMetaV1(ref v) => v.as_ref(),

            Self::TransactionMetaV2(ref v) => v.as_ref(),

            Self::ContractEventType(ref v) => v.as_ref(),

            Self::ContractEvent(ref v) => v.as_ref(),

            Self::DiagnosticEvent(ref v) => v.as_ref(),

            Self::SorobanTransactionMetaExtV1(ref v) => v.as_ref(),

            Self::SorobanTransactionMetaExt(ref v) => v.as_ref(),

            Self::SorobanTransactionMeta(ref v) => v.as_ref(),

            Self::TransactionMetaV3(ref v) => v.as_ref(),

            Self::OperationMetaV2(ref v) => v.as_ref(),

            Self::SorobanTransactionMetaV2(ref v) => v.as_ref(),

            Self::TransactionEventStage(ref v) => v.as_ref(),

            Self::TransactionEvent(ref v) => v.as_ref(),

            Self::TransactionMetaV4(ref v) => v.as_ref(),

            Self::InvokeHostFunctionSuccessPreImage(ref v) => v.as_ref(),

            Self::TransactionMeta(ref v) => v.as_ref(),

            Self::TransactionResultMeta(ref v) => v.as_ref(),

            Self::TransactionResultMetaV1(ref v) => v.as_ref(),

            Self::UpgradeEntryMeta(ref v) => v.as_ref(),

            Self::LedgerCloseMetaV0(ref v) => v.as_ref(),

            Self::LedgerCloseMetaExtV1(ref v) => v.as_ref(),

            Self::LedgerCloseMetaExt(ref v) => v.as_ref(),

            Self::LedgerCloseMetaV1(ref v) => v.as_ref(),

            Self::LedgerCloseMetaV2(ref v) => v.as_ref(),

            Self::LedgerCloseMeta(ref v) => v.as_ref(),

            Self::ErrorCode(ref v) => v.as_ref(),

            Self::SError(ref v) => v.as_ref(),

            Self::SendMore(ref v) => v.as_ref(),

            Self::SendMoreExtended(ref v) => v.as_ref(),

            Self::AuthCert(ref v) => v.as_ref(),

            Self::Hello(ref v) => v.as_ref(),

            Self::Auth(ref v) => v.as_ref(),

            Self::IpAddrType(ref v) => v.as_ref(),

            Self::PeerAddress(ref v) => v.as_ref(),

            Self::MessageType(ref v) => v.as_ref(),

            Self::DontHave(ref v) => v.as_ref(),

            Self::SurveyMessageCommandType(ref v) => v.as_ref(),

            Self::SurveyMessageResponseType(ref v) => v.as_ref(),

            Self::TimeSlicedSurveyStartCollectingMessage(ref v) => v.as_ref(),

            Self::SignedTimeSlicedSurveyStartCollectingMessage(ref v) => v.as_ref(),

            Self::TimeSlicedSurveyStopCollectingMessage(ref v) => v.as_ref(),

            Self::SignedTimeSlicedSurveyStopCollectingMessage(ref v) => v.as_ref(),

            Self::SurveyRequestMessage(ref v) => v.as_ref(),

            Self::TimeSlicedSurveyRequestMessage(ref v) => v.as_ref(),

            Self::SignedTimeSlicedSurveyRequestMessage(ref v) => v.as_ref(),

            Self::EncryptedBody(ref v) => v.as_ref(),

            Self::SurveyResponseMessage(ref v) => v.as_ref(),

            Self::TimeSlicedSurveyResponseMessage(ref v) => v.as_ref(),

            Self::SignedTimeSlicedSurveyResponseMessage(ref v) => v.as_ref(),

            Self::PeerStats(ref v) => v.as_ref(),

            Self::TimeSlicedNodeData(ref v) => v.as_ref(),

            Self::TimeSlicedPeerData(ref v) => v.as_ref(),

            Self::TimeSlicedPeerDataList(ref v) => v.as_ref(),

            Self::TopologyResponseBodyV2(ref v) => v.as_ref(),

            Self::SurveyResponseBody(ref v) => v.as_ref(),

            Self::TxAdvertVector(ref v) => v.as_ref(),

            Self::FloodAdvert(ref v) => v.as_ref(),

            Self::TxDemandVector(ref v) => v.as_ref(),

            Self::FloodDemand(ref v) => v.as_ref(),

            Self::StellarMessage(ref v) => v.as_ref(),

            Self::AuthenticatedMessage(ref v) => v.as_ref(),

            Self::LiquidityPoolParameters(ref v) => v.as_ref(),

            Self::MuxedAccount(ref v) => v.as_ref(),

            Self::DecoratedSignature(ref v) => v.as_ref(),

            Self::OperationType(ref v) => v.as_ref(),

            Self::CreateAccountOp(ref v) => v.as_ref(),

            Self::PaymentOp(ref v) => v.as_ref(),

            Self::PathPaymentStrictReceiveOp(ref v) => v.as_ref(),

            Self::PathPaymentStrictSendOp(ref v) => v.as_ref(),

            Self::ManageSellOfferOp(ref v) => v.as_ref(),

            Self::ManageBuyOfferOp(ref v) => v.as_ref(),

            Self::CreatePassiveSellOfferOp(ref v) => v.as_ref(),

            Self::SetOptionsOp(ref v) => v.as_ref(),

            Self::ChangeTrustAsset(ref v) => v.as_ref(),

            Self::ChangeTrustOp(ref v) => v.as_ref(),

            Self::AllowTrustOp(ref v) => v.as_ref(),

            Self::ManageDataOp(ref v) => v.as_ref(),

            Self::BumpSequenceOp(ref v) => v.as_ref(),

            Self::CreateClaimableBalanceOp(ref v) => v.as_ref(),

            Self::ClaimClaimableBalanceOp(ref v) => v.as_ref(),

            Self::BeginSponsoringFutureReservesOp(ref v) => v.as_ref(),

            Self::RevokeSponsorshipType(ref v) => v.as_ref(),

            Self::RevokeSponsorshipOp(ref v) => v.as_ref(),

            Self::ClawbackOp(ref v) => v.as_ref(),

            Self::ClawbackClaimableBalanceOp(ref v) => v.as_ref(),

            Self::SetTrustLineFlagsOp(ref v) => v.as_ref(),

            Self::LiquidityPoolDepositOp(ref v) => v.as_ref(),

            Self::LiquidityPoolWithdrawOp(ref v) => v.as_ref(),

            Self::HostFunctionType(ref v) => v.as_ref(),

            Self::ContractIdPreimageType(ref v) => v.as_ref(),

            Self::ContractIdPreimage(ref v) => v.as_ref(),

            Self::CreateContractArgs(ref v) => v.as_ref(),

            Self::CreateContractArgsV2(ref v) => v.as_ref(),

            Self::InvokeContractArgs(ref v) => v.as_ref(),

            Self::HostFunction(ref v) => v.as_ref(),

            Self::SorobanAuthorizedFunctionType(ref v) => v.as_ref(),

            Self::SorobanAuthorizedFunction(ref v) => v.as_ref(),

            Self::SorobanAuthorizedInvocation(ref v) => v.as_ref(),

            Self::SorobanAddressCredentials(ref v) => v.as_ref(),

            Self::SorobanCredentialsType(ref v) => v.as_ref(),

            Self::SorobanCredentials(ref v) => v.as_ref(),

            Self::SorobanAuthorizationEntry(ref v) => v.as_ref(),

            Self::SorobanAuthorizationEntries(ref v) => v.as_ref(),

            Self::InvokeHostFunctionOp(ref v) => v.as_ref(),

            Self::ExtendFootprintTtlOp(ref v) => v.as_ref(),

            Self::RestoreFootprintOp(ref v) => v.as_ref(),

            Self::Operation(ref v) => v.as_ref(),

            Self::HashIdPreimage(ref v) => v.as_ref(),

            Self::MemoType(ref v) => v.as_ref(),

            Self::Memo(ref v) => v.as_ref(),

            Self::TimeBounds(ref v) => v.as_ref(),

            Self::LedgerBounds(ref v) => v.as_ref(),

            Self::PreconditionsV2(ref v) => v.as_ref(),

            Self::PreconditionType(ref v) => v.as_ref(),

            Self::Preconditions(ref v) => v.as_ref(),

            Self::LedgerFootprint(ref v) => v.as_ref(),

            Self::SorobanResources(ref v) => v.as_ref(),

            Self::SorobanResourcesExtV0(ref v) => v.as_ref(),

            Self::SorobanTransactionData(ref v) => v.as_ref(),

            Self::TransactionV0(ref v) => v.as_ref(),

            Self::TransactionV0Envelope(ref v) => v.as_ref(),

            Self::Transaction(ref v) => v.as_ref(),

            Self::TransactionV1Envelope(ref v) => v.as_ref(),

            Self::FeeBumpTransaction(ref v) => v.as_ref(),

            Self::FeeBumpTransactionEnvelope(ref v) => v.as_ref(),

            Self::TransactionEnvelope(ref v) => v.as_ref(),

            Self::TransactionSignaturePayload(ref v) => v.as_ref(),

            Self::ClaimAtomType(ref v) => v.as_ref(),

            Self::ClaimOfferAtomV0(ref v) => v.as_ref(),

            Self::ClaimOfferAtom(ref v) => v.as_ref(),

            Self::ClaimLiquidityAtom(ref v) => v.as_ref(),

            Self::ClaimAtom(ref v) => v.as_ref(),

            Self::CreateAccountResultCode(ref v) => v.as_ref(),

            Self::CreateAccountResult(ref v) => v.as_ref(),

            Self::PaymentResultCode(ref v) => v.as_ref(),

            Self::PaymentResult(ref v) => v.as_ref(),

            Self::PathPaymentStrictReceiveResultCode(ref v) => v.as_ref(),

            Self::SimplePaymentResult(ref v) => v.as_ref(),

            Self::PathPaymentStrictReceiveResult(ref v) => v.as_ref(),

            Self::PathPaymentStrictSendResultCode(ref v) => v.as_ref(),

            Self::PathPaymentStrictSendResult(ref v) => v.as_ref(),

            Self::ManageSellOfferResultCode(ref v) => v.as_ref(),

            Self::ManageOfferEffect(ref v) => v.as_ref(),

            Self::ManageOfferSuccessResult(ref v) => v.as_ref(),

            Self::ManageSellOfferResult(ref v) => v.as_ref(),

            Self::ManageBuyOfferResultCode(ref v) => v.as_ref(),

            Self::ManageBuyOfferResult(ref v) => v.as_ref(),

            Self::SetOptionsResultCode(ref v) => v.as_ref(),

            Self::SetOptionsResult(ref v) => v.as_ref(),

            Self::ChangeTrustResultCode(ref v) => v.as_ref(),

            Self::ChangeTrustResult(ref v) => v.as_ref(),

            Self::AllowTrustResultCode(ref v) => v.as_ref(),

            Self::AllowTrustResult(ref v) => v.as_ref(),

            Self::AccountMergeResultCode(ref v) => v.as_ref(),

            Self::AccountMergeResult(ref v) => v.as_ref(),

            Self::InflationResultCode(ref v) => v.as_ref(),

            Self::InflationPayout(ref v) => v.as_ref(),

            Self::InflationResult(ref v) => v.as_ref(),

            Self::ManageDataResultCode(ref v) => v.as_ref(),

            Self::ManageDataResult(ref v) => v.as_ref(),

            Self::BumpSequenceResultCode(ref v) => v.as_ref(),

            Self::BumpSequenceResult(ref v) => v.as_ref(),

            Self::CreateClaimableBalanceResultCode(ref v) => v.as_ref(),

            Self::CreateClaimableBalanceResult(ref v) => v.as_ref(),

            Self::ClaimClaimableBalanceResultCode(ref v) => v.as_ref(),

            Self::ClaimClaimableBalanceResult(ref v) => v.as_ref(),

            Self::BeginSponsoringFutureReservesResultCode(ref v) => v.as_ref(),

            Self::BeginSponsoringFutureReservesResult(ref v) => v.as_ref(),

            Self::EndSponsoringFutureReservesResultCode(ref v) => v.as_ref(),

            Self::EndSponsoringFutureReservesResult(ref v) => v.as_ref(),

            Self::RevokeSponsorshipResultCode(ref v) => v.as_ref(),

            Self::RevokeSponsorshipResult(ref v) => v.as_ref(),

            Self::ClawbackResultCode(ref v) => v.as_ref(),

            Self::ClawbackResult(ref v) => v.as_ref(),

            Self::ClawbackClaimableBalanceResultCode(ref v) => v.as_ref(),

            Self::ClawbackClaimableBalanceResult(ref v) => v.as_ref(),

            Self::SetTrustLineFlagsResultCode(ref v) => v.as_ref(),

            Self::SetTrustLineFlagsResult(ref v) => v.as_ref(),

            Self::LiquidityPoolDepositResultCode(ref v) => v.as_ref(),

            Self::LiquidityPoolDepositResult(ref v) => v.as_ref(),

            Self::LiquidityPoolWithdrawResultCode(ref v) => v.as_ref(),

            Self::LiquidityPoolWithdrawResult(ref v) => v.as_ref(),

            Self::InvokeHostFunctionResultCode(ref v) => v.as_ref(),

            Self::InvokeHostFunctionResult(ref v) => v.as_ref(),

            Self::ExtendFootprintTtlResultCode(ref v) => v.as_ref(),

            Self::ExtendFootprintTtlResult(ref v) => v.as_ref(),

            Self::RestoreFootprintResultCode(ref v) => v.as_ref(),

            Self::RestoreFootprintResult(ref v) => v.as_ref(),

            Self::OperationResultCode(ref v) => v.as_ref(),

            Self::OperationResult(ref v) => v.as_ref(),

            Self::TransactionResultCode(ref v) => v.as_ref(),

            Self::InnerTransactionResult(ref v) => v.as_ref(),

            Self::InnerTransactionResultPair(ref v) => v.as_ref(),

            Self::TransactionResult(ref v) => v.as_ref(),

            Self::Hash(ref v) => v.as_ref(),

            Self::Uint256(ref v) => v.as_ref(),

            Self::Uint32(ref v) => v.as_ref(),

            Self::Int32(ref v) => v.as_ref(),

            Self::Uint64(ref v) => v.as_ref(),

            Self::Int64(ref v) => v.as_ref(),

            Self::TimePoint(ref v) => v.as_ref(),

            Self::Duration(ref v) => v.as_ref(),

            Self::ExtensionPoint(ref v) => v.as_ref(),

            Self::CryptoKeyType(ref v) => v.as_ref(),

            Self::PublicKeyType(ref v) => v.as_ref(),

            Self::SignerKeyType(ref v) => v.as_ref(),

            Self::PublicKey(ref v) => v.as_ref(),

            Self::SignerKey(ref v) => v.as_ref(),

            Self::Signature(ref v) => v.as_ref(),

            Self::SignatureHint(ref v) => v.as_ref(),

            Self::NodeId(ref v) => v.as_ref(),

            Self::AccountId(ref v) => v.as_ref(),

            Self::ContractId(ref v) => v.as_ref(),

            Self::Curve25519Secret(ref v) => v.as_ref(),

            Self::Curve25519Public(ref v) => v.as_ref(),

            Self::HmacSha256Key(ref v) => v.as_ref(),

            Self::HmacSha256Mac(ref v) => v.as_ref(),

            Self::ShortHashSeed(ref v) => v.as_ref(),

            Self::BinaryFuseFilterType(ref v) => v.as_ref(),

            Self::SerializedBinaryFuseFilter(ref v) => v.as_ref(),

            Self::PoolId(ref v) => v.as_ref(),

            Self::ClaimableBalanceIdType(ref v) => v.as_ref(),

            Self::ClaimableBalanceId(ref v) => v.as_ref(),
        }
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScpStatementPrepare(_) => "ScpStatementPrepare",

            Self::ScpStatementConfirm(_) => "ScpStatementConfirm",

            Self::ScpStatementExternalize(_) => "ScpStatementExternalize",

            Self::ScpStatementPledges(_) => "ScpStatementPledges",

            Self::ScEnvMetaEntryInterfaceVersion(_) => "ScEnvMetaEntryInterfaceVersion",

            Self::AccountEntryExtensionV2Ext(_) => "AccountEntryExtensionV2Ext",

            Self::AccountEntryExtensionV1Ext(_) => "AccountEntryExtensionV1Ext",

            Self::AccountEntryExt(_) => "AccountEntryExt",

            Self::TrustLineEntryExtensionV2Ext(_) => "TrustLineEntryExtensionV2Ext",

            Self::TrustLineEntryV1Ext(_) => "TrustLineEntryV1Ext",

            Self::TrustLineEntryV1(_) => "TrustLineEntryV1",

            Self::TrustLineEntryExt(_) => "TrustLineEntryExt",

            Self::OfferEntryExt(_) => "OfferEntryExt",

            Self::DataEntryExt(_) => "DataEntryExt",

            Self::ClaimantV0(_) => "ClaimantV0",

            Self::ClaimableBalanceEntryExtensionV1Ext(_) => "ClaimableBalanceEntryExtensionV1Ext",

            Self::ClaimableBalanceEntryExt(_) => "ClaimableBalanceEntryExt",

            Self::LiquidityPoolEntryConstantProduct(_) => "LiquidityPoolEntryConstantProduct",

            Self::LiquidityPoolEntryBody(_) => "LiquidityPoolEntryBody",

            Self::ContractCodeEntryV1(_) => "ContractCodeEntryV1",

            Self::ContractCodeEntryExt(_) => "ContractCodeEntryExt",

            Self::LedgerEntryExtensionV1Ext(_) => "LedgerEntryExtensionV1Ext",

            Self::LedgerEntryData(_) => "LedgerEntryData",

            Self::LedgerEntryExt(_) => "LedgerEntryExt",

            Self::LedgerKeyAccount(_) => "LedgerKeyAccount",

            Self::LedgerKeyTrustLine(_) => "LedgerKeyTrustLine",

            Self::LedgerKeyOffer(_) => "LedgerKeyOffer",

            Self::LedgerKeyData(_) => "LedgerKeyData",

            Self::LedgerKeyClaimableBalance(_) => "LedgerKeyClaimableBalance",

            Self::LedgerKeyLiquidityPool(_) => "LedgerKeyLiquidityPool",

            Self::LedgerKeyContractData(_) => "LedgerKeyContractData",

            Self::LedgerKeyContractCode(_) => "LedgerKeyContractCode",

            Self::LedgerKeyConfigSetting(_) => "LedgerKeyConfigSetting",

            Self::LedgerKeyTtl(_) => "LedgerKeyTtl",

            Self::BucketMetadataExt(_) => "BucketMetadataExt",

            Self::StellarValueExt(_) => "StellarValueExt",

            Self::LedgerHeaderExtensionV1Ext(_) => "LedgerHeaderExtensionV1Ext",

            Self::LedgerHeaderExt(_) => "LedgerHeaderExt",

            Self::TxSetComponentTxsMaybeDiscountedFee(_) => "TxSetComponentTxsMaybeDiscountedFee",

            Self::TransactionHistoryEntryExt(_) => "TransactionHistoryEntryExt",

            Self::TransactionHistoryResultEntryExt(_) => "TransactionHistoryResultEntryExt",

            Self::LedgerHeaderHistoryEntryExt(_) => "LedgerHeaderHistoryEntryExt",

            Self::ContractEventV0(_) => "ContractEventV0",

            Self::ContractEventBody(_) => "ContractEventBody",

            Self::PeerAddressIp(_) => "PeerAddressIp",

            Self::AuthenticatedMessageV0(_) => "AuthenticatedMessageV0",

            Self::MuxedAccountMed25519(_) => "MuxedAccountMed25519",

            Self::RevokeSponsorshipOpSigner(_) => "RevokeSponsorshipOpSigner",

            Self::ContractIdPreimageFromAddress(_) => "ContractIdPreimageFromAddress",

            Self::OperationBody(_) => "OperationBody",

            Self::HashIdPreimageOperationId(_) => "HashIdPreimageOperationId",

            Self::HashIdPreimageRevokeId(_) => "HashIdPreimageRevokeId",

            Self::HashIdPreimageContractId(_) => "HashIdPreimageContractId",

            Self::HashIdPreimageSorobanAuthorization(_) => "HashIdPreimageSorobanAuthorization",

            Self::SorobanTransactionDataExt(_) => "SorobanTransactionDataExt",

            Self::TransactionV0Ext(_) => "TransactionV0Ext",

            Self::TransactionExt(_) => "TransactionExt",

            Self::FeeBumpTransactionInnerTx(_) => "FeeBumpTransactionInnerTx",

            Self::FeeBumpTransactionExt(_) => "FeeBumpTransactionExt",

            Self::TransactionSignaturePayloadTaggedTransaction(_) => {
                "TransactionSignaturePayloadTaggedTransaction"
            }

            Self::PathPaymentStrictReceiveResultSuccess(_) => {
                "PathPaymentStrictReceiveResultSuccess"
            }

            Self::PathPaymentStrictSendResultSuccess(_) => "PathPaymentStrictSendResultSuccess",

            Self::ManageOfferSuccessResultOffer(_) => "ManageOfferSuccessResultOffer",

            Self::OperationResultTr(_) => "OperationResultTr",

            Self::InnerTransactionResultResult(_) => "InnerTransactionResultResult",

            Self::InnerTransactionResultExt(_) => "InnerTransactionResultExt",

            Self::TransactionResultResult(_) => "TransactionResultResult",

            Self::TransactionResultExt(_) => "TransactionResultExt",

            Self::SignerKeyEd25519SignedPayload(_) => "SignerKeyEd25519SignedPayload",

            Self::Value(_) => "Value",

            Self::ScpBallot(_) => "ScpBallot",

            Self::ScpStatementType(_) => "ScpStatementType",

            Self::ScpNomination(_) => "ScpNomination",

            Self::ScpStatement(_) => "ScpStatement",

            Self::ScpEnvelope(_) => "ScpEnvelope",

            Self::ScpQuorumSet(_) => "ScpQuorumSet",

            Self::ConfigSettingContractExecutionLanesV0(_) => {
                "ConfigSettingContractExecutionLanesV0"
            }

            Self::ConfigSettingContractComputeV0(_) => "ConfigSettingContractComputeV0",

            Self::ConfigSettingContractParallelComputeV0(_) => {
                "ConfigSettingContractParallelComputeV0"
            }

            Self::ConfigSettingContractLedgerCostV0(_) => "ConfigSettingContractLedgerCostV0",

            Self::ConfigSettingContractLedgerCostExtV0(_) => "ConfigSettingContractLedgerCostExtV0",

            Self::ConfigSettingContractHistoricalDataV0(_) => {
                "ConfigSettingContractHistoricalDataV0"
            }

            Self::ConfigSettingContractEventsV0(_) => "ConfigSettingContractEventsV0",

            Self::ConfigSettingContractBandwidthV0(_) => "ConfigSettingContractBandwidthV0",

            Self::ContractCostType(_) => "ContractCostType",

            Self::ContractCostParamEntry(_) => "ContractCostParamEntry",

            Self::StateArchivalSettings(_) => "StateArchivalSettings",

            Self::EvictionIterator(_) => "EvictionIterator",

            Self::ConfigSettingScpTiming(_) => "ConfigSettingScpTiming",

            Self::ContractCostParams(_) => "ContractCostParams",

            Self::ConfigSettingId(_) => "ConfigSettingId",

            Self::ConfigSettingEntry(_) => "ConfigSettingEntry",

            Self::ScEnvMetaKind(_) => "ScEnvMetaKind",

            Self::ScEnvMetaEntry(_) => "ScEnvMetaEntry",

            Self::ScMetaV0(_) => "ScMetaV0",

            Self::ScMetaKind(_) => "ScMetaKind",

            Self::ScMetaEntry(_) => "ScMetaEntry",

            Self::ScSpecType(_) => "ScSpecType",

            Self::ScSpecTypeOption(_) => "ScSpecTypeOption",

            Self::ScSpecTypeResult(_) => "ScSpecTypeResult",

            Self::ScSpecTypeVec(_) => "ScSpecTypeVec",

            Self::ScSpecTypeMap(_) => "ScSpecTypeMap",

            Self::ScSpecTypeTuple(_) => "ScSpecTypeTuple",

            Self::ScSpecTypeBytesN(_) => "ScSpecTypeBytesN",

            Self::ScSpecTypeUdt(_) => "ScSpecTypeUdt",

            Self::ScSpecTypeDef(_) => "ScSpecTypeDef",

            Self::ScSpecUdtStructFieldV0(_) => "ScSpecUdtStructFieldV0",

            Self::ScSpecUdtStructV0(_) => "ScSpecUdtStructV0",

            Self::ScSpecUdtUnionCaseVoidV0(_) => "ScSpecUdtUnionCaseVoidV0",

            Self::ScSpecUdtUnionCaseTupleV0(_) => "ScSpecUdtUnionCaseTupleV0",

            Self::ScSpecUdtUnionCaseV0Kind(_) => "ScSpecUdtUnionCaseV0Kind",

            Self::ScSpecUdtUnionCaseV0(_) => "ScSpecUdtUnionCaseV0",

            Self::ScSpecUdtUnionV0(_) => "ScSpecUdtUnionV0",

            Self::ScSpecUdtEnumCaseV0(_) => "ScSpecUdtEnumCaseV0",

            Self::ScSpecUdtEnumV0(_) => "ScSpecUdtEnumV0",

            Self::ScSpecUdtErrorEnumCaseV0(_) => "ScSpecUdtErrorEnumCaseV0",

            Self::ScSpecUdtErrorEnumV0(_) => "ScSpecUdtErrorEnumV0",

            Self::ScSpecFunctionInputV0(_) => "ScSpecFunctionInputV0",

            Self::ScSpecFunctionV0(_) => "ScSpecFunctionV0",

            Self::ScSpecEventParamLocationV0(_) => "ScSpecEventParamLocationV0",

            Self::ScSpecEventParamV0(_) => "ScSpecEventParamV0",

            Self::ScSpecEventDataFormat(_) => "ScSpecEventDataFormat",

            Self::ScSpecEventV0(_) => "ScSpecEventV0",

            Self::ScSpecEntryKind(_) => "ScSpecEntryKind",

            Self::ScSpecEntry(_) => "ScSpecEntry",

            Self::ScValType(_) => "ScValType",

            Self::ScErrorType(_) => "ScErrorType",

            Self::ScErrorCode(_) => "ScErrorCode",

            Self::ScError(_) => "ScError",

            Self::UInt128Parts(_) => "UInt128Parts",

            Self::Int128Parts(_) => "Int128Parts",

            Self::UInt256Parts(_) => "UInt256Parts",

            Self::Int256Parts(_) => "Int256Parts",

            Self::ContractExecutableType(_) => "ContractExecutableType",

            Self::ContractExecutable(_) => "ContractExecutable",

            Self::ScAddressType(_) => "ScAddressType",

            Self::MuxedEd25519Account(_) => "MuxedEd25519Account",

            Self::ScAddress(_) => "ScAddress",

            Self::ScVec(_) => "ScVec",

            Self::ScMap(_) => "ScMap",

            Self::ScBytes(_) => "ScBytes",

            Self::ScString(_) => "ScString",

            Self::ScSymbol(_) => "ScSymbol",

            Self::ScNonceKey(_) => "ScNonceKey",

            Self::ScContractInstance(_) => "ScContractInstance",

            Self::ScVal(_) => "ScVal",

            Self::ScMapEntry(_) => "ScMapEntry",

            Self::LedgerCloseMetaBatch(_) => "LedgerCloseMetaBatch",

            Self::StoredTransactionSet(_) => "StoredTransactionSet",

            Self::StoredDebugTransactionSet(_) => "StoredDebugTransactionSet",

            Self::PersistedScpStateV0(_) => "PersistedScpStateV0",

            Self::PersistedScpStateV1(_) => "PersistedScpStateV1",

            Self::PersistedScpState(_) => "PersistedScpState",

            Self::Thresholds(_) => "Thresholds",

            Self::String32(_) => "String32",

            Self::String64(_) => "String64",

            Self::SequenceNumber(_) => "SequenceNumber",

            Self::DataValue(_) => "DataValue",

            Self::AssetCode4(_) => "AssetCode4",

            Self::AssetCode12(_) => "AssetCode12",

            Self::AssetType(_) => "AssetType",

            Self::AssetCode(_) => "AssetCode",

            Self::AlphaNum4(_) => "AlphaNum4",

            Self::AlphaNum12(_) => "AlphaNum12",

            Self::Asset(_) => "Asset",

            Self::Price(_) => "Price",

            Self::Liabilities(_) => "Liabilities",

            Self::ThresholdIndexes(_) => "ThresholdIndexes",

            Self::LedgerEntryType(_) => "LedgerEntryType",

            Self::Signer(_) => "Signer",

            Self::AccountFlags(_) => "AccountFlags",

            Self::SponsorshipDescriptor(_) => "SponsorshipDescriptor",

            Self::AccountEntryExtensionV3(_) => "AccountEntryExtensionV3",

            Self::AccountEntryExtensionV2(_) => "AccountEntryExtensionV2",

            Self::AccountEntryExtensionV1(_) => "AccountEntryExtensionV1",

            Self::AccountEntry(_) => "AccountEntry",

            Self::TrustLineFlags(_) => "TrustLineFlags",

            Self::LiquidityPoolType(_) => "LiquidityPoolType",

            Self::TrustLineAsset(_) => "TrustLineAsset",

            Self::TrustLineEntryExtensionV2(_) => "TrustLineEntryExtensionV2",

            Self::TrustLineEntry(_) => "TrustLineEntry",

            Self::OfferEntryFlags(_) => "OfferEntryFlags",

            Self::OfferEntry(_) => "OfferEntry",

            Self::DataEntry(_) => "DataEntry",

            Self::ClaimPredicateType(_) => "ClaimPredicateType",

            Self::ClaimPredicate(_) => "ClaimPredicate",

            Self::ClaimantType(_) => "ClaimantType",

            Self::Claimant(_) => "Claimant",

            Self::ClaimableBalanceFlags(_) => "ClaimableBalanceFlags",

            Self::ClaimableBalanceEntryExtensionV1(_) => "ClaimableBalanceEntryExtensionV1",

            Self::ClaimableBalanceEntry(_) => "ClaimableBalanceEntry",

            Self::LiquidityPoolConstantProductParameters(_) => {
                "LiquidityPoolConstantProductParameters"
            }

            Self::LiquidityPoolEntry(_) => "LiquidityPoolEntry",

            Self::ContractDataDurability(_) => "ContractDataDurability",

            Self::ContractDataEntry(_) => "ContractDataEntry",

            Self::ContractCodeCostInputs(_) => "ContractCodeCostInputs",

            Self::ContractCodeEntry(_) => "ContractCodeEntry",

            Self::TtlEntry(_) => "TtlEntry",

            Self::LedgerEntryExtensionV1(_) => "LedgerEntryExtensionV1",

            Self::LedgerEntry(_) => "LedgerEntry",

            Self::LedgerKey(_) => "LedgerKey",

            Self::EnvelopeType(_) => "EnvelopeType",

            Self::BucketListType(_) => "BucketListType",

            Self::BucketEntryType(_) => "BucketEntryType",

            Self::HotArchiveBucketEntryType(_) => "HotArchiveBucketEntryType",

            Self::BucketMetadata(_) => "BucketMetadata",

            Self::BucketEntry(_) => "BucketEntry",

            Self::HotArchiveBucketEntry(_) => "HotArchiveBucketEntry",

            Self::UpgradeType(_) => "UpgradeType",

            Self::StellarValueType(_) => "StellarValueType",

            Self::LedgerCloseValueSignature(_) => "LedgerCloseValueSignature",

            Self::StellarValue(_) => "StellarValue",

            Self::LedgerHeaderFlags(_) => "LedgerHeaderFlags",

            Self::LedgerHeaderExtensionV1(_) => "LedgerHeaderExtensionV1",

            Self::LedgerHeader(_) => "LedgerHeader",

            Self::LedgerUpgradeType(_) => "LedgerUpgradeType",

            Self::ConfigUpgradeSetKey(_) => "ConfigUpgradeSetKey",

            Self::LedgerUpgrade(_) => "LedgerUpgrade",

            Self::ConfigUpgradeSet(_) => "ConfigUpgradeSet",

            Self::TxSetComponentType(_) => "TxSetComponentType",

            Self::DependentTxCluster(_) => "DependentTxCluster",

            Self::ParallelTxExecutionStage(_) => "ParallelTxExecutionStage",

            Self::ParallelTxsComponent(_) => "ParallelTxsComponent",

            Self::TxSetComponent(_) => "TxSetComponent",

            Self::TransactionPhase(_) => "TransactionPhase",

            Self::TransactionSet(_) => "TransactionSet",

            Self::TransactionSetV1(_) => "TransactionSetV1",

            Self::GeneralizedTransactionSet(_) => "GeneralizedTransactionSet",

            Self::TransactionResultPair(_) => "TransactionResultPair",

            Self::TransactionResultSet(_) => "TransactionResultSet",

            Self::TransactionHistoryEntry(_) => "TransactionHistoryEntry",

            Self::TransactionHistoryResultEntry(_) => "TransactionHistoryResultEntry",

            Self::LedgerHeaderHistoryEntry(_) => "LedgerHeaderHistoryEntry",

            Self::LedgerScpMessages(_) => "LedgerScpMessages",

            Self::ScpHistoryEntryV0(_) => "ScpHistoryEntryV0",

            Self::ScpHistoryEntry(_) => "ScpHistoryEntry",

            Self::LedgerEntryChangeType(_) => "LedgerEntryChangeType",

            Self::LedgerEntryChange(_) => "LedgerEntryChange",

            Self::LedgerEntryChanges(_) => "LedgerEntryChanges",

            Self::OperationMeta(_) => "OperationMeta",

            Self::TransactionMetaV1(_) => "TransactionMetaV1",

            Self::TransactionMetaV2(_) => "TransactionMetaV2",

            Self::ContractEventType(_) => "ContractEventType",

            Self::ContractEvent(_) => "ContractEvent",

            Self::DiagnosticEvent(_) => "DiagnosticEvent",

            Self::SorobanTransactionMetaExtV1(_) => "SorobanTransactionMetaExtV1",

            Self::SorobanTransactionMetaExt(_) => "SorobanTransactionMetaExt",

            Self::SorobanTransactionMeta(_) => "SorobanTransactionMeta",

            Self::TransactionMetaV3(_) => "TransactionMetaV3",

            Self::OperationMetaV2(_) => "OperationMetaV2",

            Self::SorobanTransactionMetaV2(_) => "SorobanTransactionMetaV2",

            Self::TransactionEventStage(_) => "TransactionEventStage",

            Self::TransactionEvent(_) => "TransactionEvent",

            Self::TransactionMetaV4(_) => "TransactionMetaV4",

            Self::InvokeHostFunctionSuccessPreImage(_) => "InvokeHostFunctionSuccessPreImage",

            Self::TransactionMeta(_) => "TransactionMeta",

            Self::TransactionResultMeta(_) => "TransactionResultMeta",

            Self::TransactionResultMetaV1(_) => "TransactionResultMetaV1",

            Self::UpgradeEntryMeta(_) => "UpgradeEntryMeta",

            Self::LedgerCloseMetaV0(_) => "LedgerCloseMetaV0",

            Self::LedgerCloseMetaExtV1(_) => "LedgerCloseMetaExtV1",

            Self::LedgerCloseMetaExt(_) => "LedgerCloseMetaExt",

            Self::LedgerCloseMetaV1(_) => "LedgerCloseMetaV1",

            Self::LedgerCloseMetaV2(_) => "LedgerCloseMetaV2",

            Self::LedgerCloseMeta(_) => "LedgerCloseMeta",

            Self::ErrorCode(_) => "ErrorCode",

            Self::SError(_) => "SError",

            Self::SendMore(_) => "SendMore",

            Self::SendMoreExtended(_) => "SendMoreExtended",

            Self::AuthCert(_) => "AuthCert",

            Self::Hello(_) => "Hello",

            Self::Auth(_) => "Auth",

            Self::IpAddrType(_) => "IpAddrType",

            Self::PeerAddress(_) => "PeerAddress",

            Self::MessageType(_) => "MessageType",

            Self::DontHave(_) => "DontHave",

            Self::SurveyMessageCommandType(_) => "SurveyMessageCommandType",

            Self::SurveyMessageResponseType(_) => "SurveyMessageResponseType",

            Self::TimeSlicedSurveyStartCollectingMessage(_) => {
                "TimeSlicedSurveyStartCollectingMessage"
            }

            Self::SignedTimeSlicedSurveyStartCollectingMessage(_) => {
                "SignedTimeSlicedSurveyStartCollectingMessage"
            }

            Self::TimeSlicedSurveyStopCollectingMessage(_) => {
                "TimeSlicedSurveyStopCollectingMessage"
            }

            Self::SignedTimeSlicedSurveyStopCollectingMessage(_) => {
                "SignedTimeSlicedSurveyStopCollectingMessage"
            }

            Self::SurveyRequestMessage(_) => "SurveyRequestMessage",

            Self::TimeSlicedSurveyRequestMessage(_) => "TimeSlicedSurveyRequestMessage",

            Self::SignedTimeSlicedSurveyRequestMessage(_) => "SignedTimeSlicedSurveyRequestMessage",

            Self::EncryptedBody(_) => "EncryptedBody",

            Self::SurveyResponseMessage(_) => "SurveyResponseMessage",

            Self::TimeSlicedSurveyResponseMessage(_) => "TimeSlicedSurveyResponseMessage",

            Self::SignedTimeSlicedSurveyResponseMessage(_) => {
                "SignedTimeSlicedSurveyResponseMessage"
            }

            Self::PeerStats(_) => "PeerStats",

            Self::TimeSlicedNodeData(_) => "TimeSlicedNodeData",

            Self::TimeSlicedPeerData(_) => "TimeSlicedPeerData",

            Self::TimeSlicedPeerDataList(_) => "TimeSlicedPeerDataList",

            Self::TopologyResponseBodyV2(_) => "TopologyResponseBodyV2",

            Self::SurveyResponseBody(_) => "SurveyResponseBody",

            Self::TxAdvertVector(_) => "TxAdvertVector",

            Self::FloodAdvert(_) => "FloodAdvert",

            Self::TxDemandVector(_) => "TxDemandVector",

            Self::FloodDemand(_) => "FloodDemand",

            Self::StellarMessage(_) => "StellarMessage",

            Self::AuthenticatedMessage(_) => "AuthenticatedMessage",

            Self::LiquidityPoolParameters(_) => "LiquidityPoolParameters",

            Self::MuxedAccount(_) => "MuxedAccount",

            Self::DecoratedSignature(_) => "DecoratedSignature",

            Self::OperationType(_) => "OperationType",

            Self::CreateAccountOp(_) => "CreateAccountOp",

            Self::PaymentOp(_) => "PaymentOp",

            Self::PathPaymentStrictReceiveOp(_) => "PathPaymentStrictReceiveOp",

            Self::PathPaymentStrictSendOp(_) => "PathPaymentStrictSendOp",

            Self::ManageSellOfferOp(_) => "ManageSellOfferOp",

            Self::ManageBuyOfferOp(_) => "ManageBuyOfferOp",

            Self::CreatePassiveSellOfferOp(_) => "CreatePassiveSellOfferOp",

            Self::SetOptionsOp(_) => "SetOptionsOp",

            Self::ChangeTrustAsset(_) => "ChangeTrustAsset",

            Self::ChangeTrustOp(_) => "ChangeTrustOp",

            Self::AllowTrustOp(_) => "AllowTrustOp",

            Self::ManageDataOp(_) => "ManageDataOp",

            Self::BumpSequenceOp(_) => "BumpSequenceOp",

            Self::CreateClaimableBalanceOp(_) => "CreateClaimableBalanceOp",

            Self::ClaimClaimableBalanceOp(_) => "ClaimClaimableBalanceOp",

            Self::BeginSponsoringFutureReservesOp(_) => "BeginSponsoringFutureReservesOp",

            Self::RevokeSponsorshipType(_) => "RevokeSponsorshipType",

            Self::RevokeSponsorshipOp(_) => "RevokeSponsorshipOp",

            Self::ClawbackOp(_) => "ClawbackOp",

            Self::ClawbackClaimableBalanceOp(_) => "ClawbackClaimableBalanceOp",

            Self::SetTrustLineFlagsOp(_) => "SetTrustLineFlagsOp",

            Self::LiquidityPoolDepositOp(_) => "LiquidityPoolDepositOp",

            Self::LiquidityPoolWithdrawOp(_) => "LiquidityPoolWithdrawOp",

            Self::HostFunctionType(_) => "HostFunctionType",

            Self::ContractIdPreimageType(_) => "ContractIdPreimageType",

            Self::ContractIdPreimage(_) => "ContractIdPreimage",

            Self::CreateContractArgs(_) => "CreateContractArgs",

            Self::CreateContractArgsV2(_) => "CreateContractArgsV2",

            Self::InvokeContractArgs(_) => "InvokeContractArgs",

            Self::HostFunction(_) => "HostFunction",

            Self::SorobanAuthorizedFunctionType(_) => "SorobanAuthorizedFunctionType",

            Self::SorobanAuthorizedFunction(_) => "SorobanAuthorizedFunction",

            Self::SorobanAuthorizedInvocation(_) => "SorobanAuthorizedInvocation",

            Self::SorobanAddressCredentials(_) => "SorobanAddressCredentials",

            Self::SorobanCredentialsType(_) => "SorobanCredentialsType",

            Self::SorobanCredentials(_) => "SorobanCredentials",

            Self::SorobanAuthorizationEntry(_) => "SorobanAuthorizationEntry",

            Self::SorobanAuthorizationEntries(_) => "SorobanAuthorizationEntries",

            Self::InvokeHostFunctionOp(_) => "InvokeHostFunctionOp",

            Self::ExtendFootprintTtlOp(_) => "ExtendFootprintTtlOp",

            Self::RestoreFootprintOp(_) => "RestoreFootprintOp",

            Self::Operation(_) => "Operation",

            Self::HashIdPreimage(_) => "HashIdPreimage",

            Self::MemoType(_) => "MemoType",

            Self::Memo(_) => "Memo",

            Self::TimeBounds(_) => "TimeBounds",

            Self::LedgerBounds(_) => "LedgerBounds",

            Self::PreconditionsV2(_) => "PreconditionsV2",

            Self::PreconditionType(_) => "PreconditionType",

            Self::Preconditions(_) => "Preconditions",

            Self::LedgerFootprint(_) => "LedgerFootprint",

            Self::SorobanResources(_) => "SorobanResources",

            Self::SorobanResourcesExtV0(_) => "SorobanResourcesExtV0",

            Self::SorobanTransactionData(_) => "SorobanTransactionData",

            Self::TransactionV0(_) => "TransactionV0",

            Self::TransactionV0Envelope(_) => "TransactionV0Envelope",

            Self::Transaction(_) => "Transaction",

            Self::TransactionV1Envelope(_) => "TransactionV1Envelope",

            Self::FeeBumpTransaction(_) => "FeeBumpTransaction",

            Self::FeeBumpTransactionEnvelope(_) => "FeeBumpTransactionEnvelope",

            Self::TransactionEnvelope(_) => "TransactionEnvelope",

            Self::TransactionSignaturePayload(_) => "TransactionSignaturePayload",

            Self::ClaimAtomType(_) => "ClaimAtomType",

            Self::ClaimOfferAtomV0(_) => "ClaimOfferAtomV0",

            Self::ClaimOfferAtom(_) => "ClaimOfferAtom",

            Self::ClaimLiquidityAtom(_) => "ClaimLiquidityAtom",

            Self::ClaimAtom(_) => "ClaimAtom",

            Self::CreateAccountResultCode(_) => "CreateAccountResultCode",

            Self::CreateAccountResult(_) => "CreateAccountResult",

            Self::PaymentResultCode(_) => "PaymentResultCode",

            Self::PaymentResult(_) => "PaymentResult",

            Self::PathPaymentStrictReceiveResultCode(_) => "PathPaymentStrictReceiveResultCode",

            Self::SimplePaymentResult(_) => "SimplePaymentResult",

            Self::PathPaymentStrictReceiveResult(_) => "PathPaymentStrictReceiveResult",

            Self::PathPaymentStrictSendResultCode(_) => "PathPaymentStrictSendResultCode",

            Self::PathPaymentStrictSendResult(_) => "PathPaymentStrictSendResult",

            Self::ManageSellOfferResultCode(_) => "ManageSellOfferResultCode",

            Self::ManageOfferEffect(_) => "ManageOfferEffect",

            Self::ManageOfferSuccessResult(_) => "ManageOfferSuccessResult",

            Self::ManageSellOfferResult(_) => "ManageSellOfferResult",

            Self::ManageBuyOfferResultCode(_) => "ManageBuyOfferResultCode",

            Self::ManageBuyOfferResult(_) => "ManageBuyOfferResult",

            Self::SetOptionsResultCode(_) => "SetOptionsResultCode",

            Self::SetOptionsResult(_) => "SetOptionsResult",

            Self::ChangeTrustResultCode(_) => "ChangeTrustResultCode",

            Self::ChangeTrustResult(_) => "ChangeTrustResult",

            Self::AllowTrustResultCode(_) => "AllowTrustResultCode",

            Self::AllowTrustResult(_) => "AllowTrustResult",

            Self::AccountMergeResultCode(_) => "AccountMergeResultCode",

            Self::AccountMergeResult(_) => "AccountMergeResult",

            Self::InflationResultCode(_) => "InflationResultCode",

            Self::InflationPayout(_) => "InflationPayout",

            Self::InflationResult(_) => "InflationResult",

            Self::ManageDataResultCode(_) => "ManageDataResultCode",

            Self::ManageDataResult(_) => "ManageDataResult",

            Self::BumpSequenceResultCode(_) => "BumpSequenceResultCode",

            Self::BumpSequenceResult(_) => "BumpSequenceResult",

            Self::CreateClaimableBalanceResultCode(_) => "CreateClaimableBalanceResultCode",

            Self::CreateClaimableBalanceResult(_) => "CreateClaimableBalanceResult",

            Self::ClaimClaimableBalanceResultCode(_) => "ClaimClaimableBalanceResultCode",

            Self::ClaimClaimableBalanceResult(_) => "ClaimClaimableBalanceResult",

            Self::BeginSponsoringFutureReservesResultCode(_) => {
                "BeginSponsoringFutureReservesResultCode"
            }

            Self::BeginSponsoringFutureReservesResult(_) => "BeginSponsoringFutureReservesResult",

            Self::EndSponsoringFutureReservesResultCode(_) => {
                "EndSponsoringFutureReservesResultCode"
            }

            Self::EndSponsoringFutureReservesResult(_) => "EndSponsoringFutureReservesResult",

            Self::RevokeSponsorshipResultCode(_) => "RevokeSponsorshipResultCode",

            Self::RevokeSponsorshipResult(_) => "RevokeSponsorshipResult",

            Self::ClawbackResultCode(_) => "ClawbackResultCode",

            Self::ClawbackResult(_) => "ClawbackResult",

            Self::ClawbackClaimableBalanceResultCode(_) => "ClawbackClaimableBalanceResultCode",

            Self::ClawbackClaimableBalanceResult(_) => "ClawbackClaimableBalanceResult",

            Self::SetTrustLineFlagsResultCode(_) => "SetTrustLineFlagsResultCode",

            Self::SetTrustLineFlagsResult(_) => "SetTrustLineFlagsResult",

            Self::LiquidityPoolDepositResultCode(_) => "LiquidityPoolDepositResultCode",

            Self::LiquidityPoolDepositResult(_) => "LiquidityPoolDepositResult",

            Self::LiquidityPoolWithdrawResultCode(_) => "LiquidityPoolWithdrawResultCode",

            Self::LiquidityPoolWithdrawResult(_) => "LiquidityPoolWithdrawResult",

            Self::InvokeHostFunctionResultCode(_) => "InvokeHostFunctionResultCode",

            Self::InvokeHostFunctionResult(_) => "InvokeHostFunctionResult",

            Self::ExtendFootprintTtlResultCode(_) => "ExtendFootprintTtlResultCode",

            Self::ExtendFootprintTtlResult(_) => "ExtendFootprintTtlResult",

            Self::RestoreFootprintResultCode(_) => "RestoreFootprintResultCode",

            Self::RestoreFootprintResult(_) => "RestoreFootprintResult",

            Self::OperationResultCode(_) => "OperationResultCode",

            Self::OperationResult(_) => "OperationResult",

            Self::TransactionResultCode(_) => "TransactionResultCode",

            Self::InnerTransactionResult(_) => "InnerTransactionResult",

            Self::InnerTransactionResultPair(_) => "InnerTransactionResultPair",

            Self::TransactionResult(_) => "TransactionResult",

            Self::Hash(_) => "Hash",

            Self::Uint256(_) => "Uint256",

            Self::Uint32(_) => "Uint32",

            Self::Int32(_) => "Int32",

            Self::Uint64(_) => "Uint64",

            Self::Int64(_) => "Int64",

            Self::TimePoint(_) => "TimePoint",

            Self::Duration(_) => "Duration",

            Self::ExtensionPoint(_) => "ExtensionPoint",

            Self::CryptoKeyType(_) => "CryptoKeyType",

            Self::PublicKeyType(_) => "PublicKeyType",

            Self::SignerKeyType(_) => "SignerKeyType",

            Self::PublicKey(_) => "PublicKey",

            Self::SignerKey(_) => "SignerKey",

            Self::Signature(_) => "Signature",

            Self::SignatureHint(_) => "SignatureHint",

            Self::NodeId(_) => "NodeId",

            Self::AccountId(_) => "AccountId",

            Self::ContractId(_) => "ContractId",

            Self::Curve25519Secret(_) => "Curve25519Secret",

            Self::Curve25519Public(_) => "Curve25519Public",

            Self::HmacSha256Key(_) => "HmacSha256Key",

            Self::HmacSha256Mac(_) => "HmacSha256Mac",

            Self::ShortHashSeed(_) => "ShortHashSeed",

            Self::BinaryFuseFilterType(_) => "BinaryFuseFilterType",

            Self::SerializedBinaryFuseFilter(_) => "SerializedBinaryFuseFilter",

            Self::PoolId(_) => "PoolId",

            Self::ClaimableBalanceIdType(_) => "ClaimableBalanceIdType",

            Self::ClaimableBalanceId(_) => "ClaimableBalanceId",
        }
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn variants() -> [TypeVariant; 463] {
        Self::VARIANTS
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn variant(&self) -> TypeVariant {
        match self {
            Self::ScpStatementPrepare(_) => TypeVariant::ScpStatementPrepare,

            Self::ScpStatementConfirm(_) => TypeVariant::ScpStatementConfirm,

            Self::ScpStatementExternalize(_) => TypeVariant::ScpStatementExternalize,

            Self::ScpStatementPledges(_) => TypeVariant::ScpStatementPledges,

            Self::ScEnvMetaEntryInterfaceVersion(_) => TypeVariant::ScEnvMetaEntryInterfaceVersion,

            Self::AccountEntryExtensionV2Ext(_) => TypeVariant::AccountEntryExtensionV2Ext,

            Self::AccountEntryExtensionV1Ext(_) => TypeVariant::AccountEntryExtensionV1Ext,

            Self::AccountEntryExt(_) => TypeVariant::AccountEntryExt,

            Self::TrustLineEntryExtensionV2Ext(_) => TypeVariant::TrustLineEntryExtensionV2Ext,

            Self::TrustLineEntryV1Ext(_) => TypeVariant::TrustLineEntryV1Ext,

            Self::TrustLineEntryV1(_) => TypeVariant::TrustLineEntryV1,

            Self::TrustLineEntryExt(_) => TypeVariant::TrustLineEntryExt,

            Self::OfferEntryExt(_) => TypeVariant::OfferEntryExt,

            Self::DataEntryExt(_) => TypeVariant::DataEntryExt,

            Self::ClaimantV0(_) => TypeVariant::ClaimantV0,

            Self::ClaimableBalanceEntryExtensionV1Ext(_) => {
                TypeVariant::ClaimableBalanceEntryExtensionV1Ext
            }

            Self::ClaimableBalanceEntryExt(_) => TypeVariant::ClaimableBalanceEntryExt,

            Self::LiquidityPoolEntryConstantProduct(_) => {
                TypeVariant::LiquidityPoolEntryConstantProduct
            }

            Self::LiquidityPoolEntryBody(_) => TypeVariant::LiquidityPoolEntryBody,

            Self::ContractCodeEntryV1(_) => TypeVariant::ContractCodeEntryV1,

            Self::ContractCodeEntryExt(_) => TypeVariant::ContractCodeEntryExt,

            Self::LedgerEntryExtensionV1Ext(_) => TypeVariant::LedgerEntryExtensionV1Ext,

            Self::LedgerEntryData(_) => TypeVariant::LedgerEntryData,

            Self::LedgerEntryExt(_) => TypeVariant::LedgerEntryExt,

            Self::LedgerKeyAccount(_) => TypeVariant::LedgerKeyAccount,

            Self::LedgerKeyTrustLine(_) => TypeVariant::LedgerKeyTrustLine,

            Self::LedgerKeyOffer(_) => TypeVariant::LedgerKeyOffer,

            Self::LedgerKeyData(_) => TypeVariant::LedgerKeyData,

            Self::LedgerKeyClaimableBalance(_) => TypeVariant::LedgerKeyClaimableBalance,

            Self::LedgerKeyLiquidityPool(_) => TypeVariant::LedgerKeyLiquidityPool,

            Self::LedgerKeyContractData(_) => TypeVariant::LedgerKeyContractData,

            Self::LedgerKeyContractCode(_) => TypeVariant::LedgerKeyContractCode,

            Self::LedgerKeyConfigSetting(_) => TypeVariant::LedgerKeyConfigSetting,

            Self::LedgerKeyTtl(_) => TypeVariant::LedgerKeyTtl,

            Self::BucketMetadataExt(_) => TypeVariant::BucketMetadataExt,

            Self::StellarValueExt(_) => TypeVariant::StellarValueExt,

            Self::LedgerHeaderExtensionV1Ext(_) => TypeVariant::LedgerHeaderExtensionV1Ext,

            Self::LedgerHeaderExt(_) => TypeVariant::LedgerHeaderExt,

            Self::TxSetComponentTxsMaybeDiscountedFee(_) => {
                TypeVariant::TxSetComponentTxsMaybeDiscountedFee
            }

            Self::TransactionHistoryEntryExt(_) => TypeVariant::TransactionHistoryEntryExt,

            Self::TransactionHistoryResultEntryExt(_) => {
                TypeVariant::TransactionHistoryResultEntryExt
            }

            Self::LedgerHeaderHistoryEntryExt(_) => TypeVariant::LedgerHeaderHistoryEntryExt,

            Self::ContractEventV0(_) => TypeVariant::ContractEventV0,

            Self::ContractEventBody(_) => TypeVariant::ContractEventBody,

            Self::PeerAddressIp(_) => TypeVariant::PeerAddressIp,

            Self::AuthenticatedMessageV0(_) => TypeVariant::AuthenticatedMessageV0,

            Self::MuxedAccountMed25519(_) => TypeVariant::MuxedAccountMed25519,

            Self::RevokeSponsorshipOpSigner(_) => TypeVariant::RevokeSponsorshipOpSigner,

            Self::ContractIdPreimageFromAddress(_) => TypeVariant::ContractIdPreimageFromAddress,

            Self::OperationBody(_) => TypeVariant::OperationBody,

            Self::HashIdPreimageOperationId(_) => TypeVariant::HashIdPreimageOperationId,

            Self::HashIdPreimageRevokeId(_) => TypeVariant::HashIdPreimageRevokeId,

            Self::HashIdPreimageContractId(_) => TypeVariant::HashIdPreimageContractId,

            Self::HashIdPreimageSorobanAuthorization(_) => {
                TypeVariant::HashIdPreimageSorobanAuthorization
            }

            Self::SorobanTransactionDataExt(_) => TypeVariant::SorobanTransactionDataExt,

            Self::TransactionV0Ext(_) => TypeVariant::TransactionV0Ext,

            Self::TransactionExt(_) => TypeVariant::TransactionExt,

            Self::FeeBumpTransactionInnerTx(_) => TypeVariant::FeeBumpTransactionInnerTx,

            Self::FeeBumpTransactionExt(_) => TypeVariant::FeeBumpTransactionExt,

            Self::TransactionSignaturePayloadTaggedTransaction(_) => {
                TypeVariant::TransactionSignaturePayloadTaggedTransaction
            }

            Self::PathPaymentStrictReceiveResultSuccess(_) => {
                TypeVariant::PathPaymentStrictReceiveResultSuccess
            }

            Self::PathPaymentStrictSendResultSuccess(_) => {
                TypeVariant::PathPaymentStrictSendResultSuccess
            }

            Self::ManageOfferSuccessResultOffer(_) => TypeVariant::ManageOfferSuccessResultOffer,

            Self::OperationResultTr(_) => TypeVariant::OperationResultTr,

            Self::InnerTransactionResultResult(_) => TypeVariant::InnerTransactionResultResult,

            Self::InnerTransactionResultExt(_) => TypeVariant::InnerTransactionResultExt,

            Self::TransactionResultResult(_) => TypeVariant::TransactionResultResult,

            Self::TransactionResultExt(_) => TypeVariant::TransactionResultExt,

            Self::SignerKeyEd25519SignedPayload(_) => TypeVariant::SignerKeyEd25519SignedPayload,

            Self::Value(_) => TypeVariant::Value,

            Self::ScpBallot(_) => TypeVariant::ScpBallot,

            Self::ScpStatementType(_) => TypeVariant::ScpStatementType,

            Self::ScpNomination(_) => TypeVariant::ScpNomination,

            Self::ScpStatement(_) => TypeVariant::ScpStatement,

            Self::ScpEnvelope(_) => TypeVariant::ScpEnvelope,

            Self::ScpQuorumSet(_) => TypeVariant::ScpQuorumSet,

            Self::ConfigSettingContractExecutionLanesV0(_) => {
                TypeVariant::ConfigSettingContractExecutionLanesV0
            }

            Self::ConfigSettingContractComputeV0(_) => TypeVariant::ConfigSettingContractComputeV0,

            Self::ConfigSettingContractParallelComputeV0(_) => {
                TypeVariant::ConfigSettingContractParallelComputeV0
            }

            Self::ConfigSettingContractLedgerCostV0(_) => {
                TypeVariant::ConfigSettingContractLedgerCostV0
            }

            Self::ConfigSettingContractLedgerCostExtV0(_) => {
                TypeVariant::ConfigSettingContractLedgerCostExtV0
            }

            Self::ConfigSettingContractHistoricalDataV0(_) => {
                TypeVariant::ConfigSettingContractHistoricalDataV0
            }

            Self::ConfigSettingContractEventsV0(_) => TypeVariant::ConfigSettingContractEventsV0,

            Self::ConfigSettingContractBandwidthV0(_) => {
                TypeVariant::ConfigSettingContractBandwidthV0
            }

            Self::ContractCostType(_) => TypeVariant::ContractCostType,

            Self::ContractCostParamEntry(_) => TypeVariant::ContractCostParamEntry,

            Self::StateArchivalSettings(_) => TypeVariant::StateArchivalSettings,

            Self::EvictionIterator(_) => TypeVariant::EvictionIterator,

            Self::ConfigSettingScpTiming(_) => TypeVariant::ConfigSettingScpTiming,

            Self::ContractCostParams(_) => TypeVariant::ContractCostParams,

            Self::ConfigSettingId(_) => TypeVariant::ConfigSettingId,

            Self::ConfigSettingEntry(_) => TypeVariant::ConfigSettingEntry,

            Self::ScEnvMetaKind(_) => TypeVariant::ScEnvMetaKind,

            Self::ScEnvMetaEntry(_) => TypeVariant::ScEnvMetaEntry,

            Self::ScMetaV0(_) => TypeVariant::ScMetaV0,

            Self::ScMetaKind(_) => TypeVariant::ScMetaKind,

            Self::ScMetaEntry(_) => TypeVariant::ScMetaEntry,

            Self::ScSpecType(_) => TypeVariant::ScSpecType,

            Self::ScSpecTypeOption(_) => TypeVariant::ScSpecTypeOption,

            Self::ScSpecTypeResult(_) => TypeVariant::ScSpecTypeResult,

            Self::ScSpecTypeVec(_) => TypeVariant::ScSpecTypeVec,

            Self::ScSpecTypeMap(_) => TypeVariant::ScSpecTypeMap,

            Self::ScSpecTypeTuple(_) => TypeVariant::ScSpecTypeTuple,

            Self::ScSpecTypeBytesN(_) => TypeVariant::ScSpecTypeBytesN,

            Self::ScSpecTypeUdt(_) => TypeVariant::ScSpecTypeUdt,

            Self::ScSpecTypeDef(_) => TypeVariant::ScSpecTypeDef,

            Self::ScSpecUdtStructFieldV0(_) => TypeVariant::ScSpecUdtStructFieldV0,

            Self::ScSpecUdtStructV0(_) => TypeVariant::ScSpecUdtStructV0,

            Self::ScSpecUdtUnionCaseVoidV0(_) => TypeVariant::ScSpecUdtUnionCaseVoidV0,

            Self::ScSpecUdtUnionCaseTupleV0(_) => TypeVariant::ScSpecUdtUnionCaseTupleV0,

            Self::ScSpecUdtUnionCaseV0Kind(_) => TypeVariant::ScSpecUdtUnionCaseV0Kind,

            Self::ScSpecUdtUnionCaseV0(_) => TypeVariant::ScSpecUdtUnionCaseV0,

            Self::ScSpecUdtUnionV0(_) => TypeVariant::ScSpecUdtUnionV0,

            Self::ScSpecUdtEnumCaseV0(_) => TypeVariant::ScSpecUdtEnumCaseV0,

            Self::ScSpecUdtEnumV0(_) => TypeVariant::ScSpecUdtEnumV0,

            Self::ScSpecUdtErrorEnumCaseV0(_) => TypeVariant::ScSpecUdtErrorEnumCaseV0,

            Self::ScSpecUdtErrorEnumV0(_) => TypeVariant::ScSpecUdtErrorEnumV0,

            Self::ScSpecFunctionInputV0(_) => TypeVariant::ScSpecFunctionInputV0,

            Self::ScSpecFunctionV0(_) => TypeVariant::ScSpecFunctionV0,

            Self::ScSpecEventParamLocationV0(_) => TypeVariant::ScSpecEventParamLocationV0,

            Self::ScSpecEventParamV0(_) => TypeVariant::ScSpecEventParamV0,

            Self::ScSpecEventDataFormat(_) => TypeVariant::ScSpecEventDataFormat,

            Self::ScSpecEventV0(_) => TypeVariant::ScSpecEventV0,

            Self::ScSpecEntryKind(_) => TypeVariant::ScSpecEntryKind,

            Self::ScSpecEntry(_) => TypeVariant::ScSpecEntry,

            Self::ScValType(_) => TypeVariant::ScValType,

            Self::ScErrorType(_) => TypeVariant::ScErrorType,

            Self::ScErrorCode(_) => TypeVariant::ScErrorCode,

            Self::ScError(_) => TypeVariant::ScError,

            Self::UInt128Parts(_) => TypeVariant::UInt128Parts,

            Self::Int128Parts(_) => TypeVariant::Int128Parts,

            Self::UInt256Parts(_) => TypeVariant::UInt256Parts,

            Self::Int256Parts(_) => TypeVariant::Int256Parts,

            Self::ContractExecutableType(_) => TypeVariant::ContractExecutableType,

            Self::ContractExecutable(_) => TypeVariant::ContractExecutable,

            Self::ScAddressType(_) => TypeVariant::ScAddressType,

            Self::MuxedEd25519Account(_) => TypeVariant::MuxedEd25519Account,

            Self::ScAddress(_) => TypeVariant::ScAddress,

            Self::ScVec(_) => TypeVariant::ScVec,

            Self::ScMap(_) => TypeVariant::ScMap,

            Self::ScBytes(_) => TypeVariant::ScBytes,

            Self::ScString(_) => TypeVariant::ScString,

            Self::ScSymbol(_) => TypeVariant::ScSymbol,

            Self::ScNonceKey(_) => TypeVariant::ScNonceKey,

            Self::ScContractInstance(_) => TypeVariant::ScContractInstance,

            Self::ScVal(_) => TypeVariant::ScVal,

            Self::ScMapEntry(_) => TypeVariant::ScMapEntry,

            Self::LedgerCloseMetaBatch(_) => TypeVariant::LedgerCloseMetaBatch,

            Self::StoredTransactionSet(_) => TypeVariant::StoredTransactionSet,

            Self::StoredDebugTransactionSet(_) => TypeVariant::StoredDebugTransactionSet,

            Self::PersistedScpStateV0(_) => TypeVariant::PersistedScpStateV0,

            Self::PersistedScpStateV1(_) => TypeVariant::PersistedScpStateV1,

            Self::PersistedScpState(_) => TypeVariant::PersistedScpState,

            Self::Thresholds(_) => TypeVariant::Thresholds,

            Self::String32(_) => TypeVariant::String32,

            Self::String64(_) => TypeVariant::String64,

            Self::SequenceNumber(_) => TypeVariant::SequenceNumber,

            Self::DataValue(_) => TypeVariant::DataValue,

            Self::AssetCode4(_) => TypeVariant::AssetCode4,

            Self::AssetCode12(_) => TypeVariant::AssetCode12,

            Self::AssetType(_) => TypeVariant::AssetType,

            Self::AssetCode(_) => TypeVariant::AssetCode,

            Self::AlphaNum4(_) => TypeVariant::AlphaNum4,

            Self::AlphaNum12(_) => TypeVariant::AlphaNum12,

            Self::Asset(_) => TypeVariant::Asset,

            Self::Price(_) => TypeVariant::Price,

            Self::Liabilities(_) => TypeVariant::Liabilities,

            Self::ThresholdIndexes(_) => TypeVariant::ThresholdIndexes,

            Self::LedgerEntryType(_) => TypeVariant::LedgerEntryType,

            Self::Signer(_) => TypeVariant::Signer,

            Self::AccountFlags(_) => TypeVariant::AccountFlags,

            Self::SponsorshipDescriptor(_) => TypeVariant::SponsorshipDescriptor,

            Self::AccountEntryExtensionV3(_) => TypeVariant::AccountEntryExtensionV3,

            Self::AccountEntryExtensionV2(_) => TypeVariant::AccountEntryExtensionV2,

            Self::AccountEntryExtensionV1(_) => TypeVariant::AccountEntryExtensionV1,

            Self::AccountEntry(_) => TypeVariant::AccountEntry,

            Self::TrustLineFlags(_) => TypeVariant::TrustLineFlags,

            Self::LiquidityPoolType(_) => TypeVariant::LiquidityPoolType,

            Self::TrustLineAsset(_) => TypeVariant::TrustLineAsset,

            Self::TrustLineEntryExtensionV2(_) => TypeVariant::TrustLineEntryExtensionV2,

            Self::TrustLineEntry(_) => TypeVariant::TrustLineEntry,

            Self::OfferEntryFlags(_) => TypeVariant::OfferEntryFlags,

            Self::OfferEntry(_) => TypeVariant::OfferEntry,

            Self::DataEntry(_) => TypeVariant::DataEntry,

            Self::ClaimPredicateType(_) => TypeVariant::ClaimPredicateType,

            Self::ClaimPredicate(_) => TypeVariant::ClaimPredicate,

            Self::ClaimantType(_) => TypeVariant::ClaimantType,

            Self::Claimant(_) => TypeVariant::Claimant,

            Self::ClaimableBalanceFlags(_) => TypeVariant::ClaimableBalanceFlags,

            Self::ClaimableBalanceEntryExtensionV1(_) => {
                TypeVariant::ClaimableBalanceEntryExtensionV1
            }

            Self::ClaimableBalanceEntry(_) => TypeVariant::ClaimableBalanceEntry,

            Self::LiquidityPoolConstantProductParameters(_) => {
                TypeVariant::LiquidityPoolConstantProductParameters
            }

            Self::LiquidityPoolEntry(_) => TypeVariant::LiquidityPoolEntry,

            Self::ContractDataDurability(_) => TypeVariant::ContractDataDurability,

            Self::ContractDataEntry(_) => TypeVariant::ContractDataEntry,

            Self::ContractCodeCostInputs(_) => TypeVariant::ContractCodeCostInputs,

            Self::ContractCodeEntry(_) => TypeVariant::ContractCodeEntry,

            Self::TtlEntry(_) => TypeVariant::TtlEntry,

            Self::LedgerEntryExtensionV1(_) => TypeVariant::LedgerEntryExtensionV1,

            Self::LedgerEntry(_) => TypeVariant::LedgerEntry,

            Self::LedgerKey(_) => TypeVariant::LedgerKey,

            Self::EnvelopeType(_) => TypeVariant::EnvelopeType,

            Self::BucketListType(_) => TypeVariant::BucketListType,

            Self::BucketEntryType(_) => TypeVariant::BucketEntryType,

            Self::HotArchiveBucketEntryType(_) => TypeVariant::HotArchiveBucketEntryType,

            Self::BucketMetadata(_) => TypeVariant::BucketMetadata,

            Self::BucketEntry(_) => TypeVariant::BucketEntry,

            Self::HotArchiveBucketEntry(_) => TypeVariant::HotArchiveBucketEntry,

            Self::UpgradeType(_) => TypeVariant::UpgradeType,

            Self::StellarValueType(_) => TypeVariant::StellarValueType,

            Self::LedgerCloseValueSignature(_) => TypeVariant::LedgerCloseValueSignature,

            Self::StellarValue(_) => TypeVariant::StellarValue,

            Self::LedgerHeaderFlags(_) => TypeVariant::LedgerHeaderFlags,

            Self::LedgerHeaderExtensionV1(_) => TypeVariant::LedgerHeaderExtensionV1,

            Self::LedgerHeader(_) => TypeVariant::LedgerHeader,

            Self::LedgerUpgradeType(_) => TypeVariant::LedgerUpgradeType,

            Self::ConfigUpgradeSetKey(_) => TypeVariant::ConfigUpgradeSetKey,

            Self::LedgerUpgrade(_) => TypeVariant::LedgerUpgrade,

            Self::ConfigUpgradeSet(_) => TypeVariant::ConfigUpgradeSet,

            Self::TxSetComponentType(_) => TypeVariant::TxSetComponentType,

            Self::DependentTxCluster(_) => TypeVariant::DependentTxCluster,

            Self::ParallelTxExecutionStage(_) => TypeVariant::ParallelTxExecutionStage,

            Self::ParallelTxsComponent(_) => TypeVariant::ParallelTxsComponent,

            Self::TxSetComponent(_) => TypeVariant::TxSetComponent,

            Self::TransactionPhase(_) => TypeVariant::TransactionPhase,

            Self::TransactionSet(_) => TypeVariant::TransactionSet,

            Self::TransactionSetV1(_) => TypeVariant::TransactionSetV1,

            Self::GeneralizedTransactionSet(_) => TypeVariant::GeneralizedTransactionSet,

            Self::TransactionResultPair(_) => TypeVariant::TransactionResultPair,

            Self::TransactionResultSet(_) => TypeVariant::TransactionResultSet,

            Self::TransactionHistoryEntry(_) => TypeVariant::TransactionHistoryEntry,

            Self::TransactionHistoryResultEntry(_) => TypeVariant::TransactionHistoryResultEntry,

            Self::LedgerHeaderHistoryEntry(_) => TypeVariant::LedgerHeaderHistoryEntry,

            Self::LedgerScpMessages(_) => TypeVariant::LedgerScpMessages,

            Self::ScpHistoryEntryV0(_) => TypeVariant::ScpHistoryEntryV0,

            Self::ScpHistoryEntry(_) => TypeVariant::ScpHistoryEntry,

            Self::LedgerEntryChangeType(_) => TypeVariant::LedgerEntryChangeType,

            Self::LedgerEntryChange(_) => TypeVariant::LedgerEntryChange,

            Self::LedgerEntryChanges(_) => TypeVariant::LedgerEntryChanges,

            Self::OperationMeta(_) => TypeVariant::OperationMeta,

            Self::TransactionMetaV1(_) => TypeVariant::TransactionMetaV1,

            Self::TransactionMetaV2(_) => TypeVariant::TransactionMetaV2,

            Self::ContractEventType(_) => TypeVariant::ContractEventType,

            Self::ContractEvent(_) => TypeVariant::ContractEvent,

            Self::DiagnosticEvent(_) => TypeVariant::DiagnosticEvent,

            Self::SorobanTransactionMetaExtV1(_) => TypeVariant::SorobanTransactionMetaExtV1,

            Self::SorobanTransactionMetaExt(_) => TypeVariant::SorobanTransactionMetaExt,

            Self::SorobanTransactionMeta(_) => TypeVariant::SorobanTransactionMeta,

            Self::TransactionMetaV3(_) => TypeVariant::TransactionMetaV3,

            Self::OperationMetaV2(_) => TypeVariant::OperationMetaV2,

            Self::SorobanTransactionMetaV2(_) => TypeVariant::SorobanTransactionMetaV2,

            Self::TransactionEventStage(_) => TypeVariant::TransactionEventStage,

            Self::TransactionEvent(_) => TypeVariant::TransactionEvent,

            Self::TransactionMetaV4(_) => TypeVariant::TransactionMetaV4,

            Self::InvokeHostFunctionSuccessPreImage(_) => {
                TypeVariant::InvokeHostFunctionSuccessPreImage
            }

            Self::TransactionMeta(_) => TypeVariant::TransactionMeta,

            Self::TransactionResultMeta(_) => TypeVariant::TransactionResultMeta,

            Self::TransactionResultMetaV1(_) => TypeVariant::TransactionResultMetaV1,

            Self::UpgradeEntryMeta(_) => TypeVariant::UpgradeEntryMeta,

            Self::LedgerCloseMetaV0(_) => TypeVariant::LedgerCloseMetaV0,

            Self::LedgerCloseMetaExtV1(_) => TypeVariant::LedgerCloseMetaExtV1,

            Self::LedgerCloseMetaExt(_) => TypeVariant::LedgerCloseMetaExt,

            Self::LedgerCloseMetaV1(_) => TypeVariant::LedgerCloseMetaV1,

            Self::LedgerCloseMetaV2(_) => TypeVariant::LedgerCloseMetaV2,

            Self::LedgerCloseMeta(_) => TypeVariant::LedgerCloseMeta,

            Self::ErrorCode(_) => TypeVariant::ErrorCode,

            Self::SError(_) => TypeVariant::SError,

            Self::SendMore(_) => TypeVariant::SendMore,

            Self::SendMoreExtended(_) => TypeVariant::SendMoreExtended,

            Self::AuthCert(_) => TypeVariant::AuthCert,

            Self::Hello(_) => TypeVariant::Hello,

            Self::Auth(_) => TypeVariant::Auth,

            Self::IpAddrType(_) => TypeVariant::IpAddrType,

            Self::PeerAddress(_) => TypeVariant::PeerAddress,

            Self::MessageType(_) => TypeVariant::MessageType,

            Self::DontHave(_) => TypeVariant::DontHave,

            Self::SurveyMessageCommandType(_) => TypeVariant::SurveyMessageCommandType,

            Self::SurveyMessageResponseType(_) => TypeVariant::SurveyMessageResponseType,

            Self::TimeSlicedSurveyStartCollectingMessage(_) => {
                TypeVariant::TimeSlicedSurveyStartCollectingMessage
            }

            Self::SignedTimeSlicedSurveyStartCollectingMessage(_) => {
                TypeVariant::SignedTimeSlicedSurveyStartCollectingMessage
            }

            Self::TimeSlicedSurveyStopCollectingMessage(_) => {
                TypeVariant::TimeSlicedSurveyStopCollectingMessage
            }

            Self::SignedTimeSlicedSurveyStopCollectingMessage(_) => {
                TypeVariant::SignedTimeSlicedSurveyStopCollectingMessage
            }

            Self::SurveyRequestMessage(_) => TypeVariant::SurveyRequestMessage,

            Self::TimeSlicedSurveyRequestMessage(_) => TypeVariant::TimeSlicedSurveyRequestMessage,

            Self::SignedTimeSlicedSurveyRequestMessage(_) => {
                TypeVariant::SignedTimeSlicedSurveyRequestMessage
            }

            Self::EncryptedBody(_) => TypeVariant::EncryptedBody,

            Self::SurveyResponseMessage(_) => TypeVariant::SurveyResponseMessage,

            Self::TimeSlicedSurveyResponseMessage(_) => {
                TypeVariant::TimeSlicedSurveyResponseMessage
            }

            Self::SignedTimeSlicedSurveyResponseMessage(_) => {
                TypeVariant::SignedTimeSlicedSurveyResponseMessage
            }

            Self::PeerStats(_) => TypeVariant::PeerStats,

            Self::TimeSlicedNodeData(_) => TypeVariant::TimeSlicedNodeData,

            Self::TimeSlicedPeerData(_) => TypeVariant::TimeSlicedPeerData,

            Self::TimeSlicedPeerDataList(_) => TypeVariant::TimeSlicedPeerDataList,

            Self::TopologyResponseBodyV2(_) => TypeVariant::TopologyResponseBodyV2,

            Self::SurveyResponseBody(_) => TypeVariant::SurveyResponseBody,

            Self::TxAdvertVector(_) => TypeVariant::TxAdvertVector,

            Self::FloodAdvert(_) => TypeVariant::FloodAdvert,

            Self::TxDemandVector(_) => TypeVariant::TxDemandVector,

            Self::FloodDemand(_) => TypeVariant::FloodDemand,

            Self::StellarMessage(_) => TypeVariant::StellarMessage,

            Self::AuthenticatedMessage(_) => TypeVariant::AuthenticatedMessage,

            Self::LiquidityPoolParameters(_) => TypeVariant::LiquidityPoolParameters,

            Self::MuxedAccount(_) => TypeVariant::MuxedAccount,

            Self::DecoratedSignature(_) => TypeVariant::DecoratedSignature,

            Self::OperationType(_) => TypeVariant::OperationType,

            Self::CreateAccountOp(_) => TypeVariant::CreateAccountOp,

            Self::PaymentOp(_) => TypeVariant::PaymentOp,

            Self::PathPaymentStrictReceiveOp(_) => TypeVariant::PathPaymentStrictReceiveOp,

            Self::PathPaymentStrictSendOp(_) => TypeVariant::PathPaymentStrictSendOp,

            Self::ManageSellOfferOp(_) => TypeVariant::ManageSellOfferOp,

            Self::ManageBuyOfferOp(_) => TypeVariant::ManageBuyOfferOp,

            Self::CreatePassiveSellOfferOp(_) => TypeVariant::CreatePassiveSellOfferOp,

            Self::SetOptionsOp(_) => TypeVariant::SetOptionsOp,

            Self::ChangeTrustAsset(_) => TypeVariant::ChangeTrustAsset,

            Self::ChangeTrustOp(_) => TypeVariant::ChangeTrustOp,

            Self::AllowTrustOp(_) => TypeVariant::AllowTrustOp,

            Self::ManageDataOp(_) => TypeVariant::ManageDataOp,

            Self::BumpSequenceOp(_) => TypeVariant::BumpSequenceOp,

            Self::CreateClaimableBalanceOp(_) => TypeVariant::CreateClaimableBalanceOp,

            Self::ClaimClaimableBalanceOp(_) => TypeVariant::ClaimClaimableBalanceOp,

            Self::BeginSponsoringFutureReservesOp(_) => {
                TypeVariant::BeginSponsoringFutureReservesOp
            }

            Self::RevokeSponsorshipType(_) => TypeVariant::RevokeSponsorshipType,

            Self::RevokeSponsorshipOp(_) => TypeVariant::RevokeSponsorshipOp,

            Self::ClawbackOp(_) => TypeVariant::ClawbackOp,

            Self::ClawbackClaimableBalanceOp(_) => TypeVariant::ClawbackClaimableBalanceOp,

            Self::SetTrustLineFlagsOp(_) => TypeVariant::SetTrustLineFlagsOp,

            Self::LiquidityPoolDepositOp(_) => TypeVariant::LiquidityPoolDepositOp,

            Self::LiquidityPoolWithdrawOp(_) => TypeVariant::LiquidityPoolWithdrawOp,

            Self::HostFunctionType(_) => TypeVariant::HostFunctionType,

            Self::ContractIdPreimageType(_) => TypeVariant::ContractIdPreimageType,

            Self::ContractIdPreimage(_) => TypeVariant::ContractIdPreimage,

            Self::CreateContractArgs(_) => TypeVariant::CreateContractArgs,

            Self::CreateContractArgsV2(_) => TypeVariant::CreateContractArgsV2,

            Self::InvokeContractArgs(_) => TypeVariant::InvokeContractArgs,

            Self::HostFunction(_) => TypeVariant::HostFunction,

            Self::SorobanAuthorizedFunctionType(_) => TypeVariant::SorobanAuthorizedFunctionType,

            Self::SorobanAuthorizedFunction(_) => TypeVariant::SorobanAuthorizedFunction,

            Self::SorobanAuthorizedInvocation(_) => TypeVariant::SorobanAuthorizedInvocation,

            Self::SorobanAddressCredentials(_) => TypeVariant::SorobanAddressCredentials,

            Self::SorobanCredentialsType(_) => TypeVariant::SorobanCredentialsType,

            Self::SorobanCredentials(_) => TypeVariant::SorobanCredentials,

            Self::SorobanAuthorizationEntry(_) => TypeVariant::SorobanAuthorizationEntry,

            Self::SorobanAuthorizationEntries(_) => TypeVariant::SorobanAuthorizationEntries,

            Self::InvokeHostFunctionOp(_) => TypeVariant::InvokeHostFunctionOp,

            Self::ExtendFootprintTtlOp(_) => TypeVariant::ExtendFootprintTtlOp,

            Self::RestoreFootprintOp(_) => TypeVariant::RestoreFootprintOp,

            Self::Operation(_) => TypeVariant::Operation,

            Self::HashIdPreimage(_) => TypeVariant::HashIdPreimage,

            Self::MemoType(_) => TypeVariant::MemoType,

            Self::Memo(_) => TypeVariant::Memo,

            Self::TimeBounds(_) => TypeVariant::TimeBounds,

            Self::LedgerBounds(_) => TypeVariant::LedgerBounds,

            Self::PreconditionsV2(_) => TypeVariant::PreconditionsV2,

            Self::PreconditionType(_) => TypeVariant::PreconditionType,

            Self::Preconditions(_) => TypeVariant::Preconditions,

            Self::LedgerFootprint(_) => TypeVariant::LedgerFootprint,

            Self::SorobanResources(_) => TypeVariant::SorobanResources,

            Self::SorobanResourcesExtV0(_) => TypeVariant::SorobanResourcesExtV0,

            Self::SorobanTransactionData(_) => TypeVariant::SorobanTransactionData,

            Self::TransactionV0(_) => TypeVariant::TransactionV0,

            Self::TransactionV0Envelope(_) => TypeVariant::TransactionV0Envelope,

            Self::Transaction(_) => TypeVariant::Transaction,

            Self::TransactionV1Envelope(_) => TypeVariant::TransactionV1Envelope,

            Self::FeeBumpTransaction(_) => TypeVariant::FeeBumpTransaction,

            Self::FeeBumpTransactionEnvelope(_) => TypeVariant::FeeBumpTransactionEnvelope,

            Self::TransactionEnvelope(_) => TypeVariant::TransactionEnvelope,

            Self::TransactionSignaturePayload(_) => TypeVariant::TransactionSignaturePayload,

            Self::ClaimAtomType(_) => TypeVariant::ClaimAtomType,

            Self::ClaimOfferAtomV0(_) => TypeVariant::ClaimOfferAtomV0,

            Self::ClaimOfferAtom(_) => TypeVariant::ClaimOfferAtom,

            Self::ClaimLiquidityAtom(_) => TypeVariant::ClaimLiquidityAtom,

            Self::ClaimAtom(_) => TypeVariant::ClaimAtom,

            Self::CreateAccountResultCode(_) => TypeVariant::CreateAccountResultCode,

            Self::CreateAccountResult(_) => TypeVariant::CreateAccountResult,

            Self::PaymentResultCode(_) => TypeVariant::PaymentResultCode,

            Self::PaymentResult(_) => TypeVariant::PaymentResult,

            Self::PathPaymentStrictReceiveResultCode(_) => {
                TypeVariant::PathPaymentStrictReceiveResultCode
            }

            Self::SimplePaymentResult(_) => TypeVariant::SimplePaymentResult,

            Self::PathPaymentStrictReceiveResult(_) => TypeVariant::PathPaymentStrictReceiveResult,

            Self::PathPaymentStrictSendResultCode(_) => {
                TypeVariant::PathPaymentStrictSendResultCode
            }

            Self::PathPaymentStrictSendResult(_) => TypeVariant::PathPaymentStrictSendResult,

            Self::ManageSellOfferResultCode(_) => TypeVariant::ManageSellOfferResultCode,

            Self::ManageOfferEffect(_) => TypeVariant::ManageOfferEffect,

            Self::ManageOfferSuccessResult(_) => TypeVariant::ManageOfferSuccessResult,

            Self::ManageSellOfferResult(_) => TypeVariant::ManageSellOfferResult,

            Self::ManageBuyOfferResultCode(_) => TypeVariant::ManageBuyOfferResultCode,

            Self::ManageBuyOfferResult(_) => TypeVariant::ManageBuyOfferResult,

            Self::SetOptionsResultCode(_) => TypeVariant::SetOptionsResultCode,

            Self::SetOptionsResult(_) => TypeVariant::SetOptionsResult,

            Self::ChangeTrustResultCode(_) => TypeVariant::ChangeTrustResultCode,

            Self::ChangeTrustResult(_) => TypeVariant::ChangeTrustResult,

            Self::AllowTrustResultCode(_) => TypeVariant::AllowTrustResultCode,

            Self::AllowTrustResult(_) => TypeVariant::AllowTrustResult,

            Self::AccountMergeResultCode(_) => TypeVariant::AccountMergeResultCode,

            Self::AccountMergeResult(_) => TypeVariant::AccountMergeResult,

            Self::InflationResultCode(_) => TypeVariant::InflationResultCode,

            Self::InflationPayout(_) => TypeVariant::InflationPayout,

            Self::InflationResult(_) => TypeVariant::InflationResult,

            Self::ManageDataResultCode(_) => TypeVariant::ManageDataResultCode,

            Self::ManageDataResult(_) => TypeVariant::ManageDataResult,

            Self::BumpSequenceResultCode(_) => TypeVariant::BumpSequenceResultCode,

            Self::BumpSequenceResult(_) => TypeVariant::BumpSequenceResult,

            Self::CreateClaimableBalanceResultCode(_) => {
                TypeVariant::CreateClaimableBalanceResultCode
            }

            Self::CreateClaimableBalanceResult(_) => TypeVariant::CreateClaimableBalanceResult,

            Self::ClaimClaimableBalanceResultCode(_) => {
                TypeVariant::ClaimClaimableBalanceResultCode
            }

            Self::ClaimClaimableBalanceResult(_) => TypeVariant::ClaimClaimableBalanceResult,

            Self::BeginSponsoringFutureReservesResultCode(_) => {
                TypeVariant::BeginSponsoringFutureReservesResultCode
            }

            Self::BeginSponsoringFutureReservesResult(_) => {
                TypeVariant::BeginSponsoringFutureReservesResult
            }

            Self::EndSponsoringFutureReservesResultCode(_) => {
                TypeVariant::EndSponsoringFutureReservesResultCode
            }

            Self::EndSponsoringFutureReservesResult(_) => {
                TypeVariant::EndSponsoringFutureReservesResult
            }

            Self::RevokeSponsorshipResultCode(_) => TypeVariant::RevokeSponsorshipResultCode,

            Self::RevokeSponsorshipResult(_) => TypeVariant::RevokeSponsorshipResult,

            Self::ClawbackResultCode(_) => TypeVariant::ClawbackResultCode,

            Self::ClawbackResult(_) => TypeVariant::ClawbackResult,

            Self::ClawbackClaimableBalanceResultCode(_) => {
                TypeVariant::ClawbackClaimableBalanceResultCode
            }

            Self::ClawbackClaimableBalanceResult(_) => TypeVariant::ClawbackClaimableBalanceResult,

            Self::SetTrustLineFlagsResultCode(_) => TypeVariant::SetTrustLineFlagsResultCode,

            Self::SetTrustLineFlagsResult(_) => TypeVariant::SetTrustLineFlagsResult,

            Self::LiquidityPoolDepositResultCode(_) => TypeVariant::LiquidityPoolDepositResultCode,

            Self::LiquidityPoolDepositResult(_) => TypeVariant::LiquidityPoolDepositResult,

            Self::LiquidityPoolWithdrawResultCode(_) => {
                TypeVariant::LiquidityPoolWithdrawResultCode
            }

            Self::LiquidityPoolWithdrawResult(_) => TypeVariant::LiquidityPoolWithdrawResult,

            Self::InvokeHostFunctionResultCode(_) => TypeVariant::InvokeHostFunctionResultCode,

            Self::InvokeHostFunctionResult(_) => TypeVariant::InvokeHostFunctionResult,

            Self::ExtendFootprintTtlResultCode(_) => TypeVariant::ExtendFootprintTtlResultCode,

            Self::ExtendFootprintTtlResult(_) => TypeVariant::ExtendFootprintTtlResult,

            Self::RestoreFootprintResultCode(_) => TypeVariant::RestoreFootprintResultCode,

            Self::RestoreFootprintResult(_) => TypeVariant::RestoreFootprintResult,

            Self::OperationResultCode(_) => TypeVariant::OperationResultCode,

            Self::OperationResult(_) => TypeVariant::OperationResult,

            Self::TransactionResultCode(_) => TypeVariant::TransactionResultCode,

            Self::InnerTransactionResult(_) => TypeVariant::InnerTransactionResult,

            Self::InnerTransactionResultPair(_) => TypeVariant::InnerTransactionResultPair,

            Self::TransactionResult(_) => TypeVariant::TransactionResult,

            Self::Hash(_) => TypeVariant::Hash,

            Self::Uint256(_) => TypeVariant::Uint256,

            Self::Uint32(_) => TypeVariant::Uint32,

            Self::Int32(_) => TypeVariant::Int32,

            Self::Uint64(_) => TypeVariant::Uint64,

            Self::Int64(_) => TypeVariant::Int64,

            Self::TimePoint(_) => TypeVariant::TimePoint,

            Self::Duration(_) => TypeVariant::Duration,

            Self::ExtensionPoint(_) => TypeVariant::ExtensionPoint,

            Self::CryptoKeyType(_) => TypeVariant::CryptoKeyType,

            Self::PublicKeyType(_) => TypeVariant::PublicKeyType,

            Self::SignerKeyType(_) => TypeVariant::SignerKeyType,

            Self::PublicKey(_) => TypeVariant::PublicKey,

            Self::SignerKey(_) => TypeVariant::SignerKey,

            Self::Signature(_) => TypeVariant::Signature,

            Self::SignatureHint(_) => TypeVariant::SignatureHint,

            Self::NodeId(_) => TypeVariant::NodeId,

            Self::AccountId(_) => TypeVariant::AccountId,

            Self::ContractId(_) => TypeVariant::ContractId,

            Self::Curve25519Secret(_) => TypeVariant::Curve25519Secret,

            Self::Curve25519Public(_) => TypeVariant::Curve25519Public,

            Self::HmacSha256Key(_) => TypeVariant::HmacSha256Key,

            Self::HmacSha256Mac(_) => TypeVariant::HmacSha256Mac,

            Self::ShortHashSeed(_) => TypeVariant::ShortHashSeed,

            Self::BinaryFuseFilterType(_) => TypeVariant::BinaryFuseFilterType,

            Self::SerializedBinaryFuseFilter(_) => TypeVariant::SerializedBinaryFuseFilter,

            Self::PoolId(_) => TypeVariant::PoolId,

            Self::ClaimableBalanceIdType(_) => TypeVariant::ClaimableBalanceIdType,

            Self::ClaimableBalanceId(_) => TypeVariant::ClaimableBalanceId,
        }
    }
}

impl Name for Type {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TypeVariant> for Type {
    fn variants() -> slice::Iter<'static, TypeVariant> {
        Self::VARIANTS.iter()
    }
}

impl WriteXdr for Type {
    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        match self {
            Self::ScpStatementPrepare(v) => v.write_xdr(w),

            Self::ScpStatementConfirm(v) => v.write_xdr(w),

            Self::ScpStatementExternalize(v) => v.write_xdr(w),

            Self::ScpStatementPledges(v) => v.write_xdr(w),

            Self::ScEnvMetaEntryInterfaceVersion(v) => v.write_xdr(w),

            Self::AccountEntryExtensionV2Ext(v) => v.write_xdr(w),

            Self::AccountEntryExtensionV1Ext(v) => v.write_xdr(w),

            Self::AccountEntryExt(v) => v.write_xdr(w),

            Self::TrustLineEntryExtensionV2Ext(v) => v.write_xdr(w),

            Self::TrustLineEntryV1Ext(v) => v.write_xdr(w),

            Self::TrustLineEntryV1(v) => v.write_xdr(w),

            Self::TrustLineEntryExt(v) => v.write_xdr(w),

            Self::OfferEntryExt(v) => v.write_xdr(w),

            Self::DataEntryExt(v) => v.write_xdr(w),

            Self::ClaimantV0(v) => v.write_xdr(w),

            Self::ClaimableBalanceEntryExtensionV1Ext(v) => v.write_xdr(w),

            Self::ClaimableBalanceEntryExt(v) => v.write_xdr(w),

            Self::LiquidityPoolEntryConstantProduct(v) => v.write_xdr(w),

            Self::LiquidityPoolEntryBody(v) => v.write_xdr(w),

            Self::ContractCodeEntryV1(v) => v.write_xdr(w),

            Self::ContractCodeEntryExt(v) => v.write_xdr(w),

            Self::LedgerEntryExtensionV1Ext(v) => v.write_xdr(w),

            Self::LedgerEntryData(v) => v.write_xdr(w),

            Self::LedgerEntryExt(v) => v.write_xdr(w),

            Self::LedgerKeyAccount(v) => v.write_xdr(w),

            Self::LedgerKeyTrustLine(v) => v.write_xdr(w),

            Self::LedgerKeyOffer(v) => v.write_xdr(w),

            Self::LedgerKeyData(v) => v.write_xdr(w),

            Self::LedgerKeyClaimableBalance(v) => v.write_xdr(w),

            Self::LedgerKeyLiquidityPool(v) => v.write_xdr(w),

            Self::LedgerKeyContractData(v) => v.write_xdr(w),

            Self::LedgerKeyContractCode(v) => v.write_xdr(w),

            Self::LedgerKeyConfigSetting(v) => v.write_xdr(w),

            Self::LedgerKeyTtl(v) => v.write_xdr(w),

            Self::BucketMetadataExt(v) => v.write_xdr(w),

            Self::StellarValueExt(v) => v.write_xdr(w),

            Self::LedgerHeaderExtensionV1Ext(v) => v.write_xdr(w),

            Self::LedgerHeaderExt(v) => v.write_xdr(w),

            Self::TxSetComponentTxsMaybeDiscountedFee(v) => v.write_xdr(w),

            Self::TransactionHistoryEntryExt(v) => v.write_xdr(w),

            Self::TransactionHistoryResultEntryExt(v) => v.write_xdr(w),

            Self::LedgerHeaderHistoryEntryExt(v) => v.write_xdr(w),

            Self::ContractEventV0(v) => v.write_xdr(w),

            Self::ContractEventBody(v) => v.write_xdr(w),

            Self::PeerAddressIp(v) => v.write_xdr(w),

            Self::AuthenticatedMessageV0(v) => v.write_xdr(w),

            Self::MuxedAccountMed25519(v) => v.write_xdr(w),

            Self::RevokeSponsorshipOpSigner(v) => v.write_xdr(w),

            Self::ContractIdPreimageFromAddress(v) => v.write_xdr(w),

            Self::OperationBody(v) => v.write_xdr(w),

            Self::HashIdPreimageOperationId(v) => v.write_xdr(w),

            Self::HashIdPreimageRevokeId(v) => v.write_xdr(w),

            Self::HashIdPreimageContractId(v) => v.write_xdr(w),

            Self::HashIdPreimageSorobanAuthorization(v) => v.write_xdr(w),

            Self::SorobanTransactionDataExt(v) => v.write_xdr(w),

            Self::TransactionV0Ext(v) => v.write_xdr(w),

            Self::TransactionExt(v) => v.write_xdr(w),

            Self::FeeBumpTransactionInnerTx(v) => v.write_xdr(w),

            Self::FeeBumpTransactionExt(v) => v.write_xdr(w),

            Self::TransactionSignaturePayloadTaggedTransaction(v) => v.write_xdr(w),

            Self::PathPaymentStrictReceiveResultSuccess(v) => v.write_xdr(w),

            Self::PathPaymentStrictSendResultSuccess(v) => v.write_xdr(w),

            Self::ManageOfferSuccessResultOffer(v) => v.write_xdr(w),

            Self::OperationResultTr(v) => v.write_xdr(w),

            Self::InnerTransactionResultResult(v) => v.write_xdr(w),

            Self::InnerTransactionResultExt(v) => v.write_xdr(w),

            Self::TransactionResultResult(v) => v.write_xdr(w),

            Self::TransactionResultExt(v) => v.write_xdr(w),

            Self::SignerKeyEd25519SignedPayload(v) => v.write_xdr(w),

            Self::Value(v) => v.write_xdr(w),

            Self::ScpBallot(v) => v.write_xdr(w),

            Self::ScpStatementType(v) => v.write_xdr(w),

            Self::ScpNomination(v) => v.write_xdr(w),

            Self::ScpStatement(v) => v.write_xdr(w),

            Self::ScpEnvelope(v) => v.write_xdr(w),

            Self::ScpQuorumSet(v) => v.write_xdr(w),

            Self::ConfigSettingContractExecutionLanesV0(v) => v.write_xdr(w),

            Self::ConfigSettingContractComputeV0(v) => v.write_xdr(w),

            Self::ConfigSettingContractParallelComputeV0(v) => v.write_xdr(w),

            Self::ConfigSettingContractLedgerCostV0(v) => v.write_xdr(w),

            Self::ConfigSettingContractLedgerCostExtV0(v) => v.write_xdr(w),

            Self::ConfigSettingContractHistoricalDataV0(v) => v.write_xdr(w),

            Self::ConfigSettingContractEventsV0(v) => v.write_xdr(w),

            Self::ConfigSettingContractBandwidthV0(v) => v.write_xdr(w),

            Self::ContractCostType(v) => v.write_xdr(w),

            Self::ContractCostParamEntry(v) => v.write_xdr(w),

            Self::StateArchivalSettings(v) => v.write_xdr(w),

            Self::EvictionIterator(v) => v.write_xdr(w),

            Self::ConfigSettingScpTiming(v) => v.write_xdr(w),

            Self::ContractCostParams(v) => v.write_xdr(w),

            Self::ConfigSettingId(v) => v.write_xdr(w),

            Self::ConfigSettingEntry(v) => v.write_xdr(w),

            Self::ScEnvMetaKind(v) => v.write_xdr(w),

            Self::ScEnvMetaEntry(v) => v.write_xdr(w),

            Self::ScMetaV0(v) => v.write_xdr(w),

            Self::ScMetaKind(v) => v.write_xdr(w),

            Self::ScMetaEntry(v) => v.write_xdr(w),

            Self::ScSpecType(v) => v.write_xdr(w),

            Self::ScSpecTypeOption(v) => v.write_xdr(w),

            Self::ScSpecTypeResult(v) => v.write_xdr(w),

            Self::ScSpecTypeVec(v) => v.write_xdr(w),

            Self::ScSpecTypeMap(v) => v.write_xdr(w),

            Self::ScSpecTypeTuple(v) => v.write_xdr(w),

            Self::ScSpecTypeBytesN(v) => v.write_xdr(w),

            Self::ScSpecTypeUdt(v) => v.write_xdr(w),

            Self::ScSpecTypeDef(v) => v.write_xdr(w),

            Self::ScSpecUdtStructFieldV0(v) => v.write_xdr(w),

            Self::ScSpecUdtStructV0(v) => v.write_xdr(w),

            Self::ScSpecUdtUnionCaseVoidV0(v) => v.write_xdr(w),

            Self::ScSpecUdtUnionCaseTupleV0(v) => v.write_xdr(w),

            Self::ScSpecUdtUnionCaseV0Kind(v) => v.write_xdr(w),

            Self::ScSpecUdtUnionCaseV0(v) => v.write_xdr(w),

            Self::ScSpecUdtUnionV0(v) => v.write_xdr(w),

            Self::ScSpecUdtEnumCaseV0(v) => v.write_xdr(w),

            Self::ScSpecUdtEnumV0(v) => v.write_xdr(w),

            Self::ScSpecUdtErrorEnumCaseV0(v) => v.write_xdr(w),

            Self::ScSpecUdtErrorEnumV0(v) => v.write_xdr(w),

            Self::ScSpecFunctionInputV0(v) => v.write_xdr(w),

            Self::ScSpecFunctionV0(v) => v.write_xdr(w),

            Self::ScSpecEventParamLocationV0(v) => v.write_xdr(w),

            Self::ScSpecEventParamV0(v) => v.write_xdr(w),

            Self::ScSpecEventDataFormat(v) => v.write_xdr(w),

            Self::ScSpecEventV0(v) => v.write_xdr(w),

            Self::ScSpecEntryKind(v) => v.write_xdr(w),

            Self::ScSpecEntry(v) => v.write_xdr(w),

            Self::ScValType(v) => v.write_xdr(w),

            Self::ScErrorType(v) => v.write_xdr(w),

            Self::ScErrorCode(v) => v.write_xdr(w),

            Self::ScError(v) => v.write_xdr(w),

            Self::UInt128Parts(v) => v.write_xdr(w),

            Self::Int128Parts(v) => v.write_xdr(w),

            Self::UInt256Parts(v) => v.write_xdr(w),

            Self::Int256Parts(v) => v.write_xdr(w),

            Self::ContractExecutableType(v) => v.write_xdr(w),

            Self::ContractExecutable(v) => v.write_xdr(w),

            Self::ScAddressType(v) => v.write_xdr(w),

            Self::MuxedEd25519Account(v) => v.write_xdr(w),

            Self::ScAddress(v) => v.write_xdr(w),

            Self::ScVec(v) => v.write_xdr(w),

            Self::ScMap(v) => v.write_xdr(w),

            Self::ScBytes(v) => v.write_xdr(w),

            Self::ScString(v) => v.write_xdr(w),

            Self::ScSymbol(v) => v.write_xdr(w),

            Self::ScNonceKey(v) => v.write_xdr(w),

            Self::ScContractInstance(v) => v.write_xdr(w),

            Self::ScVal(v) => v.write_xdr(w),

            Self::ScMapEntry(v) => v.write_xdr(w),

            Self::LedgerCloseMetaBatch(v) => v.write_xdr(w),

            Self::StoredTransactionSet(v) => v.write_xdr(w),

            Self::StoredDebugTransactionSet(v) => v.write_xdr(w),

            Self::PersistedScpStateV0(v) => v.write_xdr(w),

            Self::PersistedScpStateV1(v) => v.write_xdr(w),

            Self::PersistedScpState(v) => v.write_xdr(w),

            Self::Thresholds(v) => v.write_xdr(w),

            Self::String32(v) => v.write_xdr(w),

            Self::String64(v) => v.write_xdr(w),

            Self::SequenceNumber(v) => v.write_xdr(w),

            Self::DataValue(v) => v.write_xdr(w),

            Self::AssetCode4(v) => v.write_xdr(w),

            Self::AssetCode12(v) => v.write_xdr(w),

            Self::AssetType(v) => v.write_xdr(w),

            Self::AssetCode(v) => v.write_xdr(w),

            Self::AlphaNum4(v) => v.write_xdr(w),

            Self::AlphaNum12(v) => v.write_xdr(w),

            Self::Asset(v) => v.write_xdr(w),

            Self::Price(v) => v.write_xdr(w),

            Self::Liabilities(v) => v.write_xdr(w),

            Self::ThresholdIndexes(v) => v.write_xdr(w),

            Self::LedgerEntryType(v) => v.write_xdr(w),

            Self::Signer(v) => v.write_xdr(w),

            Self::AccountFlags(v) => v.write_xdr(w),

            Self::SponsorshipDescriptor(v) => v.write_xdr(w),

            Self::AccountEntryExtensionV3(v) => v.write_xdr(w),

            Self::AccountEntryExtensionV2(v) => v.write_xdr(w),

            Self::AccountEntryExtensionV1(v) => v.write_xdr(w),

            Self::AccountEntry(v) => v.write_xdr(w),

            Self::TrustLineFlags(v) => v.write_xdr(w),

            Self::LiquidityPoolType(v) => v.write_xdr(w),

            Self::TrustLineAsset(v) => v.write_xdr(w),

            Self::TrustLineEntryExtensionV2(v) => v.write_xdr(w),

            Self::TrustLineEntry(v) => v.write_xdr(w),

            Self::OfferEntryFlags(v) => v.write_xdr(w),

            Self::OfferEntry(v) => v.write_xdr(w),

            Self::DataEntry(v) => v.write_xdr(w),

            Self::ClaimPredicateType(v) => v.write_xdr(w),

            Self::ClaimPredicate(v) => v.write_xdr(w),

            Self::ClaimantType(v) => v.write_xdr(w),

            Self::Claimant(v) => v.write_xdr(w),

            Self::ClaimableBalanceFlags(v) => v.write_xdr(w),

            Self::ClaimableBalanceEntryExtensionV1(v) => v.write_xdr(w),

            Self::ClaimableBalanceEntry(v) => v.write_xdr(w),

            Self::LiquidityPoolConstantProductParameters(v) => v.write_xdr(w),

            Self::LiquidityPoolEntry(v) => v.write_xdr(w),

            Self::ContractDataDurability(v) => v.write_xdr(w),

            Self::ContractDataEntry(v) => v.write_xdr(w),

            Self::ContractCodeCostInputs(v) => v.write_xdr(w),

            Self::ContractCodeEntry(v) => v.write_xdr(w),

            Self::TtlEntry(v) => v.write_xdr(w),

            Self::LedgerEntryExtensionV1(v) => v.write_xdr(w),

            Self::LedgerEntry(v) => v.write_xdr(w),

            Self::LedgerKey(v) => v.write_xdr(w),

            Self::EnvelopeType(v) => v.write_xdr(w),

            Self::BucketListType(v) => v.write_xdr(w),

            Self::BucketEntryType(v) => v.write_xdr(w),

            Self::HotArchiveBucketEntryType(v) => v.write_xdr(w),

            Self::BucketMetadata(v) => v.write_xdr(w),

            Self::BucketEntry(v) => v.write_xdr(w),

            Self::HotArchiveBucketEntry(v) => v.write_xdr(w),

            Self::UpgradeType(v) => v.write_xdr(w),

            Self::StellarValueType(v) => v.write_xdr(w),

            Self::LedgerCloseValueSignature(v) => v.write_xdr(w),

            Self::StellarValue(v) => v.write_xdr(w),

            Self::LedgerHeaderFlags(v) => v.write_xdr(w),

            Self::LedgerHeaderExtensionV1(v) => v.write_xdr(w),

            Self::LedgerHeader(v) => v.write_xdr(w),

            Self::LedgerUpgradeType(v) => v.write_xdr(w),

            Self::ConfigUpgradeSetKey(v) => v.write_xdr(w),

            Self::LedgerUpgrade(v) => v.write_xdr(w),

            Self::ConfigUpgradeSet(v) => v.write_xdr(w),

            Self::TxSetComponentType(v) => v.write_xdr(w),

            Self::DependentTxCluster(v) => v.write_xdr(w),

            Self::ParallelTxExecutionStage(v) => v.write_xdr(w),

            Self::ParallelTxsComponent(v) => v.write_xdr(w),

            Self::TxSetComponent(v) => v.write_xdr(w),

            Self::TransactionPhase(v) => v.write_xdr(w),

            Self::TransactionSet(v) => v.write_xdr(w),

            Self::TransactionSetV1(v) => v.write_xdr(w),

            Self::GeneralizedTransactionSet(v) => v.write_xdr(w),

            Self::TransactionResultPair(v) => v.write_xdr(w),

            Self::TransactionResultSet(v) => v.write_xdr(w),

            Self::TransactionHistoryEntry(v) => v.write_xdr(w),

            Self::TransactionHistoryResultEntry(v) => v.write_xdr(w),

            Self::LedgerHeaderHistoryEntry(v) => v.write_xdr(w),

            Self::LedgerScpMessages(v) => v.write_xdr(w),

            Self::ScpHistoryEntryV0(v) => v.write_xdr(w),

            Self::ScpHistoryEntry(v) => v.write_xdr(w),

            Self::LedgerEntryChangeType(v) => v.write_xdr(w),

            Self::LedgerEntryChange(v) => v.write_xdr(w),

            Self::LedgerEntryChanges(v) => v.write_xdr(w),

            Self::OperationMeta(v) => v.write_xdr(w),

            Self::TransactionMetaV1(v) => v.write_xdr(w),

            Self::TransactionMetaV2(v) => v.write_xdr(w),

            Self::ContractEventType(v) => v.write_xdr(w),

            Self::ContractEvent(v) => v.write_xdr(w),

            Self::DiagnosticEvent(v) => v.write_xdr(w),

            Self::SorobanTransactionMetaExtV1(v) => v.write_xdr(w),

            Self::SorobanTransactionMetaExt(v) => v.write_xdr(w),

            Self::SorobanTransactionMeta(v) => v.write_xdr(w),

            Self::TransactionMetaV3(v) => v.write_xdr(w),

            Self::OperationMetaV2(v) => v.write_xdr(w),

            Self::SorobanTransactionMetaV2(v) => v.write_xdr(w),

            Self::TransactionEventStage(v) => v.write_xdr(w),

            Self::TransactionEvent(v) => v.write_xdr(w),

            Self::TransactionMetaV4(v) => v.write_xdr(w),

            Self::InvokeHostFunctionSuccessPreImage(v) => v.write_xdr(w),

            Self::TransactionMeta(v) => v.write_xdr(w),

            Self::TransactionResultMeta(v) => v.write_xdr(w),

            Self::TransactionResultMetaV1(v) => v.write_xdr(w),

            Self::UpgradeEntryMeta(v) => v.write_xdr(w),

            Self::LedgerCloseMetaV0(v) => v.write_xdr(w),

            Self::LedgerCloseMetaExtV1(v) => v.write_xdr(w),

            Self::LedgerCloseMetaExt(v) => v.write_xdr(w),

            Self::LedgerCloseMetaV1(v) => v.write_xdr(w),

            Self::LedgerCloseMetaV2(v) => v.write_xdr(w),

            Self::LedgerCloseMeta(v) => v.write_xdr(w),

            Self::ErrorCode(v) => v.write_xdr(w),

            Self::SError(v) => v.write_xdr(w),

            Self::SendMore(v) => v.write_xdr(w),

            Self::SendMoreExtended(v) => v.write_xdr(w),

            Self::AuthCert(v) => v.write_xdr(w),

            Self::Hello(v) => v.write_xdr(w),

            Self::Auth(v) => v.write_xdr(w),

            Self::IpAddrType(v) => v.write_xdr(w),

            Self::PeerAddress(v) => v.write_xdr(w),

            Self::MessageType(v) => v.write_xdr(w),

            Self::DontHave(v) => v.write_xdr(w),

            Self::SurveyMessageCommandType(v) => v.write_xdr(w),

            Self::SurveyMessageResponseType(v) => v.write_xdr(w),

            Self::TimeSlicedSurveyStartCollectingMessage(v) => v.write_xdr(w),

            Self::SignedTimeSlicedSurveyStartCollectingMessage(v) => v.write_xdr(w),

            Self::TimeSlicedSurveyStopCollectingMessage(v) => v.write_xdr(w),

            Self::SignedTimeSlicedSurveyStopCollectingMessage(v) => v.write_xdr(w),

            Self::SurveyRequestMessage(v) => v.write_xdr(w),

            Self::TimeSlicedSurveyRequestMessage(v) => v.write_xdr(w),

            Self::SignedTimeSlicedSurveyRequestMessage(v) => v.write_xdr(w),

            Self::EncryptedBody(v) => v.write_xdr(w),

            Self::SurveyResponseMessage(v) => v.write_xdr(w),

            Self::TimeSlicedSurveyResponseMessage(v) => v.write_xdr(w),

            Self::SignedTimeSlicedSurveyResponseMessage(v) => v.write_xdr(w),

            Self::PeerStats(v) => v.write_xdr(w),

            Self::TimeSlicedNodeData(v) => v.write_xdr(w),

            Self::TimeSlicedPeerData(v) => v.write_xdr(w),

            Self::TimeSlicedPeerDataList(v) => v.write_xdr(w),

            Self::TopologyResponseBodyV2(v) => v.write_xdr(w),

            Self::SurveyResponseBody(v) => v.write_xdr(w),

            Self::TxAdvertVector(v) => v.write_xdr(w),

            Self::FloodAdvert(v) => v.write_xdr(w),

            Self::TxDemandVector(v) => v.write_xdr(w),

            Self::FloodDemand(v) => v.write_xdr(w),

            Self::StellarMessage(v) => v.write_xdr(w),

            Self::AuthenticatedMessage(v) => v.write_xdr(w),

            Self::LiquidityPoolParameters(v) => v.write_xdr(w),

            Self::MuxedAccount(v) => v.write_xdr(w),

            Self::DecoratedSignature(v) => v.write_xdr(w),

            Self::OperationType(v) => v.write_xdr(w),

            Self::CreateAccountOp(v) => v.write_xdr(w),

            Self::PaymentOp(v) => v.write_xdr(w),

            Self::PathPaymentStrictReceiveOp(v) => v.write_xdr(w),

            Self::PathPaymentStrictSendOp(v) => v.write_xdr(w),

            Self::ManageSellOfferOp(v) => v.write_xdr(w),

            Self::ManageBuyOfferOp(v) => v.write_xdr(w),

            Self::CreatePassiveSellOfferOp(v) => v.write_xdr(w),

            Self::SetOptionsOp(v) => v.write_xdr(w),

            Self::ChangeTrustAsset(v) => v.write_xdr(w),

            Self::ChangeTrustOp(v) => v.write_xdr(w),

            Self::AllowTrustOp(v) => v.write_xdr(w),

            Self::ManageDataOp(v) => v.write_xdr(w),

            Self::BumpSequenceOp(v) => v.write_xdr(w),

            Self::CreateClaimableBalanceOp(v) => v.write_xdr(w),

            Self::ClaimClaimableBalanceOp(v) => v.write_xdr(w),

            Self::BeginSponsoringFutureReservesOp(v) => v.write_xdr(w),

            Self::RevokeSponsorshipType(v) => v.write_xdr(w),

            Self::RevokeSponsorshipOp(v) => v.write_xdr(w),

            Self::ClawbackOp(v) => v.write_xdr(w),

            Self::ClawbackClaimableBalanceOp(v) => v.write_xdr(w),

            Self::SetTrustLineFlagsOp(v) => v.write_xdr(w),

            Self::LiquidityPoolDepositOp(v) => v.write_xdr(w),

            Self::LiquidityPoolWithdrawOp(v) => v.write_xdr(w),

            Self::HostFunctionType(v) => v.write_xdr(w),

            Self::ContractIdPreimageType(v) => v.write_xdr(w),

            Self::ContractIdPreimage(v) => v.write_xdr(w),

            Self::CreateContractArgs(v) => v.write_xdr(w),

            Self::CreateContractArgsV2(v) => v.write_xdr(w),

            Self::InvokeContractArgs(v) => v.write_xdr(w),

            Self::HostFunction(v) => v.write_xdr(w),

            Self::SorobanAuthorizedFunctionType(v) => v.write_xdr(w),

            Self::SorobanAuthorizedFunction(v) => v.write_xdr(w),

            Self::SorobanAuthorizedInvocation(v) => v.write_xdr(w),

            Self::SorobanAddressCredentials(v) => v.write_xdr(w),

            Self::SorobanCredentialsType(v) => v.write_xdr(w),

            Self::SorobanCredentials(v) => v.write_xdr(w),

            Self::SorobanAuthorizationEntry(v) => v.write_xdr(w),

            Self::SorobanAuthorizationEntries(v) => v.write_xdr(w),

            Self::InvokeHostFunctionOp(v) => v.write_xdr(w),

            Self::ExtendFootprintTtlOp(v) => v.write_xdr(w),

            Self::RestoreFootprintOp(v) => v.write_xdr(w),

            Self::Operation(v) => v.write_xdr(w),

            Self::HashIdPreimage(v) => v.write_xdr(w),

            Self::MemoType(v) => v.write_xdr(w),

            Self::Memo(v) => v.write_xdr(w),

            Self::TimeBounds(v) => v.write_xdr(w),

            Self::LedgerBounds(v) => v.write_xdr(w),

            Self::PreconditionsV2(v) => v.write_xdr(w),

            Self::PreconditionType(v) => v.write_xdr(w),

            Self::Preconditions(v) => v.write_xdr(w),

            Self::LedgerFootprint(v) => v.write_xdr(w),

            Self::SorobanResources(v) => v.write_xdr(w),

            Self::SorobanResourcesExtV0(v) => v.write_xdr(w),

            Self::SorobanTransactionData(v) => v.write_xdr(w),

            Self::TransactionV0(v) => v.write_xdr(w),

            Self::TransactionV0Envelope(v) => v.write_xdr(w),

            Self::Transaction(v) => v.write_xdr(w),

            Self::TransactionV1Envelope(v) => v.write_xdr(w),

            Self::FeeBumpTransaction(v) => v.write_xdr(w),

            Self::FeeBumpTransactionEnvelope(v) => v.write_xdr(w),

            Self::TransactionEnvelope(v) => v.write_xdr(w),

            Self::TransactionSignaturePayload(v) => v.write_xdr(w),

            Self::ClaimAtomType(v) => v.write_xdr(w),

            Self::ClaimOfferAtomV0(v) => v.write_xdr(w),

            Self::ClaimOfferAtom(v) => v.write_xdr(w),

            Self::ClaimLiquidityAtom(v) => v.write_xdr(w),

            Self::ClaimAtom(v) => v.write_xdr(w),

            Self::CreateAccountResultCode(v) => v.write_xdr(w),

            Self::CreateAccountResult(v) => v.write_xdr(w),

            Self::PaymentResultCode(v) => v.write_xdr(w),

            Self::PaymentResult(v) => v.write_xdr(w),

            Self::PathPaymentStrictReceiveResultCode(v) => v.write_xdr(w),

            Self::SimplePaymentResult(v) => v.write_xdr(w),

            Self::PathPaymentStrictReceiveResult(v) => v.write_xdr(w),

            Self::PathPaymentStrictSendResultCode(v) => v.write_xdr(w),

            Self::PathPaymentStrictSendResult(v) => v.write_xdr(w),

            Self::ManageSellOfferResultCode(v) => v.write_xdr(w),

            Self::ManageOfferEffect(v) => v.write_xdr(w),

            Self::ManageOfferSuccessResult(v) => v.write_xdr(w),

            Self::ManageSellOfferResult(v) => v.write_xdr(w),

            Self::ManageBuyOfferResultCode(v) => v.write_xdr(w),

            Self::ManageBuyOfferResult(v) => v.write_xdr(w),

            Self::SetOptionsResultCode(v) => v.write_xdr(w),

            Self::SetOptionsResult(v) => v.write_xdr(w),

            Self::ChangeTrustResultCode(v) => v.write_xdr(w),

            Self::ChangeTrustResult(v) => v.write_xdr(w),

            Self::AllowTrustResultCode(v) => v.write_xdr(w),

            Self::AllowTrustResult(v) => v.write_xdr(w),

            Self::AccountMergeResultCode(v) => v.write_xdr(w),

            Self::AccountMergeResult(v) => v.write_xdr(w),

            Self::InflationResultCode(v) => v.write_xdr(w),

            Self::InflationPayout(v) => v.write_xdr(w),

            Self::InflationResult(v) => v.write_xdr(w),

            Self::ManageDataResultCode(v) => v.write_xdr(w),

            Self::ManageDataResult(v) => v.write_xdr(w),

            Self::BumpSequenceResultCode(v) => v.write_xdr(w),

            Self::BumpSequenceResult(v) => v.write_xdr(w),

            Self::CreateClaimableBalanceResultCode(v) => v.write_xdr(w),

            Self::CreateClaimableBalanceResult(v) => v.write_xdr(w),

            Self::ClaimClaimableBalanceResultCode(v) => v.write_xdr(w),

            Self::ClaimClaimableBalanceResult(v) => v.write_xdr(w),

            Self::BeginSponsoringFutureReservesResultCode(v) => v.write_xdr(w),

            Self::BeginSponsoringFutureReservesResult(v) => v.write_xdr(w),

            Self::EndSponsoringFutureReservesResultCode(v) => v.write_xdr(w),

            Self::EndSponsoringFutureReservesResult(v) => v.write_xdr(w),

            Self::RevokeSponsorshipResultCode(v) => v.write_xdr(w),

            Self::RevokeSponsorshipResult(v) => v.write_xdr(w),

            Self::ClawbackResultCode(v) => v.write_xdr(w),

            Self::ClawbackResult(v) => v.write_xdr(w),

            Self::ClawbackClaimableBalanceResultCode(v) => v.write_xdr(w),

            Self::ClawbackClaimableBalanceResult(v) => v.write_xdr(w),

            Self::SetTrustLineFlagsResultCode(v) => v.write_xdr(w),

            Self::SetTrustLineFlagsResult(v) => v.write_xdr(w),

            Self::LiquidityPoolDepositResultCode(v) => v.write_xdr(w),

            Self::LiquidityPoolDepositResult(v) => v.write_xdr(w),

            Self::LiquidityPoolWithdrawResultCode(v) => v.write_xdr(w),

            Self::LiquidityPoolWithdrawResult(v) => v.write_xdr(w),

            Self::InvokeHostFunctionResultCode(v) => v.write_xdr(w),

            Self::InvokeHostFunctionResult(v) => v.write_xdr(w),

            Self::ExtendFootprintTtlResultCode(v) => v.write_xdr(w),

            Self::ExtendFootprintTtlResult(v) => v.write_xdr(w),

            Self::RestoreFootprintResultCode(v) => v.write_xdr(w),

            Self::RestoreFootprintResult(v) => v.write_xdr(w),

            Self::OperationResultCode(v) => v.write_xdr(w),

            Self::OperationResult(v) => v.write_xdr(w),

            Self::TransactionResultCode(v) => v.write_xdr(w),

            Self::InnerTransactionResult(v) => v.write_xdr(w),

            Self::InnerTransactionResultPair(v) => v.write_xdr(w),

            Self::TransactionResult(v) => v.write_xdr(w),

            Self::Hash(v) => v.write_xdr(w),

            Self::Uint256(v) => v.write_xdr(w),

            Self::Uint32(v) => v.write_xdr(w),

            Self::Int32(v) => v.write_xdr(w),

            Self::Uint64(v) => v.write_xdr(w),

            Self::Int64(v) => v.write_xdr(w),

            Self::TimePoint(v) => v.write_xdr(w),

            Self::Duration(v) => v.write_xdr(w),

            Self::ExtensionPoint(v) => v.write_xdr(w),

            Self::CryptoKeyType(v) => v.write_xdr(w),

            Self::PublicKeyType(v) => v.write_xdr(w),

            Self::SignerKeyType(v) => v.write_xdr(w),

            Self::PublicKey(v) => v.write_xdr(w),

            Self::SignerKey(v) => v.write_xdr(w),

            Self::Signature(v) => v.write_xdr(w),

            Self::SignatureHint(v) => v.write_xdr(w),

            Self::NodeId(v) => v.write_xdr(w),

            Self::AccountId(v) => v.write_xdr(w),

            Self::ContractId(v) => v.write_xdr(w),

            Self::Curve25519Secret(v) => v.write_xdr(w),

            Self::Curve25519Public(v) => v.write_xdr(w),

            Self::HmacSha256Key(v) => v.write_xdr(w),

            Self::HmacSha256Mac(v) => v.write_xdr(w),

            Self::ShortHashSeed(v) => v.write_xdr(w),

            Self::BinaryFuseFilterType(v) => v.write_xdr(w),

            Self::SerializedBinaryFuseFilter(v) => v.write_xdr(w),

            Self::PoolId(v) => v.write_xdr(w),

            Self::ClaimableBalanceIdType(v) => v.write_xdr(w),

            Self::ClaimableBalanceId(v) => v.write_xdr(w),
        }
    }
}
