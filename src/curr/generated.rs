// Module  is generated from:
//  xdr/curr/Stellar-SCP.x
//  xdr/curr/Stellar-contract-config-setting.x
//  xdr/curr/Stellar-contract-env-meta.x
//  xdr/curr/Stellar-contract-meta.x
//  xdr/curr/Stellar-contract-spec.x
//  xdr/curr/Stellar-contract.x
//  xdr/curr/Stellar-internal.x
//  xdr/curr/Stellar-ledger-entries.x
//  xdr/curr/Stellar-ledger.x
//  xdr/curr/Stellar-overlay.x
//  xdr/curr/Stellar-transaction.x
//  xdr/curr/Stellar-types.x

#![allow(clippy::missing_errors_doc, clippy::unreadable_literal)]

/// `XDR_FILES_SHA256` is a list of pairs of source files and their SHA256 hashes.
pub const XDR_FILES_SHA256: [(&str, &str); 12] = [
    (
        "xdr/curr/Stellar-SCP.x",
        "8f32b04d008f8bc33b8843d075e69837231a673691ee41d8b821ca229a6e802a",
    ),
    (
        "xdr/curr/Stellar-contract-config-setting.x",
        "393369678663cb0f9471a0b69e2a9cfa3ac93c4415fa40cec166e9a231ecbe0d",
    ),
    (
        "xdr/curr/Stellar-contract-env-meta.x",
        "928a30de814ee589bc1d2aadd8dd81c39f71b7e6f430f56974505ccb1f49654b",
    ),
    (
        "xdr/curr/Stellar-contract-meta.x",
        "f01532c11ca044e19d9f9f16fe373e9af64835da473be556b9a807ee3319ae0d",
    ),
    (
        "xdr/curr/Stellar-contract-spec.x",
        "c7ffa21d2e91afb8e666b33524d307955426ff553a486d670c29217ed9888d49",
    ),
    (
        "xdr/curr/Stellar-contract.x",
        "7f665e4103e146a88fcdabce879aaaacd3bf9283feb194cc47ff986264c1e315",
    ),
    (
        "xdr/curr/Stellar-internal.x",
        "227835866c1b2122d1eaf28839ba85ea7289d1cb681dda4ca619c2da3d71fe00",
    ),
    (
        "xdr/curr/Stellar-ledger-entries.x",
        "77dc7062ae6d0812136333e12e35b2294d7c2896a536be9c811eb0ed2abbbccb",
    ),
    (
        "xdr/curr/Stellar-ledger.x",
        "888152fb940b79a01ac00a5218ca91360cb0f01af7acc030d5805ebfec280203",
    ),
    (
        "xdr/curr/Stellar-overlay.x",
        "de3957c58b96ae07968b3d3aebea84f83603e95322d1fa336360e13e3aba737a",
    ),
    (
        "xdr/curr/Stellar-transaction.x",
        "0d2b35a331a540b48643925d0869857236eb2487c02d340ea32e365e784ea2b8",
    ),
    (
        "xdr/curr/Stellar-types.x",
        "6e3b13f0d3e360b09fa5e2b0e55d43f4d974a769df66afb34e8aecbb329d3f15",
    ),
];

use core::{array::TryFromSliceError, fmt, fmt::Debug, marker::Sized, ops::Deref, slice};

#[cfg(feature = "std")]
use core::marker::PhantomData;

// When feature alloc is turned off use static lifetime Box and Vec types.
#[cfg(not(feature = "alloc"))]
mod noalloc {
    pub mod boxed {
        pub type Box<T> = &'static T;
    }
    pub mod vec {
        pub type Vec<T> = &'static [T];
    }
}
#[cfg(not(feature = "alloc"))]
use noalloc::{boxed::Box, vec::Vec};

// When feature std is turned off, but feature alloc is turned on import the
// alloc crate and use its Box and Vec types.
#[cfg(all(not(feature = "std"), feature = "alloc"))]
extern crate alloc;
#[cfg(all(not(feature = "std"), feature = "alloc"))]
use alloc::{
    borrow::ToOwned,
    boxed::Box,
    string::{FromUtf8Error, String},
    vec::Vec,
};
#[cfg(feature = "std")]
use std::string::FromUtf8Error;

#[cfg(feature = "arbitrary")]
use arbitrary::Arbitrary;

// TODO: Add support for read/write xdr fns when std not available.

#[cfg(feature = "std")]
use std::{
    error, io,
    io::{BufRead, BufReader, Cursor, Read, Write},
};

/// Error contains all errors returned by functions in this crate. It can be
/// compared via `PartialEq`, however any contained IO errors will only be
/// compared on their `ErrorKind`.
#[derive(Debug)]
pub enum Error {
    Invalid,
    Unsupported,
    LengthExceedsMax,
    LengthMismatch,
    NonZeroPadding,
    Utf8Error(core::str::Utf8Error),
    #[cfg(feature = "alloc")]
    InvalidHex,
    #[cfg(feature = "std")]
    Io(io::Error),
    DepthLimitExceeded,
    #[cfg(feature = "serde_json")]
    Json(serde_json::Error),
    LengthLimitExceeded,
}

impl PartialEq for Error {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::Utf8Error(l), Self::Utf8Error(r)) => l == r,
            // IO errors cannot be compared, but in the absence of any more
            // meaningful way to compare the errors we compare the kind of error
            // and ignore the embedded source error or OS error. The main use
            // case for comparing errors outputted by the XDR library is for
            // error case testing, and a lack of the ability to compare has a
            // detrimental affect on failure testing, so this is a tradeoff.
            #[cfg(feature = "std")]
            (Self::Io(l), Self::Io(r)) => l.kind() == r.kind(),
            _ => core::mem::discriminant(self) == core::mem::discriminant(other),
        }
    }
}

#[cfg(feature = "std")]
impl error::Error for Error {
    #[must_use]
    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
        match self {
            Self::Io(e) => Some(e),
            #[cfg(feature = "serde_json")]
            Self::Json(e) => Some(e),
            _ => None,
        }
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Error::Invalid => write!(f, "xdr value invalid"),
            Error::Unsupported => write!(f, "xdr value unsupported"),
            Error::LengthExceedsMax => write!(f, "xdr value max length exceeded"),
            Error::LengthMismatch => write!(f, "xdr value length does not match"),
            Error::NonZeroPadding => write!(f, "xdr padding contains non-zero bytes"),
            Error::Utf8Error(e) => write!(f, "{e}"),
            #[cfg(feature = "alloc")]
            Error::InvalidHex => write!(f, "hex invalid"),
            #[cfg(feature = "std")]
            Error::Io(e) => write!(f, "{e}"),
            Error::DepthLimitExceeded => write!(f, "depth limit exceeded"),
            #[cfg(feature = "serde_json")]
            Error::Json(e) => write!(f, "{e}"),
            Error::LengthLimitExceeded => write!(f, "length limit exceeded"),
        }
    }
}

impl From<TryFromSliceError> for Error {
    fn from(_: TryFromSliceError) -> Error {
        Error::LengthMismatch
    }
}

impl From<core::str::Utf8Error> for Error {
    #[must_use]
    fn from(e: core::str::Utf8Error) -> Self {
        Error::Utf8Error(e)
    }
}

#[cfg(feature = "alloc")]
impl From<FromUtf8Error> for Error {
    #[must_use]
    fn from(e: FromUtf8Error) -> Self {
        Error::Utf8Error(e.utf8_error())
    }
}

#[cfg(feature = "std")]
impl From<io::Error> for Error {
    #[must_use]
    fn from(e: io::Error) -> Self {
        Error::Io(e)
    }
}

#[cfg(feature = "serde_json")]
impl From<serde_json::Error> for Error {
    #[must_use]
    fn from(e: serde_json::Error) -> Self {
        Error::Json(e)
    }
}

impl From<Error> for () {
    fn from(_: Error) {}
}

#[allow(dead_code)]
type Result<T> = core::result::Result<T, Error>;

/// Name defines types that assign a static name to their value, such as the
/// name given to an identifier in an XDR enum, or the name given to the case in
/// a union.
pub trait Name {
    fn name(&self) -> &'static str;
}

/// Discriminant defines types that may contain a one-of value determined
/// according to the discriminant, and exposes the value of the discriminant for
/// that type, such as in an XDR union.
pub trait Discriminant<D> {
    fn discriminant(&self) -> D;
}

/// Iter defines types that have variants that can be iterated.
pub trait Variants<V> {
    fn variants() -> slice::Iter<'static, V>
    where
        V: Sized;
}

// Enum defines a type that is represented as an XDR enumeration when encoded.
pub trait Enum: Name + Variants<Self> + Sized {}

// Union defines a type that is represented as an XDR union when encoded.
pub trait Union<D>: Name + Discriminant<D> + Variants<D>
where
    D: Sized,
{
}

/// `Limits` contains the limits that a limited reader or writer will be
/// constrained to.
#[cfg(feature = "std")]
#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub struct Limits {
    /// Defines the maximum depth for recursive calls in `Read/WriteXdr` to
    /// prevent stack overflow.
    ///
    /// The depth limit is akin to limiting stack depth. Its purpose is to
    /// prevent the program from hitting the maximum stack size allowed by Rust,
    /// which would result in an unrecoverable `SIGABRT`.  For more information
    /// about Rust's stack size limit, refer to the [Rust
    /// documentation](https://doc.rust-lang.org/std/thread/#stack-size).
    pub depth: u32,

    /// Defines the maximum number of bytes that will be read or written.
    pub len: usize,
}

#[cfg(feature = "std")]
impl Limits {
    #[must_use]
    pub fn none() -> Self {
        Self {
            depth: u32::MAX,
            len: usize::MAX,
        }
    }

    #[must_use]
    pub fn depth(depth: u32) -> Self {
        Limits {
            depth,
            ..Limits::none()
        }
    }

    #[must_use]
    pub fn len(len: usize) -> Self {
        Limits {
            len,
            ..Limits::none()
        }
    }
}

/// `Limited` wraps an object and provides functions for enforcing limits.
///
/// Intended for use with readers and writers and limiting their reads and
/// writes.
#[cfg(feature = "std")]
pub struct Limited<L> {
    pub inner: L,
    pub(crate) limits: Limits,
}

#[cfg(feature = "std")]
impl<L> Limited<L> {
    /// Constructs a new `Limited`.
    ///
    /// - `inner`: The value being limited.
    /// - `limits`: The limits to enforce.
    pub fn new(inner: L, limits: Limits) -> Self {
        Limited { inner, limits }
    }

    /// Consume the given length from the internal remaining length limit.
    ///
    /// ### Errors
    ///
    /// If the length would consume more length than the remaining length limit
    /// allows.
    pub(crate) fn consume_len(&mut self, len: usize) -> Result<()> {
        if let Some(len) = self.limits.len.checked_sub(len) {
            self.limits.len = len;
            Ok(())
        } else {
            Err(Error::LengthLimitExceeded)
        }
    }

    /// Consumes a single depth for the duration of the given function.
    ///
    /// ### Errors
    ///
    /// If the depth limit is already exhausted.
    pub(crate) fn with_limited_depth<T, F>(&mut self, f: F) -> Result<T>
    where
        F: FnOnce(&mut Self) -> Result<T>,
    {
        if let Some(depth) = self.limits.depth.checked_sub(1) {
            self.limits.depth = depth;
            let res = f(self);
            self.limits.depth = self.limits.depth.saturating_add(1);
            res
        } else {
            Err(Error::DepthLimitExceeded)
        }
    }
}

#[cfg(feature = "std")]
impl<R: Read> Read for Limited<R> {
    /// Forwards the read operation to the wrapped object.
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        self.inner.read(buf)
    }
}

#[cfg(feature = "std")]
impl<R: BufRead> BufRead for Limited<R> {
    /// Forwards the read operation to the wrapped object.
    fn fill_buf(&mut self) -> std::io::Result<&[u8]> {
        self.inner.fill_buf()
    }

    /// Forwards the read operation to the wrapped object.
    fn consume(&mut self, amt: usize) {
        self.inner.consume(amt);
    }
}

#[cfg(feature = "std")]
impl<W: Write> Write for Limited<W> {
    /// Forwards the write operation to the wrapped object.
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        self.inner.write(buf)
    }

    /// Forwards the flush operation to the wrapped object.
    fn flush(&mut self) -> std::io::Result<()> {
        self.inner.flush()
    }
}

#[cfg(feature = "std")]
pub struct ReadXdrIter<R: Read, S: ReadXdr> {
    reader: Limited<BufReader<R>>,
    _s: PhantomData<S>,
}

#[cfg(feature = "std")]
impl<R: Read, S: ReadXdr> ReadXdrIter<R, S> {
    fn new(r: R, limits: Limits) -> Self {
        Self {
            reader: Limited {
                inner: BufReader::new(r),
                limits,
            },
            _s: PhantomData,
        }
    }
}

#[cfg(feature = "std")]
impl<R: Read, S: ReadXdr> Iterator for ReadXdrIter<R, S> {
    type Item = Result<S>;

    // Next reads the internal reader and XDR decodes it into the Self type. If
    // the EOF is reached without reading any new bytes `None` is returned. If
    // EOF is reached after reading some bytes a truncated entry is assumed an
    // an `Error::Io` containing an `UnexpectedEof`. If any other IO error
    // occurs it is returned. Iteration of this iterator stops naturally when
    // `None` is returned, but not when a `Some(Err(...))` is returned. The
    // caller is responsible for checking each Result.
    fn next(&mut self) -> Option<Self::Item> {
        // Try to fill the buffer to see if the EOF has been reached or not.
        // This happens to effectively peek to see if the stream has finished
        // and there are no more items.  It is necessary to do this because the
        // xdr types in this crate heavily use the `std::io::Read::read_exact`
        // method that doesn't distinguish between an EOF at the beginning of a
        // read and an EOF after a partial fill of a read_exact.
        match self.reader.fill_buf() {
            // If the reader has no more data and is unable to fill any new data
            // into its internal buf, then the EOF has been reached.
            Ok([]) => return None,
            // If an error occurs filling the buffer, treat that as an error and stop.
            Err(e) => return Some(Err(Error::Io(e))),
            // If there is data in the buf available for reading, continue.
            Ok([..]) => (),
        };
        // Read the buf into the type.
        let r = self.reader.with_limited_depth(|dlr| S::read_xdr(dlr));
        match r {
            Ok(s) => Some(Ok(s)),
            Err(e) => Some(Err(e)),
        }
    }
}

pub trait ReadXdr
where
    Self: Sized,
{
    /// Read the XDR and construct the type.
    ///
    /// Read bytes from the given read implementation, decoding the bytes as
    /// XDR, and construct the type implementing this interface from those
    /// bytes.
    ///
    /// Just enough bytes are read from the read implementation to construct the
    /// type. Any residual bytes remain in the read implementation.
    ///
    /// All implementations should continue if the read implementation returns
    /// [`ErrorKind::Interrupted`](std::io::ErrorKind::Interrupted).
    ///
    /// Use [`ReadXdR: Read_xdr_to_end`] when the intent is for all bytes in the
    /// read implementation to be consumed by the read.
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self>;

    /// Construct the type from the XDR bytes base64 encoded.
    ///
    /// An error is returned if the bytes are not completely consumed by the
    /// deserialization.
    #[cfg(feature = "base64")]
    fn read_xdr_base64<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(&mut r.inner, base64::STANDARD),
            r.limits.clone(),
        );
        let t = Self::read_xdr(&mut dec)?;
        Ok(t)
    }

    /// Read the XDR and construct the type, and consider it an error if the
    /// read does not completely consume the read implementation.
    ///
    /// Read bytes from the given read implementation, decoding the bytes as
    /// XDR, and construct the type implementing this interface from those
    /// bytes.
    ///
    /// Just enough bytes are read from the read implementation to construct the
    /// type, and then confirm that no further bytes remain. To confirm no
    /// further bytes remain additional bytes are attempted to be read from the
    /// read implementation. If it is possible to read any residual bytes from
    /// the read implementation an error is returned. The read implementation
    /// may not be exhaustively read if there are residual bytes, and it is
    /// considered undefined how many residual bytes or how much of the residual
    /// buffer are consumed in this case.
    ///
    /// All implementations should continue if the read implementation returns
    /// [`ErrorKind::Interrupted`](std::io::ErrorKind::Interrupted).
    #[cfg(feature = "std")]
    fn read_xdr_to_end<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        let s = Self::read_xdr(r)?;
        // Check that any further reads, such as this read of one byte, read no
        // data, indicating EOF. If a byte is read the data is invalid.
        if r.read(&mut [0u8; 1])? == 0 {
            Ok(s)
        } else {
            Err(Error::Invalid)
        }
    }

    /// Construct the type from the XDR bytes base64 encoded.
    ///
    /// An error is returned if the bytes are not completely consumed by the
    /// deserialization.
    #[cfg(feature = "base64")]
    fn read_xdr_base64_to_end<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(&mut r.inner, base64::STANDARD),
            r.limits.clone(),
        );
        let t = Self::read_xdr_to_end(&mut dec)?;
        Ok(t)
    }

    /// Read the XDR and construct the type.
    ///
    /// Read bytes from the given read implementation, decoding the bytes as
    /// XDR, and construct the type implementing this interface from those
    /// bytes.
    ///
    /// Just enough bytes are read from the read implementation to construct the
    /// type. Any residual bytes remain in the read implementation.
    ///
    /// All implementations should continue if the read implementation returns
    /// [`ErrorKind::Interrupted`](std::io::ErrorKind::Interrupted).
    ///
    /// Use [`ReadXdR: Read_xdr_into_to_end`] when the intent is for all bytes
    /// in the read implementation to be consumed by the read.
    #[cfg(feature = "std")]
    fn read_xdr_into<R: Read>(&mut self, r: &mut Limited<R>) -> Result<()> {
        *self = Self::read_xdr(r)?;
        Ok(())
    }

    /// Read the XDR into the existing value, and consider it an error if the
    /// read does not completely consume the read implementation.
    ///
    /// Read bytes from the given read implementation, decoding the bytes as
    /// XDR, and construct the type implementing this interface from those
    /// bytes.
    ///
    /// Just enough bytes are read from the read implementation to construct the
    /// type, and then confirm that no further bytes remain. To confirm no
    /// further bytes remain additional bytes are attempted to be read from the
    /// read implementation. If it is possible to read any residual bytes from
    /// the read implementation an error is returned. The read implementation
    /// may not be exhaustively read if there are residual bytes, and it is
    /// considered undefined how many residual bytes or how much of the residual
    /// buffer are consumed in this case.
    ///
    /// All implementations should continue if the read implementation returns
    /// [`ErrorKind::Interrupted`](std::io::ErrorKind::Interrupted).
    #[cfg(feature = "std")]
    fn read_xdr_into_to_end<R: Read>(&mut self, r: &mut Limited<R>) -> Result<()> {
        Self::read_xdr_into(self, r)?;
        // Check that any further reads, such as this read of one byte, read no
        // data, indicating EOF. If a byte is read the data is invalid.
        if r.read(&mut [0u8; 1])? == 0 {
            Ok(())
        } else {
            Err(Error::Invalid)
        }
    }

    /// Create an iterator that reads the read implementation as a stream of
    /// values that are read into the implementing type.
    ///
    /// Read bytes from the given read implementation, decoding the bytes as
    /// XDR, and construct the type implementing this interface from those
    /// bytes.
    ///
    /// Just enough bytes are read from the read implementation to construct the
    /// type, and then confirm that no further bytes remain. To confirm no
    /// further bytes remain additional bytes are attempted to be read from the
    /// read implementation. If it is possible to read any residual bytes from
    /// the read implementation an error is returned. The read implementation
    /// may not be exhaustively read if there are residual bytes, and it is
    /// considered undefined how many residual bytes or how much of the residual
    /// buffer are consumed in this case.
    ///
    /// All implementations should continue if the read implementation returns
    /// [`ErrorKind::Interrupted`](std::io::ErrorKind::Interrupted).
    #[cfg(feature = "std")]
    fn read_xdr_iter<R: Read>(r: &mut Limited<R>) -> ReadXdrIter<&mut R, Self> {
        ReadXdrIter::new(&mut r.inner, r.limits.clone())
    }

    /// Create an iterator that reads the read implementation as a stream of
    /// values that are read into the implementing type.
    #[cfg(feature = "base64")]
    fn read_xdr_base64_iter<R: Read>(
        r: &mut Limited<R>,
    ) -> ReadXdrIter<base64::read::DecoderReader<R>, Self> {
        let dec = base64::read::DecoderReader::new(&mut r.inner, base64::STANDARD);
        ReadXdrIter::new(dec, r.limits.clone())
    }

    /// Construct the type from the XDR bytes.
    ///
    /// An error is returned if the bytes are not completely consumed by the
    /// deserialization.
    #[cfg(feature = "std")]
    fn from_xdr(bytes: impl AsRef<[u8]>, limits: Limits) -> Result<Self> {
        let mut cursor = Limited::new(Cursor::new(bytes.as_ref()), limits);
        let t = Self::read_xdr_to_end(&mut cursor)?;
        Ok(t)
    }

    /// Construct the type from the XDR bytes base64 encoded.
    ///
    /// An error is returned if the bytes are not completely consumed by the
    /// deserialization.
    #[cfg(feature = "base64")]
    fn from_xdr_base64(b64: impl AsRef<[u8]>, limits: Limits) -> Result<Self> {
        let mut b64_reader = Cursor::new(b64);
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(&mut b64_reader, base64::STANDARD),
            limits,
        );
        let t = Self::read_xdr_to_end(&mut dec)?;
        Ok(t)
    }
}

pub trait WriteXdr {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()>;

    #[cfg(feature = "std")]
    fn to_xdr(&self, limits: Limits) -> Result<Vec<u8>> {
        let mut cursor = Limited::new(Cursor::new(vec![]), limits);
        self.write_xdr(&mut cursor)?;
        let bytes = cursor.inner.into_inner();
        Ok(bytes)
    }

    #[cfg(feature = "base64")]
    fn to_xdr_base64(&self, limits: Limits) -> Result<String> {
        let mut enc = Limited::new(
            base64::write::EncoderStringWriter::new(base64::STANDARD),
            limits,
        );
        self.write_xdr(&mut enc)?;
        let b64 = enc.inner.into_inner();
        Ok(b64)
    }
}

/// `Pad_len` returns the number of bytes to pad an XDR value of the given
/// length to make the final serialized size a multiple of 4.
#[cfg(feature = "std")]
fn pad_len(len: usize) -> usize {
    (4 - (len % 4)) % 4
}

impl ReadXdr for i32 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        let mut b = [0u8; 4];
        r.with_limited_depth(|r| {
            r.consume_len(b.len())?;
            r.read_exact(&mut b)?;
            Ok(i32::from_be_bytes(b))
        })
    }
}

impl WriteXdr for i32 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        let b: [u8; 4] = self.to_be_bytes();
        w.with_limited_depth(|w| {
            w.consume_len(b.len())?;
            Ok(w.write_all(&b)?)
        })
    }
}

impl ReadXdr for u32 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        let mut b = [0u8; 4];
        r.with_limited_depth(|r| {
            r.consume_len(b.len())?;
            r.read_exact(&mut b)?;
            Ok(u32::from_be_bytes(b))
        })
    }
}

impl WriteXdr for u32 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        let b: [u8; 4] = self.to_be_bytes();
        w.with_limited_depth(|w| {
            w.consume_len(b.len())?;
            Ok(w.write_all(&b)?)
        })
    }
}

impl ReadXdr for i64 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        let mut b = [0u8; 8];
        r.with_limited_depth(|r| {
            r.consume_len(b.len())?;
            r.read_exact(&mut b)?;
            Ok(i64::from_be_bytes(b))
        })
    }
}

impl WriteXdr for i64 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        let b: [u8; 8] = self.to_be_bytes();
        w.with_limited_depth(|w| {
            w.consume_len(b.len())?;
            Ok(w.write_all(&b)?)
        })
    }
}

impl ReadXdr for u64 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        let mut b = [0u8; 8];
        r.with_limited_depth(|r| {
            r.consume_len(b.len())?;
            r.read_exact(&mut b)?;
            Ok(u64::from_be_bytes(b))
        })
    }
}

impl WriteXdr for u64 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        let b: [u8; 8] = self.to_be_bytes();
        w.with_limited_depth(|w| {
            w.consume_len(b.len())?;
            Ok(w.write_all(&b)?)
        })
    }
}

impl ReadXdr for f32 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(_r: &mut Limited<R>) -> Result<Self> {
        todo!()
    }
}

impl WriteXdr for f32 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, _w: &mut Limited<W>) -> Result<()> {
        todo!()
    }
}

impl ReadXdr for f64 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(_r: &mut Limited<R>) -> Result<Self> {
        todo!()
    }
}

impl WriteXdr for f64 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, _w: &mut Limited<W>) -> Result<()> {
        todo!()
    }
}

impl ReadXdr for bool {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = u32::read_xdr(r)?;
            let b = i == 1;
            Ok(b)
        })
    }
}

impl WriteXdr for bool {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i = u32::from(*self); // true = 1, false = 0
            i.write_xdr(w)
        })
    }
}

impl<T: ReadXdr> ReadXdr for Option<T> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = u32::read_xdr(r)?;
            match i {
                0 => Ok(None),
                1 => {
                    let t = T::read_xdr(r)?;
                    Ok(Some(t))
                }
                _ => Err(Error::Invalid),
            }
        })
    }
}

impl<T: WriteXdr> WriteXdr for Option<T> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            if let Some(t) = self {
                1u32.write_xdr(w)?;
                t.write_xdr(w)?;
            } else {
                0u32.write_xdr(w)?;
            }
            Ok(())
        })
    }
}

impl<T: ReadXdr> ReadXdr for Box<T> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| Ok(Box::new(T::read_xdr(r)?)))
    }
}

impl<T: WriteXdr> WriteXdr for Box<T> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| T::write_xdr(self, w))
    }
}

impl ReadXdr for () {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(_r: &mut Limited<R>) -> Result<Self> {
        Ok(())
    }
}

impl WriteXdr for () {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, _w: &mut Limited<W>) -> Result<()> {
        Ok(())
    }
}

impl<const N: usize> ReadXdr for [u8; N] {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            r.consume_len(N)?;
            let padding = pad_len(N);
            r.consume_len(padding)?;
            let mut arr = [0u8; N];
            r.read_exact(&mut arr)?;
            let pad = &mut [0u8; 3][..padding];
            r.read_exact(pad)?;
            if pad.iter().any(|b| *b != 0) {
                return Err(Error::NonZeroPadding);
            }
            Ok(arr)
        })
    }
}

impl<const N: usize> WriteXdr for [u8; N] {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            w.consume_len(N)?;
            let padding = pad_len(N);
            w.consume_len(padding)?;
            w.write_all(self)?;
            w.write_all(&[0u8; 3][..padding])?;
            Ok(())
        })
    }
}

impl<T: ReadXdr, const N: usize> ReadXdr for [T; N] {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let mut vec = Vec::with_capacity(N);
            for _ in 0..N {
                let t = T::read_xdr(r)?;
                vec.push(t);
            }
            let arr: [T; N] = vec.try_into().unwrap_or_else(|_: Vec<T>| unreachable!());
            Ok(arr)
        })
    }
}

impl<T: WriteXdr, const N: usize> WriteXdr for [T; N] {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            for t in self {
                t.write_xdr(w)?;
            }
            Ok(())
        })
    }
}

// VecM ------------------------------------------------------------------------

#[cfg(feature = "alloc")]
#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct VecM<T, const MAX: u32 = { u32::MAX }>(Vec<T>);

#[cfg(not(feature = "alloc"))]
#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct VecM<T, const MAX: u32 = { u32::MAX }>(Vec<T>)
where
    T: 'static;

impl<T, const MAX: u32> Deref for VecM<T, MAX> {
    type Target = Vec<T>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<T, const MAX: u32> Default for VecM<T, MAX> {
    fn default() -> Self {
        Self(Vec::default())
    }
}

impl<T, const MAX: u32> VecM<T, MAX> {
    pub const MAX_LEN: usize = { MAX as usize };

    #[must_use]
    #[allow(clippy::unused_self)]
    pub fn max_len(&self) -> usize {
        Self::MAX_LEN
    }

    #[must_use]
    pub fn as_vec(&self) -> &Vec<T> {
        self.as_ref()
    }
}

impl<T: Clone, const MAX: u32> VecM<T, MAX> {
    #[must_use]
    #[cfg(feature = "alloc")]
    pub fn to_vec(&self) -> Vec<T> {
        self.into()
    }

    #[must_use]
    pub fn into_vec(self) -> Vec<T> {
        self.into()
    }
}

impl<const MAX: u32> VecM<u8, MAX> {
    #[cfg(feature = "alloc")]
    pub fn to_string(&self) -> Result<String> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    pub fn into_string(self) -> Result<String> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn to_string_lossy(&self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn into_string_lossy(self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }
}

impl<T: Clone> VecM<T, 1> {
    #[must_use]
    pub fn to_option(&self) -> Option<T> {
        if self.len() > 0 {
            Some(self.0[0].clone())
        } else {
            None
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<T: Clone> From<VecM<T, 1>> for Option<T> {
    #[must_use]
    fn from(v: VecM<T, 1>) -> Self {
        v.to_option()
    }
}

#[cfg(feature = "alloc")]
impl<T> VecM<T, 1> {
    #[must_use]
    pub fn into_option(mut self) -> Option<T> {
        self.0.drain(..).next()
    }
}

#[cfg(feature = "alloc")]
impl<T> From<VecM<T, 1>> for Option<T> {
    #[must_use]
    fn from(v: VecM<T, 1>) -> Self {
        v.into_option()
    }
}

impl<T, const MAX: u32> TryFrom<Vec<T>> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: Vec<T>) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<T, const MAX: u32> From<VecM<T, MAX>> for Vec<T> {
    #[must_use]
    fn from(v: VecM<T, MAX>) -> Self {
        v.0
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const MAX: u32> From<&VecM<T, MAX>> for Vec<T> {
    #[must_use]
    fn from(v: &VecM<T, MAX>) -> Self {
        v.0.clone()
    }
}

impl<T, const MAX: u32> AsRef<Vec<T>> for VecM<T, MAX> {
    #[must_use]
    fn as_ref(&self) -> &Vec<T> {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const MAX: u32> TryFrom<&Vec<T>> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: &Vec<T>) -> Result<Self> {
        v.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const MAX: u32> TryFrom<&[T]> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: &[T]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<T, const MAX: u32> AsRef<[T]> for VecM<T, MAX> {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[T] {
        self.0.as_ref()
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[T] {
        self.0
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const N: usize, const MAX: u32> TryFrom<[T; N]> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: [T; N]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const N: usize, const MAX: u32> TryFrom<VecM<T, MAX>> for [T; N] {
    type Error = VecM<T, MAX>;

    fn try_from(v: VecM<T, MAX>) -> core::result::Result<Self, Self::Error> {
        let s: [T; N] = v.0.try_into().map_err(|v: Vec<T>| VecM::<T, MAX>(v))?;
        Ok(s)
    }
}

#[cfg(feature = "alloc")]
impl<T: Clone, const N: usize, const MAX: u32> TryFrom<&[T; N]> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: &[T; N]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<T: Clone, const N: usize, const MAX: u32> TryFrom<&'static [T; N]> for VecM<T, MAX> {
    type Error = Error;

    fn try_from(v: &'static [T; N]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&String> for VecM<u8, MAX> {
    type Error = Error;

    fn try_from(v: &String) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.as_bytes().to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<String> for VecM<u8, MAX> {
    type Error = Error;

    fn try_from(v: String) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<VecM<u8, MAX>> for String {
    type Error = Error;

    fn try_from(v: VecM<u8, MAX>) -> Result<Self> {
        Ok(String::from_utf8(v.0)?)
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&VecM<u8, MAX>> for String {
    type Error = Error;

    fn try_from(v: &VecM<u8, MAX>) -> Result<Self> {
        Ok(core::str::from_utf8(v.as_ref())?.to_owned())
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&str> for VecM<u8, MAX> {
    type Error = Error;

    fn try_from(v: &str) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<const MAX: u32> TryFrom<&'static str> for VecM<u8, MAX> {
    type Error = Error;

    fn try_from(v: &'static str) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(VecM(v.as_bytes()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<'a, const MAX: u32> TryFrom<&'a VecM<u8, MAX>> for &'a str {
    type Error = Error;

    fn try_from(v: &'a VecM<u8, MAX>) -> Result<Self> {
        Ok(core::str::from_utf8(v.as_ref())?)
    }
}

impl<const MAX: u32> ReadXdr for VecM<u8, MAX> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let len: u32 = u32::read_xdr(r)?;
            if len > MAX {
                return Err(Error::LengthExceedsMax);
            }

            r.consume_len(len as usize)?;
            let padding = pad_len(len as usize);
            r.consume_len(padding)?;

            let mut vec = vec![0u8; len as usize];
            r.read_exact(&mut vec)?;

            let pad = &mut [0u8; 3][..padding];
            r.read_exact(pad)?;
            if pad.iter().any(|b| *b != 0) {
                return Err(Error::NonZeroPadding);
            }

            Ok(VecM(vec))
        })
    }
}

impl<const MAX: u32> WriteXdr for VecM<u8, MAX> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let len: u32 = self.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
            len.write_xdr(w)?;

            w.consume_len(self.len())?;
            let padding = pad_len(self.len());
            w.consume_len(padding)?;

            w.write_all(&self.0)?;

            w.write_all(&[0u8; 3][..padding])?;

            Ok(())
        })
    }
}

impl<T: ReadXdr, const MAX: u32> ReadXdr for VecM<T, MAX> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let len = u32::read_xdr(r)?;
            if len > MAX {
                return Err(Error::LengthExceedsMax);
            }

            let mut vec = Vec::new();
            for _ in 0..len {
                let t = T::read_xdr(r)?;
                vec.push(t);
            }

            Ok(VecM(vec))
        })
    }
}

impl<T: WriteXdr, const MAX: u32> WriteXdr for VecM<T, MAX> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let len: u32 = self.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
            len.write_xdr(w)?;

            for t in &self.0 {
                t.write_xdr(w)?;
            }

            Ok(())
        })
    }
}

// BytesM ------------------------------------------------------------------------

#[cfg(feature = "alloc")]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    feature = "serde",
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct BytesM<const MAX: u32 = { u32::MAX }>(Vec<u8>);

#[cfg(not(feature = "alloc"))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct BytesM<const MAX: u32 = { u32::MAX }>(Vec<u8>);

impl<const MAX: u32> core::fmt::Display for BytesM<MAX> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        #[cfg(feature = "alloc")]
        let v = &self.0;
        #[cfg(not(feature = "alloc"))]
        let v = self.0;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        Ok(())
    }
}

impl<const MAX: u32> core::fmt::Debug for BytesM<MAX> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        #[cfg(feature = "alloc")]
        let v = &self.0;
        #[cfg(not(feature = "alloc"))]
        let v = self.0;
        write!(f, "BytesM(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> core::str::FromStr for BytesM<MAX> {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        hex::decode(s).map_err(|_| Error::InvalidHex)?.try_into()
    }
}

impl<const MAX: u32> Deref for BytesM<MAX> {
    type Target = Vec<u8>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<const MAX: u32> Default for BytesM<MAX> {
    fn default() -> Self {
        Self(Vec::default())
    }
}

impl<const MAX: u32> BytesM<MAX> {
    pub const MAX_LEN: usize = { MAX as usize };

    #[must_use]
    #[allow(clippy::unused_self)]
    pub fn max_len(&self) -> usize {
        Self::MAX_LEN
    }

    #[must_use]
    pub fn as_vec(&self) -> &Vec<u8> {
        self.as_ref()
    }
}

impl<const MAX: u32> BytesM<MAX> {
    #[must_use]
    #[cfg(feature = "alloc")]
    pub fn to_vec(&self) -> Vec<u8> {
        self.into()
    }

    #[must_use]
    pub fn into_vec(self) -> Vec<u8> {
        self.into()
    }
}

impl<const MAX: u32> BytesM<MAX> {
    #[cfg(feature = "alloc")]
    pub fn to_string(&self) -> Result<String> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    pub fn into_string(self) -> Result<String> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn to_string_lossy(&self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn into_string_lossy(self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }
}

impl<const MAX: u32> TryFrom<Vec<u8>> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: Vec<u8>) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<const MAX: u32> From<BytesM<MAX>> for Vec<u8> {
    #[must_use]
    fn from(v: BytesM<MAX>) -> Self {
        v.0
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> From<&BytesM<MAX>> for Vec<u8> {
    #[must_use]
    fn from(v: &BytesM<MAX>) -> Self {
        v.0.clone()
    }
}

impl<const MAX: u32> AsRef<Vec<u8>> for BytesM<MAX> {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&Vec<u8>> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &Vec<u8>) -> Result<Self> {
        v.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&[u8]> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &[u8]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<const MAX: u32> AsRef<[u8]> for BytesM<MAX> {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0.as_ref()
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<[u8; N]> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: [u8; N]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<BytesM<MAX>> for [u8; N] {
    type Error = BytesM<MAX>;

    fn try_from(v: BytesM<MAX>) -> core::result::Result<Self, Self::Error> {
        let s: [u8; N] = v.0.try_into().map_err(BytesM::<MAX>)?;
        Ok(s)
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<&[u8; N]> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &[u8; N]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<const N: usize, const MAX: u32> TryFrom<&'static [u8; N]> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &'static [u8; N]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&String> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &String) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.as_bytes().to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<String> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: String) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<BytesM<MAX>> for String {
    type Error = Error;

    fn try_from(v: BytesM<MAX>) -> Result<Self> {
        Ok(String::from_utf8(v.0)?)
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&BytesM<MAX>> for String {
    type Error = Error;

    fn try_from(v: &BytesM<MAX>) -> Result<Self> {
        Ok(core::str::from_utf8(v.as_ref())?.to_owned())
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&str> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &str) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<const MAX: u32> TryFrom<&'static str> for BytesM<MAX> {
    type Error = Error;

    fn try_from(v: &'static str) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(BytesM(v.as_bytes()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<'a, const MAX: u32> TryFrom<&'a BytesM<MAX>> for &'a str {
    type Error = Error;

    fn try_from(v: &'a BytesM<MAX>) -> Result<Self> {
        Ok(core::str::from_utf8(v.as_ref())?)
    }
}

impl<const MAX: u32> ReadXdr for BytesM<MAX> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let len: u32 = u32::read_xdr(r)?;
            if len > MAX {
                return Err(Error::LengthExceedsMax);
            }

            r.consume_len(len as usize)?;
            let padding = pad_len(len as usize);
            r.consume_len(padding)?;

            let mut vec = vec![0u8; len as usize];
            r.read_exact(&mut vec)?;

            let pad = &mut [0u8; 3][..padding];
            r.read_exact(pad)?;
            if pad.iter().any(|b| *b != 0) {
                return Err(Error::NonZeroPadding);
            }

            Ok(BytesM(vec))
        })
    }
}

impl<const MAX: u32> WriteXdr for BytesM<MAX> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let len: u32 = self.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
            len.write_xdr(w)?;

            w.consume_len(self.len())?;
            let padding = pad_len(self.len());
            w.consume_len(padding)?;

            w.write_all(&self.0)?;

            w.write_all(&[0u8; 3][..pad_len(len as usize)])?;

            Ok(())
        })
    }
}

// StringM ------------------------------------------------------------------------

/// A string type that contains arbitrary bytes.
///
/// Convertible, fallibly, to/from a Rust UTF-8 String using
/// [`TryFrom`]/[`TryInto`]/[`StringM::to_utf8_string`].
///
/// Convertible, lossyly, to a Rust UTF-8 String using
/// [`StringM::to_utf8_string_lossy`].
///
/// Convertible to/from escaped printable-ASCII using
/// [`Display`]/[`ToString`]/[`FromStr`].

#[cfg(feature = "alloc")]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    feature = "serde",
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct StringM<const MAX: u32 = { u32::MAX }>(Vec<u8>);

#[cfg(not(feature = "alloc"))]
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
pub struct StringM<const MAX: u32 = { u32::MAX }>(Vec<u8>);

impl<const MAX: u32> core::fmt::Display for StringM<MAX> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        #[cfg(feature = "alloc")]
        let v = &self.0;
        #[cfg(not(feature = "alloc"))]
        let v = self.0;
        for b in escape_bytes::Escape::new(v) {
            write!(f, "{}", b as char)?;
        }
        Ok(())
    }
}

impl<const MAX: u32> core::fmt::Debug for StringM<MAX> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        #[cfg(feature = "alloc")]
        let v = &self.0;
        #[cfg(not(feature = "alloc"))]
        let v = self.0;
        write!(f, "StringM(")?;
        for b in escape_bytes::Escape::new(v) {
            write!(f, "{}", b as char)?;
        }
        write!(f, ")")?;
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> core::str::FromStr for StringM<MAX> {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        let b = escape_bytes::unescape(s.as_bytes()).map_err(|_| Error::Invalid)?;
        Ok(Self(b))
    }
}

impl<const MAX: u32> Deref for StringM<MAX> {
    type Target = Vec<u8>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<const MAX: u32> Default for StringM<MAX> {
    fn default() -> Self {
        Self(Vec::default())
    }
}

impl<const MAX: u32> StringM<MAX> {
    pub const MAX_LEN: usize = { MAX as usize };

    #[must_use]
    #[allow(clippy::unused_self)]
    pub fn max_len(&self) -> usize {
        Self::MAX_LEN
    }

    #[must_use]
    pub fn as_vec(&self) -> &Vec<u8> {
        self.as_ref()
    }
}

impl<const MAX: u32> StringM<MAX> {
    #[must_use]
    #[cfg(feature = "alloc")]
    pub fn to_vec(&self) -> Vec<u8> {
        self.into()
    }

    #[must_use]
    pub fn into_vec(self) -> Vec<u8> {
        self.into()
    }
}

impl<const MAX: u32> StringM<MAX> {
    #[cfg(feature = "alloc")]
    pub fn to_utf8_string(&self) -> Result<String> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    pub fn into_utf8_string(self) -> Result<String> {
        self.try_into()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn to_utf8_string_lossy(&self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    pub fn into_utf8_string_lossy(self) -> String {
        String::from_utf8_lossy(&self.0).into_owned()
    }
}

impl<const MAX: u32> TryFrom<Vec<u8>> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: Vec<u8>) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<const MAX: u32> From<StringM<MAX>> for Vec<u8> {
    #[must_use]
    fn from(v: StringM<MAX>) -> Self {
        v.0
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> From<&StringM<MAX>> for Vec<u8> {
    #[must_use]
    fn from(v: &StringM<MAX>) -> Self {
        v.0.clone()
    }
}

impl<const MAX: u32> AsRef<Vec<u8>> for StringM<MAX> {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&Vec<u8>> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &Vec<u8>) -> Result<Self> {
        v.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&[u8]> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &[u8]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<const MAX: u32> AsRef<[u8]> for StringM<MAX> {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0.as_ref()
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<[u8; N]> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: [u8; N]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<StringM<MAX>> for [u8; N] {
    type Error = StringM<MAX>;

    fn try_from(v: StringM<MAX>) -> core::result::Result<Self, Self::Error> {
        let s: [u8; N] = v.0.try_into().map_err(StringM::<MAX>)?;
        Ok(s)
    }
}

#[cfg(feature = "alloc")]
impl<const N: usize, const MAX: u32> TryFrom<&[u8; N]> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &[u8; N]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<const N: usize, const MAX: u32> TryFrom<&'static [u8; N]> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &'static [u8; N]) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&String> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &String) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.as_bytes().to_vec()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<String> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: String) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<StringM<MAX>> for String {
    type Error = Error;

    fn try_from(v: StringM<MAX>) -> Result<Self> {
        Ok(String::from_utf8(v.0)?)
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&StringM<MAX>> for String {
    type Error = Error;

    fn try_from(v: &StringM<MAX>) -> Result<Self> {
        Ok(core::str::from_utf8(v.as_ref())?.to_owned())
    }
}

#[cfg(feature = "alloc")]
impl<const MAX: u32> TryFrom<&str> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &str) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.into()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

#[cfg(not(feature = "alloc"))]
impl<const MAX: u32> TryFrom<&'static str> for StringM<MAX> {
    type Error = Error;

    fn try_from(v: &'static str) -> Result<Self> {
        let len: u32 = v.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
        if len <= MAX {
            Ok(StringM(v.as_bytes()))
        } else {
            Err(Error::LengthExceedsMax)
        }
    }
}

impl<'a, const MAX: u32> TryFrom<&'a StringM<MAX>> for &'a str {
    type Error = Error;

    fn try_from(v: &'a StringM<MAX>) -> Result<Self> {
        Ok(core::str::from_utf8(v.as_ref())?)
    }
}

impl<const MAX: u32> ReadXdr for StringM<MAX> {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let len: u32 = u32::read_xdr(r)?;
            if len > MAX {
                return Err(Error::LengthExceedsMax);
            }

            r.consume_len(len as usize)?;
            let padding = pad_len(len as usize);
            r.consume_len(padding)?;

            let mut vec = vec![0u8; len as usize];
            r.read_exact(&mut vec)?;

            let pad = &mut [0u8; 3][..padding];
            r.read_exact(pad)?;
            if pad.iter().any(|b| *b != 0) {
                return Err(Error::NonZeroPadding);
            }

            Ok(StringM(vec))
        })
    }
}

impl<const MAX: u32> WriteXdr for StringM<MAX> {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let len: u32 = self.len().try_into().map_err(|_| Error::LengthExceedsMax)?;
            len.write_xdr(w)?;

            w.consume_len(self.len())?;
            let padding = pad_len(self.len());
            w.consume_len(padding)?;

            w.write_all(&self.0)?;

            w.write_all(&[0u8; 3][..padding])?;

            Ok(())
        })
    }
}

// Frame ------------------------------------------------------------------------

#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Frame<T>(pub T)
where
    T: ReadXdr;

impl<T> ReadXdr for Frame<T>
where
    T: ReadXdr,
{
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        // Read the frame header value that contains 1 flag-bit and a 33-bit length.
        //  - The 1 flag bit is 0 when there are more frames for the same record.
        //  - The 31-bit length is the length of the bytes within the frame that
        //  follow the frame header.
        let header = u32::read_xdr(r)?;
        // TODO: Use the length and cap the length we'll read from `r`.
        let last_record = header >> 31 == 1;
        if last_record {
            // Read the record in the frame.
            Ok(Self(T::read_xdr(r)?))
        } else {
            // TODO: Support reading those additional frames for the same
            // record.
            Err(Error::Unsupported)
        }
    }
}

#[cfg(all(test, feature = "std"))]
mod tests {
    use std::io::Cursor;

    use super::*;

    #[test]
    pub fn vec_u8_read_without_padding() {
        let buf = Cursor::new(vec![0, 0, 0, 4, 2, 2, 2, 2]);
        let v = VecM::<u8, 8>::read_xdr(&mut Limited::new(buf, Limits::none())).unwrap();
        assert_eq!(v.to_vec(), vec![2, 2, 2, 2]);
    }

    #[test]
    pub fn vec_u8_read_with_padding() {
        let buf = Cursor::new(vec![0, 0, 0, 1, 2, 0, 0, 0]);
        let v = VecM::<u8, 8>::read_xdr(&mut Limited::new(buf, Limits::none())).unwrap();
        assert_eq!(v.to_vec(), vec![2]);
    }

    #[test]
    pub fn vec_u8_read_with_insufficient_padding() {
        let buf = Cursor::new(vec![0, 0, 0, 1, 2, 0, 0]);
        let res = VecM::<u8, 8>::read_xdr(&mut Limited::new(buf, Limits::none()));
        match res {
            Err(Error::Io(_)) => (),
            _ => panic!("expected IO error got {res:?}"),
        }
    }

    #[test]
    pub fn vec_u8_read_with_non_zero_padding() {
        let buf = Cursor::new(vec![0, 0, 0, 1, 2, 3, 0, 0]);
        let res = VecM::<u8, 8>::read_xdr(&mut Limited::new(buf, Limits::none()));
        match res {
            Err(Error::NonZeroPadding) => (),
            _ => panic!("expected NonZeroPadding got {res:?}"),
        }
    }

    #[test]
    pub fn vec_u8_write_without_padding() {
        let mut buf = vec![];
        let v: VecM<u8, 8> = vec![2, 2, 2, 2].try_into().unwrap();

        v.write_xdr(&mut Limited::new(Cursor::new(&mut buf), Limits::none()))
            .unwrap();
        assert_eq!(buf, vec![0, 0, 0, 4, 2, 2, 2, 2]);
    }

    #[test]
    pub fn vec_u8_write_with_padding() {
        let mut buf = vec![];
        let v: VecM<u8, 8> = vec![2].try_into().unwrap();
        v.write_xdr(&mut Limited::new(Cursor::new(&mut buf), Limits::none()))
            .unwrap();
        assert_eq!(buf, vec![0, 0, 0, 1, 2, 0, 0, 0]);
    }

    #[test]
    pub fn arr_u8_read_without_padding() {
        let buf = Cursor::new(vec![2, 2, 2, 2]);
        let v = <[u8; 4]>::read_xdr(&mut Limited::new(buf, Limits::none())).unwrap();
        assert_eq!(v, [2, 2, 2, 2]);
    }

    #[test]
    pub fn arr_u8_read_with_padding() {
        let buf = Cursor::new(vec![2, 0, 0, 0]);
        let v = <[u8; 1]>::read_xdr(&mut Limited::new(buf, Limits::none())).unwrap();
        assert_eq!(v, [2]);
    }

    #[test]
    pub fn arr_u8_read_with_insufficient_padding() {
        let buf = Cursor::new(vec![2, 0, 0]);
        let res = <[u8; 1]>::read_xdr(&mut Limited::new(buf, Limits::none()));
        match res {
            Err(Error::Io(_)) => (),
            _ => panic!("expected IO error got {res:?}"),
        }
    }

    #[test]
    pub fn arr_u8_read_with_non_zero_padding() {
        let buf = Cursor::new(vec![2, 3, 0, 0]);
        let res = <[u8; 1]>::read_xdr(&mut Limited::new(buf, Limits::none()));
        match res {
            Err(Error::NonZeroPadding) => (),
            _ => panic!("expected NonZeroPadding got {res:?}"),
        }
    }

    #[test]
    pub fn arr_u8_write_without_padding() {
        let mut buf = vec![];
        [2u8, 2, 2, 2]
            .write_xdr(&mut Limited::new(Cursor::new(&mut buf), Limits::none()))
            .unwrap();
        assert_eq!(buf, vec![2, 2, 2, 2]);
    }

    #[test]
    pub fn arr_u8_write_with_padding() {
        let mut buf = vec![];
        [2u8]
            .write_xdr(&mut Limited::new(Cursor::new(&mut buf), Limits::none()))
            .unwrap();
        assert_eq!(buf, vec![2, 0, 0, 0]);
    }
}

#[cfg(all(test, feature = "std"))]
mod test {
    use super::*;

    #[test]
    fn into_option_none() {
        let v: VecM<u32, 1> = vec![].try_into().unwrap();
        assert_eq!(v.into_option(), None);
    }

    #[test]
    fn into_option_some() {
        let v: VecM<_, 1> = vec![1].try_into().unwrap();
        assert_eq!(v.into_option(), Some(1));
    }

    #[test]
    fn to_option_none() {
        let v: VecM<u32, 1> = vec![].try_into().unwrap();
        assert_eq!(v.to_option(), None);
    }

    #[test]
    fn to_option_some() {
        let v: VecM<_, 1> = vec![1].try_into().unwrap();
        assert_eq!(v.to_option(), Some(1));
    }

    #[test]
    fn depth_limited_read_write_under_the_limit_success() {
        let a: Option<Option<Option<u32>>> = Some(Some(Some(5)));
        let mut buf = Limited::new(Vec::new(), Limits::depth(4));
        a.write_xdr(&mut buf).unwrap();

        let mut dlr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::depth(4));
        let a_back: Option<Option<Option<u32>>> = ReadXdr::read_xdr(&mut dlr).unwrap();
        assert_eq!(a, a_back);
    }

    #[test]
    fn write_over_depth_limit_fail() {
        let a: Option<Option<Option<u32>>> = Some(Some(Some(5)));
        let mut buf = Limited::new(Vec::new(), Limits::depth(3));
        let res = a.write_xdr(&mut buf);
        match res {
            Err(Error::DepthLimitExceeded) => (),
            _ => panic!("expected DepthLimitExceeded got {res:?}"),
        }
    }

    #[test]
    fn read_over_depth_limit_fail() {
        let read_limits = Limits::depth(3);
        let write_limits = Limits::depth(5);
        let a: Option<Option<Option<u32>>> = Some(Some(Some(5)));
        let mut buf = Limited::new(Vec::new(), write_limits);
        a.write_xdr(&mut buf).unwrap();

        let mut dlr = Limited::new(Cursor::new(buf.inner.as_slice()), read_limits);
        let res: Result<Option<Option<Option<u32>>>> = ReadXdr::read_xdr(&mut dlr);
        match res {
            Err(Error::DepthLimitExceeded) => (),
            _ => panic!("expected DepthLimitExceeded got {res:?}"),
        }
    }

    #[test]
    fn length_limited_read_write_i32() {
        // Exact limit, success
        let v = 123i32;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(4));
        let v_back: i32 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = 123i32;
        let mut buf = Limited::new(Vec::new(), Limits::len(5));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(5));
        let v_back: i32 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = 123i32;
        let mut buf = Limited::new(Vec::new(), Limits::len(3));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = 123i32;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(3));
        assert_eq!(
            <i32 as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_u32() {
        // Exact limit, success
        let v = 123u32;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(4));
        let v_back: u32 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = 123u32;
        let mut buf = Limited::new(Vec::new(), Limits::len(5));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(5));
        let v_back: u32 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = 123u32;
        let mut buf = Limited::new(Vec::new(), Limits::len(3));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = 123u32;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(3));
        assert_eq!(
            <u32 as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_i64() {
        // Exact limit, success
        let v = 123i64;
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(8));
        let v_back: i64 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = 123i64;
        let mut buf = Limited::new(Vec::new(), Limits::len(9));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(9));
        let v_back: i64 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = 123i64;
        let mut buf = Limited::new(Vec::new(), Limits::len(7));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = 123i64;
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(7));
        assert_eq!(
            <i64 as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_u64() {
        // Exact limit, success
        let v = 123u64;
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(8));
        let v_back: u64 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = 123u64;
        let mut buf = Limited::new(Vec::new(), Limits::len(9));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(9));
        let v_back: u64 = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = 123u64;
        let mut buf = Limited::new(Vec::new(), Limits::len(7));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = 123u64;
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(7));
        assert_eq!(
            <u64 as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_bool() {
        // Exact limit, success
        let v = true;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(4));
        let v_back: bool = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = true;
        let mut buf = Limited::new(Vec::new(), Limits::len(5));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(5));
        let v_back: bool = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = true;
        let mut buf = Limited::new(Vec::new(), Limits::len(3));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = true;
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(3));
        assert_eq!(
            <bool as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_option() {
        // Exact limit, success
        let v = Some(true);
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(8));
        let v_back: Option<bool> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = Some(true);
        let mut buf = Limited::new(Vec::new(), Limits::len(9));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(9));
        let v_back: Option<bool> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = Some(true);
        let mut buf = Limited::new(Vec::new(), Limits::len(7));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = Some(true);
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(7));
        assert_eq!(
            <Option<bool> as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_array_u8() {
        // Exact limit, success
        let v = [1u8, 2, 3];
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(4));
        let v_back: [u8; 3] = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = [1u8, 2, 3];
        let mut buf = Limited::new(Vec::new(), Limits::len(5));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(5));
        let v_back: [u8; 3] = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = [1u8, 2, 3];
        let mut buf = Limited::new(Vec::new(), Limits::len(3));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = [1u8, 2, 3];
        let mut buf = Limited::new(Vec::new(), Limits::len(4));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(3));
        assert_eq!(
            <[u8; 3] as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_array_type() {
        // Exact limit, success
        let v = [true, false, true];
        let mut buf = Limited::new(Vec::new(), Limits::len(12));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(12));
        let v_back: [bool; 3] = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = [true, false, true];
        let mut buf = Limited::new(Vec::new(), Limits::len(13));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(13));
        let v_back: [bool; 3] = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = [true, false, true];
        let mut buf = Limited::new(Vec::new(), Limits::len(11));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = [true, false, true];
        let mut buf = Limited::new(Vec::new(), Limits::len(12));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(11));
        assert_eq!(
            <[bool; 3] as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_vec() {
        // Exact limit, success
        let v = VecM::<i32, 3>::try_from([1i32, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(16));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(16));
        let v_back: VecM<i32, 3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = VecM::<i32, 3>::try_from([1i32, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(17));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(17));
        let v_back: VecM<i32, 3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = VecM::<i32, 3>::try_from([1i32, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(15));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = VecM::<i32, 3>::try_from([1i32, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(16));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(15));
        assert_eq!(
            <VecM<i32, 3> as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_bytes() {
        // Exact limit, success
        let v = BytesM::<3>::try_from([1u8, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(8));
        let v_back: BytesM<3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = BytesM::<3>::try_from([1u8, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(9));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(9));
        let v_back: BytesM<3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = BytesM::<3>::try_from([1u8, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(7));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = BytesM::<3>::try_from([1u8, 2, 3]).unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(7));
        assert_eq!(
            <BytesM<3> as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }

    #[test]
    fn length_limited_read_write_string() {
        // Exact limit, success
        let v = StringM::<3>::try_from("123").unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(8));
        let v_back: StringM<3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 0);
        assert_eq!(v, v_back);

        // Over limit, success
        let v = StringM::<3>::try_from("123").unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(9));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 1);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(9));
        let v_back: StringM<3> = ReadXdr::read_xdr(&mut lr).unwrap();
        assert_eq!(buf.limits.len, 1);
        assert_eq!(v, v_back);

        // Write under limit, failure
        let v = StringM::<3>::try_from("123").unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(7));
        assert_eq!(v.write_xdr(&mut buf), Err(Error::LengthLimitExceeded));

        // Read under limit, failure
        let v = StringM::<3>::try_from("123").unwrap();
        let mut buf = Limited::new(Vec::new(), Limits::len(8));
        v.write_xdr(&mut buf).unwrap();
        assert_eq!(buf.limits.len, 0);
        let mut lr = Limited::new(Cursor::new(buf.inner.as_slice()), Limits::len(7));
        assert_eq!(
            <StringM<3> as ReadXdr>::read_xdr(&mut lr),
            Err(Error::LengthLimitExceeded)
        );
    }
}

#[cfg(all(test, not(feature = "alloc")))]
mod test {
    use super::VecM;

    #[test]
    fn to_option_none() {
        let v: VecM<u32, 1> = (&[]).try_into().unwrap();
        assert_eq!(v.to_option(), None);
    }

    #[test]
    fn to_option_some() {
        let v: VecM<_, 1> = (&[1]).try_into().unwrap();
        assert_eq!(v.to_option(), Some(1));
    }
}

/// Value is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque Value<>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct Value(pub BytesM);

impl From<Value> for BytesM {
    #[must_use]
    fn from(x: Value) -> Self {
        x.0
    }
}

impl From<BytesM> for Value {
    #[must_use]
    fn from(x: BytesM) -> Self {
        Value(x)
    }
}

impl AsRef<BytesM> for Value {
    #[must_use]
    fn as_ref(&self) -> &BytesM {
        &self.0
    }
}

impl ReadXdr for Value {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = BytesM::read_xdr(r)?;
            let v = Value(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Value {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for Value {
    type Target = BytesM;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<Value> for Vec<u8> {
    #[must_use]
    fn from(x: Value) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for Value {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        Ok(Value(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for Value {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        Ok(Value(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for Value {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for Value {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// ScpBallot is an XDR Struct defines as:
///
/// ```text
/// struct SCPBallot
/// {
///     uint32 counter; // n
///     Value value;    // x
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScpBallot {
    pub counter: u32,
    pub value: Value,
}

impl ReadXdr for ScpBallot {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                counter: u32::read_xdr(r)?,
                value: Value::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpBallot {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.counter.write_xdr(w)?;
            self.value.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScpStatementType is an XDR Enum defines as:
///
/// ```text
/// enum SCPStatementType
/// {
///     SCP_ST_PREPARE = 0,
///     SCP_ST_CONFIRM = 1,
///     SCP_ST_EXTERNALIZE = 2,
///     SCP_ST_NOMINATE = 3
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ScpStatementType {
    Prepare = 0,
    Confirm = 1,
    Externalize = 2,
    Nominate = 3,
}

impl ScpStatementType {
    pub const VARIANTS: [ScpStatementType; 4] = [
        ScpStatementType::Prepare,
        ScpStatementType::Confirm,
        ScpStatementType::Externalize,
        ScpStatementType::Nominate,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = ["Prepare", "Confirm", "Externalize", "Nominate"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Prepare => "Prepare",
            Self::Confirm => "Confirm",
            Self::Externalize => "Externalize",
            Self::Nominate => "Nominate",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScpStatementType; 4] {
        Self::VARIANTS
    }
}

impl Name for ScpStatementType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScpStatementType> for ScpStatementType {
    fn variants() -> slice::Iter<'static, ScpStatementType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScpStatementType {}

impl fmt::Display for ScpStatementType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScpStatementType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ScpStatementType::Prepare,
            1 => ScpStatementType::Confirm,
            2 => ScpStatementType::Externalize,
            3 => ScpStatementType::Nominate,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScpStatementType> for i32 {
    #[must_use]
    fn from(e: ScpStatementType) -> Self {
        e as Self
    }
}

impl ReadXdr for ScpStatementType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScpStatementType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScpNomination is an XDR Struct defines as:
///
/// ```text
/// struct SCPNomination
/// {
///     Hash quorumSetHash; // D
///     Value votes<>;      // X
///     Value accepted<>;   // Y
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScpNomination {
    pub quorum_set_hash: Hash,
    pub votes: VecM<Value>,
    pub accepted: VecM<Value>,
}

impl ReadXdr for ScpNomination {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                quorum_set_hash: Hash::read_xdr(r)?,
                votes: VecM::<Value>::read_xdr(r)?,
                accepted: VecM::<Value>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpNomination {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.quorum_set_hash.write_xdr(w)?;
            self.votes.write_xdr(w)?;
            self.accepted.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScpStatementPrepare is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///         {
///             Hash quorumSetHash;       // D
///             SCPBallot ballot;         // b
///             SCPBallot* prepared;      // p
///             SCPBallot* preparedPrime; // p'
///             uint32 nC;                // c.n
///             uint32 nH;                // h.n
///         }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScpStatementPrepare {
    pub quorum_set_hash: Hash,
    pub ballot: ScpBallot,
    pub prepared: Option<ScpBallot>,
    pub prepared_prime: Option<ScpBallot>,
    pub n_c: u32,
    pub n_h: u32,
}

impl ReadXdr for ScpStatementPrepare {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                quorum_set_hash: Hash::read_xdr(r)?,
                ballot: ScpBallot::read_xdr(r)?,
                prepared: Option::<ScpBallot>::read_xdr(r)?,
                prepared_prime: Option::<ScpBallot>::read_xdr(r)?,
                n_c: u32::read_xdr(r)?,
                n_h: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpStatementPrepare {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.quorum_set_hash.write_xdr(w)?;
            self.ballot.write_xdr(w)?;
            self.prepared.write_xdr(w)?;
            self.prepared_prime.write_xdr(w)?;
            self.n_c.write_xdr(w)?;
            self.n_h.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScpStatementConfirm is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///         {
///             SCPBallot ballot;   // b
///             uint32 nPrepared;   // p.n
///             uint32 nCommit;     // c.n
///             uint32 nH;          // h.n
///             Hash quorumSetHash; // D
///         }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScpStatementConfirm {
    pub ballot: ScpBallot,
    pub n_prepared: u32,
    pub n_commit: u32,
    pub n_h: u32,
    pub quorum_set_hash: Hash,
}

impl ReadXdr for ScpStatementConfirm {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ballot: ScpBallot::read_xdr(r)?,
                n_prepared: u32::read_xdr(r)?,
                n_commit: u32::read_xdr(r)?,
                n_h: u32::read_xdr(r)?,
                quorum_set_hash: Hash::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpStatementConfirm {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ballot.write_xdr(w)?;
            self.n_prepared.write_xdr(w)?;
            self.n_commit.write_xdr(w)?;
            self.n_h.write_xdr(w)?;
            self.quorum_set_hash.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScpStatementExternalize is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///         {
///             SCPBallot commit;         // c
///             uint32 nH;                // h.n
///             Hash commitQuorumSetHash; // D used before EXTERNALIZE
///         }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScpStatementExternalize {
    pub commit: ScpBallot,
    pub n_h: u32,
    pub commit_quorum_set_hash: Hash,
}

impl ReadXdr for ScpStatementExternalize {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                commit: ScpBallot::read_xdr(r)?,
                n_h: u32::read_xdr(r)?,
                commit_quorum_set_hash: Hash::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpStatementExternalize {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.commit.write_xdr(w)?;
            self.n_h.write_xdr(w)?;
            self.commit_quorum_set_hash.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScpStatementPledges is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (SCPStatementType type)
///     {
///     case SCP_ST_PREPARE:
///         struct
///         {
///             Hash quorumSetHash;       // D
///             SCPBallot ballot;         // b
///             SCPBallot* prepared;      // p
///             SCPBallot* preparedPrime; // p'
///             uint32 nC;                // c.n
///             uint32 nH;                // h.n
///         } prepare;
///     case SCP_ST_CONFIRM:
///         struct
///         {
///             SCPBallot ballot;   // b
///             uint32 nPrepared;   // p.n
///             uint32 nCommit;     // c.n
///             uint32 nH;          // h.n
///             Hash quorumSetHash; // D
///         } confirm;
///     case SCP_ST_EXTERNALIZE:
///         struct
///         {
///             SCPBallot commit;         // c
///             uint32 nH;                // h.n
///             Hash commitQuorumSetHash; // D used before EXTERNALIZE
///         } externalize;
///     case SCP_ST_NOMINATE:
///         SCPNomination nominate;
///     }
/// ```
///
// union with discriminant ScpStatementType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ScpStatementPledges {
    Prepare(ScpStatementPrepare),
    Confirm(ScpStatementConfirm),
    Externalize(ScpStatementExternalize),
    Nominate(ScpNomination),
}

impl ScpStatementPledges {
    pub const VARIANTS: [ScpStatementType; 4] = [
        ScpStatementType::Prepare,
        ScpStatementType::Confirm,
        ScpStatementType::Externalize,
        ScpStatementType::Nominate,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = ["Prepare", "Confirm", "Externalize", "Nominate"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Prepare(_) => "Prepare",
            Self::Confirm(_) => "Confirm",
            Self::Externalize(_) => "Externalize",
            Self::Nominate(_) => "Nominate",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScpStatementType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Prepare(_) => ScpStatementType::Prepare,
            Self::Confirm(_) => ScpStatementType::Confirm,
            Self::Externalize(_) => ScpStatementType::Externalize,
            Self::Nominate(_) => ScpStatementType::Nominate,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScpStatementType; 4] {
        Self::VARIANTS
    }
}

impl Name for ScpStatementPledges {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScpStatementType> for ScpStatementPledges {
    #[must_use]
    fn discriminant(&self) -> ScpStatementType {
        Self::discriminant(self)
    }
}

impl Variants<ScpStatementType> for ScpStatementPledges {
    fn variants() -> slice::Iter<'static, ScpStatementType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScpStatementType> for ScpStatementPledges {}

impl ReadXdr for ScpStatementPledges {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ScpStatementType = <ScpStatementType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScpStatementType::Prepare => Self::Prepare(ScpStatementPrepare::read_xdr(r)?),
                ScpStatementType::Confirm => Self::Confirm(ScpStatementConfirm::read_xdr(r)?),
                ScpStatementType::Externalize => {
                    Self::Externalize(ScpStatementExternalize::read_xdr(r)?)
                }
                ScpStatementType::Nominate => Self::Nominate(ScpNomination::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScpStatementPledges {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Prepare(v) => v.write_xdr(w)?,
                Self::Confirm(v) => v.write_xdr(w)?,
                Self::Externalize(v) => v.write_xdr(w)?,
                Self::Nominate(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScpStatement is an XDR Struct defines as:
///
/// ```text
/// struct SCPStatement
/// {
///     NodeID nodeID;    // v
///     uint64 slotIndex; // i
///
///     union switch (SCPStatementType type)
///     {
///     case SCP_ST_PREPARE:
///         struct
///         {
///             Hash quorumSetHash;       // D
///             SCPBallot ballot;         // b
///             SCPBallot* prepared;      // p
///             SCPBallot* preparedPrime; // p'
///             uint32 nC;                // c.n
///             uint32 nH;                // h.n
///         } prepare;
///     case SCP_ST_CONFIRM:
///         struct
///         {
///             SCPBallot ballot;   // b
///             uint32 nPrepared;   // p.n
///             uint32 nCommit;     // c.n
///             uint32 nH;          // h.n
///             Hash quorumSetHash; // D
///         } confirm;
///     case SCP_ST_EXTERNALIZE:
///         struct
///         {
///             SCPBallot commit;         // c
///             uint32 nH;                // h.n
///             Hash commitQuorumSetHash; // D used before EXTERNALIZE
///         } externalize;
///     case SCP_ST_NOMINATE:
///         SCPNomination nominate;
///     }
///     pledges;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScpStatement {
    pub node_id: NodeId,
    pub slot_index: u64,
    pub pledges: ScpStatementPledges,
}

impl ReadXdr for ScpStatement {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                node_id: NodeId::read_xdr(r)?,
                slot_index: u64::read_xdr(r)?,
                pledges: ScpStatementPledges::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpStatement {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.node_id.write_xdr(w)?;
            self.slot_index.write_xdr(w)?;
            self.pledges.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScpEnvelope is an XDR Struct defines as:
///
/// ```text
/// struct SCPEnvelope
/// {
///     SCPStatement statement;
///     Signature signature;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScpEnvelope {
    pub statement: ScpStatement,
    pub signature: Signature,
}

impl ReadXdr for ScpEnvelope {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                statement: ScpStatement::read_xdr(r)?,
                signature: Signature::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpEnvelope {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.statement.write_xdr(w)?;
            self.signature.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScpQuorumSet is an XDR Struct defines as:
///
/// ```text
/// struct SCPQuorumSet
/// {
///     uint32 threshold;
///     NodeID validators<>;
///     SCPQuorumSet innerSets<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScpQuorumSet {
    pub threshold: u32,
    pub validators: VecM<NodeId>,
    pub inner_sets: VecM<ScpQuorumSet>,
}

impl ReadXdr for ScpQuorumSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                threshold: u32::read_xdr(r)?,
                validators: VecM::<NodeId>::read_xdr(r)?,
                inner_sets: VecM::<ScpQuorumSet>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpQuorumSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.threshold.write_xdr(w)?;
            self.validators.write_xdr(w)?;
            self.inner_sets.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ConfigSettingContractExecutionLanesV0 is an XDR Struct defines as:
///
/// ```text
/// struct ConfigSettingContractExecutionLanesV0
/// {
///     // maximum number of Soroban transactions per ledger
///     uint32 ledgerMaxTxCount;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ConfigSettingContractExecutionLanesV0 {
    pub ledger_max_tx_count: u32,
}

impl ReadXdr for ConfigSettingContractExecutionLanesV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_max_tx_count: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractExecutionLanesV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ledger_max_tx_count.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ConfigSettingContractComputeV0 is an XDR Struct defines as:
///
/// ```text
/// struct ConfigSettingContractComputeV0
/// {
///     // Maximum instructions per ledger
///     int64 ledgerMaxInstructions;
///     // Maximum instructions per transaction
///     int64 txMaxInstructions;
///     // Cost of 10000 instructions
///     int64 feeRatePerInstructionsIncrement;
///
///     // Memory limit per transaction. Unlike instructions, there is no fee
///     // for memory, just the limit.
///     uint32 txMemoryLimit;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ConfigSettingContractComputeV0 {
    pub ledger_max_instructions: i64,
    pub tx_max_instructions: i64,
    pub fee_rate_per_instructions_increment: i64,
    pub tx_memory_limit: u32,
}

impl ReadXdr for ConfigSettingContractComputeV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_max_instructions: i64::read_xdr(r)?,
                tx_max_instructions: i64::read_xdr(r)?,
                fee_rate_per_instructions_increment: i64::read_xdr(r)?,
                tx_memory_limit: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractComputeV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ledger_max_instructions.write_xdr(w)?;
            self.tx_max_instructions.write_xdr(w)?;
            self.fee_rate_per_instructions_increment.write_xdr(w)?;
            self.tx_memory_limit.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ConfigSettingContractLedgerCostV0 is an XDR Struct defines as:
///
/// ```text
/// struct ConfigSettingContractLedgerCostV0
/// {
///     // Maximum number of ledger entry read operations per ledger
///     uint32 ledgerMaxReadLedgerEntries;
///     // Maximum number of bytes that can be read per ledger
///     uint32 ledgerMaxReadBytes;
///     // Maximum number of ledger entry write operations per ledger
///     uint32 ledgerMaxWriteLedgerEntries;
///     // Maximum number of bytes that can be written per ledger
///     uint32 ledgerMaxWriteBytes;
///
///     // Maximum number of ledger entry read operations per transaction
///     uint32 txMaxReadLedgerEntries;
///     // Maximum number of bytes that can be read per transaction
///     uint32 txMaxReadBytes;
///     // Maximum number of ledger entry write operations per transaction
///     uint32 txMaxWriteLedgerEntries;
///     // Maximum number of bytes that can be written per transaction
///     uint32 txMaxWriteBytes;
///
///     int64 feeReadLedgerEntry;  // Fee per ledger entry read
///     int64 feeWriteLedgerEntry; // Fee per ledger entry write
///
///     int64 feeRead1KB;  // Fee for reading 1KB
///
///     // The following parameters determine the write fee per 1KB.
///     // Write fee grows linearly until bucket list reaches this size
///     int64 bucketListTargetSizeBytes;
///     // Fee per 1KB write when the bucket list is empty
///     int64 writeFee1KBBucketListLow;
///     // Fee per 1KB write when the bucket list has reached `bucketListTargetSizeBytes`
///     int64 writeFee1KBBucketListHigh;
///     // Write fee multiplier for any additional data past the first `bucketListTargetSizeBytes`
///     uint32 bucketListWriteFeeGrowthFactor;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ConfigSettingContractLedgerCostV0 {
    pub ledger_max_read_ledger_entries: u32,
    pub ledger_max_read_bytes: u32,
    pub ledger_max_write_ledger_entries: u32,
    pub ledger_max_write_bytes: u32,
    pub tx_max_read_ledger_entries: u32,
    pub tx_max_read_bytes: u32,
    pub tx_max_write_ledger_entries: u32,
    pub tx_max_write_bytes: u32,
    pub fee_read_ledger_entry: i64,
    pub fee_write_ledger_entry: i64,
    pub fee_read1_kb: i64,
    pub bucket_list_target_size_bytes: i64,
    pub write_fee1_kb_bucket_list_low: i64,
    pub write_fee1_kb_bucket_list_high: i64,
    pub bucket_list_write_fee_growth_factor: u32,
}

impl ReadXdr for ConfigSettingContractLedgerCostV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_max_read_ledger_entries: u32::read_xdr(r)?,
                ledger_max_read_bytes: u32::read_xdr(r)?,
                ledger_max_write_ledger_entries: u32::read_xdr(r)?,
                ledger_max_write_bytes: u32::read_xdr(r)?,
                tx_max_read_ledger_entries: u32::read_xdr(r)?,
                tx_max_read_bytes: u32::read_xdr(r)?,
                tx_max_write_ledger_entries: u32::read_xdr(r)?,
                tx_max_write_bytes: u32::read_xdr(r)?,
                fee_read_ledger_entry: i64::read_xdr(r)?,
                fee_write_ledger_entry: i64::read_xdr(r)?,
                fee_read1_kb: i64::read_xdr(r)?,
                bucket_list_target_size_bytes: i64::read_xdr(r)?,
                write_fee1_kb_bucket_list_low: i64::read_xdr(r)?,
                write_fee1_kb_bucket_list_high: i64::read_xdr(r)?,
                bucket_list_write_fee_growth_factor: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractLedgerCostV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ledger_max_read_ledger_entries.write_xdr(w)?;
            self.ledger_max_read_bytes.write_xdr(w)?;
            self.ledger_max_write_ledger_entries.write_xdr(w)?;
            self.ledger_max_write_bytes.write_xdr(w)?;
            self.tx_max_read_ledger_entries.write_xdr(w)?;
            self.tx_max_read_bytes.write_xdr(w)?;
            self.tx_max_write_ledger_entries.write_xdr(w)?;
            self.tx_max_write_bytes.write_xdr(w)?;
            self.fee_read_ledger_entry.write_xdr(w)?;
            self.fee_write_ledger_entry.write_xdr(w)?;
            self.fee_read1_kb.write_xdr(w)?;
            self.bucket_list_target_size_bytes.write_xdr(w)?;
            self.write_fee1_kb_bucket_list_low.write_xdr(w)?;
            self.write_fee1_kb_bucket_list_high.write_xdr(w)?;
            self.bucket_list_write_fee_growth_factor.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ConfigSettingContractHistoricalDataV0 is an XDR Struct defines as:
///
/// ```text
/// struct ConfigSettingContractHistoricalDataV0
/// {
///     int64 feeHistorical1KB; // Fee for storing 1KB in archives
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ConfigSettingContractHistoricalDataV0 {
    pub fee_historical1_kb: i64,
}

impl ReadXdr for ConfigSettingContractHistoricalDataV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                fee_historical1_kb: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractHistoricalDataV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.fee_historical1_kb.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ConfigSettingContractEventsV0 is an XDR Struct defines as:
///
/// ```text
/// struct ConfigSettingContractEventsV0
/// {
///     // Maximum size of events that a contract call can emit.
///     uint32 txMaxContractEventsSizeBytes;
///     // Fee for generating 1KB of contract events.
///     int64 feeContractEvents1KB;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ConfigSettingContractEventsV0 {
    pub tx_max_contract_events_size_bytes: u32,
    pub fee_contract_events1_kb: i64,
}

impl ReadXdr for ConfigSettingContractEventsV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_max_contract_events_size_bytes: u32::read_xdr(r)?,
                fee_contract_events1_kb: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractEventsV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.tx_max_contract_events_size_bytes.write_xdr(w)?;
            self.fee_contract_events1_kb.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ConfigSettingContractBandwidthV0 is an XDR Struct defines as:
///
/// ```text
/// struct ConfigSettingContractBandwidthV0
/// {
///     // Maximum sum of all transaction sizes in the ledger in bytes
///     uint32 ledgerMaxTxsSizeBytes;
///     // Maximum size in bytes for a transaction
///     uint32 txMaxSizeBytes;
///
///     // Fee for 1 KB of transaction size
///     int64 feeTxSize1KB;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ConfigSettingContractBandwidthV0 {
    pub ledger_max_txs_size_bytes: u32,
    pub tx_max_size_bytes: u32,
    pub fee_tx_size1_kb: i64,
}

impl ReadXdr for ConfigSettingContractBandwidthV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_max_txs_size_bytes: u32::read_xdr(r)?,
                tx_max_size_bytes: u32::read_xdr(r)?,
                fee_tx_size1_kb: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigSettingContractBandwidthV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ledger_max_txs_size_bytes.write_xdr(w)?;
            self.tx_max_size_bytes.write_xdr(w)?;
            self.fee_tx_size1_kb.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ContractCostType is an XDR Enum defines as:
///
/// ```text
/// enum ContractCostType {
///     // Cost of running 1 wasm instruction
///     WasmInsnExec = 0,
///     // Cost of allocating a slice of memory (in bytes)
///     MemAlloc = 1,
///     // Cost of copying a slice of bytes into a pre-allocated memory
///     MemCpy = 2,
///     // Cost of comparing two slices of memory
///     MemCmp = 3,
///     // Cost of a host function dispatch, not including the actual work done by
///     // the function nor the cost of VM invocation machinary
///     DispatchHostFunction = 4,
///     // Cost of visiting a host object from the host object storage. Exists to
///     // make sure some baseline cost coverage, i.e. repeatly visiting objects
///     // by the guest will always incur some charges.
///     VisitObject = 5,
///     // Cost of serializing an xdr object to bytes
///     ValSer = 6,
///     // Cost of deserializing an xdr object from bytes
///     ValDeser = 7,
///     // Cost of computing the sha256 hash from bytes
///     ComputeSha256Hash = 8,
///     // Cost of computing the ed25519 pubkey from bytes
///     ComputeEd25519PubKey = 9,
///     // Cost of verifying ed25519 signature of a payload.
///     VerifyEd25519Sig = 10,
///     // Cost of instantiation a VM from wasm bytes code.
///     VmInstantiation = 11,
///     // Cost of instantiation a VM from a cached state.
///     VmCachedInstantiation = 12,
///     // Cost of invoking a function on the VM. If the function is a host function,
///     // additional cost will be covered by `DispatchHostFunction`.
///     InvokeVmFunction = 13,
///     // Cost of computing a keccak256 hash from bytes.
///     ComputeKeccak256Hash = 14,
///     // Cost of decoding an ECDSA signature computed from a 256-bit prime modulus
///     // curve (e.g. secp256k1 and secp256r1)
///     DecodeEcdsaCurve256Sig = 15,
///     // Cost of recovering an ECDSA secp256k1 key from a signature.
///     RecoverEcdsaSecp256k1Key = 16,
///     // Cost of int256 addition (`+`) and subtraction (`-`) operations
///     Int256AddSub = 17,
///     // Cost of int256 multiplication (`*`) operation
///     Int256Mul = 18,
///     // Cost of int256 division (`/`) operation
///     Int256Div = 19,
///     // Cost of int256 power (`exp`) operation
///     Int256Pow = 20,
///     // Cost of int256 shift (`shl`, `shr`) operation
///     Int256Shift = 21,
///     // Cost of drawing random bytes using a ChaCha20 PRNG
///     ChaCha20DrawBytes = 22,
///
///     // Cost of parsing wasm bytes that only encode instructions.
///     ParseWasmInstructions = 23,
///     // Cost of parsing a known number of wasm functions.
///     ParseWasmFunctions = 24,
///     // Cost of parsing a known number of wasm globals.
///     ParseWasmGlobals = 25,
///     // Cost of parsing a known number of wasm table entries.
///     ParseWasmTableEntries = 26,
///     // Cost of parsing a known number of wasm types.
///     ParseWasmTypes = 27,
///     // Cost of parsing a known number of wasm data segments.
///     ParseWasmDataSegments = 28,
///     // Cost of parsing a known number of wasm element segments.
///     ParseWasmElemSegments = 29,
///     // Cost of parsing a known number of wasm imports.
///     ParseWasmImports = 30,
///     // Cost of parsing a known number of wasm exports.
///     ParseWasmExports = 31,
///     // Cost of parsing a known number of data segment bytes.
///     ParseWasmDataSegmentBytes = 32,
///
///     // Cost of instantiating wasm bytes that only encode instructions.
///     InstantiateWasmInstructions = 33,
///     // Cost of instantiating a known number of wasm functions.
///     InstantiateWasmFunctions = 34,
///     // Cost of instantiating a known number of wasm globals.
///     InstantiateWasmGlobals = 35,
///     // Cost of instantiating a known number of wasm table entries.
///     InstantiateWasmTableEntries = 36,
///     // Cost of instantiating a known number of wasm types.
///     InstantiateWasmTypes = 37,
///     // Cost of instantiating a known number of wasm data segments.
///     InstantiateWasmDataSegments = 38,
///     // Cost of instantiating a known number of wasm element segments.
///     InstantiateWasmElemSegments = 39,
///     // Cost of instantiating a known number of wasm imports.
///     InstantiateWasmImports = 40,
///     // Cost of instantiating a known number of wasm exports.
///     InstantiateWasmExports = 41,
///     // Cost of instantiating a known number of data segment bytes.
///     InstantiateWasmDataSegmentBytes = 42,
///
///     // Cost of decoding a bytes array representing an uncompressed SEC-1 encoded
///     // point on a 256-bit elliptic curve
///     Sec1DecodePointUncompressed = 43,
///     // Cost of verifying an ECDSA Secp256r1 signature
///     VerifyEcdsaSecp256r1Sig = 44
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ContractCostType {
    WasmInsnExec = 0,
    MemAlloc = 1,
    MemCpy = 2,
    MemCmp = 3,
    DispatchHostFunction = 4,
    VisitObject = 5,
    ValSer = 6,
    ValDeser = 7,
    ComputeSha256Hash = 8,
    ComputeEd25519PubKey = 9,
    VerifyEd25519Sig = 10,
    VmInstantiation = 11,
    VmCachedInstantiation = 12,
    InvokeVmFunction = 13,
    ComputeKeccak256Hash = 14,
    DecodeEcdsaCurve256Sig = 15,
    RecoverEcdsaSecp256k1Key = 16,
    Int256AddSub = 17,
    Int256Mul = 18,
    Int256Div = 19,
    Int256Pow = 20,
    Int256Shift = 21,
    ChaCha20DrawBytes = 22,
    ParseWasmInstructions = 23,
    ParseWasmFunctions = 24,
    ParseWasmGlobals = 25,
    ParseWasmTableEntries = 26,
    ParseWasmTypes = 27,
    ParseWasmDataSegments = 28,
    ParseWasmElemSegments = 29,
    ParseWasmImports = 30,
    ParseWasmExports = 31,
    ParseWasmDataSegmentBytes = 32,
    InstantiateWasmInstructions = 33,
    InstantiateWasmFunctions = 34,
    InstantiateWasmGlobals = 35,
    InstantiateWasmTableEntries = 36,
    InstantiateWasmTypes = 37,
    InstantiateWasmDataSegments = 38,
    InstantiateWasmElemSegments = 39,
    InstantiateWasmImports = 40,
    InstantiateWasmExports = 41,
    InstantiateWasmDataSegmentBytes = 42,
    Sec1DecodePointUncompressed = 43,
    VerifyEcdsaSecp256r1Sig = 44,
}

impl ContractCostType {
    pub const VARIANTS: [ContractCostType; 45] = [
        ContractCostType::WasmInsnExec,
        ContractCostType::MemAlloc,
        ContractCostType::MemCpy,
        ContractCostType::MemCmp,
        ContractCostType::DispatchHostFunction,
        ContractCostType::VisitObject,
        ContractCostType::ValSer,
        ContractCostType::ValDeser,
        ContractCostType::ComputeSha256Hash,
        ContractCostType::ComputeEd25519PubKey,
        ContractCostType::VerifyEd25519Sig,
        ContractCostType::VmInstantiation,
        ContractCostType::VmCachedInstantiation,
        ContractCostType::InvokeVmFunction,
        ContractCostType::ComputeKeccak256Hash,
        ContractCostType::DecodeEcdsaCurve256Sig,
        ContractCostType::RecoverEcdsaSecp256k1Key,
        ContractCostType::Int256AddSub,
        ContractCostType::Int256Mul,
        ContractCostType::Int256Div,
        ContractCostType::Int256Pow,
        ContractCostType::Int256Shift,
        ContractCostType::ChaCha20DrawBytes,
        ContractCostType::ParseWasmInstructions,
        ContractCostType::ParseWasmFunctions,
        ContractCostType::ParseWasmGlobals,
        ContractCostType::ParseWasmTableEntries,
        ContractCostType::ParseWasmTypes,
        ContractCostType::ParseWasmDataSegments,
        ContractCostType::ParseWasmElemSegments,
        ContractCostType::ParseWasmImports,
        ContractCostType::ParseWasmExports,
        ContractCostType::ParseWasmDataSegmentBytes,
        ContractCostType::InstantiateWasmInstructions,
        ContractCostType::InstantiateWasmFunctions,
        ContractCostType::InstantiateWasmGlobals,
        ContractCostType::InstantiateWasmTableEntries,
        ContractCostType::InstantiateWasmTypes,
        ContractCostType::InstantiateWasmDataSegments,
        ContractCostType::InstantiateWasmElemSegments,
        ContractCostType::InstantiateWasmImports,
        ContractCostType::InstantiateWasmExports,
        ContractCostType::InstantiateWasmDataSegmentBytes,
        ContractCostType::Sec1DecodePointUncompressed,
        ContractCostType::VerifyEcdsaSecp256r1Sig,
    ];
    pub const VARIANTS_STR: [&'static str; 45] = [
        "WasmInsnExec",
        "MemAlloc",
        "MemCpy",
        "MemCmp",
        "DispatchHostFunction",
        "VisitObject",
        "ValSer",
        "ValDeser",
        "ComputeSha256Hash",
        "ComputeEd25519PubKey",
        "VerifyEd25519Sig",
        "VmInstantiation",
        "VmCachedInstantiation",
        "InvokeVmFunction",
        "ComputeKeccak256Hash",
        "DecodeEcdsaCurve256Sig",
        "RecoverEcdsaSecp256k1Key",
        "Int256AddSub",
        "Int256Mul",
        "Int256Div",
        "Int256Pow",
        "Int256Shift",
        "ChaCha20DrawBytes",
        "ParseWasmInstructions",
        "ParseWasmFunctions",
        "ParseWasmGlobals",
        "ParseWasmTableEntries",
        "ParseWasmTypes",
        "ParseWasmDataSegments",
        "ParseWasmElemSegments",
        "ParseWasmImports",
        "ParseWasmExports",
        "ParseWasmDataSegmentBytes",
        "InstantiateWasmInstructions",
        "InstantiateWasmFunctions",
        "InstantiateWasmGlobals",
        "InstantiateWasmTableEntries",
        "InstantiateWasmTypes",
        "InstantiateWasmDataSegments",
        "InstantiateWasmElemSegments",
        "InstantiateWasmImports",
        "InstantiateWasmExports",
        "InstantiateWasmDataSegmentBytes",
        "Sec1DecodePointUncompressed",
        "VerifyEcdsaSecp256r1Sig",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::WasmInsnExec => "WasmInsnExec",
            Self::MemAlloc => "MemAlloc",
            Self::MemCpy => "MemCpy",
            Self::MemCmp => "MemCmp",
            Self::DispatchHostFunction => "DispatchHostFunction",
            Self::VisitObject => "VisitObject",
            Self::ValSer => "ValSer",
            Self::ValDeser => "ValDeser",
            Self::ComputeSha256Hash => "ComputeSha256Hash",
            Self::ComputeEd25519PubKey => "ComputeEd25519PubKey",
            Self::VerifyEd25519Sig => "VerifyEd25519Sig",
            Self::VmInstantiation => "VmInstantiation",
            Self::VmCachedInstantiation => "VmCachedInstantiation",
            Self::InvokeVmFunction => "InvokeVmFunction",
            Self::ComputeKeccak256Hash => "ComputeKeccak256Hash",
            Self::DecodeEcdsaCurve256Sig => "DecodeEcdsaCurve256Sig",
            Self::RecoverEcdsaSecp256k1Key => "RecoverEcdsaSecp256k1Key",
            Self::Int256AddSub => "Int256AddSub",
            Self::Int256Mul => "Int256Mul",
            Self::Int256Div => "Int256Div",
            Self::Int256Pow => "Int256Pow",
            Self::Int256Shift => "Int256Shift",
            Self::ChaCha20DrawBytes => "ChaCha20DrawBytes",
            Self::ParseWasmInstructions => "ParseWasmInstructions",
            Self::ParseWasmFunctions => "ParseWasmFunctions",
            Self::ParseWasmGlobals => "ParseWasmGlobals",
            Self::ParseWasmTableEntries => "ParseWasmTableEntries",
            Self::ParseWasmTypes => "ParseWasmTypes",
            Self::ParseWasmDataSegments => "ParseWasmDataSegments",
            Self::ParseWasmElemSegments => "ParseWasmElemSegments",
            Self::ParseWasmImports => "ParseWasmImports",
            Self::ParseWasmExports => "ParseWasmExports",
            Self::ParseWasmDataSegmentBytes => "ParseWasmDataSegmentBytes",
            Self::InstantiateWasmInstructions => "InstantiateWasmInstructions",
            Self::InstantiateWasmFunctions => "InstantiateWasmFunctions",
            Self::InstantiateWasmGlobals => "InstantiateWasmGlobals",
            Self::InstantiateWasmTableEntries => "InstantiateWasmTableEntries",
            Self::InstantiateWasmTypes => "InstantiateWasmTypes",
            Self::InstantiateWasmDataSegments => "InstantiateWasmDataSegments",
            Self::InstantiateWasmElemSegments => "InstantiateWasmElemSegments",
            Self::InstantiateWasmImports => "InstantiateWasmImports",
            Self::InstantiateWasmExports => "InstantiateWasmExports",
            Self::InstantiateWasmDataSegmentBytes => "InstantiateWasmDataSegmentBytes",
            Self::Sec1DecodePointUncompressed => "Sec1DecodePointUncompressed",
            Self::VerifyEcdsaSecp256r1Sig => "VerifyEcdsaSecp256r1Sig",
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractCostType; 45] {
        Self::VARIANTS
    }
}

impl Name for ContractCostType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ContractCostType> for ContractCostType {
    fn variants() -> slice::Iter<'static, ContractCostType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ContractCostType {}

impl fmt::Display for ContractCostType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ContractCostType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ContractCostType::WasmInsnExec,
            1 => ContractCostType::MemAlloc,
            2 => ContractCostType::MemCpy,
            3 => ContractCostType::MemCmp,
            4 => ContractCostType::DispatchHostFunction,
            5 => ContractCostType::VisitObject,
            6 => ContractCostType::ValSer,
            7 => ContractCostType::ValDeser,
            8 => ContractCostType::ComputeSha256Hash,
            9 => ContractCostType::ComputeEd25519PubKey,
            10 => ContractCostType::VerifyEd25519Sig,
            11 => ContractCostType::VmInstantiation,
            12 => ContractCostType::VmCachedInstantiation,
            13 => ContractCostType::InvokeVmFunction,
            14 => ContractCostType::ComputeKeccak256Hash,
            15 => ContractCostType::DecodeEcdsaCurve256Sig,
            16 => ContractCostType::RecoverEcdsaSecp256k1Key,
            17 => ContractCostType::Int256AddSub,
            18 => ContractCostType::Int256Mul,
            19 => ContractCostType::Int256Div,
            20 => ContractCostType::Int256Pow,
            21 => ContractCostType::Int256Shift,
            22 => ContractCostType::ChaCha20DrawBytes,
            23 => ContractCostType::ParseWasmInstructions,
            24 => ContractCostType::ParseWasmFunctions,
            25 => ContractCostType::ParseWasmGlobals,
            26 => ContractCostType::ParseWasmTableEntries,
            27 => ContractCostType::ParseWasmTypes,
            28 => ContractCostType::ParseWasmDataSegments,
            29 => ContractCostType::ParseWasmElemSegments,
            30 => ContractCostType::ParseWasmImports,
            31 => ContractCostType::ParseWasmExports,
            32 => ContractCostType::ParseWasmDataSegmentBytes,
            33 => ContractCostType::InstantiateWasmInstructions,
            34 => ContractCostType::InstantiateWasmFunctions,
            35 => ContractCostType::InstantiateWasmGlobals,
            36 => ContractCostType::InstantiateWasmTableEntries,
            37 => ContractCostType::InstantiateWasmTypes,
            38 => ContractCostType::InstantiateWasmDataSegments,
            39 => ContractCostType::InstantiateWasmElemSegments,
            40 => ContractCostType::InstantiateWasmImports,
            41 => ContractCostType::InstantiateWasmExports,
            42 => ContractCostType::InstantiateWasmDataSegmentBytes,
            43 => ContractCostType::Sec1DecodePointUncompressed,
            44 => ContractCostType::VerifyEcdsaSecp256r1Sig,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ContractCostType> for i32 {
    #[must_use]
    fn from(e: ContractCostType) -> Self {
        e as Self
    }
}

impl ReadXdr for ContractCostType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ContractCostType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractCostParamEntry is an XDR Struct defines as:
///
/// ```text
/// struct ContractCostParamEntry {
///     // use `ext` to add more terms (e.g. higher order polynomials) in the future
///     ExtensionPoint ext;
///
///     int64 constTerm;
///     int64 linearTerm;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ContractCostParamEntry {
    pub ext: ExtensionPoint,
    pub const_term: i64,
    pub linear_term: i64,
}

impl ReadXdr for ContractCostParamEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
                const_term: i64::read_xdr(r)?,
                linear_term: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractCostParamEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.const_term.write_xdr(w)?;
            self.linear_term.write_xdr(w)?;
            Ok(())
        })
    }
}

/// StateArchivalSettings is an XDR Struct defines as:
///
/// ```text
/// struct StateArchivalSettings {
///     uint32 maxEntryTTL;
///     uint32 minTemporaryTTL;
///     uint32 minPersistentTTL;
///
///     // rent_fee = wfee_rate_average / rent_rate_denominator_for_type
///     int64 persistentRentRateDenominator;
///     int64 tempRentRateDenominator;
///
///     // max number of entries that emit archival meta in a single ledger
///     uint32 maxEntriesToArchive;
///
///     // Number of snapshots to use when calculating average BucketList size
///     uint32 bucketListSizeWindowSampleSize;
///
///     // How often to sample the BucketList size for the average, in ledgers
///     uint32 bucketListWindowSamplePeriod;
///
///     // Maximum number of bytes that we scan for eviction per ledger
///     uint32 evictionScanSize;
///
///     // Lowest BucketList level to be scanned to evict entries
///     uint32 startingEvictionScanLevel;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct StateArchivalSettings {
    pub max_entry_ttl: u32,
    pub min_temporary_ttl: u32,
    pub min_persistent_ttl: u32,
    pub persistent_rent_rate_denominator: i64,
    pub temp_rent_rate_denominator: i64,
    pub max_entries_to_archive: u32,
    pub bucket_list_size_window_sample_size: u32,
    pub bucket_list_window_sample_period: u32,
    pub eviction_scan_size: u32,
    pub starting_eviction_scan_level: u32,
}

impl ReadXdr for StateArchivalSettings {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                max_entry_ttl: u32::read_xdr(r)?,
                min_temporary_ttl: u32::read_xdr(r)?,
                min_persistent_ttl: u32::read_xdr(r)?,
                persistent_rent_rate_denominator: i64::read_xdr(r)?,
                temp_rent_rate_denominator: i64::read_xdr(r)?,
                max_entries_to_archive: u32::read_xdr(r)?,
                bucket_list_size_window_sample_size: u32::read_xdr(r)?,
                bucket_list_window_sample_period: u32::read_xdr(r)?,
                eviction_scan_size: u32::read_xdr(r)?,
                starting_eviction_scan_level: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for StateArchivalSettings {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.max_entry_ttl.write_xdr(w)?;
            self.min_temporary_ttl.write_xdr(w)?;
            self.min_persistent_ttl.write_xdr(w)?;
            self.persistent_rent_rate_denominator.write_xdr(w)?;
            self.temp_rent_rate_denominator.write_xdr(w)?;
            self.max_entries_to_archive.write_xdr(w)?;
            self.bucket_list_size_window_sample_size.write_xdr(w)?;
            self.bucket_list_window_sample_period.write_xdr(w)?;
            self.eviction_scan_size.write_xdr(w)?;
            self.starting_eviction_scan_level.write_xdr(w)?;
            Ok(())
        })
    }
}

/// EvictionIterator is an XDR Struct defines as:
///
/// ```text
/// struct EvictionIterator {
///     uint32 bucketListLevel;
///     bool isCurrBucket;
///     uint64 bucketFileOffset;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct EvictionIterator {
    pub bucket_list_level: u32,
    pub is_curr_bucket: bool,
    pub bucket_file_offset: u64,
}

impl ReadXdr for EvictionIterator {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                bucket_list_level: u32::read_xdr(r)?,
                is_curr_bucket: bool::read_xdr(r)?,
                bucket_file_offset: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for EvictionIterator {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.bucket_list_level.write_xdr(w)?;
            self.is_curr_bucket.write_xdr(w)?;
            self.bucket_file_offset.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ContractCostCountLimit is an XDR Const defines as:
///
/// ```text
/// const CONTRACT_COST_COUNT_LIMIT = 1024;
/// ```
///
pub const CONTRACT_COST_COUNT_LIMIT: u64 = 1024;

/// ContractCostParams is an XDR Typedef defines as:
///
/// ```text
/// typedef ContractCostParamEntry ContractCostParams<CONTRACT_COST_COUNT_LIMIT>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct ContractCostParams(pub VecM<ContractCostParamEntry, 1024>);

impl From<ContractCostParams> for VecM<ContractCostParamEntry, 1024> {
    #[must_use]
    fn from(x: ContractCostParams) -> Self {
        x.0
    }
}

impl From<VecM<ContractCostParamEntry, 1024>> for ContractCostParams {
    #[must_use]
    fn from(x: VecM<ContractCostParamEntry, 1024>) -> Self {
        ContractCostParams(x)
    }
}

impl AsRef<VecM<ContractCostParamEntry, 1024>> for ContractCostParams {
    #[must_use]
    fn as_ref(&self) -> &VecM<ContractCostParamEntry, 1024> {
        &self.0
    }
}

impl ReadXdr for ContractCostParams {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = VecM::<ContractCostParamEntry, 1024>::read_xdr(r)?;
            let v = ContractCostParams(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ContractCostParams {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ContractCostParams {
    type Target = VecM<ContractCostParamEntry, 1024>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ContractCostParams> for Vec<ContractCostParamEntry> {
    #[must_use]
    fn from(x: ContractCostParams) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<ContractCostParamEntry>> for ContractCostParams {
    type Error = Error;
    fn try_from(x: Vec<ContractCostParamEntry>) -> Result<Self> {
        Ok(ContractCostParams(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<ContractCostParamEntry>> for ContractCostParams {
    type Error = Error;
    fn try_from(x: &Vec<ContractCostParamEntry>) -> Result<Self> {
        Ok(ContractCostParams(x.try_into()?))
    }
}

impl AsRef<Vec<ContractCostParamEntry>> for ContractCostParams {
    #[must_use]
    fn as_ref(&self) -> &Vec<ContractCostParamEntry> {
        &self.0 .0
    }
}

impl AsRef<[ContractCostParamEntry]> for ContractCostParams {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[ContractCostParamEntry] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[ContractCostParamEntry] {
        self.0 .0
    }
}

/// ConfigSettingId is an XDR Enum defines as:
///
/// ```text
/// enum ConfigSettingID
/// {
///     CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES = 0,
///     CONFIG_SETTING_CONTRACT_COMPUTE_V0 = 1,
///     CONFIG_SETTING_CONTRACT_LEDGER_COST_V0 = 2,
///     CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0 = 3,
///     CONFIG_SETTING_CONTRACT_EVENTS_V0 = 4,
///     CONFIG_SETTING_CONTRACT_BANDWIDTH_V0 = 5,
///     CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS = 6,
///     CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES = 7,
///     CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES = 8,
///     CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES = 9,
///     CONFIG_SETTING_STATE_ARCHIVAL = 10,
///     CONFIG_SETTING_CONTRACT_EXECUTION_LANES = 11,
///     CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW = 12,
///     CONFIG_SETTING_EVICTION_ITERATOR = 13
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ConfigSettingId {
    ContractMaxSizeBytes = 0,
    ContractComputeV0 = 1,
    ContractLedgerCostV0 = 2,
    ContractHistoricalDataV0 = 3,
    ContractEventsV0 = 4,
    ContractBandwidthV0 = 5,
    ContractCostParamsCpuInstructions = 6,
    ContractCostParamsMemoryBytes = 7,
    ContractDataKeySizeBytes = 8,
    ContractDataEntrySizeBytes = 9,
    StateArchival = 10,
    ContractExecutionLanes = 11,
    BucketlistSizeWindow = 12,
    EvictionIterator = 13,
}

impl ConfigSettingId {
    pub const VARIANTS: [ConfigSettingId; 14] = [
        ConfigSettingId::ContractMaxSizeBytes,
        ConfigSettingId::ContractComputeV0,
        ConfigSettingId::ContractLedgerCostV0,
        ConfigSettingId::ContractHistoricalDataV0,
        ConfigSettingId::ContractEventsV0,
        ConfigSettingId::ContractBandwidthV0,
        ConfigSettingId::ContractCostParamsCpuInstructions,
        ConfigSettingId::ContractCostParamsMemoryBytes,
        ConfigSettingId::ContractDataKeySizeBytes,
        ConfigSettingId::ContractDataEntrySizeBytes,
        ConfigSettingId::StateArchival,
        ConfigSettingId::ContractExecutionLanes,
        ConfigSettingId::BucketlistSizeWindow,
        ConfigSettingId::EvictionIterator,
    ];
    pub const VARIANTS_STR: [&'static str; 14] = [
        "ContractMaxSizeBytes",
        "ContractComputeV0",
        "ContractLedgerCostV0",
        "ContractHistoricalDataV0",
        "ContractEventsV0",
        "ContractBandwidthV0",
        "ContractCostParamsCpuInstructions",
        "ContractCostParamsMemoryBytes",
        "ContractDataKeySizeBytes",
        "ContractDataEntrySizeBytes",
        "StateArchival",
        "ContractExecutionLanes",
        "BucketlistSizeWindow",
        "EvictionIterator",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ContractMaxSizeBytes => "ContractMaxSizeBytes",
            Self::ContractComputeV0 => "ContractComputeV0",
            Self::ContractLedgerCostV0 => "ContractLedgerCostV0",
            Self::ContractHistoricalDataV0 => "ContractHistoricalDataV0",
            Self::ContractEventsV0 => "ContractEventsV0",
            Self::ContractBandwidthV0 => "ContractBandwidthV0",
            Self::ContractCostParamsCpuInstructions => "ContractCostParamsCpuInstructions",
            Self::ContractCostParamsMemoryBytes => "ContractCostParamsMemoryBytes",
            Self::ContractDataKeySizeBytes => "ContractDataKeySizeBytes",
            Self::ContractDataEntrySizeBytes => "ContractDataEntrySizeBytes",
            Self::StateArchival => "StateArchival",
            Self::ContractExecutionLanes => "ContractExecutionLanes",
            Self::BucketlistSizeWindow => "BucketlistSizeWindow",
            Self::EvictionIterator => "EvictionIterator",
        }
    }

    #[must_use]
    pub const fn variants() -> [ConfigSettingId; 14] {
        Self::VARIANTS
    }
}

impl Name for ConfigSettingId {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ConfigSettingId> for ConfigSettingId {
    fn variants() -> slice::Iter<'static, ConfigSettingId> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ConfigSettingId {}

impl fmt::Display for ConfigSettingId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ConfigSettingId {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ConfigSettingId::ContractMaxSizeBytes,
            1 => ConfigSettingId::ContractComputeV0,
            2 => ConfigSettingId::ContractLedgerCostV0,
            3 => ConfigSettingId::ContractHistoricalDataV0,
            4 => ConfigSettingId::ContractEventsV0,
            5 => ConfigSettingId::ContractBandwidthV0,
            6 => ConfigSettingId::ContractCostParamsCpuInstructions,
            7 => ConfigSettingId::ContractCostParamsMemoryBytes,
            8 => ConfigSettingId::ContractDataKeySizeBytes,
            9 => ConfigSettingId::ContractDataEntrySizeBytes,
            10 => ConfigSettingId::StateArchival,
            11 => ConfigSettingId::ContractExecutionLanes,
            12 => ConfigSettingId::BucketlistSizeWindow,
            13 => ConfigSettingId::EvictionIterator,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ConfigSettingId> for i32 {
    #[must_use]
    fn from(e: ConfigSettingId) -> Self {
        e as Self
    }
}

impl ReadXdr for ConfigSettingId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ConfigSettingId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ConfigSettingEntry is an XDR Union defines as:
///
/// ```text
/// union ConfigSettingEntry switch (ConfigSettingID configSettingID)
/// {
/// case CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES:
///     uint32 contractMaxSizeBytes;
/// case CONFIG_SETTING_CONTRACT_COMPUTE_V0:
///     ConfigSettingContractComputeV0 contractCompute;
/// case CONFIG_SETTING_CONTRACT_LEDGER_COST_V0:
///     ConfigSettingContractLedgerCostV0 contractLedgerCost;
/// case CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0:
///     ConfigSettingContractHistoricalDataV0 contractHistoricalData;
/// case CONFIG_SETTING_CONTRACT_EVENTS_V0:
///     ConfigSettingContractEventsV0 contractEvents;
/// case CONFIG_SETTING_CONTRACT_BANDWIDTH_V0:
///     ConfigSettingContractBandwidthV0 contractBandwidth;
/// case CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS:
///     ContractCostParams contractCostParamsCpuInsns;
/// case CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES:
///     ContractCostParams contractCostParamsMemBytes;
/// case CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES:
///     uint32 contractDataKeySizeBytes;
/// case CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES:
///     uint32 contractDataEntrySizeBytes;
/// case CONFIG_SETTING_STATE_ARCHIVAL:
///     StateArchivalSettings stateArchivalSettings;
/// case CONFIG_SETTING_CONTRACT_EXECUTION_LANES:
///     ConfigSettingContractExecutionLanesV0 contractExecutionLanes;
/// case CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW:
///     uint64 bucketListSizeWindow<>;
/// case CONFIG_SETTING_EVICTION_ITERATOR:
///     EvictionIterator evictionIterator;
/// };
/// ```
///
// union with discriminant ConfigSettingId
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ConfigSettingEntry {
    ContractMaxSizeBytes(u32),
    ContractComputeV0(ConfigSettingContractComputeV0),
    ContractLedgerCostV0(ConfigSettingContractLedgerCostV0),
    ContractHistoricalDataV0(ConfigSettingContractHistoricalDataV0),
    ContractEventsV0(ConfigSettingContractEventsV0),
    ContractBandwidthV0(ConfigSettingContractBandwidthV0),
    ContractCostParamsCpuInstructions(ContractCostParams),
    ContractCostParamsMemoryBytes(ContractCostParams),
    ContractDataKeySizeBytes(u32),
    ContractDataEntrySizeBytes(u32),
    StateArchival(StateArchivalSettings),
    ContractExecutionLanes(ConfigSettingContractExecutionLanesV0),
    BucketlistSizeWindow(VecM<u64>),
    EvictionIterator(EvictionIterator),
}

impl ConfigSettingEntry {
    pub const VARIANTS: [ConfigSettingId; 14] = [
        ConfigSettingId::ContractMaxSizeBytes,
        ConfigSettingId::ContractComputeV0,
        ConfigSettingId::ContractLedgerCostV0,
        ConfigSettingId::ContractHistoricalDataV0,
        ConfigSettingId::ContractEventsV0,
        ConfigSettingId::ContractBandwidthV0,
        ConfigSettingId::ContractCostParamsCpuInstructions,
        ConfigSettingId::ContractCostParamsMemoryBytes,
        ConfigSettingId::ContractDataKeySizeBytes,
        ConfigSettingId::ContractDataEntrySizeBytes,
        ConfigSettingId::StateArchival,
        ConfigSettingId::ContractExecutionLanes,
        ConfigSettingId::BucketlistSizeWindow,
        ConfigSettingId::EvictionIterator,
    ];
    pub const VARIANTS_STR: [&'static str; 14] = [
        "ContractMaxSizeBytes",
        "ContractComputeV0",
        "ContractLedgerCostV0",
        "ContractHistoricalDataV0",
        "ContractEventsV0",
        "ContractBandwidthV0",
        "ContractCostParamsCpuInstructions",
        "ContractCostParamsMemoryBytes",
        "ContractDataKeySizeBytes",
        "ContractDataEntrySizeBytes",
        "StateArchival",
        "ContractExecutionLanes",
        "BucketlistSizeWindow",
        "EvictionIterator",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ContractMaxSizeBytes(_) => "ContractMaxSizeBytes",
            Self::ContractComputeV0(_) => "ContractComputeV0",
            Self::ContractLedgerCostV0(_) => "ContractLedgerCostV0",
            Self::ContractHistoricalDataV0(_) => "ContractHistoricalDataV0",
            Self::ContractEventsV0(_) => "ContractEventsV0",
            Self::ContractBandwidthV0(_) => "ContractBandwidthV0",
            Self::ContractCostParamsCpuInstructions(_) => "ContractCostParamsCpuInstructions",
            Self::ContractCostParamsMemoryBytes(_) => "ContractCostParamsMemoryBytes",
            Self::ContractDataKeySizeBytes(_) => "ContractDataKeySizeBytes",
            Self::ContractDataEntrySizeBytes(_) => "ContractDataEntrySizeBytes",
            Self::StateArchival(_) => "StateArchival",
            Self::ContractExecutionLanes(_) => "ContractExecutionLanes",
            Self::BucketlistSizeWindow(_) => "BucketlistSizeWindow",
            Self::EvictionIterator(_) => "EvictionIterator",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ConfigSettingId {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ContractMaxSizeBytes(_) => ConfigSettingId::ContractMaxSizeBytes,
            Self::ContractComputeV0(_) => ConfigSettingId::ContractComputeV0,
            Self::ContractLedgerCostV0(_) => ConfigSettingId::ContractLedgerCostV0,
            Self::ContractHistoricalDataV0(_) => ConfigSettingId::ContractHistoricalDataV0,
            Self::ContractEventsV0(_) => ConfigSettingId::ContractEventsV0,
            Self::ContractBandwidthV0(_) => ConfigSettingId::ContractBandwidthV0,
            Self::ContractCostParamsCpuInstructions(_) => {
                ConfigSettingId::ContractCostParamsCpuInstructions
            }
            Self::ContractCostParamsMemoryBytes(_) => {
                ConfigSettingId::ContractCostParamsMemoryBytes
            }
            Self::ContractDataKeySizeBytes(_) => ConfigSettingId::ContractDataKeySizeBytes,
            Self::ContractDataEntrySizeBytes(_) => ConfigSettingId::ContractDataEntrySizeBytes,
            Self::StateArchival(_) => ConfigSettingId::StateArchival,
            Self::ContractExecutionLanes(_) => ConfigSettingId::ContractExecutionLanes,
            Self::BucketlistSizeWindow(_) => ConfigSettingId::BucketlistSizeWindow,
            Self::EvictionIterator(_) => ConfigSettingId::EvictionIterator,
        }
    }

    #[must_use]
    pub const fn variants() -> [ConfigSettingId; 14] {
        Self::VARIANTS
    }
}

impl Name for ConfigSettingEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ConfigSettingId> for ConfigSettingEntry {
    #[must_use]
    fn discriminant(&self) -> ConfigSettingId {
        Self::discriminant(self)
    }
}

impl Variants<ConfigSettingId> for ConfigSettingEntry {
    fn variants() -> slice::Iter<'static, ConfigSettingId> {
        Self::VARIANTS.iter()
    }
}

impl Union<ConfigSettingId> for ConfigSettingEntry {}

impl ReadXdr for ConfigSettingEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ConfigSettingId = <ConfigSettingId as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ConfigSettingId::ContractMaxSizeBytes => {
                    Self::ContractMaxSizeBytes(u32::read_xdr(r)?)
                }
                ConfigSettingId::ContractComputeV0 => {
                    Self::ContractComputeV0(ConfigSettingContractComputeV0::read_xdr(r)?)
                }
                ConfigSettingId::ContractLedgerCostV0 => {
                    Self::ContractLedgerCostV0(ConfigSettingContractLedgerCostV0::read_xdr(r)?)
                }
                ConfigSettingId::ContractHistoricalDataV0 => Self::ContractHistoricalDataV0(
                    ConfigSettingContractHistoricalDataV0::read_xdr(r)?,
                ),
                ConfigSettingId::ContractEventsV0 => {
                    Self::ContractEventsV0(ConfigSettingContractEventsV0::read_xdr(r)?)
                }
                ConfigSettingId::ContractBandwidthV0 => {
                    Self::ContractBandwidthV0(ConfigSettingContractBandwidthV0::read_xdr(r)?)
                }
                ConfigSettingId::ContractCostParamsCpuInstructions => {
                    Self::ContractCostParamsCpuInstructions(ContractCostParams::read_xdr(r)?)
                }
                ConfigSettingId::ContractCostParamsMemoryBytes => {
                    Self::ContractCostParamsMemoryBytes(ContractCostParams::read_xdr(r)?)
                }
                ConfigSettingId::ContractDataKeySizeBytes => {
                    Self::ContractDataKeySizeBytes(u32::read_xdr(r)?)
                }
                ConfigSettingId::ContractDataEntrySizeBytes => {
                    Self::ContractDataEntrySizeBytes(u32::read_xdr(r)?)
                }
                ConfigSettingId::StateArchival => {
                    Self::StateArchival(StateArchivalSettings::read_xdr(r)?)
                }
                ConfigSettingId::ContractExecutionLanes => Self::ContractExecutionLanes(
                    ConfigSettingContractExecutionLanesV0::read_xdr(r)?,
                ),
                ConfigSettingId::BucketlistSizeWindow => {
                    Self::BucketlistSizeWindow(VecM::<u64>::read_xdr(r)?)
                }
                ConfigSettingId::EvictionIterator => {
                    Self::EvictionIterator(EvictionIterator::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ConfigSettingEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ContractMaxSizeBytes(v) => v.write_xdr(w)?,
                Self::ContractComputeV0(v) => v.write_xdr(w)?,
                Self::ContractLedgerCostV0(v) => v.write_xdr(w)?,
                Self::ContractHistoricalDataV0(v) => v.write_xdr(w)?,
                Self::ContractEventsV0(v) => v.write_xdr(w)?,
                Self::ContractBandwidthV0(v) => v.write_xdr(w)?,
                Self::ContractCostParamsCpuInstructions(v) => v.write_xdr(w)?,
                Self::ContractCostParamsMemoryBytes(v) => v.write_xdr(w)?,
                Self::ContractDataKeySizeBytes(v) => v.write_xdr(w)?,
                Self::ContractDataEntrySizeBytes(v) => v.write_xdr(w)?,
                Self::StateArchival(v) => v.write_xdr(w)?,
                Self::ContractExecutionLanes(v) => v.write_xdr(w)?,
                Self::BucketlistSizeWindow(v) => v.write_xdr(w)?,
                Self::EvictionIterator(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScEnvMetaKind is an XDR Enum defines as:
///
/// ```text
/// enum SCEnvMetaKind
/// {
///     SC_ENV_META_KIND_INTERFACE_VERSION = 0
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ScEnvMetaKind {
    ScEnvMetaKindInterfaceVersion = 0,
}

impl ScEnvMetaKind {
    pub const VARIANTS: [ScEnvMetaKind; 1] = [ScEnvMetaKind::ScEnvMetaKindInterfaceVersion];
    pub const VARIANTS_STR: [&'static str; 1] = ["ScEnvMetaKindInterfaceVersion"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScEnvMetaKindInterfaceVersion => "ScEnvMetaKindInterfaceVersion",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScEnvMetaKind; 1] {
        Self::VARIANTS
    }
}

impl Name for ScEnvMetaKind {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScEnvMetaKind> for ScEnvMetaKind {
    fn variants() -> slice::Iter<'static, ScEnvMetaKind> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScEnvMetaKind {}

impl fmt::Display for ScEnvMetaKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScEnvMetaKind {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ScEnvMetaKind::ScEnvMetaKindInterfaceVersion,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScEnvMetaKind> for i32 {
    #[must_use]
    fn from(e: ScEnvMetaKind) -> Self {
        e as Self
    }
}

impl ReadXdr for ScEnvMetaKind {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScEnvMetaKind {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScEnvMetaEntry is an XDR Union defines as:
///
/// ```text
/// union SCEnvMetaEntry switch (SCEnvMetaKind kind)
/// {
/// case SC_ENV_META_KIND_INTERFACE_VERSION:
///     uint64 interfaceVersion;
/// };
/// ```
///
// union with discriminant ScEnvMetaKind
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ScEnvMetaEntry {
    ScEnvMetaKindInterfaceVersion(u64),
}

impl ScEnvMetaEntry {
    pub const VARIANTS: [ScEnvMetaKind; 1] = [ScEnvMetaKind::ScEnvMetaKindInterfaceVersion];
    pub const VARIANTS_STR: [&'static str; 1] = ["ScEnvMetaKindInterfaceVersion"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScEnvMetaKindInterfaceVersion(_) => "ScEnvMetaKindInterfaceVersion",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScEnvMetaKind {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ScEnvMetaKindInterfaceVersion(_) => ScEnvMetaKind::ScEnvMetaKindInterfaceVersion,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScEnvMetaKind; 1] {
        Self::VARIANTS
    }
}

impl Name for ScEnvMetaEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScEnvMetaKind> for ScEnvMetaEntry {
    #[must_use]
    fn discriminant(&self) -> ScEnvMetaKind {
        Self::discriminant(self)
    }
}

impl Variants<ScEnvMetaKind> for ScEnvMetaEntry {
    fn variants() -> slice::Iter<'static, ScEnvMetaKind> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScEnvMetaKind> for ScEnvMetaEntry {}

impl ReadXdr for ScEnvMetaEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ScEnvMetaKind = <ScEnvMetaKind as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScEnvMetaKind::ScEnvMetaKindInterfaceVersion => {
                    Self::ScEnvMetaKindInterfaceVersion(u64::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScEnvMetaEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ScEnvMetaKindInterfaceVersion(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScMetaV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCMetaV0
/// {
///     string key<>;
///     string val<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScMetaV0 {
    pub key: StringM,
    pub val: StringM,
}

impl ReadXdr for ScMetaV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: StringM::read_xdr(r)?,
                val: StringM::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScMetaV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;
            self.val.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScMetaKind is an XDR Enum defines as:
///
/// ```text
/// enum SCMetaKind
/// {
///     SC_META_V0 = 0
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ScMetaKind {
    ScMetaV0 = 0,
}

impl ScMetaKind {
    pub const VARIANTS: [ScMetaKind; 1] = [ScMetaKind::ScMetaV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ScMetaV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScMetaV0 => "ScMetaV0",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScMetaKind; 1] {
        Self::VARIANTS
    }
}

impl Name for ScMetaKind {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScMetaKind> for ScMetaKind {
    fn variants() -> slice::Iter<'static, ScMetaKind> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScMetaKind {}

impl fmt::Display for ScMetaKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScMetaKind {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ScMetaKind::ScMetaV0,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScMetaKind> for i32 {
    #[must_use]
    fn from(e: ScMetaKind) -> Self {
        e as Self
    }
}

impl ReadXdr for ScMetaKind {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScMetaKind {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScMetaEntry is an XDR Union defines as:
///
/// ```text
/// union SCMetaEntry switch (SCMetaKind kind)
/// {
/// case SC_META_V0:
///     SCMetaV0 v0;
/// };
/// ```
///
// union with discriminant ScMetaKind
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ScMetaEntry {
    ScMetaV0(ScMetaV0),
}

impl ScMetaEntry {
    pub const VARIANTS: [ScMetaKind; 1] = [ScMetaKind::ScMetaV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ScMetaV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ScMetaV0(_) => "ScMetaV0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScMetaKind {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ScMetaV0(_) => ScMetaKind::ScMetaV0,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScMetaKind; 1] {
        Self::VARIANTS
    }
}

impl Name for ScMetaEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScMetaKind> for ScMetaEntry {
    #[must_use]
    fn discriminant(&self) -> ScMetaKind {
        Self::discriminant(self)
    }
}

impl Variants<ScMetaKind> for ScMetaEntry {
    fn variants() -> slice::Iter<'static, ScMetaKind> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScMetaKind> for ScMetaEntry {}

impl ReadXdr for ScMetaEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ScMetaKind = <ScMetaKind as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScMetaKind::ScMetaV0 => Self::ScMetaV0(ScMetaV0::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScMetaEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ScMetaV0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScSpecDocLimit is an XDR Const defines as:
///
/// ```text
/// const SC_SPEC_DOC_LIMIT = 1024;
/// ```
///
pub const SC_SPEC_DOC_LIMIT: u64 = 1024;

/// ScSpecType is an XDR Enum defines as:
///
/// ```text
/// enum SCSpecType
/// {
///     SC_SPEC_TYPE_VAL = 0,
///
///     // Types with no parameters.
///     SC_SPEC_TYPE_BOOL = 1,
///     SC_SPEC_TYPE_VOID = 2,
///     SC_SPEC_TYPE_ERROR = 3,
///     SC_SPEC_TYPE_U32 = 4,
///     SC_SPEC_TYPE_I32 = 5,
///     SC_SPEC_TYPE_U64 = 6,
///     SC_SPEC_TYPE_I64 = 7,
///     SC_SPEC_TYPE_TIMEPOINT = 8,
///     SC_SPEC_TYPE_DURATION = 9,
///     SC_SPEC_TYPE_U128 = 10,
///     SC_SPEC_TYPE_I128 = 11,
///     SC_SPEC_TYPE_U256 = 12,
///     SC_SPEC_TYPE_I256 = 13,
///     SC_SPEC_TYPE_BYTES = 14,
///     SC_SPEC_TYPE_STRING = 16,
///     SC_SPEC_TYPE_SYMBOL = 17,
///     SC_SPEC_TYPE_ADDRESS = 19,
///
///     // Types with parameters.
///     SC_SPEC_TYPE_OPTION = 1000,
///     SC_SPEC_TYPE_RESULT = 1001,
///     SC_SPEC_TYPE_VEC = 1002,
///     SC_SPEC_TYPE_MAP = 1004,
///     SC_SPEC_TYPE_TUPLE = 1005,
///     SC_SPEC_TYPE_BYTES_N = 1006,
///
///     // User defined types.
///     SC_SPEC_TYPE_UDT = 2000
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ScSpecType {
    Val = 0,
    Bool = 1,
    Void = 2,
    Error = 3,
    U32 = 4,
    I32 = 5,
    U64 = 6,
    I64 = 7,
    Timepoint = 8,
    Duration = 9,
    U128 = 10,
    I128 = 11,
    U256 = 12,
    I256 = 13,
    Bytes = 14,
    String = 16,
    Symbol = 17,
    Address = 19,
    Option = 1000,
    Result = 1001,
    Vec = 1002,
    Map = 1004,
    Tuple = 1005,
    BytesN = 1006,
    Udt = 2000,
}

impl ScSpecType {
    pub const VARIANTS: [ScSpecType; 25] = [
        ScSpecType::Val,
        ScSpecType::Bool,
        ScSpecType::Void,
        ScSpecType::Error,
        ScSpecType::U32,
        ScSpecType::I32,
        ScSpecType::U64,
        ScSpecType::I64,
        ScSpecType::Timepoint,
        ScSpecType::Duration,
        ScSpecType::U128,
        ScSpecType::I128,
        ScSpecType::U256,
        ScSpecType::I256,
        ScSpecType::Bytes,
        ScSpecType::String,
        ScSpecType::Symbol,
        ScSpecType::Address,
        ScSpecType::Option,
        ScSpecType::Result,
        ScSpecType::Vec,
        ScSpecType::Map,
        ScSpecType::Tuple,
        ScSpecType::BytesN,
        ScSpecType::Udt,
    ];
    pub const VARIANTS_STR: [&'static str; 25] = [
        "Val",
        "Bool",
        "Void",
        "Error",
        "U32",
        "I32",
        "U64",
        "I64",
        "Timepoint",
        "Duration",
        "U128",
        "I128",
        "U256",
        "I256",
        "Bytes",
        "String",
        "Symbol",
        "Address",
        "Option",
        "Result",
        "Vec",
        "Map",
        "Tuple",
        "BytesN",
        "Udt",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Val => "Val",
            Self::Bool => "Bool",
            Self::Void => "Void",
            Self::Error => "Error",
            Self::U32 => "U32",
            Self::I32 => "I32",
            Self::U64 => "U64",
            Self::I64 => "I64",
            Self::Timepoint => "Timepoint",
            Self::Duration => "Duration",
            Self::U128 => "U128",
            Self::I128 => "I128",
            Self::U256 => "U256",
            Self::I256 => "I256",
            Self::Bytes => "Bytes",
            Self::String => "String",
            Self::Symbol => "Symbol",
            Self::Address => "Address",
            Self::Option => "Option",
            Self::Result => "Result",
            Self::Vec => "Vec",
            Self::Map => "Map",
            Self::Tuple => "Tuple",
            Self::BytesN => "BytesN",
            Self::Udt => "Udt",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecType; 25] {
        Self::VARIANTS
    }
}

impl Name for ScSpecType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScSpecType> for ScSpecType {
    fn variants() -> slice::Iter<'static, ScSpecType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScSpecType {}

impl fmt::Display for ScSpecType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScSpecType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ScSpecType::Val,
            1 => ScSpecType::Bool,
            2 => ScSpecType::Void,
            3 => ScSpecType::Error,
            4 => ScSpecType::U32,
            5 => ScSpecType::I32,
            6 => ScSpecType::U64,
            7 => ScSpecType::I64,
            8 => ScSpecType::Timepoint,
            9 => ScSpecType::Duration,
            10 => ScSpecType::U128,
            11 => ScSpecType::I128,
            12 => ScSpecType::U256,
            13 => ScSpecType::I256,
            14 => ScSpecType::Bytes,
            16 => ScSpecType::String,
            17 => ScSpecType::Symbol,
            19 => ScSpecType::Address,
            1000 => ScSpecType::Option,
            1001 => ScSpecType::Result,
            1002 => ScSpecType::Vec,
            1004 => ScSpecType::Map,
            1005 => ScSpecType::Tuple,
            1006 => ScSpecType::BytesN,
            2000 => ScSpecType::Udt,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScSpecType> for i32 {
    #[must_use]
    fn from(e: ScSpecType) -> Self {
        e as Self
    }
}

impl ReadXdr for ScSpecType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScSpecTypeOption is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecTypeOption
/// {
///     SCSpecTypeDef valueType;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecTypeOption {
    pub value_type: Box<ScSpecTypeDef>,
}

impl ReadXdr for ScSpecTypeOption {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                value_type: Box::<ScSpecTypeDef>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeOption {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.value_type.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecTypeResult is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecTypeResult
/// {
///     SCSpecTypeDef okType;
///     SCSpecTypeDef errorType;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecTypeResult {
    pub ok_type: Box<ScSpecTypeDef>,
    pub error_type: Box<ScSpecTypeDef>,
}

impl ReadXdr for ScSpecTypeResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ok_type: Box::<ScSpecTypeDef>::read_xdr(r)?,
                error_type: Box::<ScSpecTypeDef>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ok_type.write_xdr(w)?;
            self.error_type.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecTypeVec is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecTypeVec
/// {
///     SCSpecTypeDef elementType;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecTypeVec {
    pub element_type: Box<ScSpecTypeDef>,
}

impl ReadXdr for ScSpecTypeVec {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                element_type: Box::<ScSpecTypeDef>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeVec {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.element_type.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecTypeMap is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecTypeMap
/// {
///     SCSpecTypeDef keyType;
///     SCSpecTypeDef valueType;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecTypeMap {
    pub key_type: Box<ScSpecTypeDef>,
    pub value_type: Box<ScSpecTypeDef>,
}

impl ReadXdr for ScSpecTypeMap {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key_type: Box::<ScSpecTypeDef>::read_xdr(r)?,
                value_type: Box::<ScSpecTypeDef>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeMap {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.key_type.write_xdr(w)?;
            self.value_type.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecTypeTuple is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecTypeTuple
/// {
///     SCSpecTypeDef valueTypes<12>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecTypeTuple {
    pub value_types: VecM<ScSpecTypeDef, 12>,
}

impl ReadXdr for ScSpecTypeTuple {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                value_types: VecM::<ScSpecTypeDef, 12>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeTuple {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.value_types.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecTypeBytesN is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecTypeBytesN
/// {
///     uint32 n;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecTypeBytesN {
    pub n: u32,
}

impl ReadXdr for ScSpecTypeBytesN {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                n: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeBytesN {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.n.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecTypeUdt is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecTypeUDT
/// {
///     string name<60>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecTypeUdt {
    pub name: StringM<60>,
}

impl ReadXdr for ScSpecTypeUdt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                name: StringM::<60>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecTypeUdt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.name.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecTypeDef is an XDR Union defines as:
///
/// ```text
/// union SCSpecTypeDef switch (SCSpecType type)
/// {
/// case SC_SPEC_TYPE_VAL:
/// case SC_SPEC_TYPE_BOOL:
/// case SC_SPEC_TYPE_VOID:
/// case SC_SPEC_TYPE_ERROR:
/// case SC_SPEC_TYPE_U32:
/// case SC_SPEC_TYPE_I32:
/// case SC_SPEC_TYPE_U64:
/// case SC_SPEC_TYPE_I64:
/// case SC_SPEC_TYPE_TIMEPOINT:
/// case SC_SPEC_TYPE_DURATION:
/// case SC_SPEC_TYPE_U128:
/// case SC_SPEC_TYPE_I128:
/// case SC_SPEC_TYPE_U256:
/// case SC_SPEC_TYPE_I256:
/// case SC_SPEC_TYPE_BYTES:
/// case SC_SPEC_TYPE_STRING:
/// case SC_SPEC_TYPE_SYMBOL:
/// case SC_SPEC_TYPE_ADDRESS:
///     void;
/// case SC_SPEC_TYPE_OPTION:
///     SCSpecTypeOption option;
/// case SC_SPEC_TYPE_RESULT:
///     SCSpecTypeResult result;
/// case SC_SPEC_TYPE_VEC:
///     SCSpecTypeVec vec;
/// case SC_SPEC_TYPE_MAP:
///     SCSpecTypeMap map;
/// case SC_SPEC_TYPE_TUPLE:
///     SCSpecTypeTuple tuple;
/// case SC_SPEC_TYPE_BYTES_N:
///     SCSpecTypeBytesN bytesN;
/// case SC_SPEC_TYPE_UDT:
///     SCSpecTypeUDT udt;
/// };
/// ```
///
// union with discriminant ScSpecType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ScSpecTypeDef {
    Val,
    Bool,
    Void,
    Error,
    U32,
    I32,
    U64,
    I64,
    Timepoint,
    Duration,
    U128,
    I128,
    U256,
    I256,
    Bytes,
    String,
    Symbol,
    Address,
    Option(Box<ScSpecTypeOption>),
    Result(Box<ScSpecTypeResult>),
    Vec(Box<ScSpecTypeVec>),
    Map(Box<ScSpecTypeMap>),
    Tuple(Box<ScSpecTypeTuple>),
    BytesN(ScSpecTypeBytesN),
    Udt(ScSpecTypeUdt),
}

impl ScSpecTypeDef {
    pub const VARIANTS: [ScSpecType; 25] = [
        ScSpecType::Val,
        ScSpecType::Bool,
        ScSpecType::Void,
        ScSpecType::Error,
        ScSpecType::U32,
        ScSpecType::I32,
        ScSpecType::U64,
        ScSpecType::I64,
        ScSpecType::Timepoint,
        ScSpecType::Duration,
        ScSpecType::U128,
        ScSpecType::I128,
        ScSpecType::U256,
        ScSpecType::I256,
        ScSpecType::Bytes,
        ScSpecType::String,
        ScSpecType::Symbol,
        ScSpecType::Address,
        ScSpecType::Option,
        ScSpecType::Result,
        ScSpecType::Vec,
        ScSpecType::Map,
        ScSpecType::Tuple,
        ScSpecType::BytesN,
        ScSpecType::Udt,
    ];
    pub const VARIANTS_STR: [&'static str; 25] = [
        "Val",
        "Bool",
        "Void",
        "Error",
        "U32",
        "I32",
        "U64",
        "I64",
        "Timepoint",
        "Duration",
        "U128",
        "I128",
        "U256",
        "I256",
        "Bytes",
        "String",
        "Symbol",
        "Address",
        "Option",
        "Result",
        "Vec",
        "Map",
        "Tuple",
        "BytesN",
        "Udt",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Val => "Val",
            Self::Bool => "Bool",
            Self::Void => "Void",
            Self::Error => "Error",
            Self::U32 => "U32",
            Self::I32 => "I32",
            Self::U64 => "U64",
            Self::I64 => "I64",
            Self::Timepoint => "Timepoint",
            Self::Duration => "Duration",
            Self::U128 => "U128",
            Self::I128 => "I128",
            Self::U256 => "U256",
            Self::I256 => "I256",
            Self::Bytes => "Bytes",
            Self::String => "String",
            Self::Symbol => "Symbol",
            Self::Address => "Address",
            Self::Option(_) => "Option",
            Self::Result(_) => "Result",
            Self::Vec(_) => "Vec",
            Self::Map(_) => "Map",
            Self::Tuple(_) => "Tuple",
            Self::BytesN(_) => "BytesN",
            Self::Udt(_) => "Udt",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScSpecType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Val => ScSpecType::Val,
            Self::Bool => ScSpecType::Bool,
            Self::Void => ScSpecType::Void,
            Self::Error => ScSpecType::Error,
            Self::U32 => ScSpecType::U32,
            Self::I32 => ScSpecType::I32,
            Self::U64 => ScSpecType::U64,
            Self::I64 => ScSpecType::I64,
            Self::Timepoint => ScSpecType::Timepoint,
            Self::Duration => ScSpecType::Duration,
            Self::U128 => ScSpecType::U128,
            Self::I128 => ScSpecType::I128,
            Self::U256 => ScSpecType::U256,
            Self::I256 => ScSpecType::I256,
            Self::Bytes => ScSpecType::Bytes,
            Self::String => ScSpecType::String,
            Self::Symbol => ScSpecType::Symbol,
            Self::Address => ScSpecType::Address,
            Self::Option(_) => ScSpecType::Option,
            Self::Result(_) => ScSpecType::Result,
            Self::Vec(_) => ScSpecType::Vec,
            Self::Map(_) => ScSpecType::Map,
            Self::Tuple(_) => ScSpecType::Tuple,
            Self::BytesN(_) => ScSpecType::BytesN,
            Self::Udt(_) => ScSpecType::Udt,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecType; 25] {
        Self::VARIANTS
    }
}

impl Name for ScSpecTypeDef {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScSpecType> for ScSpecTypeDef {
    #[must_use]
    fn discriminant(&self) -> ScSpecType {
        Self::discriminant(self)
    }
}

impl Variants<ScSpecType> for ScSpecTypeDef {
    fn variants() -> slice::Iter<'static, ScSpecType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScSpecType> for ScSpecTypeDef {}

impl ReadXdr for ScSpecTypeDef {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ScSpecType = <ScSpecType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScSpecType::Val => Self::Val,
                ScSpecType::Bool => Self::Bool,
                ScSpecType::Void => Self::Void,
                ScSpecType::Error => Self::Error,
                ScSpecType::U32 => Self::U32,
                ScSpecType::I32 => Self::I32,
                ScSpecType::U64 => Self::U64,
                ScSpecType::I64 => Self::I64,
                ScSpecType::Timepoint => Self::Timepoint,
                ScSpecType::Duration => Self::Duration,
                ScSpecType::U128 => Self::U128,
                ScSpecType::I128 => Self::I128,
                ScSpecType::U256 => Self::U256,
                ScSpecType::I256 => Self::I256,
                ScSpecType::Bytes => Self::Bytes,
                ScSpecType::String => Self::String,
                ScSpecType::Symbol => Self::Symbol,
                ScSpecType::Address => Self::Address,
                ScSpecType::Option => Self::Option(Box::<ScSpecTypeOption>::read_xdr(r)?),
                ScSpecType::Result => Self::Result(Box::<ScSpecTypeResult>::read_xdr(r)?),
                ScSpecType::Vec => Self::Vec(Box::<ScSpecTypeVec>::read_xdr(r)?),
                ScSpecType::Map => Self::Map(Box::<ScSpecTypeMap>::read_xdr(r)?),
                ScSpecType::Tuple => Self::Tuple(Box::<ScSpecTypeTuple>::read_xdr(r)?),
                ScSpecType::BytesN => Self::BytesN(ScSpecTypeBytesN::read_xdr(r)?),
                ScSpecType::Udt => Self::Udt(ScSpecTypeUdt::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecTypeDef {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Val => ().write_xdr(w)?,
                Self::Bool => ().write_xdr(w)?,
                Self::Void => ().write_xdr(w)?,
                Self::Error => ().write_xdr(w)?,
                Self::U32 => ().write_xdr(w)?,
                Self::I32 => ().write_xdr(w)?,
                Self::U64 => ().write_xdr(w)?,
                Self::I64 => ().write_xdr(w)?,
                Self::Timepoint => ().write_xdr(w)?,
                Self::Duration => ().write_xdr(w)?,
                Self::U128 => ().write_xdr(w)?,
                Self::I128 => ().write_xdr(w)?,
                Self::U256 => ().write_xdr(w)?,
                Self::I256 => ().write_xdr(w)?,
                Self::Bytes => ().write_xdr(w)?,
                Self::String => ().write_xdr(w)?,
                Self::Symbol => ().write_xdr(w)?,
                Self::Address => ().write_xdr(w)?,
                Self::Option(v) => v.write_xdr(w)?,
                Self::Result(v) => v.write_xdr(w)?,
                Self::Vec(v) => v.write_xdr(w)?,
                Self::Map(v) => v.write_xdr(w)?,
                Self::Tuple(v) => v.write_xdr(w)?,
                Self::BytesN(v) => v.write_xdr(w)?,
                Self::Udt(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScSpecUdtStructFieldV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecUDTStructFieldV0
/// {
///     string doc<SC_SPEC_DOC_LIMIT>;
///     string name<30>;
///     SCSpecTypeDef type;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecUdtStructFieldV0 {
    pub doc: StringM<1024>,
    pub name: StringM<30>,
    pub type_: ScSpecTypeDef,
}

impl ReadXdr for ScSpecUdtStructFieldV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<1024>::read_xdr(r)?,
                name: StringM::<30>::read_xdr(r)?,
                type_: ScSpecTypeDef::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtStructFieldV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;
            self.name.write_xdr(w)?;
            self.type_.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecUdtStructV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecUDTStructV0
/// {
///     string doc<SC_SPEC_DOC_LIMIT>;
///     string lib<80>;
///     string name<60>;
///     SCSpecUDTStructFieldV0 fields<40>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecUdtStructV0 {
    pub doc: StringM<1024>,
    pub lib: StringM<80>,
    pub name: StringM<60>,
    pub fields: VecM<ScSpecUdtStructFieldV0, 40>,
}

impl ReadXdr for ScSpecUdtStructV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<1024>::read_xdr(r)?,
                lib: StringM::<80>::read_xdr(r)?,
                name: StringM::<60>::read_xdr(r)?,
                fields: VecM::<ScSpecUdtStructFieldV0, 40>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtStructV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;
            self.lib.write_xdr(w)?;
            self.name.write_xdr(w)?;
            self.fields.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecUdtUnionCaseVoidV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecUDTUnionCaseVoidV0
/// {
///     string doc<SC_SPEC_DOC_LIMIT>;
///     string name<60>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecUdtUnionCaseVoidV0 {
    pub doc: StringM<1024>,
    pub name: StringM<60>,
}

impl ReadXdr for ScSpecUdtUnionCaseVoidV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<1024>::read_xdr(r)?,
                name: StringM::<60>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtUnionCaseVoidV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;
            self.name.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecUdtUnionCaseTupleV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecUDTUnionCaseTupleV0
/// {
///     string doc<SC_SPEC_DOC_LIMIT>;
///     string name<60>;
///     SCSpecTypeDef type<12>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecUdtUnionCaseTupleV0 {
    pub doc: StringM<1024>,
    pub name: StringM<60>,
    pub type_: VecM<ScSpecTypeDef, 12>,
}

impl ReadXdr for ScSpecUdtUnionCaseTupleV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<1024>::read_xdr(r)?,
                name: StringM::<60>::read_xdr(r)?,
                type_: VecM::<ScSpecTypeDef, 12>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtUnionCaseTupleV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;
            self.name.write_xdr(w)?;
            self.type_.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecUdtUnionCaseV0Kind is an XDR Enum defines as:
///
/// ```text
/// enum SCSpecUDTUnionCaseV0Kind
/// {
///     SC_SPEC_UDT_UNION_CASE_VOID_V0 = 0,
///     SC_SPEC_UDT_UNION_CASE_TUPLE_V0 = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ScSpecUdtUnionCaseV0Kind {
    VoidV0 = 0,
    TupleV0 = 1,
}

impl ScSpecUdtUnionCaseV0Kind {
    pub const VARIANTS: [ScSpecUdtUnionCaseV0Kind; 2] = [
        ScSpecUdtUnionCaseV0Kind::VoidV0,
        ScSpecUdtUnionCaseV0Kind::TupleV0,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["VoidV0", "TupleV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::VoidV0 => "VoidV0",
            Self::TupleV0 => "TupleV0",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecUdtUnionCaseV0Kind; 2] {
        Self::VARIANTS
    }
}

impl Name for ScSpecUdtUnionCaseV0Kind {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScSpecUdtUnionCaseV0Kind> for ScSpecUdtUnionCaseV0Kind {
    fn variants() -> slice::Iter<'static, ScSpecUdtUnionCaseV0Kind> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScSpecUdtUnionCaseV0Kind {}

impl fmt::Display for ScSpecUdtUnionCaseV0Kind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScSpecUdtUnionCaseV0Kind {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ScSpecUdtUnionCaseV0Kind::VoidV0,
            1 => ScSpecUdtUnionCaseV0Kind::TupleV0,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScSpecUdtUnionCaseV0Kind> for i32 {
    #[must_use]
    fn from(e: ScSpecUdtUnionCaseV0Kind) -> Self {
        e as Self
    }
}

impl ReadXdr for ScSpecUdtUnionCaseV0Kind {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecUdtUnionCaseV0Kind {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScSpecUdtUnionCaseV0 is an XDR Union defines as:
///
/// ```text
/// union SCSpecUDTUnionCaseV0 switch (SCSpecUDTUnionCaseV0Kind kind)
/// {
/// case SC_SPEC_UDT_UNION_CASE_VOID_V0:
///     SCSpecUDTUnionCaseVoidV0 voidCase;
/// case SC_SPEC_UDT_UNION_CASE_TUPLE_V0:
///     SCSpecUDTUnionCaseTupleV0 tupleCase;
/// };
/// ```
///
// union with discriminant ScSpecUdtUnionCaseV0Kind
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ScSpecUdtUnionCaseV0 {
    VoidV0(ScSpecUdtUnionCaseVoidV0),
    TupleV0(ScSpecUdtUnionCaseTupleV0),
}

impl ScSpecUdtUnionCaseV0 {
    pub const VARIANTS: [ScSpecUdtUnionCaseV0Kind; 2] = [
        ScSpecUdtUnionCaseV0Kind::VoidV0,
        ScSpecUdtUnionCaseV0Kind::TupleV0,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["VoidV0", "TupleV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::VoidV0(_) => "VoidV0",
            Self::TupleV0(_) => "TupleV0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScSpecUdtUnionCaseV0Kind {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::VoidV0(_) => ScSpecUdtUnionCaseV0Kind::VoidV0,
            Self::TupleV0(_) => ScSpecUdtUnionCaseV0Kind::TupleV0,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecUdtUnionCaseV0Kind; 2] {
        Self::VARIANTS
    }
}

impl Name for ScSpecUdtUnionCaseV0 {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScSpecUdtUnionCaseV0Kind> for ScSpecUdtUnionCaseV0 {
    #[must_use]
    fn discriminant(&self) -> ScSpecUdtUnionCaseV0Kind {
        Self::discriminant(self)
    }
}

impl Variants<ScSpecUdtUnionCaseV0Kind> for ScSpecUdtUnionCaseV0 {
    fn variants() -> slice::Iter<'static, ScSpecUdtUnionCaseV0Kind> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScSpecUdtUnionCaseV0Kind> for ScSpecUdtUnionCaseV0 {}

impl ReadXdr for ScSpecUdtUnionCaseV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ScSpecUdtUnionCaseV0Kind = <ScSpecUdtUnionCaseV0Kind as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScSpecUdtUnionCaseV0Kind::VoidV0 => {
                    Self::VoidV0(ScSpecUdtUnionCaseVoidV0::read_xdr(r)?)
                }
                ScSpecUdtUnionCaseV0Kind::TupleV0 => {
                    Self::TupleV0(ScSpecUdtUnionCaseTupleV0::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecUdtUnionCaseV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::VoidV0(v) => v.write_xdr(w)?,
                Self::TupleV0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScSpecUdtUnionV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecUDTUnionV0
/// {
///     string doc<SC_SPEC_DOC_LIMIT>;
///     string lib<80>;
///     string name<60>;
///     SCSpecUDTUnionCaseV0 cases<50>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecUdtUnionV0 {
    pub doc: StringM<1024>,
    pub lib: StringM<80>,
    pub name: StringM<60>,
    pub cases: VecM<ScSpecUdtUnionCaseV0, 50>,
}

impl ReadXdr for ScSpecUdtUnionV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<1024>::read_xdr(r)?,
                lib: StringM::<80>::read_xdr(r)?,
                name: StringM::<60>::read_xdr(r)?,
                cases: VecM::<ScSpecUdtUnionCaseV0, 50>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtUnionV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;
            self.lib.write_xdr(w)?;
            self.name.write_xdr(w)?;
            self.cases.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecUdtEnumCaseV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecUDTEnumCaseV0
/// {
///     string doc<SC_SPEC_DOC_LIMIT>;
///     string name<60>;
///     uint32 value;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecUdtEnumCaseV0 {
    pub doc: StringM<1024>,
    pub name: StringM<60>,
    pub value: u32,
}

impl ReadXdr for ScSpecUdtEnumCaseV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<1024>::read_xdr(r)?,
                name: StringM::<60>::read_xdr(r)?,
                value: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtEnumCaseV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;
            self.name.write_xdr(w)?;
            self.value.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecUdtEnumV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecUDTEnumV0
/// {
///     string doc<SC_SPEC_DOC_LIMIT>;
///     string lib<80>;
///     string name<60>;
///     SCSpecUDTEnumCaseV0 cases<50>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecUdtEnumV0 {
    pub doc: StringM<1024>,
    pub lib: StringM<80>,
    pub name: StringM<60>,
    pub cases: VecM<ScSpecUdtEnumCaseV0, 50>,
}

impl ReadXdr for ScSpecUdtEnumV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<1024>::read_xdr(r)?,
                lib: StringM::<80>::read_xdr(r)?,
                name: StringM::<60>::read_xdr(r)?,
                cases: VecM::<ScSpecUdtEnumCaseV0, 50>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtEnumV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;
            self.lib.write_xdr(w)?;
            self.name.write_xdr(w)?;
            self.cases.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecUdtErrorEnumCaseV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecUDTErrorEnumCaseV0
/// {
///     string doc<SC_SPEC_DOC_LIMIT>;
///     string name<60>;
///     uint32 value;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecUdtErrorEnumCaseV0 {
    pub doc: StringM<1024>,
    pub name: StringM<60>,
    pub value: u32,
}

impl ReadXdr for ScSpecUdtErrorEnumCaseV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<1024>::read_xdr(r)?,
                name: StringM::<60>::read_xdr(r)?,
                value: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtErrorEnumCaseV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;
            self.name.write_xdr(w)?;
            self.value.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecUdtErrorEnumV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecUDTErrorEnumV0
/// {
///     string doc<SC_SPEC_DOC_LIMIT>;
///     string lib<80>;
///     string name<60>;
///     SCSpecUDTErrorEnumCaseV0 cases<50>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecUdtErrorEnumV0 {
    pub doc: StringM<1024>,
    pub lib: StringM<80>,
    pub name: StringM<60>,
    pub cases: VecM<ScSpecUdtErrorEnumCaseV0, 50>,
}

impl ReadXdr for ScSpecUdtErrorEnumV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<1024>::read_xdr(r)?,
                lib: StringM::<80>::read_xdr(r)?,
                name: StringM::<60>::read_xdr(r)?,
                cases: VecM::<ScSpecUdtErrorEnumCaseV0, 50>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecUdtErrorEnumV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;
            self.lib.write_xdr(w)?;
            self.name.write_xdr(w)?;
            self.cases.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecFunctionInputV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecFunctionInputV0
/// {
///     string doc<SC_SPEC_DOC_LIMIT>;
///     string name<30>;
///     SCSpecTypeDef type;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecFunctionInputV0 {
    pub doc: StringM<1024>,
    pub name: StringM<30>,
    pub type_: ScSpecTypeDef,
}

impl ReadXdr for ScSpecFunctionInputV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<1024>::read_xdr(r)?,
                name: StringM::<30>::read_xdr(r)?,
                type_: ScSpecTypeDef::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecFunctionInputV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;
            self.name.write_xdr(w)?;
            self.type_.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecFunctionV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCSpecFunctionV0
/// {
///     string doc<SC_SPEC_DOC_LIMIT>;
///     SCSymbol name;
///     SCSpecFunctionInputV0 inputs<10>;
///     SCSpecTypeDef outputs<1>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScSpecFunctionV0 {
    pub doc: StringM<1024>,
    pub name: ScSymbol,
    pub inputs: VecM<ScSpecFunctionInputV0, 10>,
    pub outputs: VecM<ScSpecTypeDef, 1>,
}

impl ReadXdr for ScSpecFunctionV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                doc: StringM::<1024>::read_xdr(r)?,
                name: ScSymbol::read_xdr(r)?,
                inputs: VecM::<ScSpecFunctionInputV0, 10>::read_xdr(r)?,
                outputs: VecM::<ScSpecTypeDef, 1>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScSpecFunctionV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.doc.write_xdr(w)?;
            self.name.write_xdr(w)?;
            self.inputs.write_xdr(w)?;
            self.outputs.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScSpecEntryKind is an XDR Enum defines as:
///
/// ```text
/// enum SCSpecEntryKind
/// {
///     SC_SPEC_ENTRY_FUNCTION_V0 = 0,
///     SC_SPEC_ENTRY_UDT_STRUCT_V0 = 1,
///     SC_SPEC_ENTRY_UDT_UNION_V0 = 2,
///     SC_SPEC_ENTRY_UDT_ENUM_V0 = 3,
///     SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0 = 4
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ScSpecEntryKind {
    FunctionV0 = 0,
    UdtStructV0 = 1,
    UdtUnionV0 = 2,
    UdtEnumV0 = 3,
    UdtErrorEnumV0 = 4,
}

impl ScSpecEntryKind {
    pub const VARIANTS: [ScSpecEntryKind; 5] = [
        ScSpecEntryKind::FunctionV0,
        ScSpecEntryKind::UdtStructV0,
        ScSpecEntryKind::UdtUnionV0,
        ScSpecEntryKind::UdtEnumV0,
        ScSpecEntryKind::UdtErrorEnumV0,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "FunctionV0",
        "UdtStructV0",
        "UdtUnionV0",
        "UdtEnumV0",
        "UdtErrorEnumV0",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::FunctionV0 => "FunctionV0",
            Self::UdtStructV0 => "UdtStructV0",
            Self::UdtUnionV0 => "UdtUnionV0",
            Self::UdtEnumV0 => "UdtEnumV0",
            Self::UdtErrorEnumV0 => "UdtErrorEnumV0",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecEntryKind; 5] {
        Self::VARIANTS
    }
}

impl Name for ScSpecEntryKind {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScSpecEntryKind> for ScSpecEntryKind {
    fn variants() -> slice::Iter<'static, ScSpecEntryKind> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScSpecEntryKind {}

impl fmt::Display for ScSpecEntryKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScSpecEntryKind {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ScSpecEntryKind::FunctionV0,
            1 => ScSpecEntryKind::UdtStructV0,
            2 => ScSpecEntryKind::UdtUnionV0,
            3 => ScSpecEntryKind::UdtEnumV0,
            4 => ScSpecEntryKind::UdtErrorEnumV0,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScSpecEntryKind> for i32 {
    #[must_use]
    fn from(e: ScSpecEntryKind) -> Self {
        e as Self
    }
}

impl ReadXdr for ScSpecEntryKind {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecEntryKind {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScSpecEntry is an XDR Union defines as:
///
/// ```text
/// union SCSpecEntry switch (SCSpecEntryKind kind)
/// {
/// case SC_SPEC_ENTRY_FUNCTION_V0:
///     SCSpecFunctionV0 functionV0;
/// case SC_SPEC_ENTRY_UDT_STRUCT_V0:
///     SCSpecUDTStructV0 udtStructV0;
/// case SC_SPEC_ENTRY_UDT_UNION_V0:
///     SCSpecUDTUnionV0 udtUnionV0;
/// case SC_SPEC_ENTRY_UDT_ENUM_V0:
///     SCSpecUDTEnumV0 udtEnumV0;
/// case SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
///     SCSpecUDTErrorEnumV0 udtErrorEnumV0;
/// };
/// ```
///
// union with discriminant ScSpecEntryKind
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ScSpecEntry {
    FunctionV0(ScSpecFunctionV0),
    UdtStructV0(ScSpecUdtStructV0),
    UdtUnionV0(ScSpecUdtUnionV0),
    UdtEnumV0(ScSpecUdtEnumV0),
    UdtErrorEnumV0(ScSpecUdtErrorEnumV0),
}

impl ScSpecEntry {
    pub const VARIANTS: [ScSpecEntryKind; 5] = [
        ScSpecEntryKind::FunctionV0,
        ScSpecEntryKind::UdtStructV0,
        ScSpecEntryKind::UdtUnionV0,
        ScSpecEntryKind::UdtEnumV0,
        ScSpecEntryKind::UdtErrorEnumV0,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "FunctionV0",
        "UdtStructV0",
        "UdtUnionV0",
        "UdtEnumV0",
        "UdtErrorEnumV0",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::FunctionV0(_) => "FunctionV0",
            Self::UdtStructV0(_) => "UdtStructV0",
            Self::UdtUnionV0(_) => "UdtUnionV0",
            Self::UdtEnumV0(_) => "UdtEnumV0",
            Self::UdtErrorEnumV0(_) => "UdtErrorEnumV0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScSpecEntryKind {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::FunctionV0(_) => ScSpecEntryKind::FunctionV0,
            Self::UdtStructV0(_) => ScSpecEntryKind::UdtStructV0,
            Self::UdtUnionV0(_) => ScSpecEntryKind::UdtUnionV0,
            Self::UdtEnumV0(_) => ScSpecEntryKind::UdtEnumV0,
            Self::UdtErrorEnumV0(_) => ScSpecEntryKind::UdtErrorEnumV0,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScSpecEntryKind; 5] {
        Self::VARIANTS
    }
}

impl Name for ScSpecEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScSpecEntryKind> for ScSpecEntry {
    #[must_use]
    fn discriminant(&self) -> ScSpecEntryKind {
        Self::discriminant(self)
    }
}

impl Variants<ScSpecEntryKind> for ScSpecEntry {
    fn variants() -> slice::Iter<'static, ScSpecEntryKind> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScSpecEntryKind> for ScSpecEntry {}

impl ReadXdr for ScSpecEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ScSpecEntryKind = <ScSpecEntryKind as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScSpecEntryKind::FunctionV0 => Self::FunctionV0(ScSpecFunctionV0::read_xdr(r)?),
                ScSpecEntryKind::UdtStructV0 => Self::UdtStructV0(ScSpecUdtStructV0::read_xdr(r)?),
                ScSpecEntryKind::UdtUnionV0 => Self::UdtUnionV0(ScSpecUdtUnionV0::read_xdr(r)?),
                ScSpecEntryKind::UdtEnumV0 => Self::UdtEnumV0(ScSpecUdtEnumV0::read_xdr(r)?),
                ScSpecEntryKind::UdtErrorEnumV0 => {
                    Self::UdtErrorEnumV0(ScSpecUdtErrorEnumV0::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScSpecEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::FunctionV0(v) => v.write_xdr(w)?,
                Self::UdtStructV0(v) => v.write_xdr(w)?,
                Self::UdtUnionV0(v) => v.write_xdr(w)?,
                Self::UdtEnumV0(v) => v.write_xdr(w)?,
                Self::UdtErrorEnumV0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScValType is an XDR Enum defines as:
///
/// ```text
/// enum SCValType
/// {
///     SCV_BOOL = 0,
///     SCV_VOID = 1,
///     SCV_ERROR = 2,
///
///     // 32 bits is the smallest type in WASM or XDR; no need for u8/u16.
///     SCV_U32 = 3,
///     SCV_I32 = 4,
///
///     // 64 bits is naturally supported by both WASM and XDR also.
///     SCV_U64 = 5,
///     SCV_I64 = 6,
///
///     // Time-related u64 subtypes with their own functions and formatting.
///     SCV_TIMEPOINT = 7,
///     SCV_DURATION = 8,
///
///     // 128 bits is naturally supported by Rust and we use it for Soroban
///     // fixed-point arithmetic prices / balances / similar "quantities". These
///     // are represented in XDR as a pair of 2 u64s.
///     SCV_U128 = 9,
///     SCV_I128 = 10,
///
///     // 256 bits is the size of sha256 output, ed25519 keys, and the EVM machine
///     // word, so for interop use we include this even though it requires a small
///     // amount of Rust guest and/or host library code.
///     SCV_U256 = 11,
///     SCV_I256 = 12,
///
///     // Bytes come in 3 flavors, 2 of which have meaningfully different
///     // formatting and validity-checking / domain-restriction.
///     SCV_BYTES = 13,
///     SCV_STRING = 14,
///     SCV_SYMBOL = 15,
///
///     // Vecs and maps are just polymorphic containers of other ScVals.
///     SCV_VEC = 16,
///     SCV_MAP = 17,
///
///     // Address is the universal identifier for contracts and classic
///     // accounts.
///     SCV_ADDRESS = 18,
///
///     // The following are the internal SCVal variants that are not
///     // exposed to the contracts.
///     SCV_CONTRACT_INSTANCE = 19,
///
///     // SCV_LEDGER_KEY_CONTRACT_INSTANCE and SCV_LEDGER_KEY_NONCE are unique
///     // symbolic SCVals used as the key for ledger entries for a contract's
///     // instance and an address' nonce, respectively.
///     SCV_LEDGER_KEY_CONTRACT_INSTANCE = 20,
///     SCV_LEDGER_KEY_NONCE = 21
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ScValType {
    Bool = 0,
    Void = 1,
    Error = 2,
    U32 = 3,
    I32 = 4,
    U64 = 5,
    I64 = 6,
    Timepoint = 7,
    Duration = 8,
    U128 = 9,
    I128 = 10,
    U256 = 11,
    I256 = 12,
    Bytes = 13,
    String = 14,
    Symbol = 15,
    Vec = 16,
    Map = 17,
    Address = 18,
    ContractInstance = 19,
    LedgerKeyContractInstance = 20,
    LedgerKeyNonce = 21,
}

impl ScValType {
    pub const VARIANTS: [ScValType; 22] = [
        ScValType::Bool,
        ScValType::Void,
        ScValType::Error,
        ScValType::U32,
        ScValType::I32,
        ScValType::U64,
        ScValType::I64,
        ScValType::Timepoint,
        ScValType::Duration,
        ScValType::U128,
        ScValType::I128,
        ScValType::U256,
        ScValType::I256,
        ScValType::Bytes,
        ScValType::String,
        ScValType::Symbol,
        ScValType::Vec,
        ScValType::Map,
        ScValType::Address,
        ScValType::ContractInstance,
        ScValType::LedgerKeyContractInstance,
        ScValType::LedgerKeyNonce,
    ];
    pub const VARIANTS_STR: [&'static str; 22] = [
        "Bool",
        "Void",
        "Error",
        "U32",
        "I32",
        "U64",
        "I64",
        "Timepoint",
        "Duration",
        "U128",
        "I128",
        "U256",
        "I256",
        "Bytes",
        "String",
        "Symbol",
        "Vec",
        "Map",
        "Address",
        "ContractInstance",
        "LedgerKeyContractInstance",
        "LedgerKeyNonce",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Bool => "Bool",
            Self::Void => "Void",
            Self::Error => "Error",
            Self::U32 => "U32",
            Self::I32 => "I32",
            Self::U64 => "U64",
            Self::I64 => "I64",
            Self::Timepoint => "Timepoint",
            Self::Duration => "Duration",
            Self::U128 => "U128",
            Self::I128 => "I128",
            Self::U256 => "U256",
            Self::I256 => "I256",
            Self::Bytes => "Bytes",
            Self::String => "String",
            Self::Symbol => "Symbol",
            Self::Vec => "Vec",
            Self::Map => "Map",
            Self::Address => "Address",
            Self::ContractInstance => "ContractInstance",
            Self::LedgerKeyContractInstance => "LedgerKeyContractInstance",
            Self::LedgerKeyNonce => "LedgerKeyNonce",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScValType; 22] {
        Self::VARIANTS
    }
}

impl Name for ScValType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScValType> for ScValType {
    fn variants() -> slice::Iter<'static, ScValType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScValType {}

impl fmt::Display for ScValType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScValType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ScValType::Bool,
            1 => ScValType::Void,
            2 => ScValType::Error,
            3 => ScValType::U32,
            4 => ScValType::I32,
            5 => ScValType::U64,
            6 => ScValType::I64,
            7 => ScValType::Timepoint,
            8 => ScValType::Duration,
            9 => ScValType::U128,
            10 => ScValType::I128,
            11 => ScValType::U256,
            12 => ScValType::I256,
            13 => ScValType::Bytes,
            14 => ScValType::String,
            15 => ScValType::Symbol,
            16 => ScValType::Vec,
            17 => ScValType::Map,
            18 => ScValType::Address,
            19 => ScValType::ContractInstance,
            20 => ScValType::LedgerKeyContractInstance,
            21 => ScValType::LedgerKeyNonce,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScValType> for i32 {
    #[must_use]
    fn from(e: ScValType) -> Self {
        e as Self
    }
}

impl ReadXdr for ScValType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScValType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScErrorType is an XDR Enum defines as:
///
/// ```text
/// enum SCErrorType
/// {
///     SCE_CONTRACT = 0,          // Contract-specific, user-defined codes.
///     SCE_WASM_VM = 1,           // Errors while interpreting WASM bytecode.
///     SCE_CONTEXT = 2,           // Errors in the contract's host context.
///     SCE_STORAGE = 3,           // Errors accessing host storage.
///     SCE_OBJECT = 4,            // Errors working with host objects.
///     SCE_CRYPTO = 5,            // Errors in cryptographic operations.
///     SCE_EVENTS = 6,            // Errors while emitting events.
///     SCE_BUDGET = 7,            // Errors relating to budget limits.
///     SCE_VALUE = 8,             // Errors working with host values or SCVals.
///     SCE_AUTH = 9               // Errors from the authentication subsystem.
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ScErrorType {
    Contract = 0,
    WasmVm = 1,
    Context = 2,
    Storage = 3,
    Object = 4,
    Crypto = 5,
    Events = 6,
    Budget = 7,
    Value = 8,
    Auth = 9,
}

impl ScErrorType {
    pub const VARIANTS: [ScErrorType; 10] = [
        ScErrorType::Contract,
        ScErrorType::WasmVm,
        ScErrorType::Context,
        ScErrorType::Storage,
        ScErrorType::Object,
        ScErrorType::Crypto,
        ScErrorType::Events,
        ScErrorType::Budget,
        ScErrorType::Value,
        ScErrorType::Auth,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "Contract", "WasmVm", "Context", "Storage", "Object", "Crypto", "Events", "Budget",
        "Value", "Auth",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Contract => "Contract",
            Self::WasmVm => "WasmVm",
            Self::Context => "Context",
            Self::Storage => "Storage",
            Self::Object => "Object",
            Self::Crypto => "Crypto",
            Self::Events => "Events",
            Self::Budget => "Budget",
            Self::Value => "Value",
            Self::Auth => "Auth",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScErrorType; 10] {
        Self::VARIANTS
    }
}

impl Name for ScErrorType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScErrorType> for ScErrorType {
    fn variants() -> slice::Iter<'static, ScErrorType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScErrorType {}

impl fmt::Display for ScErrorType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScErrorType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ScErrorType::Contract,
            1 => ScErrorType::WasmVm,
            2 => ScErrorType::Context,
            3 => ScErrorType::Storage,
            4 => ScErrorType::Object,
            5 => ScErrorType::Crypto,
            6 => ScErrorType::Events,
            7 => ScErrorType::Budget,
            8 => ScErrorType::Value,
            9 => ScErrorType::Auth,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScErrorType> for i32 {
    #[must_use]
    fn from(e: ScErrorType) -> Self {
        e as Self
    }
}

impl ReadXdr for ScErrorType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScErrorType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScErrorCode is an XDR Enum defines as:
///
/// ```text
/// enum SCErrorCode
/// {
///     SCEC_ARITH_DOMAIN = 0,      // Some arithmetic was undefined (overflow, divide-by-zero).
///     SCEC_INDEX_BOUNDS = 1,      // Something was indexed beyond its bounds.
///     SCEC_INVALID_INPUT = 2,     // User provided some otherwise-bad data.
///     SCEC_MISSING_VALUE = 3,     // Some value was required but not provided.
///     SCEC_EXISTING_VALUE = 4,    // Some value was provided where not allowed.
///     SCEC_EXCEEDED_LIMIT = 5,    // Some arbitrary limit -- gas or otherwise -- was hit.
///     SCEC_INVALID_ACTION = 6,    // Data was valid but action requested was not.
///     SCEC_INTERNAL_ERROR = 7,    // The host detected an error in its own logic.
///     SCEC_UNEXPECTED_TYPE = 8,   // Some type wasn't as expected.
///     SCEC_UNEXPECTED_SIZE = 9    // Something's size wasn't as expected.
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ScErrorCode {
    ArithDomain = 0,
    IndexBounds = 1,
    InvalidInput = 2,
    MissingValue = 3,
    ExistingValue = 4,
    ExceededLimit = 5,
    InvalidAction = 6,
    InternalError = 7,
    UnexpectedType = 8,
    UnexpectedSize = 9,
}

impl ScErrorCode {
    pub const VARIANTS: [ScErrorCode; 10] = [
        ScErrorCode::ArithDomain,
        ScErrorCode::IndexBounds,
        ScErrorCode::InvalidInput,
        ScErrorCode::MissingValue,
        ScErrorCode::ExistingValue,
        ScErrorCode::ExceededLimit,
        ScErrorCode::InvalidAction,
        ScErrorCode::InternalError,
        ScErrorCode::UnexpectedType,
        ScErrorCode::UnexpectedSize,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "ArithDomain",
        "IndexBounds",
        "InvalidInput",
        "MissingValue",
        "ExistingValue",
        "ExceededLimit",
        "InvalidAction",
        "InternalError",
        "UnexpectedType",
        "UnexpectedSize",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ArithDomain => "ArithDomain",
            Self::IndexBounds => "IndexBounds",
            Self::InvalidInput => "InvalidInput",
            Self::MissingValue => "MissingValue",
            Self::ExistingValue => "ExistingValue",
            Self::ExceededLimit => "ExceededLimit",
            Self::InvalidAction => "InvalidAction",
            Self::InternalError => "InternalError",
            Self::UnexpectedType => "UnexpectedType",
            Self::UnexpectedSize => "UnexpectedSize",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScErrorCode; 10] {
        Self::VARIANTS
    }
}

impl Name for ScErrorCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScErrorCode> for ScErrorCode {
    fn variants() -> slice::Iter<'static, ScErrorCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScErrorCode {}

impl fmt::Display for ScErrorCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScErrorCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ScErrorCode::ArithDomain,
            1 => ScErrorCode::IndexBounds,
            2 => ScErrorCode::InvalidInput,
            3 => ScErrorCode::MissingValue,
            4 => ScErrorCode::ExistingValue,
            5 => ScErrorCode::ExceededLimit,
            6 => ScErrorCode::InvalidAction,
            7 => ScErrorCode::InternalError,
            8 => ScErrorCode::UnexpectedType,
            9 => ScErrorCode::UnexpectedSize,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScErrorCode> for i32 {
    #[must_use]
    fn from(e: ScErrorCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ScErrorCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScErrorCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScError is an XDR Union defines as:
///
/// ```text
/// union SCError switch (SCErrorType type)
/// {
/// case SCE_CONTRACT:
///     uint32 contractCode;
/// case SCE_WASM_VM:
/// case SCE_CONTEXT:
/// case SCE_STORAGE:
/// case SCE_OBJECT:
/// case SCE_CRYPTO:
/// case SCE_EVENTS:
/// case SCE_BUDGET:
/// case SCE_VALUE:
/// case SCE_AUTH:
///     SCErrorCode code;
/// };
/// ```
///
// union with discriminant ScErrorType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ScError {
    Contract(u32),
    WasmVm(ScErrorCode),
    Context(ScErrorCode),
    Storage(ScErrorCode),
    Object(ScErrorCode),
    Crypto(ScErrorCode),
    Events(ScErrorCode),
    Budget(ScErrorCode),
    Value(ScErrorCode),
    Auth(ScErrorCode),
}

impl ScError {
    pub const VARIANTS: [ScErrorType; 10] = [
        ScErrorType::Contract,
        ScErrorType::WasmVm,
        ScErrorType::Context,
        ScErrorType::Storage,
        ScErrorType::Object,
        ScErrorType::Crypto,
        ScErrorType::Events,
        ScErrorType::Budget,
        ScErrorType::Value,
        ScErrorType::Auth,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "Contract", "WasmVm", "Context", "Storage", "Object", "Crypto", "Events", "Budget",
        "Value", "Auth",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Contract(_) => "Contract",
            Self::WasmVm(_) => "WasmVm",
            Self::Context(_) => "Context",
            Self::Storage(_) => "Storage",
            Self::Object(_) => "Object",
            Self::Crypto(_) => "Crypto",
            Self::Events(_) => "Events",
            Self::Budget(_) => "Budget",
            Self::Value(_) => "Value",
            Self::Auth(_) => "Auth",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScErrorType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Contract(_) => ScErrorType::Contract,
            Self::WasmVm(_) => ScErrorType::WasmVm,
            Self::Context(_) => ScErrorType::Context,
            Self::Storage(_) => ScErrorType::Storage,
            Self::Object(_) => ScErrorType::Object,
            Self::Crypto(_) => ScErrorType::Crypto,
            Self::Events(_) => ScErrorType::Events,
            Self::Budget(_) => ScErrorType::Budget,
            Self::Value(_) => ScErrorType::Value,
            Self::Auth(_) => ScErrorType::Auth,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScErrorType; 10] {
        Self::VARIANTS
    }
}

impl Name for ScError {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScErrorType> for ScError {
    #[must_use]
    fn discriminant(&self) -> ScErrorType {
        Self::discriminant(self)
    }
}

impl Variants<ScErrorType> for ScError {
    fn variants() -> slice::Iter<'static, ScErrorType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScErrorType> for ScError {}

impl ReadXdr for ScError {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ScErrorType = <ScErrorType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScErrorType::Contract => Self::Contract(u32::read_xdr(r)?),
                ScErrorType::WasmVm => Self::WasmVm(ScErrorCode::read_xdr(r)?),
                ScErrorType::Context => Self::Context(ScErrorCode::read_xdr(r)?),
                ScErrorType::Storage => Self::Storage(ScErrorCode::read_xdr(r)?),
                ScErrorType::Object => Self::Object(ScErrorCode::read_xdr(r)?),
                ScErrorType::Crypto => Self::Crypto(ScErrorCode::read_xdr(r)?),
                ScErrorType::Events => Self::Events(ScErrorCode::read_xdr(r)?),
                ScErrorType::Budget => Self::Budget(ScErrorCode::read_xdr(r)?),
                ScErrorType::Value => Self::Value(ScErrorCode::read_xdr(r)?),
                ScErrorType::Auth => Self::Auth(ScErrorCode::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScError {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Contract(v) => v.write_xdr(w)?,
                Self::WasmVm(v) => v.write_xdr(w)?,
                Self::Context(v) => v.write_xdr(w)?,
                Self::Storage(v) => v.write_xdr(w)?,
                Self::Object(v) => v.write_xdr(w)?,
                Self::Crypto(v) => v.write_xdr(w)?,
                Self::Events(v) => v.write_xdr(w)?,
                Self::Budget(v) => v.write_xdr(w)?,
                Self::Value(v) => v.write_xdr(w)?,
                Self::Auth(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// UInt128Parts is an XDR Struct defines as:
///
/// ```text
/// struct UInt128Parts {
///     uint64 hi;
///     uint64 lo;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct UInt128Parts {
    pub hi: u64,
    pub lo: u64,
}

impl ReadXdr for UInt128Parts {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hi: u64::read_xdr(r)?,
                lo: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for UInt128Parts {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.hi.write_xdr(w)?;
            self.lo.write_xdr(w)?;
            Ok(())
        })
    }
}

/// Int128Parts is an XDR Struct defines as:
///
/// ```text
/// struct Int128Parts {
///     int64 hi;
///     uint64 lo;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Int128Parts {
    pub hi: i64,
    pub lo: u64,
}

impl ReadXdr for Int128Parts {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hi: i64::read_xdr(r)?,
                lo: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Int128Parts {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.hi.write_xdr(w)?;
            self.lo.write_xdr(w)?;
            Ok(())
        })
    }
}

/// UInt256Parts is an XDR Struct defines as:
///
/// ```text
/// struct UInt256Parts {
///     uint64 hi_hi;
///     uint64 hi_lo;
///     uint64 lo_hi;
///     uint64 lo_lo;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct UInt256Parts {
    pub hi_hi: u64,
    pub hi_lo: u64,
    pub lo_hi: u64,
    pub lo_lo: u64,
}

impl ReadXdr for UInt256Parts {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hi_hi: u64::read_xdr(r)?,
                hi_lo: u64::read_xdr(r)?,
                lo_hi: u64::read_xdr(r)?,
                lo_lo: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for UInt256Parts {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.hi_hi.write_xdr(w)?;
            self.hi_lo.write_xdr(w)?;
            self.lo_hi.write_xdr(w)?;
            self.lo_lo.write_xdr(w)?;
            Ok(())
        })
    }
}

/// Int256Parts is an XDR Struct defines as:
///
/// ```text
/// struct Int256Parts {
///     int64 hi_hi;
///     uint64 hi_lo;
///     uint64 lo_hi;
///     uint64 lo_lo;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Int256Parts {
    pub hi_hi: i64,
    pub hi_lo: u64,
    pub lo_hi: u64,
    pub lo_lo: u64,
}

impl ReadXdr for Int256Parts {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hi_hi: i64::read_xdr(r)?,
                hi_lo: u64::read_xdr(r)?,
                lo_hi: u64::read_xdr(r)?,
                lo_lo: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Int256Parts {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.hi_hi.write_xdr(w)?;
            self.hi_lo.write_xdr(w)?;
            self.lo_hi.write_xdr(w)?;
            self.lo_lo.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ContractExecutableType is an XDR Enum defines as:
///
/// ```text
/// enum ContractExecutableType
/// {
///     CONTRACT_EXECUTABLE_WASM = 0,
///     CONTRACT_EXECUTABLE_STELLAR_ASSET = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ContractExecutableType {
    Wasm = 0,
    StellarAsset = 1,
}

impl ContractExecutableType {
    pub const VARIANTS: [ContractExecutableType; 2] = [
        ContractExecutableType::Wasm,
        ContractExecutableType::StellarAsset,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["Wasm", "StellarAsset"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Wasm => "Wasm",
            Self::StellarAsset => "StellarAsset",
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractExecutableType; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractExecutableType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ContractExecutableType> for ContractExecutableType {
    fn variants() -> slice::Iter<'static, ContractExecutableType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ContractExecutableType {}

impl fmt::Display for ContractExecutableType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ContractExecutableType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ContractExecutableType::Wasm,
            1 => ContractExecutableType::StellarAsset,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ContractExecutableType> for i32 {
    #[must_use]
    fn from(e: ContractExecutableType) -> Self {
        e as Self
    }
}

impl ReadXdr for ContractExecutableType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ContractExecutableType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractExecutable is an XDR Union defines as:
///
/// ```text
/// union ContractExecutable switch (ContractExecutableType type)
/// {
/// case CONTRACT_EXECUTABLE_WASM:
///     Hash wasm_hash;
/// case CONTRACT_EXECUTABLE_STELLAR_ASSET:
///     void;
/// };
/// ```
///
// union with discriminant ContractExecutableType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ContractExecutable {
    Wasm(Hash),
    StellarAsset,
}

impl ContractExecutable {
    pub const VARIANTS: [ContractExecutableType; 2] = [
        ContractExecutableType::Wasm,
        ContractExecutableType::StellarAsset,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["Wasm", "StellarAsset"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Wasm(_) => "Wasm",
            Self::StellarAsset => "StellarAsset",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ContractExecutableType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Wasm(_) => ContractExecutableType::Wasm,
            Self::StellarAsset => ContractExecutableType::StellarAsset,
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractExecutableType; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractExecutable {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ContractExecutableType> for ContractExecutable {
    #[must_use]
    fn discriminant(&self) -> ContractExecutableType {
        Self::discriminant(self)
    }
}

impl Variants<ContractExecutableType> for ContractExecutable {
    fn variants() -> slice::Iter<'static, ContractExecutableType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ContractExecutableType> for ContractExecutable {}

impl ReadXdr for ContractExecutable {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ContractExecutableType = <ContractExecutableType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ContractExecutableType::Wasm => Self::Wasm(Hash::read_xdr(r)?),
                ContractExecutableType::StellarAsset => Self::StellarAsset,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ContractExecutable {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Wasm(v) => v.write_xdr(w)?,
                Self::StellarAsset => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScAddressType is an XDR Enum defines as:
///
/// ```text
/// enum SCAddressType
/// {
///     SC_ADDRESS_TYPE_ACCOUNT = 0,
///     SC_ADDRESS_TYPE_CONTRACT = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ScAddressType {
    Account = 0,
    Contract = 1,
}

impl ScAddressType {
    pub const VARIANTS: [ScAddressType; 2] = [ScAddressType::Account, ScAddressType::Contract];
    pub const VARIANTS_STR: [&'static str; 2] = ["Account", "Contract"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Account => "Account",
            Self::Contract => "Contract",
        }
    }

    #[must_use]
    pub const fn variants() -> [ScAddressType; 2] {
        Self::VARIANTS
    }
}

impl Name for ScAddressType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ScAddressType> for ScAddressType {
    fn variants() -> slice::Iter<'static, ScAddressType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ScAddressType {}

impl fmt::Display for ScAddressType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ScAddressType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ScAddressType::Account,
            1 => ScAddressType::Contract,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ScAddressType> for i32 {
    #[must_use]
    fn from(e: ScAddressType) -> Self {
        e as Self
    }
}

impl ReadXdr for ScAddressType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ScAddressType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ScAddress is an XDR Union defines as:
///
/// ```text
/// union SCAddress switch (SCAddressType type)
/// {
/// case SC_ADDRESS_TYPE_ACCOUNT:
///     AccountID accountId;
/// case SC_ADDRESS_TYPE_CONTRACT:
///     Hash contractId;
/// };
/// ```
///
// union with discriminant ScAddressType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[allow(clippy::large_enum_variant)]
pub enum ScAddress {
    Account(AccountId),
    Contract(Hash),
}

impl ScAddress {
    pub const VARIANTS: [ScAddressType; 2] = [ScAddressType::Account, ScAddressType::Contract];
    pub const VARIANTS_STR: [&'static str; 2] = ["Account", "Contract"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Account(_) => "Account",
            Self::Contract(_) => "Contract",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScAddressType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Account(_) => ScAddressType::Account,
            Self::Contract(_) => ScAddressType::Contract,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScAddressType; 2] {
        Self::VARIANTS
    }
}

impl Name for ScAddress {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScAddressType> for ScAddress {
    #[must_use]
    fn discriminant(&self) -> ScAddressType {
        Self::discriminant(self)
    }
}

impl Variants<ScAddressType> for ScAddress {
    fn variants() -> slice::Iter<'static, ScAddressType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScAddressType> for ScAddress {}

impl ReadXdr for ScAddress {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ScAddressType = <ScAddressType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScAddressType::Account => Self::Account(AccountId::read_xdr(r)?),
                ScAddressType::Contract => Self::Contract(Hash::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScAddress {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Account(v) => v.write_xdr(w)?,
                Self::Contract(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScsymbolLimit is an XDR Const defines as:
///
/// ```text
/// const SCSYMBOL_LIMIT = 32;
/// ```
///
pub const SCSYMBOL_LIMIT: u64 = 32;

/// ScVec is an XDR Typedef defines as:
///
/// ```text
/// typedef SCVal SCVec<>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct ScVec(pub VecM<ScVal>);

impl From<ScVec> for VecM<ScVal> {
    #[must_use]
    fn from(x: ScVec) -> Self {
        x.0
    }
}

impl From<VecM<ScVal>> for ScVec {
    #[must_use]
    fn from(x: VecM<ScVal>) -> Self {
        ScVec(x)
    }
}

impl AsRef<VecM<ScVal>> for ScVec {
    #[must_use]
    fn as_ref(&self) -> &VecM<ScVal> {
        &self.0
    }
}

impl ReadXdr for ScVec {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = VecM::<ScVal>::read_xdr(r)?;
            let v = ScVec(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ScVec {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ScVec {
    type Target = VecM<ScVal>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ScVec> for Vec<ScVal> {
    #[must_use]
    fn from(x: ScVec) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<ScVal>> for ScVec {
    type Error = Error;
    fn try_from(x: Vec<ScVal>) -> Result<Self> {
        Ok(ScVec(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<ScVal>> for ScVec {
    type Error = Error;
    fn try_from(x: &Vec<ScVal>) -> Result<Self> {
        Ok(ScVec(x.try_into()?))
    }
}

impl AsRef<Vec<ScVal>> for ScVec {
    #[must_use]
    fn as_ref(&self) -> &Vec<ScVal> {
        &self.0 .0
    }
}

impl AsRef<[ScVal]> for ScVec {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[ScVal] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[ScVal] {
        self.0 .0
    }
}

/// ScMap is an XDR Typedef defines as:
///
/// ```text
/// typedef SCMapEntry SCMap<>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct ScMap(pub VecM<ScMapEntry>);

impl From<ScMap> for VecM<ScMapEntry> {
    #[must_use]
    fn from(x: ScMap) -> Self {
        x.0
    }
}

impl From<VecM<ScMapEntry>> for ScMap {
    #[must_use]
    fn from(x: VecM<ScMapEntry>) -> Self {
        ScMap(x)
    }
}

impl AsRef<VecM<ScMapEntry>> for ScMap {
    #[must_use]
    fn as_ref(&self) -> &VecM<ScMapEntry> {
        &self.0
    }
}

impl ReadXdr for ScMap {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = VecM::<ScMapEntry>::read_xdr(r)?;
            let v = ScMap(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ScMap {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ScMap {
    type Target = VecM<ScMapEntry>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ScMap> for Vec<ScMapEntry> {
    #[must_use]
    fn from(x: ScMap) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<ScMapEntry>> for ScMap {
    type Error = Error;
    fn try_from(x: Vec<ScMapEntry>) -> Result<Self> {
        Ok(ScMap(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<ScMapEntry>> for ScMap {
    type Error = Error;
    fn try_from(x: &Vec<ScMapEntry>) -> Result<Self> {
        Ok(ScMap(x.try_into()?))
    }
}

impl AsRef<Vec<ScMapEntry>> for ScMap {
    #[must_use]
    fn as_ref(&self) -> &Vec<ScMapEntry> {
        &self.0 .0
    }
}

impl AsRef<[ScMapEntry]> for ScMap {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[ScMapEntry] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[ScMapEntry] {
        self.0 .0
    }
}

/// ScBytes is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque SCBytes<>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct ScBytes(pub BytesM);

impl From<ScBytes> for BytesM {
    #[must_use]
    fn from(x: ScBytes) -> Self {
        x.0
    }
}

impl From<BytesM> for ScBytes {
    #[must_use]
    fn from(x: BytesM) -> Self {
        ScBytes(x)
    }
}

impl AsRef<BytesM> for ScBytes {
    #[must_use]
    fn as_ref(&self) -> &BytesM {
        &self.0
    }
}

impl ReadXdr for ScBytes {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = BytesM::read_xdr(r)?;
            let v = ScBytes(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ScBytes {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ScBytes {
    type Target = BytesM;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ScBytes> for Vec<u8> {
    #[must_use]
    fn from(x: ScBytes) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for ScBytes {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        Ok(ScBytes(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for ScBytes {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        Ok(ScBytes(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for ScBytes {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for ScBytes {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// ScString is an XDR Typedef defines as:
///
/// ```text
/// typedef string SCString<>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct ScString(pub StringM);

impl From<ScString> for StringM {
    #[must_use]
    fn from(x: ScString) -> Self {
        x.0
    }
}

impl From<StringM> for ScString {
    #[must_use]
    fn from(x: StringM) -> Self {
        ScString(x)
    }
}

impl AsRef<StringM> for ScString {
    #[must_use]
    fn as_ref(&self) -> &StringM {
        &self.0
    }
}

impl ReadXdr for ScString {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = StringM::read_xdr(r)?;
            let v = ScString(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ScString {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ScString {
    type Target = StringM;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ScString> for Vec<u8> {
    #[must_use]
    fn from(x: ScString) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for ScString {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        Ok(ScString(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for ScString {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        Ok(ScString(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for ScString {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for ScString {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// ScSymbol is an XDR Typedef defines as:
///
/// ```text
/// typedef string SCSymbol<SCSYMBOL_LIMIT>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct ScSymbol(pub StringM<32>);

impl From<ScSymbol> for StringM<32> {
    #[must_use]
    fn from(x: ScSymbol) -> Self {
        x.0
    }
}

impl From<StringM<32>> for ScSymbol {
    #[must_use]
    fn from(x: StringM<32>) -> Self {
        ScSymbol(x)
    }
}

impl AsRef<StringM<32>> for ScSymbol {
    #[must_use]
    fn as_ref(&self) -> &StringM<32> {
        &self.0
    }
}

impl ReadXdr for ScSymbol {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = StringM::<32>::read_xdr(r)?;
            let v = ScSymbol(i);
            Ok(v)
        })
    }
}

impl WriteXdr for ScSymbol {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for ScSymbol {
    type Target = StringM<32>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<ScSymbol> for Vec<u8> {
    #[must_use]
    fn from(x: ScSymbol) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for ScSymbol {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        Ok(ScSymbol(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for ScSymbol {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        Ok(ScSymbol(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for ScSymbol {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for ScSymbol {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// ScNonceKey is an XDR Struct defines as:
///
/// ```text
/// struct SCNonceKey {
///     int64 nonce;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScNonceKey {
    pub nonce: i64,
}

impl ReadXdr for ScNonceKey {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                nonce: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScNonceKey {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.nonce.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScContractInstance is an XDR Struct defines as:
///
/// ```text
/// struct SCContractInstance {
///     ContractExecutable executable;
///     SCMap* storage;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScContractInstance {
    pub executable: ContractExecutable,
    pub storage: Option<ScMap>,
}

impl ReadXdr for ScContractInstance {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                executable: ContractExecutable::read_xdr(r)?,
                storage: Option::<ScMap>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScContractInstance {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.executable.write_xdr(w)?;
            self.storage.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScVal is an XDR Union defines as:
///
/// ```text
/// union SCVal switch (SCValType type)
/// {
///
/// case SCV_BOOL:
///     bool b;
/// case SCV_VOID:
///     void;
/// case SCV_ERROR:
///     SCError error;
///
/// case SCV_U32:
///     uint32 u32;
/// case SCV_I32:
///     int32 i32;
///
/// case SCV_U64:
///     uint64 u64;
/// case SCV_I64:
///     int64 i64;
/// case SCV_TIMEPOINT:
///     TimePoint timepoint;
/// case SCV_DURATION:
///     Duration duration;
///
/// case SCV_U128:
///     UInt128Parts u128;
/// case SCV_I128:
///     Int128Parts i128;
///
/// case SCV_U256:
///     UInt256Parts u256;
/// case SCV_I256:
///     Int256Parts i256;
///
/// case SCV_BYTES:
///     SCBytes bytes;
/// case SCV_STRING:
///     SCString str;
/// case SCV_SYMBOL:
///     SCSymbol sym;
///
/// // Vec and Map are recursive so need to live
/// // behind an option, due to xdrpp limitations.
/// case SCV_VEC:
///     SCVec *vec;
/// case SCV_MAP:
///     SCMap *map;
///
/// case SCV_ADDRESS:
///     SCAddress address;
///
/// // Special SCVals reserved for system-constructed contract-data
/// // ledger keys, not generally usable elsewhere.
/// case SCV_LEDGER_KEY_CONTRACT_INSTANCE:
///     void;
/// case SCV_LEDGER_KEY_NONCE:
///     SCNonceKey nonce_key;
///
/// case SCV_CONTRACT_INSTANCE:
///     SCContractInstance instance;
/// };
/// ```
///
// union with discriminant ScValType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ScVal {
    Bool(bool),
    Void,
    Error(ScError),
    U32(u32),
    I32(i32),
    U64(u64),
    I64(i64),
    Timepoint(TimePoint),
    Duration(Duration),
    U128(UInt128Parts),
    I128(Int128Parts),
    U256(UInt256Parts),
    I256(Int256Parts),
    Bytes(ScBytes),
    String(ScString),
    Symbol(ScSymbol),
    Vec(Option<ScVec>),
    Map(Option<ScMap>),
    Address(ScAddress),
    LedgerKeyContractInstance,
    LedgerKeyNonce(ScNonceKey),
    ContractInstance(ScContractInstance),
}

impl ScVal {
    pub const VARIANTS: [ScValType; 22] = [
        ScValType::Bool,
        ScValType::Void,
        ScValType::Error,
        ScValType::U32,
        ScValType::I32,
        ScValType::U64,
        ScValType::I64,
        ScValType::Timepoint,
        ScValType::Duration,
        ScValType::U128,
        ScValType::I128,
        ScValType::U256,
        ScValType::I256,
        ScValType::Bytes,
        ScValType::String,
        ScValType::Symbol,
        ScValType::Vec,
        ScValType::Map,
        ScValType::Address,
        ScValType::LedgerKeyContractInstance,
        ScValType::LedgerKeyNonce,
        ScValType::ContractInstance,
    ];
    pub const VARIANTS_STR: [&'static str; 22] = [
        "Bool",
        "Void",
        "Error",
        "U32",
        "I32",
        "U64",
        "I64",
        "Timepoint",
        "Duration",
        "U128",
        "I128",
        "U256",
        "I256",
        "Bytes",
        "String",
        "Symbol",
        "Vec",
        "Map",
        "Address",
        "LedgerKeyContractInstance",
        "LedgerKeyNonce",
        "ContractInstance",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Bool(_) => "Bool",
            Self::Void => "Void",
            Self::Error(_) => "Error",
            Self::U32(_) => "U32",
            Self::I32(_) => "I32",
            Self::U64(_) => "U64",
            Self::I64(_) => "I64",
            Self::Timepoint(_) => "Timepoint",
            Self::Duration(_) => "Duration",
            Self::U128(_) => "U128",
            Self::I128(_) => "I128",
            Self::U256(_) => "U256",
            Self::I256(_) => "I256",
            Self::Bytes(_) => "Bytes",
            Self::String(_) => "String",
            Self::Symbol(_) => "Symbol",
            Self::Vec(_) => "Vec",
            Self::Map(_) => "Map",
            Self::Address(_) => "Address",
            Self::LedgerKeyContractInstance => "LedgerKeyContractInstance",
            Self::LedgerKeyNonce(_) => "LedgerKeyNonce",
            Self::ContractInstance(_) => "ContractInstance",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ScValType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Bool(_) => ScValType::Bool,
            Self::Void => ScValType::Void,
            Self::Error(_) => ScValType::Error,
            Self::U32(_) => ScValType::U32,
            Self::I32(_) => ScValType::I32,
            Self::U64(_) => ScValType::U64,
            Self::I64(_) => ScValType::I64,
            Self::Timepoint(_) => ScValType::Timepoint,
            Self::Duration(_) => ScValType::Duration,
            Self::U128(_) => ScValType::U128,
            Self::I128(_) => ScValType::I128,
            Self::U256(_) => ScValType::U256,
            Self::I256(_) => ScValType::I256,
            Self::Bytes(_) => ScValType::Bytes,
            Self::String(_) => ScValType::String,
            Self::Symbol(_) => ScValType::Symbol,
            Self::Vec(_) => ScValType::Vec,
            Self::Map(_) => ScValType::Map,
            Self::Address(_) => ScValType::Address,
            Self::LedgerKeyContractInstance => ScValType::LedgerKeyContractInstance,
            Self::LedgerKeyNonce(_) => ScValType::LedgerKeyNonce,
            Self::ContractInstance(_) => ScValType::ContractInstance,
        }
    }

    #[must_use]
    pub const fn variants() -> [ScValType; 22] {
        Self::VARIANTS
    }
}

impl Name for ScVal {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ScValType> for ScVal {
    #[must_use]
    fn discriminant(&self) -> ScValType {
        Self::discriminant(self)
    }
}

impl Variants<ScValType> for ScVal {
    fn variants() -> slice::Iter<'static, ScValType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ScValType> for ScVal {}

impl ReadXdr for ScVal {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ScValType = <ScValType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ScValType::Bool => Self::Bool(bool::read_xdr(r)?),
                ScValType::Void => Self::Void,
                ScValType::Error => Self::Error(ScError::read_xdr(r)?),
                ScValType::U32 => Self::U32(u32::read_xdr(r)?),
                ScValType::I32 => Self::I32(i32::read_xdr(r)?),
                ScValType::U64 => Self::U64(u64::read_xdr(r)?),
                ScValType::I64 => Self::I64(i64::read_xdr(r)?),
                ScValType::Timepoint => Self::Timepoint(TimePoint::read_xdr(r)?),
                ScValType::Duration => Self::Duration(Duration::read_xdr(r)?),
                ScValType::U128 => Self::U128(UInt128Parts::read_xdr(r)?),
                ScValType::I128 => Self::I128(Int128Parts::read_xdr(r)?),
                ScValType::U256 => Self::U256(UInt256Parts::read_xdr(r)?),
                ScValType::I256 => Self::I256(Int256Parts::read_xdr(r)?),
                ScValType::Bytes => Self::Bytes(ScBytes::read_xdr(r)?),
                ScValType::String => Self::String(ScString::read_xdr(r)?),
                ScValType::Symbol => Self::Symbol(ScSymbol::read_xdr(r)?),
                ScValType::Vec => Self::Vec(Option::<ScVec>::read_xdr(r)?),
                ScValType::Map => Self::Map(Option::<ScMap>::read_xdr(r)?),
                ScValType::Address => Self::Address(ScAddress::read_xdr(r)?),
                ScValType::LedgerKeyContractInstance => Self::LedgerKeyContractInstance,
                ScValType::LedgerKeyNonce => Self::LedgerKeyNonce(ScNonceKey::read_xdr(r)?),
                ScValType::ContractInstance => {
                    Self::ContractInstance(ScContractInstance::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScVal {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Bool(v) => v.write_xdr(w)?,
                Self::Void => ().write_xdr(w)?,
                Self::Error(v) => v.write_xdr(w)?,
                Self::U32(v) => v.write_xdr(w)?,
                Self::I32(v) => v.write_xdr(w)?,
                Self::U64(v) => v.write_xdr(w)?,
                Self::I64(v) => v.write_xdr(w)?,
                Self::Timepoint(v) => v.write_xdr(w)?,
                Self::Duration(v) => v.write_xdr(w)?,
                Self::U128(v) => v.write_xdr(w)?,
                Self::I128(v) => v.write_xdr(w)?,
                Self::U256(v) => v.write_xdr(w)?,
                Self::I256(v) => v.write_xdr(w)?,
                Self::Bytes(v) => v.write_xdr(w)?,
                Self::String(v) => v.write_xdr(w)?,
                Self::Symbol(v) => v.write_xdr(w)?,
                Self::Vec(v) => v.write_xdr(w)?,
                Self::Map(v) => v.write_xdr(w)?,
                Self::Address(v) => v.write_xdr(w)?,
                Self::LedgerKeyContractInstance => ().write_xdr(w)?,
                Self::LedgerKeyNonce(v) => v.write_xdr(w)?,
                Self::ContractInstance(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ScMapEntry is an XDR Struct defines as:
///
/// ```text
/// struct SCMapEntry
/// {
///     SCVal key;
///     SCVal val;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScMapEntry {
    pub key: ScVal,
    pub val: ScVal,
}

impl ReadXdr for ScMapEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: ScVal::read_xdr(r)?,
                val: ScVal::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScMapEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;
            self.val.write_xdr(w)?;
            Ok(())
        })
    }
}

/// StoredTransactionSet is an XDR Union defines as:
///
/// ```text
/// union StoredTransactionSet switch (int v)
/// {
/// case 0:
/// 	TransactionSet txSet;
/// case 1:
/// 	GeneralizedTransactionSet generalizedTxSet;
/// };
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum StoredTransactionSet {
    V0(TransactionSet),
    V1(GeneralizedTransactionSet),
}

impl StoredTransactionSet {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for StoredTransactionSet {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for StoredTransactionSet {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for StoredTransactionSet {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for StoredTransactionSet {}

impl ReadXdr for StoredTransactionSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(TransactionSet::read_xdr(r)?),
                1 => Self::V1(GeneralizedTransactionSet::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for StoredTransactionSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// StoredDebugTransactionSet is an XDR Struct defines as:
///
/// ```text
/// struct StoredDebugTransactionSet
/// {
/// 	StoredTransactionSet txSet;
/// 	uint32 ledgerSeq;
/// 	StellarValue scpValue;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct StoredDebugTransactionSet {
    pub tx_set: StoredTransactionSet,
    pub ledger_seq: u32,
    pub scp_value: StellarValue,
}

impl ReadXdr for StoredDebugTransactionSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_set: StoredTransactionSet::read_xdr(r)?,
                ledger_seq: u32::read_xdr(r)?,
                scp_value: StellarValue::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for StoredDebugTransactionSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.tx_set.write_xdr(w)?;
            self.ledger_seq.write_xdr(w)?;
            self.scp_value.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PersistedScpStateV0 is an XDR Struct defines as:
///
/// ```text
/// struct PersistedSCPStateV0
/// {
/// 	SCPEnvelope scpEnvelopes<>;
/// 	SCPQuorumSet quorumSets<>;
/// 	StoredTransactionSet txSets<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct PersistedScpStateV0 {
    pub scp_envelopes: VecM<ScpEnvelope>,
    pub quorum_sets: VecM<ScpQuorumSet>,
    pub tx_sets: VecM<StoredTransactionSet>,
}

impl ReadXdr for PersistedScpStateV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                scp_envelopes: VecM::<ScpEnvelope>::read_xdr(r)?,
                quorum_sets: VecM::<ScpQuorumSet>::read_xdr(r)?,
                tx_sets: VecM::<StoredTransactionSet>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PersistedScpStateV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.scp_envelopes.write_xdr(w)?;
            self.quorum_sets.write_xdr(w)?;
            self.tx_sets.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PersistedScpStateV1 is an XDR Struct defines as:
///
/// ```text
/// struct PersistedSCPStateV1
/// {
/// 	// Tx sets are saved separately
/// 	SCPEnvelope scpEnvelopes<>;
/// 	SCPQuorumSet quorumSets<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct PersistedScpStateV1 {
    pub scp_envelopes: VecM<ScpEnvelope>,
    pub quorum_sets: VecM<ScpQuorumSet>,
}

impl ReadXdr for PersistedScpStateV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                scp_envelopes: VecM::<ScpEnvelope>::read_xdr(r)?,
                quorum_sets: VecM::<ScpQuorumSet>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PersistedScpStateV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.scp_envelopes.write_xdr(w)?;
            self.quorum_sets.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PersistedScpState is an XDR Union defines as:
///
/// ```text
/// union PersistedSCPState switch (int v)
/// {
/// case 0:
/// 	PersistedSCPStateV0 v0;
/// case 1:
/// 	PersistedSCPStateV1 v1;
/// };
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum PersistedScpState {
    V0(PersistedScpStateV0),
    V1(PersistedScpStateV1),
}

impl PersistedScpState {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for PersistedScpState {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for PersistedScpState {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for PersistedScpState {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for PersistedScpState {}

impl ReadXdr for PersistedScpState {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(PersistedScpStateV0::read_xdr(r)?),
                1 => Self::V1(PersistedScpStateV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PersistedScpState {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// Thresholds is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque Thresholds[4];
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
pub struct Thresholds(pub [u8; 4]);

impl core::fmt::Debug for Thresholds {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "Thresholds(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}
impl core::fmt::Display for Thresholds {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl core::str::FromStr for Thresholds {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        hex::decode(s).map_err(|_| Error::InvalidHex)?.try_into()
    }
}
impl From<Thresholds> for [u8; 4] {
    #[must_use]
    fn from(x: Thresholds) -> Self {
        x.0
    }
}

impl From<[u8; 4]> for Thresholds {
    #[must_use]
    fn from(x: [u8; 4]) -> Self {
        Thresholds(x)
    }
}

impl AsRef<[u8; 4]> for Thresholds {
    #[must_use]
    fn as_ref(&self) -> &[u8; 4] {
        &self.0
    }
}

impl ReadXdr for Thresholds {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = <[u8; 4]>::read_xdr(r)?;
            let v = Thresholds(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Thresholds {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Thresholds {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for Thresholds {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for Thresholds {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for Thresholds {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self> {
        Ok(Thresholds(x.try_into()?))
    }
}

impl AsRef<[u8]> for Thresholds {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// String32 is an XDR Typedef defines as:
///
/// ```text
/// typedef string string32<32>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct String32(pub StringM<32>);

impl From<String32> for StringM<32> {
    #[must_use]
    fn from(x: String32) -> Self {
        x.0
    }
}

impl From<StringM<32>> for String32 {
    #[must_use]
    fn from(x: StringM<32>) -> Self {
        String32(x)
    }
}

impl AsRef<StringM<32>> for String32 {
    #[must_use]
    fn as_ref(&self) -> &StringM<32> {
        &self.0
    }
}

impl ReadXdr for String32 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = StringM::<32>::read_xdr(r)?;
            let v = String32(i);
            Ok(v)
        })
    }
}

impl WriteXdr for String32 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for String32 {
    type Target = StringM<32>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<String32> for Vec<u8> {
    #[must_use]
    fn from(x: String32) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for String32 {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        Ok(String32(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for String32 {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        Ok(String32(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for String32 {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for String32 {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// String64 is an XDR Typedef defines as:
///
/// ```text
/// typedef string string64<64>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct String64(pub StringM<64>);

impl From<String64> for StringM<64> {
    #[must_use]
    fn from(x: String64) -> Self {
        x.0
    }
}

impl From<StringM<64>> for String64 {
    #[must_use]
    fn from(x: StringM<64>) -> Self {
        String64(x)
    }
}

impl AsRef<StringM<64>> for String64 {
    #[must_use]
    fn as_ref(&self) -> &StringM<64> {
        &self.0
    }
}

impl ReadXdr for String64 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = StringM::<64>::read_xdr(r)?;
            let v = String64(i);
            Ok(v)
        })
    }
}

impl WriteXdr for String64 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for String64 {
    type Target = StringM<64>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<String64> for Vec<u8> {
    #[must_use]
    fn from(x: String64) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for String64 {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        Ok(String64(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for String64 {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        Ok(String64(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for String64 {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for String64 {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// SequenceNumber is an XDR Typedef defines as:
///
/// ```text
/// typedef int64 SequenceNumber;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct SequenceNumber(pub i64);

impl From<SequenceNumber> for i64 {
    #[must_use]
    fn from(x: SequenceNumber) -> Self {
        x.0
    }
}

impl From<i64> for SequenceNumber {
    #[must_use]
    fn from(x: i64) -> Self {
        SequenceNumber(x)
    }
}

impl AsRef<i64> for SequenceNumber {
    #[must_use]
    fn as_ref(&self) -> &i64 {
        &self.0
    }
}

impl ReadXdr for SequenceNumber {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = i64::read_xdr(r)?;
            let v = SequenceNumber(i);
            Ok(v)
        })
    }
}

impl WriteXdr for SequenceNumber {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// DataValue is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque DataValue<64>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct DataValue(pub BytesM<64>);

impl From<DataValue> for BytesM<64> {
    #[must_use]
    fn from(x: DataValue) -> Self {
        x.0
    }
}

impl From<BytesM<64>> for DataValue {
    #[must_use]
    fn from(x: BytesM<64>) -> Self {
        DataValue(x)
    }
}

impl AsRef<BytesM<64>> for DataValue {
    #[must_use]
    fn as_ref(&self) -> &BytesM<64> {
        &self.0
    }
}

impl ReadXdr for DataValue {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = BytesM::<64>::read_xdr(r)?;
            let v = DataValue(i);
            Ok(v)
        })
    }
}

impl WriteXdr for DataValue {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for DataValue {
    type Target = BytesM<64>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<DataValue> for Vec<u8> {
    #[must_use]
    fn from(x: DataValue) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for DataValue {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        Ok(DataValue(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for DataValue {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        Ok(DataValue(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for DataValue {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for DataValue {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// PoolId is an XDR Typedef defines as:
///
/// ```text
/// typedef Hash PoolID;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct PoolId(pub Hash);

impl From<PoolId> for Hash {
    #[must_use]
    fn from(x: PoolId) -> Self {
        x.0
    }
}

impl From<Hash> for PoolId {
    #[must_use]
    fn from(x: Hash) -> Self {
        PoolId(x)
    }
}

impl AsRef<Hash> for PoolId {
    #[must_use]
    fn as_ref(&self) -> &Hash {
        &self.0
    }
}

impl ReadXdr for PoolId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = Hash::read_xdr(r)?;
            let v = PoolId(i);
            Ok(v)
        })
    }
}

impl WriteXdr for PoolId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// AssetCode4 is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque AssetCode4[4];
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
pub struct AssetCode4(pub [u8; 4]);

impl core::fmt::Debug for AssetCode4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "AssetCode4(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}
impl From<AssetCode4> for [u8; 4] {
    #[must_use]
    fn from(x: AssetCode4) -> Self {
        x.0
    }
}

impl From<[u8; 4]> for AssetCode4 {
    #[must_use]
    fn from(x: [u8; 4]) -> Self {
        AssetCode4(x)
    }
}

impl AsRef<[u8; 4]> for AssetCode4 {
    #[must_use]
    fn as_ref(&self) -> &[u8; 4] {
        &self.0
    }
}

impl ReadXdr for AssetCode4 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = <[u8; 4]>::read_xdr(r)?;
            let v = AssetCode4(i);
            Ok(v)
        })
    }
}

impl WriteXdr for AssetCode4 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl AssetCode4 {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for AssetCode4 {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for AssetCode4 {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for AssetCode4 {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self> {
        Ok(AssetCode4(x.try_into()?))
    }
}

impl AsRef<[u8]> for AssetCode4 {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// AssetCode12 is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque AssetCode12[12];
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
pub struct AssetCode12(pub [u8; 12]);

impl core::fmt::Debug for AssetCode12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "AssetCode12(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}
impl From<AssetCode12> for [u8; 12] {
    #[must_use]
    fn from(x: AssetCode12) -> Self {
        x.0
    }
}

impl From<[u8; 12]> for AssetCode12 {
    #[must_use]
    fn from(x: [u8; 12]) -> Self {
        AssetCode12(x)
    }
}

impl AsRef<[u8; 12]> for AssetCode12 {
    #[must_use]
    fn as_ref(&self) -> &[u8; 12] {
        &self.0
    }
}

impl ReadXdr for AssetCode12 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = <[u8; 12]>::read_xdr(r)?;
            let v = AssetCode12(i);
            Ok(v)
        })
    }
}

impl WriteXdr for AssetCode12 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl AssetCode12 {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for AssetCode12 {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for AssetCode12 {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for AssetCode12 {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self> {
        Ok(AssetCode12(x.try_into()?))
    }
}

impl AsRef<[u8]> for AssetCode12 {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// AssetType is an XDR Enum defines as:
///
/// ```text
/// enum AssetType
/// {
///     ASSET_TYPE_NATIVE = 0,
///     ASSET_TYPE_CREDIT_ALPHANUM4 = 1,
///     ASSET_TYPE_CREDIT_ALPHANUM12 = 2,
///     ASSET_TYPE_POOL_SHARE = 3
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum AssetType {
    Native = 0,
    CreditAlphanum4 = 1,
    CreditAlphanum12 = 2,
    PoolShare = 3,
}

impl AssetType {
    pub const VARIANTS: [AssetType; 4] = [
        AssetType::Native,
        AssetType::CreditAlphanum4,
        AssetType::CreditAlphanum12,
        AssetType::PoolShare,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Native", "CreditAlphanum4", "CreditAlphanum12", "PoolShare"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Native => "Native",
            Self::CreditAlphanum4 => "CreditAlphanum4",
            Self::CreditAlphanum12 => "CreditAlphanum12",
            Self::PoolShare => "PoolShare",
        }
    }

    #[must_use]
    pub const fn variants() -> [AssetType; 4] {
        Self::VARIANTS
    }
}

impl Name for AssetType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<AssetType> for AssetType {
    fn variants() -> slice::Iter<'static, AssetType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for AssetType {}

impl fmt::Display for AssetType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for AssetType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => AssetType::Native,
            1 => AssetType::CreditAlphanum4,
            2 => AssetType::CreditAlphanum12,
            3 => AssetType::PoolShare,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<AssetType> for i32 {
    #[must_use]
    fn from(e: AssetType) -> Self {
        e as Self
    }
}

impl ReadXdr for AssetType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for AssetType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// AssetCode is an XDR Union defines as:
///
/// ```text
/// union AssetCode switch (AssetType type)
/// {
/// case ASSET_TYPE_CREDIT_ALPHANUM4:
///     AssetCode4 assetCode4;
///
/// case ASSET_TYPE_CREDIT_ALPHANUM12:
///     AssetCode12 assetCode12;
///
///     // add other asset types here in the future
/// };
/// ```
///
// union with discriminant AssetType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[allow(clippy::large_enum_variant)]
pub enum AssetCode {
    CreditAlphanum4(AssetCode4),
    CreditAlphanum12(AssetCode12),
}

impl AssetCode {
    pub const VARIANTS: [AssetType; 2] = [AssetType::CreditAlphanum4, AssetType::CreditAlphanum12];
    pub const VARIANTS_STR: [&'static str; 2] = ["CreditAlphanum4", "CreditAlphanum12"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::CreditAlphanum4(_) => "CreditAlphanum4",
            Self::CreditAlphanum12(_) => "CreditAlphanum12",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AssetType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::CreditAlphanum4(_) => AssetType::CreditAlphanum4,
            Self::CreditAlphanum12(_) => AssetType::CreditAlphanum12,
        }
    }

    #[must_use]
    pub const fn variants() -> [AssetType; 2] {
        Self::VARIANTS
    }
}

impl Name for AssetCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AssetType> for AssetCode {
    #[must_use]
    fn discriminant(&self) -> AssetType {
        Self::discriminant(self)
    }
}

impl Variants<AssetType> for AssetCode {
    fn variants() -> slice::Iter<'static, AssetType> {
        Self::VARIANTS.iter()
    }
}

impl Union<AssetType> for AssetCode {}

impl ReadXdr for AssetCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: AssetType = <AssetType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AssetType::CreditAlphanum4 => Self::CreditAlphanum4(AssetCode4::read_xdr(r)?),
                AssetType::CreditAlphanum12 => Self::CreditAlphanum12(AssetCode12::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AssetCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::CreditAlphanum4(v) => v.write_xdr(w)?,
                Self::CreditAlphanum12(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AlphaNum4 is an XDR Struct defines as:
///
/// ```text
/// struct AlphaNum4
/// {
///     AssetCode4 assetCode;
///     AccountID issuer;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct AlphaNum4 {
    pub asset_code: AssetCode4,
    pub issuer: AccountId,
}

impl ReadXdr for AlphaNum4 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                asset_code: AssetCode4::read_xdr(r)?,
                issuer: AccountId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AlphaNum4 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.asset_code.write_xdr(w)?;
            self.issuer.write_xdr(w)?;
            Ok(())
        })
    }
}

/// AlphaNum12 is an XDR Struct defines as:
///
/// ```text
/// struct AlphaNum12
/// {
///     AssetCode12 assetCode;
///     AccountID issuer;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct AlphaNum12 {
    pub asset_code: AssetCode12,
    pub issuer: AccountId,
}

impl ReadXdr for AlphaNum12 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                asset_code: AssetCode12::read_xdr(r)?,
                issuer: AccountId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AlphaNum12 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.asset_code.write_xdr(w)?;
            self.issuer.write_xdr(w)?;
            Ok(())
        })
    }
}

/// Asset is an XDR Union defines as:
///
/// ```text
/// union Asset switch (AssetType type)
/// {
/// case ASSET_TYPE_NATIVE: // Not credit
///     void;
///
/// case ASSET_TYPE_CREDIT_ALPHANUM4:
///     AlphaNum4 alphaNum4;
///
/// case ASSET_TYPE_CREDIT_ALPHANUM12:
///     AlphaNum12 alphaNum12;
///
///     // add other asset types here in the future
/// };
/// ```
///
// union with discriminant AssetType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum Asset {
    Native,
    CreditAlphanum4(AlphaNum4),
    CreditAlphanum12(AlphaNum12),
}

impl Asset {
    pub const VARIANTS: [AssetType; 3] = [
        AssetType::Native,
        AssetType::CreditAlphanum4,
        AssetType::CreditAlphanum12,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["Native", "CreditAlphanum4", "CreditAlphanum12"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Native => "Native",
            Self::CreditAlphanum4(_) => "CreditAlphanum4",
            Self::CreditAlphanum12(_) => "CreditAlphanum12",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AssetType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Native => AssetType::Native,
            Self::CreditAlphanum4(_) => AssetType::CreditAlphanum4,
            Self::CreditAlphanum12(_) => AssetType::CreditAlphanum12,
        }
    }

    #[must_use]
    pub const fn variants() -> [AssetType; 3] {
        Self::VARIANTS
    }
}

impl Name for Asset {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AssetType> for Asset {
    #[must_use]
    fn discriminant(&self) -> AssetType {
        Self::discriminant(self)
    }
}

impl Variants<AssetType> for Asset {
    fn variants() -> slice::Iter<'static, AssetType> {
        Self::VARIANTS.iter()
    }
}

impl Union<AssetType> for Asset {}

impl ReadXdr for Asset {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: AssetType = <AssetType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AssetType::Native => Self::Native,
                AssetType::CreditAlphanum4 => Self::CreditAlphanum4(AlphaNum4::read_xdr(r)?),
                AssetType::CreditAlphanum12 => Self::CreditAlphanum12(AlphaNum12::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for Asset {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Native => ().write_xdr(w)?,
                Self::CreditAlphanum4(v) => v.write_xdr(w)?,
                Self::CreditAlphanum12(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// Price is an XDR Struct defines as:
///
/// ```text
/// struct Price
/// {
///     int32 n; // numerator
///     int32 d; // denominator
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Price {
    pub n: i32,
    pub d: i32,
}

impl ReadXdr for Price {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                n: i32::read_xdr(r)?,
                d: i32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Price {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.n.write_xdr(w)?;
            self.d.write_xdr(w)?;
            Ok(())
        })
    }
}

/// Liabilities is an XDR Struct defines as:
///
/// ```text
/// struct Liabilities
/// {
///     int64 buying;
///     int64 selling;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Liabilities {
    pub buying: i64,
    pub selling: i64,
}

impl ReadXdr for Liabilities {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                buying: i64::read_xdr(r)?,
                selling: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Liabilities {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.buying.write_xdr(w)?;
            self.selling.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ThresholdIndexes is an XDR Enum defines as:
///
/// ```text
/// enum ThresholdIndexes
/// {
///     THRESHOLD_MASTER_WEIGHT = 0,
///     THRESHOLD_LOW = 1,
///     THRESHOLD_MED = 2,
///     THRESHOLD_HIGH = 3
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ThresholdIndexes {
    MasterWeight = 0,
    Low = 1,
    Med = 2,
    High = 3,
}

impl ThresholdIndexes {
    pub const VARIANTS: [ThresholdIndexes; 4] = [
        ThresholdIndexes::MasterWeight,
        ThresholdIndexes::Low,
        ThresholdIndexes::Med,
        ThresholdIndexes::High,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = ["MasterWeight", "Low", "Med", "High"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::MasterWeight => "MasterWeight",
            Self::Low => "Low",
            Self::Med => "Med",
            Self::High => "High",
        }
    }

    #[must_use]
    pub const fn variants() -> [ThresholdIndexes; 4] {
        Self::VARIANTS
    }
}

impl Name for ThresholdIndexes {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ThresholdIndexes> for ThresholdIndexes {
    fn variants() -> slice::Iter<'static, ThresholdIndexes> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ThresholdIndexes {}

impl fmt::Display for ThresholdIndexes {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ThresholdIndexes {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ThresholdIndexes::MasterWeight,
            1 => ThresholdIndexes::Low,
            2 => ThresholdIndexes::Med,
            3 => ThresholdIndexes::High,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ThresholdIndexes> for i32 {
    #[must_use]
    fn from(e: ThresholdIndexes) -> Self {
        e as Self
    }
}

impl ReadXdr for ThresholdIndexes {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ThresholdIndexes {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LedgerEntryType is an XDR Enum defines as:
///
/// ```text
/// enum LedgerEntryType
/// {
///     ACCOUNT = 0,
///     TRUSTLINE = 1,
///     OFFER = 2,
///     DATA = 3,
///     CLAIMABLE_BALANCE = 4,
///     LIQUIDITY_POOL = 5,
///     CONTRACT_DATA = 6,
///     CONTRACT_CODE = 7,
///     CONFIG_SETTING = 8,
///     TTL = 9
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum LedgerEntryType {
    Account = 0,
    Trustline = 1,
    Offer = 2,
    Data = 3,
    ClaimableBalance = 4,
    LiquidityPool = 5,
    ContractData = 6,
    ContractCode = 7,
    ConfigSetting = 8,
    Ttl = 9,
}

impl LedgerEntryType {
    pub const VARIANTS: [LedgerEntryType; 10] = [
        LedgerEntryType::Account,
        LedgerEntryType::Trustline,
        LedgerEntryType::Offer,
        LedgerEntryType::Data,
        LedgerEntryType::ClaimableBalance,
        LedgerEntryType::LiquidityPool,
        LedgerEntryType::ContractData,
        LedgerEntryType::ContractCode,
        LedgerEntryType::ConfigSetting,
        LedgerEntryType::Ttl,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "Account",
        "Trustline",
        "Offer",
        "Data",
        "ClaimableBalance",
        "LiquidityPool",
        "ContractData",
        "ContractCode",
        "ConfigSetting",
        "Ttl",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Account => "Account",
            Self::Trustline => "Trustline",
            Self::Offer => "Offer",
            Self::Data => "Data",
            Self::ClaimableBalance => "ClaimableBalance",
            Self::LiquidityPool => "LiquidityPool",
            Self::ContractData => "ContractData",
            Self::ContractCode => "ContractCode",
            Self::ConfigSetting => "ConfigSetting",
            Self::Ttl => "Ttl",
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerEntryType; 10] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LedgerEntryType> for LedgerEntryType {
    fn variants() -> slice::Iter<'static, LedgerEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LedgerEntryType {}

impl fmt::Display for LedgerEntryType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LedgerEntryType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => LedgerEntryType::Account,
            1 => LedgerEntryType::Trustline,
            2 => LedgerEntryType::Offer,
            3 => LedgerEntryType::Data,
            4 => LedgerEntryType::ClaimableBalance,
            5 => LedgerEntryType::LiquidityPool,
            6 => LedgerEntryType::ContractData,
            7 => LedgerEntryType::ContractCode,
            8 => LedgerEntryType::ConfigSetting,
            9 => LedgerEntryType::Ttl,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LedgerEntryType> for i32 {
    #[must_use]
    fn from(e: LedgerEntryType) -> Self {
        e as Self
    }
}

impl ReadXdr for LedgerEntryType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// Signer is an XDR Struct defines as:
///
/// ```text
/// struct Signer
/// {
///     SignerKey key;
///     uint32 weight; // really only need 1 byte
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Signer {
    pub key: SignerKey,
    pub weight: u32,
}

impl ReadXdr for Signer {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: SignerKey::read_xdr(r)?,
                weight: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Signer {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;
            self.weight.write_xdr(w)?;
            Ok(())
        })
    }
}

/// AccountFlags is an XDR Enum defines as:
///
/// ```text
/// enum AccountFlags
/// { // masks for each flag
///
///     // Flags set on issuer accounts
///     // TrustLines are created with authorized set to "false" requiring
///     // the issuer to set it for each TrustLine
///     AUTH_REQUIRED_FLAG = 0x1,
///     // If set, the authorized flag in TrustLines can be cleared
///     // otherwise, authorization cannot be revoked
///     AUTH_REVOCABLE_FLAG = 0x2,
///     // Once set, causes all AUTH_* flags to be read-only
///     AUTH_IMMUTABLE_FLAG = 0x4,
///     // Trustlines are created with clawback enabled set to "true",
///     // and claimable balances created from those trustlines are created
///     // with clawback enabled set to "true"
///     AUTH_CLAWBACK_ENABLED_FLAG = 0x8
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum AccountFlags {
    RequiredFlag = 1,
    RevocableFlag = 2,
    ImmutableFlag = 4,
    ClawbackEnabledFlag = 8,
}

impl AccountFlags {
    pub const VARIANTS: [AccountFlags; 4] = [
        AccountFlags::RequiredFlag,
        AccountFlags::RevocableFlag,
        AccountFlags::ImmutableFlag,
        AccountFlags::ClawbackEnabledFlag,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "RequiredFlag",
        "RevocableFlag",
        "ImmutableFlag",
        "ClawbackEnabledFlag",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::RequiredFlag => "RequiredFlag",
            Self::RevocableFlag => "RevocableFlag",
            Self::ImmutableFlag => "ImmutableFlag",
            Self::ClawbackEnabledFlag => "ClawbackEnabledFlag",
        }
    }

    #[must_use]
    pub const fn variants() -> [AccountFlags; 4] {
        Self::VARIANTS
    }
}

impl Name for AccountFlags {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<AccountFlags> for AccountFlags {
    fn variants() -> slice::Iter<'static, AccountFlags> {
        Self::VARIANTS.iter()
    }
}

impl Enum for AccountFlags {}

impl fmt::Display for AccountFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for AccountFlags {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            1 => AccountFlags::RequiredFlag,
            2 => AccountFlags::RevocableFlag,
            4 => AccountFlags::ImmutableFlag,
            8 => AccountFlags::ClawbackEnabledFlag,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<AccountFlags> for i32 {
    #[must_use]
    fn from(e: AccountFlags) -> Self {
        e as Self
    }
}

impl ReadXdr for AccountFlags {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for AccountFlags {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// MaskAccountFlags is an XDR Const defines as:
///
/// ```text
/// const MASK_ACCOUNT_FLAGS = 0x7;
/// ```
///
pub const MASK_ACCOUNT_FLAGS: u64 = 0x7;

/// MaskAccountFlagsV17 is an XDR Const defines as:
///
/// ```text
/// const MASK_ACCOUNT_FLAGS_V17 = 0xF;
/// ```
///
pub const MASK_ACCOUNT_FLAGS_V17: u64 = 0xF;

/// MaxSigners is an XDR Const defines as:
///
/// ```text
/// const MAX_SIGNERS = 20;
/// ```
///
pub const MAX_SIGNERS: u64 = 20;

/// SponsorshipDescriptor is an XDR Typedef defines as:
///
/// ```text
/// typedef AccountID* SponsorshipDescriptor;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct SponsorshipDescriptor(pub Option<AccountId>);

impl From<SponsorshipDescriptor> for Option<AccountId> {
    #[must_use]
    fn from(x: SponsorshipDescriptor) -> Self {
        x.0
    }
}

impl From<Option<AccountId>> for SponsorshipDescriptor {
    #[must_use]
    fn from(x: Option<AccountId>) -> Self {
        SponsorshipDescriptor(x)
    }
}

impl AsRef<Option<AccountId>> for SponsorshipDescriptor {
    #[must_use]
    fn as_ref(&self) -> &Option<AccountId> {
        &self.0
    }
}

impl ReadXdr for SponsorshipDescriptor {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = Option::<AccountId>::read_xdr(r)?;
            let v = SponsorshipDescriptor(i);
            Ok(v)
        })
    }
}

impl WriteXdr for SponsorshipDescriptor {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// AccountEntryExtensionV3 is an XDR Struct defines as:
///
/// ```text
/// struct AccountEntryExtensionV3
/// {
///     // We can use this to add more fields, or because it is first, to
///     // change AccountEntryExtensionV3 into a union.
///     ExtensionPoint ext;
///
///     // Ledger number at which `seqNum` took on its present value.
///     uint32 seqLedger;
///
///     // Time at which `seqNum` took on its present value.
///     TimePoint seqTime;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct AccountEntryExtensionV3 {
    pub ext: ExtensionPoint,
    pub seq_ledger: u32,
    pub seq_time: TimePoint,
}

impl ReadXdr for AccountEntryExtensionV3 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
                seq_ledger: u32::read_xdr(r)?,
                seq_time: TimePoint::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AccountEntryExtensionV3 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.seq_ledger.write_xdr(w)?;
            self.seq_time.write_xdr(w)?;
            Ok(())
        })
    }
}

/// AccountEntryExtensionV2Ext is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     case 3:
///         AccountEntryExtensionV3 v3;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum AccountEntryExtensionV2Ext {
    V0,
    V3(AccountEntryExtensionV3),
}

impl AccountEntryExtensionV2Ext {
    pub const VARIANTS: [i32; 2] = [0, 3];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V3"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V3(_) => "V3",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V3(_) => 3,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for AccountEntryExtensionV2Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for AccountEntryExtensionV2Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for AccountEntryExtensionV2Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for AccountEntryExtensionV2Ext {}

impl ReadXdr for AccountEntryExtensionV2Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                3 => Self::V3(AccountEntryExtensionV3::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AccountEntryExtensionV2Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V3(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AccountEntryExtensionV2 is an XDR Struct defines as:
///
/// ```text
/// struct AccountEntryExtensionV2
/// {
///     uint32 numSponsored;
///     uint32 numSponsoring;
///     SponsorshipDescriptor signerSponsoringIDs<MAX_SIGNERS>;
///
///     union switch (int v)
///     {
///     case 0:
///         void;
///     case 3:
///         AccountEntryExtensionV3 v3;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct AccountEntryExtensionV2 {
    pub num_sponsored: u32,
    pub num_sponsoring: u32,
    pub signer_sponsoring_i_ds: VecM<SponsorshipDescriptor, 20>,
    pub ext: AccountEntryExtensionV2Ext,
}

impl ReadXdr for AccountEntryExtensionV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                num_sponsored: u32::read_xdr(r)?,
                num_sponsoring: u32::read_xdr(r)?,
                signer_sponsoring_i_ds: VecM::<SponsorshipDescriptor, 20>::read_xdr(r)?,
                ext: AccountEntryExtensionV2Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AccountEntryExtensionV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.num_sponsored.write_xdr(w)?;
            self.num_sponsoring.write_xdr(w)?;
            self.signer_sponsoring_i_ds.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// AccountEntryExtensionV1Ext is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     case 2:
///         AccountEntryExtensionV2 v2;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum AccountEntryExtensionV1Ext {
    V0,
    V2(AccountEntryExtensionV2),
}

impl AccountEntryExtensionV1Ext {
    pub const VARIANTS: [i32; 2] = [0, 2];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V2"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V2(_) => "V2",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V2(_) => 2,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for AccountEntryExtensionV1Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for AccountEntryExtensionV1Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for AccountEntryExtensionV1Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for AccountEntryExtensionV1Ext {}

impl ReadXdr for AccountEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                2 => Self::V2(AccountEntryExtensionV2::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AccountEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V2(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AccountEntryExtensionV1 is an XDR Struct defines as:
///
/// ```text
/// struct AccountEntryExtensionV1
/// {
///     Liabilities liabilities;
///
///     union switch (int v)
///     {
///     case 0:
///         void;
///     case 2:
///         AccountEntryExtensionV2 v2;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct AccountEntryExtensionV1 {
    pub liabilities: Liabilities,
    pub ext: AccountEntryExtensionV1Ext,
}

impl ReadXdr for AccountEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liabilities: Liabilities::read_xdr(r)?,
                ext: AccountEntryExtensionV1Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AccountEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.liabilities.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// AccountEntryExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         AccountEntryExtensionV1 v1;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum AccountEntryExt {
    V0,
    V1(AccountEntryExtensionV1),
}

impl AccountEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for AccountEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for AccountEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for AccountEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for AccountEntryExt {}

impl ReadXdr for AccountEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                1 => Self::V1(AccountEntryExtensionV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AccountEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AccountEntry is an XDR Struct defines as:
///
/// ```text
/// struct AccountEntry
/// {
///     AccountID accountID;      // master public key for this account
///     int64 balance;            // in stroops
///     SequenceNumber seqNum;    // last sequence number used for this account
///     uint32 numSubEntries;     // number of sub-entries this account has
///                               // drives the reserve
///     AccountID* inflationDest; // Account to vote for during inflation
///     uint32 flags;             // see AccountFlags
///
///     string32 homeDomain; // can be used for reverse federation and memo lookup
///
///     // fields used for signatures
///     // thresholds stores unsigned bytes: [weight of master|low|medium|high]
///     Thresholds thresholds;
///
///     Signer signers<MAX_SIGNERS>; // possible signers for this account
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         AccountEntryExtensionV1 v1;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct AccountEntry {
    pub account_id: AccountId,
    pub balance: i64,
    pub seq_num: SequenceNumber,
    pub num_sub_entries: u32,
    pub inflation_dest: Option<AccountId>,
    pub flags: u32,
    pub home_domain: String32,
    pub thresholds: Thresholds,
    pub signers: VecM<Signer, 20>,
    pub ext: AccountEntryExt,
}

impl ReadXdr for AccountEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,
                balance: i64::read_xdr(r)?,
                seq_num: SequenceNumber::read_xdr(r)?,
                num_sub_entries: u32::read_xdr(r)?,
                inflation_dest: Option::<AccountId>::read_xdr(r)?,
                flags: u32::read_xdr(r)?,
                home_domain: String32::read_xdr(r)?,
                thresholds: Thresholds::read_xdr(r)?,
                signers: VecM::<Signer, 20>::read_xdr(r)?,
                ext: AccountEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AccountEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;
            self.balance.write_xdr(w)?;
            self.seq_num.write_xdr(w)?;
            self.num_sub_entries.write_xdr(w)?;
            self.inflation_dest.write_xdr(w)?;
            self.flags.write_xdr(w)?;
            self.home_domain.write_xdr(w)?;
            self.thresholds.write_xdr(w)?;
            self.signers.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TrustLineFlags is an XDR Enum defines as:
///
/// ```text
/// enum TrustLineFlags
/// {
///     // issuer has authorized account to perform transactions with its credit
///     AUTHORIZED_FLAG = 1,
///     // issuer has authorized account to maintain and reduce liabilities for its
///     // credit
///     AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG = 2,
///     // issuer has specified that it may clawback its credit, and that claimable
///     // balances created with its credit may also be clawed back
///     TRUSTLINE_CLAWBACK_ENABLED_FLAG = 4
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum TrustLineFlags {
    AuthorizedFlag = 1,
    AuthorizedToMaintainLiabilitiesFlag = 2,
    TrustlineClawbackEnabledFlag = 4,
}

impl TrustLineFlags {
    pub const VARIANTS: [TrustLineFlags; 3] = [
        TrustLineFlags::AuthorizedFlag,
        TrustLineFlags::AuthorizedToMaintainLiabilitiesFlag,
        TrustLineFlags::TrustlineClawbackEnabledFlag,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = [
        "AuthorizedFlag",
        "AuthorizedToMaintainLiabilitiesFlag",
        "TrustlineClawbackEnabledFlag",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::AuthorizedFlag => "AuthorizedFlag",
            Self::AuthorizedToMaintainLiabilitiesFlag => "AuthorizedToMaintainLiabilitiesFlag",
            Self::TrustlineClawbackEnabledFlag => "TrustlineClawbackEnabledFlag",
        }
    }

    #[must_use]
    pub const fn variants() -> [TrustLineFlags; 3] {
        Self::VARIANTS
    }
}

impl Name for TrustLineFlags {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TrustLineFlags> for TrustLineFlags {
    fn variants() -> slice::Iter<'static, TrustLineFlags> {
        Self::VARIANTS.iter()
    }
}

impl Enum for TrustLineFlags {}

impl fmt::Display for TrustLineFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for TrustLineFlags {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            1 => TrustLineFlags::AuthorizedFlag,
            2 => TrustLineFlags::AuthorizedToMaintainLiabilitiesFlag,
            4 => TrustLineFlags::TrustlineClawbackEnabledFlag,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<TrustLineFlags> for i32 {
    #[must_use]
    fn from(e: TrustLineFlags) -> Self {
        e as Self
    }
}

impl ReadXdr for TrustLineFlags {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for TrustLineFlags {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// MaskTrustlineFlags is an XDR Const defines as:
///
/// ```text
/// const MASK_TRUSTLINE_FLAGS = 1;
/// ```
///
pub const MASK_TRUSTLINE_FLAGS: u64 = 1;

/// MaskTrustlineFlagsV13 is an XDR Const defines as:
///
/// ```text
/// const MASK_TRUSTLINE_FLAGS_V13 = 3;
/// ```
///
pub const MASK_TRUSTLINE_FLAGS_V13: u64 = 3;

/// MaskTrustlineFlagsV17 is an XDR Const defines as:
///
/// ```text
/// const MASK_TRUSTLINE_FLAGS_V17 = 7;
/// ```
///
pub const MASK_TRUSTLINE_FLAGS_V17: u64 = 7;

/// LiquidityPoolType is an XDR Enum defines as:
///
/// ```text
/// enum LiquidityPoolType
/// {
///     LIQUIDITY_POOL_CONSTANT_PRODUCT = 0
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum LiquidityPoolType {
    LiquidityPoolConstantProduct = 0,
}

impl LiquidityPoolType {
    pub const VARIANTS: [LiquidityPoolType; 1] = [LiquidityPoolType::LiquidityPoolConstantProduct];
    pub const VARIANTS_STR: [&'static str; 1] = ["LiquidityPoolConstantProduct"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LiquidityPoolConstantProduct => "LiquidityPoolConstantProduct",
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolType; 1] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LiquidityPoolType> for LiquidityPoolType {
    fn variants() -> slice::Iter<'static, LiquidityPoolType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LiquidityPoolType {}

impl fmt::Display for LiquidityPoolType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LiquidityPoolType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => LiquidityPoolType::LiquidityPoolConstantProduct,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LiquidityPoolType> for i32 {
    #[must_use]
    fn from(e: LiquidityPoolType) -> Self {
        e as Self
    }
}

impl ReadXdr for LiquidityPoolType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// TrustLineAsset is an XDR Union defines as:
///
/// ```text
/// union TrustLineAsset switch (AssetType type)
/// {
/// case ASSET_TYPE_NATIVE: // Not credit
///     void;
///
/// case ASSET_TYPE_CREDIT_ALPHANUM4:
///     AlphaNum4 alphaNum4;
///
/// case ASSET_TYPE_CREDIT_ALPHANUM12:
///     AlphaNum12 alphaNum12;
///
/// case ASSET_TYPE_POOL_SHARE:
///     PoolID liquidityPoolID;
///
///     // add other asset types here in the future
/// };
/// ```
///
// union with discriminant AssetType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TrustLineAsset {
    Native,
    CreditAlphanum4(AlphaNum4),
    CreditAlphanum12(AlphaNum12),
    PoolShare(PoolId),
}

impl TrustLineAsset {
    pub const VARIANTS: [AssetType; 4] = [
        AssetType::Native,
        AssetType::CreditAlphanum4,
        AssetType::CreditAlphanum12,
        AssetType::PoolShare,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Native", "CreditAlphanum4", "CreditAlphanum12", "PoolShare"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Native => "Native",
            Self::CreditAlphanum4(_) => "CreditAlphanum4",
            Self::CreditAlphanum12(_) => "CreditAlphanum12",
            Self::PoolShare(_) => "PoolShare",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AssetType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Native => AssetType::Native,
            Self::CreditAlphanum4(_) => AssetType::CreditAlphanum4,
            Self::CreditAlphanum12(_) => AssetType::CreditAlphanum12,
            Self::PoolShare(_) => AssetType::PoolShare,
        }
    }

    #[must_use]
    pub const fn variants() -> [AssetType; 4] {
        Self::VARIANTS
    }
}

impl Name for TrustLineAsset {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AssetType> for TrustLineAsset {
    #[must_use]
    fn discriminant(&self) -> AssetType {
        Self::discriminant(self)
    }
}

impl Variants<AssetType> for TrustLineAsset {
    fn variants() -> slice::Iter<'static, AssetType> {
        Self::VARIANTS.iter()
    }
}

impl Union<AssetType> for TrustLineAsset {}

impl ReadXdr for TrustLineAsset {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: AssetType = <AssetType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AssetType::Native => Self::Native,
                AssetType::CreditAlphanum4 => Self::CreditAlphanum4(AlphaNum4::read_xdr(r)?),
                AssetType::CreditAlphanum12 => Self::CreditAlphanum12(AlphaNum12::read_xdr(r)?),
                AssetType::PoolShare => Self::PoolShare(PoolId::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TrustLineAsset {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Native => ().write_xdr(w)?,
                Self::CreditAlphanum4(v) => v.write_xdr(w)?,
                Self::CreditAlphanum12(v) => v.write_xdr(w)?,
                Self::PoolShare(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TrustLineEntryExtensionV2Ext is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TrustLineEntryExtensionV2Ext {
    V0,
}

impl TrustLineEntryExtensionV2Ext {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for TrustLineEntryExtensionV2Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TrustLineEntryExtensionV2Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TrustLineEntryExtensionV2Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TrustLineEntryExtensionV2Ext {}

impl ReadXdr for TrustLineEntryExtensionV2Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TrustLineEntryExtensionV2Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TrustLineEntryExtensionV2 is an XDR Struct defines as:
///
/// ```text
/// struct TrustLineEntryExtensionV2
/// {
///     int32 liquidityPoolUseCount;
///
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TrustLineEntryExtensionV2 {
    pub liquidity_pool_use_count: i32,
    pub ext: TrustLineEntryExtensionV2Ext,
}

impl ReadXdr for TrustLineEntryExtensionV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_use_count: i32::read_xdr(r)?,
                ext: TrustLineEntryExtensionV2Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TrustLineEntryExtensionV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_use_count.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TrustLineEntryV1Ext is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///             {
///             case 0:
///                 void;
///             case 2:
///                 TrustLineEntryExtensionV2 v2;
///             }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TrustLineEntryV1Ext {
    V0,
    V2(TrustLineEntryExtensionV2),
}

impl TrustLineEntryV1Ext {
    pub const VARIANTS: [i32; 2] = [0, 2];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V2"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V2(_) => "V2",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V2(_) => 2,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for TrustLineEntryV1Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TrustLineEntryV1Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TrustLineEntryV1Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TrustLineEntryV1Ext {}

impl ReadXdr for TrustLineEntryV1Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                2 => Self::V2(TrustLineEntryExtensionV2::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TrustLineEntryV1Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V2(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TrustLineEntryV1 is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///         {
///             Liabilities liabilities;
///
///             union switch (int v)
///             {
///             case 0:
///                 void;
///             case 2:
///                 TrustLineEntryExtensionV2 v2;
///             }
///             ext;
///         }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TrustLineEntryV1 {
    pub liabilities: Liabilities,
    pub ext: TrustLineEntryV1Ext,
}

impl ReadXdr for TrustLineEntryV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liabilities: Liabilities::read_xdr(r)?,
                ext: TrustLineEntryV1Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TrustLineEntryV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.liabilities.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TrustLineEntryExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         struct
///         {
///             Liabilities liabilities;
///
///             union switch (int v)
///             {
///             case 0:
///                 void;
///             case 2:
///                 TrustLineEntryExtensionV2 v2;
///             }
///             ext;
///         } v1;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TrustLineEntryExt {
    V0,
    V1(TrustLineEntryV1),
}

impl TrustLineEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for TrustLineEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TrustLineEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TrustLineEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TrustLineEntryExt {}

impl ReadXdr for TrustLineEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                1 => Self::V1(TrustLineEntryV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TrustLineEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TrustLineEntry is an XDR Struct defines as:
///
/// ```text
/// struct TrustLineEntry
/// {
///     AccountID accountID;  // account this trustline belongs to
///     TrustLineAsset asset; // type of asset (with issuer)
///     int64 balance;        // how much of this asset the user has.
///                           // Asset defines the unit for this;
///
///     int64 limit;  // balance cannot be above this
///     uint32 flags; // see TrustLineFlags
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         struct
///         {
///             Liabilities liabilities;
///
///             union switch (int v)
///             {
///             case 0:
///                 void;
///             case 2:
///                 TrustLineEntryExtensionV2 v2;
///             }
///             ext;
///         } v1;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TrustLineEntry {
    pub account_id: AccountId,
    pub asset: TrustLineAsset,
    pub balance: i64,
    pub limit: i64,
    pub flags: u32,
    pub ext: TrustLineEntryExt,
}

impl ReadXdr for TrustLineEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,
                asset: TrustLineAsset::read_xdr(r)?,
                balance: i64::read_xdr(r)?,
                limit: i64::read_xdr(r)?,
                flags: u32::read_xdr(r)?,
                ext: TrustLineEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TrustLineEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;
            self.asset.write_xdr(w)?;
            self.balance.write_xdr(w)?;
            self.limit.write_xdr(w)?;
            self.flags.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// OfferEntryFlags is an XDR Enum defines as:
///
/// ```text
/// enum OfferEntryFlags
/// {
///     // an offer with this flag will not act on and take a reverse offer of equal
///     // price
///     PASSIVE_FLAG = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum OfferEntryFlags {
    PassiveFlag = 1,
}

impl OfferEntryFlags {
    pub const VARIANTS: [OfferEntryFlags; 1] = [OfferEntryFlags::PassiveFlag];
    pub const VARIANTS_STR: [&'static str; 1] = ["PassiveFlag"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PassiveFlag => "PassiveFlag",
        }
    }

    #[must_use]
    pub const fn variants() -> [OfferEntryFlags; 1] {
        Self::VARIANTS
    }
}

impl Name for OfferEntryFlags {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<OfferEntryFlags> for OfferEntryFlags {
    fn variants() -> slice::Iter<'static, OfferEntryFlags> {
        Self::VARIANTS.iter()
    }
}

impl Enum for OfferEntryFlags {}

impl fmt::Display for OfferEntryFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for OfferEntryFlags {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            1 => OfferEntryFlags::PassiveFlag,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<OfferEntryFlags> for i32 {
    #[must_use]
    fn from(e: OfferEntryFlags) -> Self {
        e as Self
    }
}

impl ReadXdr for OfferEntryFlags {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for OfferEntryFlags {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// MaskOfferentryFlags is an XDR Const defines as:
///
/// ```text
/// const MASK_OFFERENTRY_FLAGS = 1;
/// ```
///
pub const MASK_OFFERENTRY_FLAGS: u64 = 1;

/// OfferEntryExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum OfferEntryExt {
    V0,
}

impl OfferEntryExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for OfferEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for OfferEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for OfferEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for OfferEntryExt {}

impl ReadXdr for OfferEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for OfferEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// OfferEntry is an XDR Struct defines as:
///
/// ```text
/// struct OfferEntry
/// {
///     AccountID sellerID;
///     int64 offerID;
///     Asset selling; // A
///     Asset buying;  // B
///     int64 amount;  // amount of A
///
///     /* price for this offer:
///         price of A in terms of B
///         price=AmountB/AmountA=priceNumerator/priceDenominator
///         price is after fees
///     */
///     Price price;
///     uint32 flags; // see OfferEntryFlags
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct OfferEntry {
    pub seller_id: AccountId,
    pub offer_id: i64,
    pub selling: Asset,
    pub buying: Asset,
    pub amount: i64,
    pub price: Price,
    pub flags: u32,
    pub ext: OfferEntryExt,
}

impl ReadXdr for OfferEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                seller_id: AccountId::read_xdr(r)?,
                offer_id: i64::read_xdr(r)?,
                selling: Asset::read_xdr(r)?,
                buying: Asset::read_xdr(r)?,
                amount: i64::read_xdr(r)?,
                price: Price::read_xdr(r)?,
                flags: u32::read_xdr(r)?,
                ext: OfferEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for OfferEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.seller_id.write_xdr(w)?;
            self.offer_id.write_xdr(w)?;
            self.selling.write_xdr(w)?;
            self.buying.write_xdr(w)?;
            self.amount.write_xdr(w)?;
            self.price.write_xdr(w)?;
            self.flags.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// DataEntryExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum DataEntryExt {
    V0,
}

impl DataEntryExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for DataEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for DataEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for DataEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for DataEntryExt {}

impl ReadXdr for DataEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for DataEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// DataEntry is an XDR Struct defines as:
///
/// ```text
/// struct DataEntry
/// {
///     AccountID accountID; // account this data belongs to
///     string64 dataName;
///     DataValue dataValue;
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct DataEntry {
    pub account_id: AccountId,
    pub data_name: String64,
    pub data_value: DataValue,
    pub ext: DataEntryExt,
}

impl ReadXdr for DataEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,
                data_name: String64::read_xdr(r)?,
                data_value: DataValue::read_xdr(r)?,
                ext: DataEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for DataEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;
            self.data_name.write_xdr(w)?;
            self.data_value.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ClaimPredicateType is an XDR Enum defines as:
///
/// ```text
/// enum ClaimPredicateType
/// {
///     CLAIM_PREDICATE_UNCONDITIONAL = 0,
///     CLAIM_PREDICATE_AND = 1,
///     CLAIM_PREDICATE_OR = 2,
///     CLAIM_PREDICATE_NOT = 3,
///     CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME = 4,
///     CLAIM_PREDICATE_BEFORE_RELATIVE_TIME = 5
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ClaimPredicateType {
    Unconditional = 0,
    And = 1,
    Or = 2,
    Not = 3,
    BeforeAbsoluteTime = 4,
    BeforeRelativeTime = 5,
}

impl ClaimPredicateType {
    pub const VARIANTS: [ClaimPredicateType; 6] = [
        ClaimPredicateType::Unconditional,
        ClaimPredicateType::And,
        ClaimPredicateType::Or,
        ClaimPredicateType::Not,
        ClaimPredicateType::BeforeAbsoluteTime,
        ClaimPredicateType::BeforeRelativeTime,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Unconditional",
        "And",
        "Or",
        "Not",
        "BeforeAbsoluteTime",
        "BeforeRelativeTime",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Unconditional => "Unconditional",
            Self::And => "And",
            Self::Or => "Or",
            Self::Not => "Not",
            Self::BeforeAbsoluteTime => "BeforeAbsoluteTime",
            Self::BeforeRelativeTime => "BeforeRelativeTime",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimPredicateType; 6] {
        Self::VARIANTS
    }
}

impl Name for ClaimPredicateType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimPredicateType> for ClaimPredicateType {
    fn variants() -> slice::Iter<'static, ClaimPredicateType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimPredicateType {}

impl fmt::Display for ClaimPredicateType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimPredicateType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ClaimPredicateType::Unconditional,
            1 => ClaimPredicateType::And,
            2 => ClaimPredicateType::Or,
            3 => ClaimPredicateType::Not,
            4 => ClaimPredicateType::BeforeAbsoluteTime,
            5 => ClaimPredicateType::BeforeRelativeTime,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimPredicateType> for i32 {
    #[must_use]
    fn from(e: ClaimPredicateType) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimPredicateType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimPredicateType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClaimPredicate is an XDR Union defines as:
///
/// ```text
/// union ClaimPredicate switch (ClaimPredicateType type)
/// {
/// case CLAIM_PREDICATE_UNCONDITIONAL:
///     void;
/// case CLAIM_PREDICATE_AND:
///     ClaimPredicate andPredicates<2>;
/// case CLAIM_PREDICATE_OR:
///     ClaimPredicate orPredicates<2>;
/// case CLAIM_PREDICATE_NOT:
///     ClaimPredicate* notPredicate;
/// case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
///     int64 absBefore; // Predicate will be true if closeTime < absBefore
/// case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
///     int64 relBefore; // Seconds since closeTime of the ledger in which the
///                      // ClaimableBalanceEntry was created
/// };
/// ```
///
// union with discriminant ClaimPredicateType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ClaimPredicate {
    Unconditional,
    And(VecM<ClaimPredicate, 2>),
    Or(VecM<ClaimPredicate, 2>),
    Not(Option<Box<ClaimPredicate>>),
    BeforeAbsoluteTime(i64),
    BeforeRelativeTime(i64),
}

impl ClaimPredicate {
    pub const VARIANTS: [ClaimPredicateType; 6] = [
        ClaimPredicateType::Unconditional,
        ClaimPredicateType::And,
        ClaimPredicateType::Or,
        ClaimPredicateType::Not,
        ClaimPredicateType::BeforeAbsoluteTime,
        ClaimPredicateType::BeforeRelativeTime,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Unconditional",
        "And",
        "Or",
        "Not",
        "BeforeAbsoluteTime",
        "BeforeRelativeTime",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Unconditional => "Unconditional",
            Self::And(_) => "And",
            Self::Or(_) => "Or",
            Self::Not(_) => "Not",
            Self::BeforeAbsoluteTime(_) => "BeforeAbsoluteTime",
            Self::BeforeRelativeTime(_) => "BeforeRelativeTime",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClaimPredicateType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Unconditional => ClaimPredicateType::Unconditional,
            Self::And(_) => ClaimPredicateType::And,
            Self::Or(_) => ClaimPredicateType::Or,
            Self::Not(_) => ClaimPredicateType::Not,
            Self::BeforeAbsoluteTime(_) => ClaimPredicateType::BeforeAbsoluteTime,
            Self::BeforeRelativeTime(_) => ClaimPredicateType::BeforeRelativeTime,
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimPredicateType; 6] {
        Self::VARIANTS
    }
}

impl Name for ClaimPredicate {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClaimPredicateType> for ClaimPredicate {
    #[must_use]
    fn discriminant(&self) -> ClaimPredicateType {
        Self::discriminant(self)
    }
}

impl Variants<ClaimPredicateType> for ClaimPredicate {
    fn variants() -> slice::Iter<'static, ClaimPredicateType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClaimPredicateType> for ClaimPredicate {}

impl ReadXdr for ClaimPredicate {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ClaimPredicateType = <ClaimPredicateType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClaimPredicateType::Unconditional => Self::Unconditional,
                ClaimPredicateType::And => Self::And(VecM::<ClaimPredicate, 2>::read_xdr(r)?),
                ClaimPredicateType::Or => Self::Or(VecM::<ClaimPredicate, 2>::read_xdr(r)?),
                ClaimPredicateType::Not => Self::Not(Option::<Box<ClaimPredicate>>::read_xdr(r)?),
                ClaimPredicateType::BeforeAbsoluteTime => {
                    Self::BeforeAbsoluteTime(i64::read_xdr(r)?)
                }
                ClaimPredicateType::BeforeRelativeTime => {
                    Self::BeforeRelativeTime(i64::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimPredicate {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Unconditional => ().write_xdr(w)?,
                Self::And(v) => v.write_xdr(w)?,
                Self::Or(v) => v.write_xdr(w)?,
                Self::Not(v) => v.write_xdr(w)?,
                Self::BeforeAbsoluteTime(v) => v.write_xdr(w)?,
                Self::BeforeRelativeTime(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClaimantType is an XDR Enum defines as:
///
/// ```text
/// enum ClaimantType
/// {
///     CLAIMANT_TYPE_V0 = 0
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ClaimantType {
    ClaimantTypeV0 = 0,
}

impl ClaimantType {
    pub const VARIANTS: [ClaimantType; 1] = [ClaimantType::ClaimantTypeV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ClaimantTypeV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimantTypeV0 => "ClaimantTypeV0",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimantType; 1] {
        Self::VARIANTS
    }
}

impl Name for ClaimantType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimantType> for ClaimantType {
    fn variants() -> slice::Iter<'static, ClaimantType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimantType {}

impl fmt::Display for ClaimantType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimantType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ClaimantType::ClaimantTypeV0,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimantType> for i32 {
    #[must_use]
    fn from(e: ClaimantType) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimantType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimantType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClaimantV0 is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         AccountID destination;    // The account that can use this condition
///         ClaimPredicate predicate; // Claimable if predicate is true
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ClaimantV0 {
    pub destination: AccountId,
    pub predicate: ClaimPredicate,
}

impl ReadXdr for ClaimantV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                destination: AccountId::read_xdr(r)?,
                predicate: ClaimPredicate::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimantV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.destination.write_xdr(w)?;
            self.predicate.write_xdr(w)?;
            Ok(())
        })
    }
}

/// Claimant is an XDR Union defines as:
///
/// ```text
/// union Claimant switch (ClaimantType type)
/// {
/// case CLAIMANT_TYPE_V0:
///     struct
///     {
///         AccountID destination;    // The account that can use this condition
///         ClaimPredicate predicate; // Claimable if predicate is true
///     } v0;
/// };
/// ```
///
// union with discriminant ClaimantType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum Claimant {
    ClaimantTypeV0(ClaimantV0),
}

impl Claimant {
    pub const VARIANTS: [ClaimantType; 1] = [ClaimantType::ClaimantTypeV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ClaimantTypeV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimantTypeV0(_) => "ClaimantTypeV0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClaimantType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ClaimantTypeV0(_) => ClaimantType::ClaimantTypeV0,
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimantType; 1] {
        Self::VARIANTS
    }
}

impl Name for Claimant {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClaimantType> for Claimant {
    #[must_use]
    fn discriminant(&self) -> ClaimantType {
        Self::discriminant(self)
    }
}

impl Variants<ClaimantType> for Claimant {
    fn variants() -> slice::Iter<'static, ClaimantType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClaimantType> for Claimant {}

impl ReadXdr for Claimant {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ClaimantType = <ClaimantType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClaimantType::ClaimantTypeV0 => Self::ClaimantTypeV0(ClaimantV0::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for Claimant {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ClaimantTypeV0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClaimableBalanceIdType is an XDR Enum defines as:
///
/// ```text
/// enum ClaimableBalanceIDType
/// {
///     CLAIMABLE_BALANCE_ID_TYPE_V0 = 0
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ClaimableBalanceIdType {
    ClaimableBalanceIdTypeV0 = 0,
}

impl ClaimableBalanceIdType {
    pub const VARIANTS: [ClaimableBalanceIdType; 1] =
        [ClaimableBalanceIdType::ClaimableBalanceIdTypeV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ClaimableBalanceIdTypeV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimableBalanceIdTypeV0 => "ClaimableBalanceIdTypeV0",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimableBalanceIdType; 1] {
        Self::VARIANTS
    }
}

impl Name for ClaimableBalanceIdType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimableBalanceIdType> for ClaimableBalanceIdType {
    fn variants() -> slice::Iter<'static, ClaimableBalanceIdType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimableBalanceIdType {}

impl fmt::Display for ClaimableBalanceIdType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimableBalanceIdType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ClaimableBalanceIdType::ClaimableBalanceIdTypeV0,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimableBalanceIdType> for i32 {
    #[must_use]
    fn from(e: ClaimableBalanceIdType) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimableBalanceIdType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimableBalanceIdType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClaimableBalanceId is an XDR Union defines as:
///
/// ```text
/// union ClaimableBalanceID switch (ClaimableBalanceIDType type)
/// {
/// case CLAIMABLE_BALANCE_ID_TYPE_V0:
///     Hash v0;
/// };
/// ```
///
// union with discriminant ClaimableBalanceIdType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ClaimableBalanceId {
    ClaimableBalanceIdTypeV0(Hash),
}

impl ClaimableBalanceId {
    pub const VARIANTS: [ClaimableBalanceIdType; 1] =
        [ClaimableBalanceIdType::ClaimableBalanceIdTypeV0];
    pub const VARIANTS_STR: [&'static str; 1] = ["ClaimableBalanceIdTypeV0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimableBalanceIdTypeV0(_) => "ClaimableBalanceIdTypeV0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClaimableBalanceIdType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ClaimableBalanceIdTypeV0(_) => ClaimableBalanceIdType::ClaimableBalanceIdTypeV0,
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimableBalanceIdType; 1] {
        Self::VARIANTS
    }
}

impl Name for ClaimableBalanceId {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClaimableBalanceIdType> for ClaimableBalanceId {
    #[must_use]
    fn discriminant(&self) -> ClaimableBalanceIdType {
        Self::discriminant(self)
    }
}

impl Variants<ClaimableBalanceIdType> for ClaimableBalanceId {
    fn variants() -> slice::Iter<'static, ClaimableBalanceIdType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClaimableBalanceIdType> for ClaimableBalanceId {}

impl ReadXdr for ClaimableBalanceId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ClaimableBalanceIdType = <ClaimableBalanceIdType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClaimableBalanceIdType::ClaimableBalanceIdTypeV0 => {
                    Self::ClaimableBalanceIdTypeV0(Hash::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimableBalanceId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ClaimableBalanceIdTypeV0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClaimableBalanceFlags is an XDR Enum defines as:
///
/// ```text
/// enum ClaimableBalanceFlags
/// {
///     // If set, the issuer account of the asset held by the claimable balance may
///     // clawback the claimable balance
///     CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG = 0x1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ClaimableBalanceFlags {
    ClaimableBalanceClawbackEnabledFlag = 1,
}

impl ClaimableBalanceFlags {
    pub const VARIANTS: [ClaimableBalanceFlags; 1] =
        [ClaimableBalanceFlags::ClaimableBalanceClawbackEnabledFlag];
    pub const VARIANTS_STR: [&'static str; 1] = ["ClaimableBalanceClawbackEnabledFlag"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ClaimableBalanceClawbackEnabledFlag => "ClaimableBalanceClawbackEnabledFlag",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimableBalanceFlags; 1] {
        Self::VARIANTS
    }
}

impl Name for ClaimableBalanceFlags {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimableBalanceFlags> for ClaimableBalanceFlags {
    fn variants() -> slice::Iter<'static, ClaimableBalanceFlags> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimableBalanceFlags {}

impl fmt::Display for ClaimableBalanceFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimableBalanceFlags {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            1 => ClaimableBalanceFlags::ClaimableBalanceClawbackEnabledFlag,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimableBalanceFlags> for i32 {
    #[must_use]
    fn from(e: ClaimableBalanceFlags) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimableBalanceFlags {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimableBalanceFlags {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// MaskClaimableBalanceFlags is an XDR Const defines as:
///
/// ```text
/// const MASK_CLAIMABLE_BALANCE_FLAGS = 0x1;
/// ```
///
pub const MASK_CLAIMABLE_BALANCE_FLAGS: u64 = 0x1;

/// ClaimableBalanceEntryExtensionV1Ext is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ClaimableBalanceEntryExtensionV1Ext {
    V0,
}

impl ClaimableBalanceEntryExtensionV1Ext {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for ClaimableBalanceEntryExtensionV1Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ClaimableBalanceEntryExtensionV1Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ClaimableBalanceEntryExtensionV1Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ClaimableBalanceEntryExtensionV1Ext {}

impl ReadXdr for ClaimableBalanceEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimableBalanceEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClaimableBalanceEntryExtensionV1 is an XDR Struct defines as:
///
/// ```text
/// struct ClaimableBalanceEntryExtensionV1
/// {
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
///
///     uint32 flags; // see ClaimableBalanceFlags
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ClaimableBalanceEntryExtensionV1 {
    pub ext: ClaimableBalanceEntryExtensionV1Ext,
    pub flags: u32,
}

impl ReadXdr for ClaimableBalanceEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ClaimableBalanceEntryExtensionV1Ext::read_xdr(r)?,
                flags: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimableBalanceEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.flags.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ClaimableBalanceEntryExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         ClaimableBalanceEntryExtensionV1 v1;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ClaimableBalanceEntryExt {
    V0,
    V1(ClaimableBalanceEntryExtensionV1),
}

impl ClaimableBalanceEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for ClaimableBalanceEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ClaimableBalanceEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ClaimableBalanceEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ClaimableBalanceEntryExt {}

impl ReadXdr for ClaimableBalanceEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                1 => Self::V1(ClaimableBalanceEntryExtensionV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimableBalanceEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClaimableBalanceEntry is an XDR Struct defines as:
///
/// ```text
/// struct ClaimableBalanceEntry
/// {
///     // Unique identifier for this ClaimableBalanceEntry
///     ClaimableBalanceID balanceID;
///
///     // List of claimants with associated predicate
///     Claimant claimants<10>;
///
///     // Any asset including native
///     Asset asset;
///
///     // Amount of asset
///     int64 amount;
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         ClaimableBalanceEntryExtensionV1 v1;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ClaimableBalanceEntry {
    pub balance_id: ClaimableBalanceId,
    pub claimants: VecM<Claimant, 10>,
    pub asset: Asset,
    pub amount: i64,
    pub ext: ClaimableBalanceEntryExt,
}

impl ReadXdr for ClaimableBalanceEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                balance_id: ClaimableBalanceId::read_xdr(r)?,
                claimants: VecM::<Claimant, 10>::read_xdr(r)?,
                asset: Asset::read_xdr(r)?,
                amount: i64::read_xdr(r)?,
                ext: ClaimableBalanceEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimableBalanceEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.balance_id.write_xdr(w)?;
            self.claimants.write_xdr(w)?;
            self.asset.write_xdr(w)?;
            self.amount.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LiquidityPoolConstantProductParameters is an XDR Struct defines as:
///
/// ```text
/// struct LiquidityPoolConstantProductParameters
/// {
///     Asset assetA; // assetA < assetB
///     Asset assetB;
///     int32 fee; // Fee is in basis points, so the actual rate is (fee/100)%
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LiquidityPoolConstantProductParameters {
    pub asset_a: Asset,
    pub asset_b: Asset,
    pub fee: i32,
}

impl ReadXdr for LiquidityPoolConstantProductParameters {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                asset_a: Asset::read_xdr(r)?,
                asset_b: Asset::read_xdr(r)?,
                fee: i32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LiquidityPoolConstantProductParameters {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.asset_a.write_xdr(w)?;
            self.asset_b.write_xdr(w)?;
            self.fee.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LiquidityPoolEntryConstantProduct is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///         {
///             LiquidityPoolConstantProductParameters params;
///
///             int64 reserveA;        // amount of A in the pool
///             int64 reserveB;        // amount of B in the pool
///             int64 totalPoolShares; // total number of pool shares issued
///             int64 poolSharesTrustLineCount; // number of trust lines for the
///                                             // associated pool shares
///         }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LiquidityPoolEntryConstantProduct {
    pub params: LiquidityPoolConstantProductParameters,
    pub reserve_a: i64,
    pub reserve_b: i64,
    pub total_pool_shares: i64,
    pub pool_shares_trust_line_count: i64,
}

impl ReadXdr for LiquidityPoolEntryConstantProduct {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                params: LiquidityPoolConstantProductParameters::read_xdr(r)?,
                reserve_a: i64::read_xdr(r)?,
                reserve_b: i64::read_xdr(r)?,
                total_pool_shares: i64::read_xdr(r)?,
                pool_shares_trust_line_count: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LiquidityPoolEntryConstantProduct {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.params.write_xdr(w)?;
            self.reserve_a.write_xdr(w)?;
            self.reserve_b.write_xdr(w)?;
            self.total_pool_shares.write_xdr(w)?;
            self.pool_shares_trust_line_count.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LiquidityPoolEntryBody is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (LiquidityPoolType type)
///     {
///     case LIQUIDITY_POOL_CONSTANT_PRODUCT:
///         struct
///         {
///             LiquidityPoolConstantProductParameters params;
///
///             int64 reserveA;        // amount of A in the pool
///             int64 reserveB;        // amount of B in the pool
///             int64 totalPoolShares; // total number of pool shares issued
///             int64 poolSharesTrustLineCount; // number of trust lines for the
///                                             // associated pool shares
///         } constantProduct;
///     }
/// ```
///
// union with discriminant LiquidityPoolType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LiquidityPoolEntryBody {
    LiquidityPoolConstantProduct(LiquidityPoolEntryConstantProduct),
}

impl LiquidityPoolEntryBody {
    pub const VARIANTS: [LiquidityPoolType; 1] = [LiquidityPoolType::LiquidityPoolConstantProduct];
    pub const VARIANTS_STR: [&'static str; 1] = ["LiquidityPoolConstantProduct"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LiquidityPoolConstantProduct(_) => "LiquidityPoolConstantProduct",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LiquidityPoolType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::LiquidityPoolConstantProduct(_) => {
                LiquidityPoolType::LiquidityPoolConstantProduct
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolType; 1] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolEntryBody {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LiquidityPoolType> for LiquidityPoolEntryBody {
    #[must_use]
    fn discriminant(&self) -> LiquidityPoolType {
        Self::discriminant(self)
    }
}

impl Variants<LiquidityPoolType> for LiquidityPoolEntryBody {
    fn variants() -> slice::Iter<'static, LiquidityPoolType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LiquidityPoolType> for LiquidityPoolEntryBody {}

impl ReadXdr for LiquidityPoolEntryBody {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: LiquidityPoolType = <LiquidityPoolType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LiquidityPoolType::LiquidityPoolConstantProduct => {
                    Self::LiquidityPoolConstantProduct(LiquidityPoolEntryConstantProduct::read_xdr(
                        r,
                    )?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolEntryBody {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::LiquidityPoolConstantProduct(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LiquidityPoolEntry is an XDR Struct defines as:
///
/// ```text
/// struct LiquidityPoolEntry
/// {
///     PoolID liquidityPoolID;
///
///     union switch (LiquidityPoolType type)
///     {
///     case LIQUIDITY_POOL_CONSTANT_PRODUCT:
///         struct
///         {
///             LiquidityPoolConstantProductParameters params;
///
///             int64 reserveA;        // amount of A in the pool
///             int64 reserveB;        // amount of B in the pool
///             int64 totalPoolShares; // total number of pool shares issued
///             int64 poolSharesTrustLineCount; // number of trust lines for the
///                                             // associated pool shares
///         } constantProduct;
///     }
///     body;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LiquidityPoolEntry {
    pub liquidity_pool_id: PoolId,
    pub body: LiquidityPoolEntryBody,
}

impl ReadXdr for LiquidityPoolEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_id: PoolId::read_xdr(r)?,
                body: LiquidityPoolEntryBody::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LiquidityPoolEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_id.write_xdr(w)?;
            self.body.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ContractDataDurability is an XDR Enum defines as:
///
/// ```text
/// enum ContractDataDurability {
///     TEMPORARY = 0,
///     PERSISTENT = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ContractDataDurability {
    Temporary = 0,
    Persistent = 1,
}

impl ContractDataDurability {
    pub const VARIANTS: [ContractDataDurability; 2] = [
        ContractDataDurability::Temporary,
        ContractDataDurability::Persistent,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["Temporary", "Persistent"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Temporary => "Temporary",
            Self::Persistent => "Persistent",
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractDataDurability; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractDataDurability {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ContractDataDurability> for ContractDataDurability {
    fn variants() -> slice::Iter<'static, ContractDataDurability> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ContractDataDurability {}

impl fmt::Display for ContractDataDurability {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ContractDataDurability {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ContractDataDurability::Temporary,
            1 => ContractDataDurability::Persistent,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ContractDataDurability> for i32 {
    #[must_use]
    fn from(e: ContractDataDurability) -> Self {
        e as Self
    }
}

impl ReadXdr for ContractDataDurability {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ContractDataDurability {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractDataEntry is an XDR Struct defines as:
///
/// ```text
/// struct ContractDataEntry {
///     ExtensionPoint ext;
///
///     SCAddress contract;
///     SCVal key;
///     ContractDataDurability durability;
///     SCVal val;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ContractDataEntry {
    pub ext: ExtensionPoint,
    pub contract: ScAddress,
    pub key: ScVal,
    pub durability: ContractDataDurability,
    pub val: ScVal,
}

impl ReadXdr for ContractDataEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
                contract: ScAddress::read_xdr(r)?,
                key: ScVal::read_xdr(r)?,
                durability: ContractDataDurability::read_xdr(r)?,
                val: ScVal::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractDataEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.contract.write_xdr(w)?;
            self.key.write_xdr(w)?;
            self.durability.write_xdr(w)?;
            self.val.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ContractCodeCostInputs is an XDR Struct defines as:
///
/// ```text
/// struct ContractCodeCostInputs {
///     ExtensionPoint ext;
///     uint32 nInstructions;
///     uint32 nFunctions;
///     uint32 nGlobals;
///     uint32 nTableEntries;
///     uint32 nTypes;
///     uint32 nDataSegments;
///     uint32 nElemSegments;
///     uint32 nImports;
///     uint32 nExports;
///     uint32 nDataSegmentBytes;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ContractCodeCostInputs {
    pub ext: ExtensionPoint,
    pub n_instructions: u32,
    pub n_functions: u32,
    pub n_globals: u32,
    pub n_table_entries: u32,
    pub n_types: u32,
    pub n_data_segments: u32,
    pub n_elem_segments: u32,
    pub n_imports: u32,
    pub n_exports: u32,
    pub n_data_segment_bytes: u32,
}

impl ReadXdr for ContractCodeCostInputs {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
                n_instructions: u32::read_xdr(r)?,
                n_functions: u32::read_xdr(r)?,
                n_globals: u32::read_xdr(r)?,
                n_table_entries: u32::read_xdr(r)?,
                n_types: u32::read_xdr(r)?,
                n_data_segments: u32::read_xdr(r)?,
                n_elem_segments: u32::read_xdr(r)?,
                n_imports: u32::read_xdr(r)?,
                n_exports: u32::read_xdr(r)?,
                n_data_segment_bytes: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractCodeCostInputs {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.n_instructions.write_xdr(w)?;
            self.n_functions.write_xdr(w)?;
            self.n_globals.write_xdr(w)?;
            self.n_table_entries.write_xdr(w)?;
            self.n_types.write_xdr(w)?;
            self.n_data_segments.write_xdr(w)?;
            self.n_elem_segments.write_xdr(w)?;
            self.n_imports.write_xdr(w)?;
            self.n_exports.write_xdr(w)?;
            self.n_data_segment_bytes.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ContractCodeEntryV1 is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///             {
///                 ExtensionPoint ext;
///                 ContractCodeCostInputs costInputs;
///             }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ContractCodeEntryV1 {
    pub ext: ExtensionPoint,
    pub cost_inputs: ContractCodeCostInputs,
}

impl ReadXdr for ContractCodeEntryV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
                cost_inputs: ContractCodeCostInputs::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractCodeEntryV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.cost_inputs.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ContractCodeEntryExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///         case 0:
///             void;
///         case 1:
///             struct
///             {
///                 ExtensionPoint ext;
///                 ContractCodeCostInputs costInputs;
///             } v1;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ContractCodeEntryExt {
    V0,
    V1(ContractCodeEntryV1),
}

impl ContractCodeEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractCodeEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ContractCodeEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ContractCodeEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ContractCodeEntryExt {}

impl ReadXdr for ContractCodeEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                1 => Self::V1(ContractCodeEntryV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ContractCodeEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ContractCodeEntry is an XDR Struct defines as:
///
/// ```text
/// struct ContractCodeEntry {
///     union switch (int v)
///     {
///         case 0:
///             void;
///         case 1:
///             struct
///             {
///                 ExtensionPoint ext;
///                 ContractCodeCostInputs costInputs;
///             } v1;
///     } ext;
///
///     Hash hash;
///     opaque code<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ContractCodeEntry {
    pub ext: ContractCodeEntryExt,
    pub hash: Hash,
    pub code: BytesM,
}

impl ReadXdr for ContractCodeEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ContractCodeEntryExt::read_xdr(r)?,
                hash: Hash::read_xdr(r)?,
                code: BytesM::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractCodeEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.hash.write_xdr(w)?;
            self.code.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TtlEntry is an XDR Struct defines as:
///
/// ```text
/// struct TTLEntry {
///     // Hash of the LedgerKey that is associated with this TTLEntry
///     Hash keyHash;
///     uint32 liveUntilLedgerSeq;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TtlEntry {
    pub key_hash: Hash,
    pub live_until_ledger_seq: u32,
}

impl ReadXdr for TtlEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key_hash: Hash::read_xdr(r)?,
                live_until_ledger_seq: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TtlEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.key_hash.write_xdr(w)?;
            self.live_until_ledger_seq.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerEntryExtensionV1Ext is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LedgerEntryExtensionV1Ext {
    V0,
}

impl LedgerEntryExtensionV1Ext {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryExtensionV1Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerEntryExtensionV1Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerEntryExtensionV1Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerEntryExtensionV1Ext {}

impl ReadXdr for LedgerEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryExtensionV1Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerEntryExtensionV1 is an XDR Struct defines as:
///
/// ```text
/// struct LedgerEntryExtensionV1
/// {
///     SponsorshipDescriptor sponsoringID;
///
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerEntryExtensionV1 {
    pub sponsoring_id: SponsorshipDescriptor,
    pub ext: LedgerEntryExtensionV1Ext,
}

impl ReadXdr for LedgerEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                sponsoring_id: SponsorshipDescriptor::read_xdr(r)?,
                ext: LedgerEntryExtensionV1Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerEntryExtensionV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.sponsoring_id.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerEntryData is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (LedgerEntryType type)
///     {
///     case ACCOUNT:
///         AccountEntry account;
///     case TRUSTLINE:
///         TrustLineEntry trustLine;
///     case OFFER:
///         OfferEntry offer;
///     case DATA:
///         DataEntry data;
///     case CLAIMABLE_BALANCE:
///         ClaimableBalanceEntry claimableBalance;
///     case LIQUIDITY_POOL:
///         LiquidityPoolEntry liquidityPool;
///     case CONTRACT_DATA:
///         ContractDataEntry contractData;
///     case CONTRACT_CODE:
///         ContractCodeEntry contractCode;
///     case CONFIG_SETTING:
///         ConfigSettingEntry configSetting;
///     case TTL:
///         TTLEntry ttl;
///     }
/// ```
///
// union with discriminant LedgerEntryType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LedgerEntryData {
    Account(AccountEntry),
    Trustline(TrustLineEntry),
    Offer(OfferEntry),
    Data(DataEntry),
    ClaimableBalance(ClaimableBalanceEntry),
    LiquidityPool(LiquidityPoolEntry),
    ContractData(ContractDataEntry),
    ContractCode(ContractCodeEntry),
    ConfigSetting(ConfigSettingEntry),
    Ttl(TtlEntry),
}

impl LedgerEntryData {
    pub const VARIANTS: [LedgerEntryType; 10] = [
        LedgerEntryType::Account,
        LedgerEntryType::Trustline,
        LedgerEntryType::Offer,
        LedgerEntryType::Data,
        LedgerEntryType::ClaimableBalance,
        LedgerEntryType::LiquidityPool,
        LedgerEntryType::ContractData,
        LedgerEntryType::ContractCode,
        LedgerEntryType::ConfigSetting,
        LedgerEntryType::Ttl,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "Account",
        "Trustline",
        "Offer",
        "Data",
        "ClaimableBalance",
        "LiquidityPool",
        "ContractData",
        "ContractCode",
        "ConfigSetting",
        "Ttl",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Account(_) => "Account",
            Self::Trustline(_) => "Trustline",
            Self::Offer(_) => "Offer",
            Self::Data(_) => "Data",
            Self::ClaimableBalance(_) => "ClaimableBalance",
            Self::LiquidityPool(_) => "LiquidityPool",
            Self::ContractData(_) => "ContractData",
            Self::ContractCode(_) => "ContractCode",
            Self::ConfigSetting(_) => "ConfigSetting",
            Self::Ttl(_) => "Ttl",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LedgerEntryType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Account(_) => LedgerEntryType::Account,
            Self::Trustline(_) => LedgerEntryType::Trustline,
            Self::Offer(_) => LedgerEntryType::Offer,
            Self::Data(_) => LedgerEntryType::Data,
            Self::ClaimableBalance(_) => LedgerEntryType::ClaimableBalance,
            Self::LiquidityPool(_) => LedgerEntryType::LiquidityPool,
            Self::ContractData(_) => LedgerEntryType::ContractData,
            Self::ContractCode(_) => LedgerEntryType::ContractCode,
            Self::ConfigSetting(_) => LedgerEntryType::ConfigSetting,
            Self::Ttl(_) => LedgerEntryType::Ttl,
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerEntryType; 10] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryData {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LedgerEntryType> for LedgerEntryData {
    #[must_use]
    fn discriminant(&self) -> LedgerEntryType {
        Self::discriminant(self)
    }
}

impl Variants<LedgerEntryType> for LedgerEntryData {
    fn variants() -> slice::Iter<'static, LedgerEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LedgerEntryType> for LedgerEntryData {}

impl ReadXdr for LedgerEntryData {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: LedgerEntryType = <LedgerEntryType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LedgerEntryType::Account => Self::Account(AccountEntry::read_xdr(r)?),
                LedgerEntryType::Trustline => Self::Trustline(TrustLineEntry::read_xdr(r)?),
                LedgerEntryType::Offer => Self::Offer(OfferEntry::read_xdr(r)?),
                LedgerEntryType::Data => Self::Data(DataEntry::read_xdr(r)?),
                LedgerEntryType::ClaimableBalance => {
                    Self::ClaimableBalance(ClaimableBalanceEntry::read_xdr(r)?)
                }
                LedgerEntryType::LiquidityPool => {
                    Self::LiquidityPool(LiquidityPoolEntry::read_xdr(r)?)
                }
                LedgerEntryType::ContractData => {
                    Self::ContractData(ContractDataEntry::read_xdr(r)?)
                }
                LedgerEntryType::ContractCode => {
                    Self::ContractCode(ContractCodeEntry::read_xdr(r)?)
                }
                LedgerEntryType::ConfigSetting => {
                    Self::ConfigSetting(ConfigSettingEntry::read_xdr(r)?)
                }
                LedgerEntryType::Ttl => Self::Ttl(TtlEntry::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryData {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Account(v) => v.write_xdr(w)?,
                Self::Trustline(v) => v.write_xdr(w)?,
                Self::Offer(v) => v.write_xdr(w)?,
                Self::Data(v) => v.write_xdr(w)?,
                Self::ClaimableBalance(v) => v.write_xdr(w)?,
                Self::LiquidityPool(v) => v.write_xdr(w)?,
                Self::ContractData(v) => v.write_xdr(w)?,
                Self::ContractCode(v) => v.write_xdr(w)?,
                Self::ConfigSetting(v) => v.write_xdr(w)?,
                Self::Ttl(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerEntryExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         LedgerEntryExtensionV1 v1;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LedgerEntryExt {
    V0,
    V1(LedgerEntryExtensionV1),
}

impl LedgerEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerEntryExt {}

impl ReadXdr for LedgerEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                1 => Self::V1(LedgerEntryExtensionV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerEntry is an XDR Struct defines as:
///
/// ```text
/// struct LedgerEntry
/// {
///     uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed
///
///     union switch (LedgerEntryType type)
///     {
///     case ACCOUNT:
///         AccountEntry account;
///     case TRUSTLINE:
///         TrustLineEntry trustLine;
///     case OFFER:
///         OfferEntry offer;
///     case DATA:
///         DataEntry data;
///     case CLAIMABLE_BALANCE:
///         ClaimableBalanceEntry claimableBalance;
///     case LIQUIDITY_POOL:
///         LiquidityPoolEntry liquidityPool;
///     case CONTRACT_DATA:
///         ContractDataEntry contractData;
///     case CONTRACT_CODE:
///         ContractCodeEntry contractCode;
///     case CONFIG_SETTING:
///         ConfigSettingEntry configSetting;
///     case TTL:
///         TTLEntry ttl;
///     }
///     data;
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         LedgerEntryExtensionV1 v1;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerEntry {
    pub last_modified_ledger_seq: u32,
    pub data: LedgerEntryData,
    pub ext: LedgerEntryExt,
}

impl ReadXdr for LedgerEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                last_modified_ledger_seq: u32::read_xdr(r)?,
                data: LedgerEntryData::read_xdr(r)?,
                ext: LedgerEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.last_modified_ledger_seq.write_xdr(w)?;
            self.data.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerKeyAccount is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         AccountID accountID;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerKeyAccount {
    pub account_id: AccountId,
}

impl ReadXdr for LedgerKeyAccount {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyAccount {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerKeyTrustLine is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         AccountID accountID;
///         TrustLineAsset asset;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerKeyTrustLine {
    pub account_id: AccountId,
    pub asset: TrustLineAsset,
}

impl ReadXdr for LedgerKeyTrustLine {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,
                asset: TrustLineAsset::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyTrustLine {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;
            self.asset.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerKeyOffer is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         AccountID sellerID;
///         int64 offerID;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerKeyOffer {
    pub seller_id: AccountId,
    pub offer_id: i64,
}

impl ReadXdr for LedgerKeyOffer {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                seller_id: AccountId::read_xdr(r)?,
                offer_id: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyOffer {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.seller_id.write_xdr(w)?;
            self.offer_id.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerKeyData is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         AccountID accountID;
///         string64 dataName;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerKeyData {
    pub account_id: AccountId,
    pub data_name: String64,
}

impl ReadXdr for LedgerKeyData {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,
                data_name: String64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyData {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;
            self.data_name.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerKeyClaimableBalance is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         ClaimableBalanceID balanceID;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerKeyClaimableBalance {
    pub balance_id: ClaimableBalanceId,
}

impl ReadXdr for LedgerKeyClaimableBalance {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                balance_id: ClaimableBalanceId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyClaimableBalance {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.balance_id.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerKeyLiquidityPool is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         PoolID liquidityPoolID;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerKeyLiquidityPool {
    pub liquidity_pool_id: PoolId,
}

impl ReadXdr for LedgerKeyLiquidityPool {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_id: PoolId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyLiquidityPool {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_id.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerKeyContractData is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         SCAddress contract;
///         SCVal key;
///         ContractDataDurability durability;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerKeyContractData {
    pub contract: ScAddress,
    pub key: ScVal,
    pub durability: ContractDataDurability,
}

impl ReadXdr for LedgerKeyContractData {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                contract: ScAddress::read_xdr(r)?,
                key: ScVal::read_xdr(r)?,
                durability: ContractDataDurability::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyContractData {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.contract.write_xdr(w)?;
            self.key.write_xdr(w)?;
            self.durability.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerKeyContractCode is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         Hash hash;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerKeyContractCode {
    pub hash: Hash,
}

impl ReadXdr for LedgerKeyContractCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hash: Hash::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyContractCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.hash.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerKeyConfigSetting is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         ConfigSettingID configSettingID;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerKeyConfigSetting {
    pub config_setting_id: ConfigSettingId,
}

impl ReadXdr for LedgerKeyConfigSetting {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                config_setting_id: ConfigSettingId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyConfigSetting {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.config_setting_id.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerKeyTtl is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         // Hash of the LedgerKey that is associated with this TTLEntry
///         Hash keyHash;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerKeyTtl {
    pub key_hash: Hash,
}

impl ReadXdr for LedgerKeyTtl {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key_hash: Hash::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerKeyTtl {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.key_hash.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerKey is an XDR Union defines as:
///
/// ```text
/// union LedgerKey switch (LedgerEntryType type)
/// {
/// case ACCOUNT:
///     struct
///     {
///         AccountID accountID;
///     } account;
///
/// case TRUSTLINE:
///     struct
///     {
///         AccountID accountID;
///         TrustLineAsset asset;
///     } trustLine;
///
/// case OFFER:
///     struct
///     {
///         AccountID sellerID;
///         int64 offerID;
///     } offer;
///
/// case DATA:
///     struct
///     {
///         AccountID accountID;
///         string64 dataName;
///     } data;
///
/// case CLAIMABLE_BALANCE:
///     struct
///     {
///         ClaimableBalanceID balanceID;
///     } claimableBalance;
///
/// case LIQUIDITY_POOL:
///     struct
///     {
///         PoolID liquidityPoolID;
///     } liquidityPool;
/// case CONTRACT_DATA:
///     struct
///     {
///         SCAddress contract;
///         SCVal key;
///         ContractDataDurability durability;
///     } contractData;
/// case CONTRACT_CODE:
///     struct
///     {
///         Hash hash;
///     } contractCode;
/// case CONFIG_SETTING:
///     struct
///     {
///         ConfigSettingID configSettingID;
///     } configSetting;
/// case TTL:
///     struct
///     {
///         // Hash of the LedgerKey that is associated with this TTLEntry
///         Hash keyHash;
///     } ttl;
/// };
/// ```
///
// union with discriminant LedgerEntryType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LedgerKey {
    Account(LedgerKeyAccount),
    Trustline(LedgerKeyTrustLine),
    Offer(LedgerKeyOffer),
    Data(LedgerKeyData),
    ClaimableBalance(LedgerKeyClaimableBalance),
    LiquidityPool(LedgerKeyLiquidityPool),
    ContractData(LedgerKeyContractData),
    ContractCode(LedgerKeyContractCode),
    ConfigSetting(LedgerKeyConfigSetting),
    Ttl(LedgerKeyTtl),
}

impl LedgerKey {
    pub const VARIANTS: [LedgerEntryType; 10] = [
        LedgerEntryType::Account,
        LedgerEntryType::Trustline,
        LedgerEntryType::Offer,
        LedgerEntryType::Data,
        LedgerEntryType::ClaimableBalance,
        LedgerEntryType::LiquidityPool,
        LedgerEntryType::ContractData,
        LedgerEntryType::ContractCode,
        LedgerEntryType::ConfigSetting,
        LedgerEntryType::Ttl,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "Account",
        "Trustline",
        "Offer",
        "Data",
        "ClaimableBalance",
        "LiquidityPool",
        "ContractData",
        "ContractCode",
        "ConfigSetting",
        "Ttl",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Account(_) => "Account",
            Self::Trustline(_) => "Trustline",
            Self::Offer(_) => "Offer",
            Self::Data(_) => "Data",
            Self::ClaimableBalance(_) => "ClaimableBalance",
            Self::LiquidityPool(_) => "LiquidityPool",
            Self::ContractData(_) => "ContractData",
            Self::ContractCode(_) => "ContractCode",
            Self::ConfigSetting(_) => "ConfigSetting",
            Self::Ttl(_) => "Ttl",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LedgerEntryType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Account(_) => LedgerEntryType::Account,
            Self::Trustline(_) => LedgerEntryType::Trustline,
            Self::Offer(_) => LedgerEntryType::Offer,
            Self::Data(_) => LedgerEntryType::Data,
            Self::ClaimableBalance(_) => LedgerEntryType::ClaimableBalance,
            Self::LiquidityPool(_) => LedgerEntryType::LiquidityPool,
            Self::ContractData(_) => LedgerEntryType::ContractData,
            Self::ContractCode(_) => LedgerEntryType::ContractCode,
            Self::ConfigSetting(_) => LedgerEntryType::ConfigSetting,
            Self::Ttl(_) => LedgerEntryType::Ttl,
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerEntryType; 10] {
        Self::VARIANTS
    }
}

impl Name for LedgerKey {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LedgerEntryType> for LedgerKey {
    #[must_use]
    fn discriminant(&self) -> LedgerEntryType {
        Self::discriminant(self)
    }
}

impl Variants<LedgerEntryType> for LedgerKey {
    fn variants() -> slice::Iter<'static, LedgerEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LedgerEntryType> for LedgerKey {}

impl ReadXdr for LedgerKey {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: LedgerEntryType = <LedgerEntryType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LedgerEntryType::Account => Self::Account(LedgerKeyAccount::read_xdr(r)?),
                LedgerEntryType::Trustline => Self::Trustline(LedgerKeyTrustLine::read_xdr(r)?),
                LedgerEntryType::Offer => Self::Offer(LedgerKeyOffer::read_xdr(r)?),
                LedgerEntryType::Data => Self::Data(LedgerKeyData::read_xdr(r)?),
                LedgerEntryType::ClaimableBalance => {
                    Self::ClaimableBalance(LedgerKeyClaimableBalance::read_xdr(r)?)
                }
                LedgerEntryType::LiquidityPool => {
                    Self::LiquidityPool(LedgerKeyLiquidityPool::read_xdr(r)?)
                }
                LedgerEntryType::ContractData => {
                    Self::ContractData(LedgerKeyContractData::read_xdr(r)?)
                }
                LedgerEntryType::ContractCode => {
                    Self::ContractCode(LedgerKeyContractCode::read_xdr(r)?)
                }
                LedgerEntryType::ConfigSetting => {
                    Self::ConfigSetting(LedgerKeyConfigSetting::read_xdr(r)?)
                }
                LedgerEntryType::Ttl => Self::Ttl(LedgerKeyTtl::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerKey {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Account(v) => v.write_xdr(w)?,
                Self::Trustline(v) => v.write_xdr(w)?,
                Self::Offer(v) => v.write_xdr(w)?,
                Self::Data(v) => v.write_xdr(w)?,
                Self::ClaimableBalance(v) => v.write_xdr(w)?,
                Self::LiquidityPool(v) => v.write_xdr(w)?,
                Self::ContractData(v) => v.write_xdr(w)?,
                Self::ContractCode(v) => v.write_xdr(w)?,
                Self::ConfigSetting(v) => v.write_xdr(w)?,
                Self::Ttl(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// EnvelopeType is an XDR Enum defines as:
///
/// ```text
/// enum EnvelopeType
/// {
///     ENVELOPE_TYPE_TX_V0 = 0,
///     ENVELOPE_TYPE_SCP = 1,
///     ENVELOPE_TYPE_TX = 2,
///     ENVELOPE_TYPE_AUTH = 3,
///     ENVELOPE_TYPE_SCPVALUE = 4,
///     ENVELOPE_TYPE_TX_FEE_BUMP = 5,
///     ENVELOPE_TYPE_OP_ID = 6,
///     ENVELOPE_TYPE_POOL_REVOKE_OP_ID = 7,
///     ENVELOPE_TYPE_CONTRACT_ID = 8,
///     ENVELOPE_TYPE_SOROBAN_AUTHORIZATION = 9
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum EnvelopeType {
    TxV0 = 0,
    Scp = 1,
    Tx = 2,
    Auth = 3,
    Scpvalue = 4,
    TxFeeBump = 5,
    OpId = 6,
    PoolRevokeOpId = 7,
    ContractId = 8,
    SorobanAuthorization = 9,
}

impl EnvelopeType {
    pub const VARIANTS: [EnvelopeType; 10] = [
        EnvelopeType::TxV0,
        EnvelopeType::Scp,
        EnvelopeType::Tx,
        EnvelopeType::Auth,
        EnvelopeType::Scpvalue,
        EnvelopeType::TxFeeBump,
        EnvelopeType::OpId,
        EnvelopeType::PoolRevokeOpId,
        EnvelopeType::ContractId,
        EnvelopeType::SorobanAuthorization,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "TxV0",
        "Scp",
        "Tx",
        "Auth",
        "Scpvalue",
        "TxFeeBump",
        "OpId",
        "PoolRevokeOpId",
        "ContractId",
        "SorobanAuthorization",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxV0 => "TxV0",
            Self::Scp => "Scp",
            Self::Tx => "Tx",
            Self::Auth => "Auth",
            Self::Scpvalue => "Scpvalue",
            Self::TxFeeBump => "TxFeeBump",
            Self::OpId => "OpId",
            Self::PoolRevokeOpId => "PoolRevokeOpId",
            Self::ContractId => "ContractId",
            Self::SorobanAuthorization => "SorobanAuthorization",
        }
    }

    #[must_use]
    pub const fn variants() -> [EnvelopeType; 10] {
        Self::VARIANTS
    }
}

impl Name for EnvelopeType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<EnvelopeType> for EnvelopeType {
    fn variants() -> slice::Iter<'static, EnvelopeType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for EnvelopeType {}

impl fmt::Display for EnvelopeType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for EnvelopeType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => EnvelopeType::TxV0,
            1 => EnvelopeType::Scp,
            2 => EnvelopeType::Tx,
            3 => EnvelopeType::Auth,
            4 => EnvelopeType::Scpvalue,
            5 => EnvelopeType::TxFeeBump,
            6 => EnvelopeType::OpId,
            7 => EnvelopeType::PoolRevokeOpId,
            8 => EnvelopeType::ContractId,
            9 => EnvelopeType::SorobanAuthorization,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<EnvelopeType> for i32 {
    #[must_use]
    fn from(e: EnvelopeType) -> Self {
        e as Self
    }
}

impl ReadXdr for EnvelopeType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for EnvelopeType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// UpgradeType is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque UpgradeType<128>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct UpgradeType(pub BytesM<128>);

impl From<UpgradeType> for BytesM<128> {
    #[must_use]
    fn from(x: UpgradeType) -> Self {
        x.0
    }
}

impl From<BytesM<128>> for UpgradeType {
    #[must_use]
    fn from(x: BytesM<128>) -> Self {
        UpgradeType(x)
    }
}

impl AsRef<BytesM<128>> for UpgradeType {
    #[must_use]
    fn as_ref(&self) -> &BytesM<128> {
        &self.0
    }
}

impl ReadXdr for UpgradeType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = BytesM::<128>::read_xdr(r)?;
            let v = UpgradeType(i);
            Ok(v)
        })
    }
}

impl WriteXdr for UpgradeType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for UpgradeType {
    type Target = BytesM<128>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<UpgradeType> for Vec<u8> {
    #[must_use]
    fn from(x: UpgradeType) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for UpgradeType {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        Ok(UpgradeType(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for UpgradeType {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        Ok(UpgradeType(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for UpgradeType {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for UpgradeType {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// StellarValueType is an XDR Enum defines as:
///
/// ```text
/// enum StellarValueType
/// {
///     STELLAR_VALUE_BASIC = 0,
///     STELLAR_VALUE_SIGNED = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum StellarValueType {
    Basic = 0,
    Signed = 1,
}

impl StellarValueType {
    pub const VARIANTS: [StellarValueType; 2] = [StellarValueType::Basic, StellarValueType::Signed];
    pub const VARIANTS_STR: [&'static str; 2] = ["Basic", "Signed"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Basic => "Basic",
            Self::Signed => "Signed",
        }
    }

    #[must_use]
    pub const fn variants() -> [StellarValueType; 2] {
        Self::VARIANTS
    }
}

impl Name for StellarValueType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<StellarValueType> for StellarValueType {
    fn variants() -> slice::Iter<'static, StellarValueType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for StellarValueType {}

impl fmt::Display for StellarValueType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for StellarValueType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => StellarValueType::Basic,
            1 => StellarValueType::Signed,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<StellarValueType> for i32 {
    #[must_use]
    fn from(e: StellarValueType) -> Self {
        e as Self
    }
}

impl ReadXdr for StellarValueType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for StellarValueType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LedgerCloseValueSignature is an XDR Struct defines as:
///
/// ```text
/// struct LedgerCloseValueSignature
/// {
///     NodeID nodeID;       // which node introduced the value
///     Signature signature; // nodeID's signature
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerCloseValueSignature {
    pub node_id: NodeId,
    pub signature: Signature,
}

impl ReadXdr for LedgerCloseValueSignature {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                node_id: NodeId::read_xdr(r)?,
                signature: Signature::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerCloseValueSignature {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.node_id.write_xdr(w)?;
            self.signature.write_xdr(w)?;
            Ok(())
        })
    }
}

/// StellarValueExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (StellarValueType v)
///     {
///     case STELLAR_VALUE_BASIC:
///         void;
///     case STELLAR_VALUE_SIGNED:
///         LedgerCloseValueSignature lcValueSignature;
///     }
/// ```
///
// union with discriminant StellarValueType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum StellarValueExt {
    Basic,
    Signed(LedgerCloseValueSignature),
}

impl StellarValueExt {
    pub const VARIANTS: [StellarValueType; 2] = [StellarValueType::Basic, StellarValueType::Signed];
    pub const VARIANTS_STR: [&'static str; 2] = ["Basic", "Signed"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Basic => "Basic",
            Self::Signed(_) => "Signed",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> StellarValueType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Basic => StellarValueType::Basic,
            Self::Signed(_) => StellarValueType::Signed,
        }
    }

    #[must_use]
    pub const fn variants() -> [StellarValueType; 2] {
        Self::VARIANTS
    }
}

impl Name for StellarValueExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<StellarValueType> for StellarValueExt {
    #[must_use]
    fn discriminant(&self) -> StellarValueType {
        Self::discriminant(self)
    }
}

impl Variants<StellarValueType> for StellarValueExt {
    fn variants() -> slice::Iter<'static, StellarValueType> {
        Self::VARIANTS.iter()
    }
}

impl Union<StellarValueType> for StellarValueExt {}

impl ReadXdr for StellarValueExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: StellarValueType = <StellarValueType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                StellarValueType::Basic => Self::Basic,
                StellarValueType::Signed => Self::Signed(LedgerCloseValueSignature::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for StellarValueExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Basic => ().write_xdr(w)?,
                Self::Signed(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// StellarValue is an XDR Struct defines as:
///
/// ```text
/// struct StellarValue
/// {
///     Hash txSetHash;      // transaction set to apply to previous ledger
///     TimePoint closeTime; // network close time
///
///     // upgrades to apply to the previous ledger (usually empty)
///     // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop
///     // unknown steps during consensus if needed.
///     // see notes below on 'LedgerUpgrade' for more detail
///     // max size is dictated by number of upgrade types (+ room for future)
///     UpgradeType upgrades<6>;
///
///     // reserved for future use
///     union switch (StellarValueType v)
///     {
///     case STELLAR_VALUE_BASIC:
///         void;
///     case STELLAR_VALUE_SIGNED:
///         LedgerCloseValueSignature lcValueSignature;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct StellarValue {
    pub tx_set_hash: Hash,
    pub close_time: TimePoint,
    pub upgrades: VecM<UpgradeType, 6>,
    pub ext: StellarValueExt,
}

impl ReadXdr for StellarValue {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_set_hash: Hash::read_xdr(r)?,
                close_time: TimePoint::read_xdr(r)?,
                upgrades: VecM::<UpgradeType, 6>::read_xdr(r)?,
                ext: StellarValueExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for StellarValue {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.tx_set_hash.write_xdr(w)?;
            self.close_time.write_xdr(w)?;
            self.upgrades.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// MaskLedgerHeaderFlags is an XDR Const defines as:
///
/// ```text
/// const MASK_LEDGER_HEADER_FLAGS = 0x7;
/// ```
///
pub const MASK_LEDGER_HEADER_FLAGS: u64 = 0x7;

/// LedgerHeaderFlags is an XDR Enum defines as:
///
/// ```text
/// enum LedgerHeaderFlags
/// {
///     DISABLE_LIQUIDITY_POOL_TRADING_FLAG = 0x1,
///     DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG = 0x2,
///     DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG = 0x4
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum LedgerHeaderFlags {
    TradingFlag = 1,
    DepositFlag = 2,
    WithdrawalFlag = 4,
}

impl LedgerHeaderFlags {
    pub const VARIANTS: [LedgerHeaderFlags; 3] = [
        LedgerHeaderFlags::TradingFlag,
        LedgerHeaderFlags::DepositFlag,
        LedgerHeaderFlags::WithdrawalFlag,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["TradingFlag", "DepositFlag", "WithdrawalFlag"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TradingFlag => "TradingFlag",
            Self::DepositFlag => "DepositFlag",
            Self::WithdrawalFlag => "WithdrawalFlag",
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerHeaderFlags; 3] {
        Self::VARIANTS
    }
}

impl Name for LedgerHeaderFlags {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LedgerHeaderFlags> for LedgerHeaderFlags {
    fn variants() -> slice::Iter<'static, LedgerHeaderFlags> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LedgerHeaderFlags {}

impl fmt::Display for LedgerHeaderFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LedgerHeaderFlags {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            1 => LedgerHeaderFlags::TradingFlag,
            2 => LedgerHeaderFlags::DepositFlag,
            4 => LedgerHeaderFlags::WithdrawalFlag,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LedgerHeaderFlags> for i32 {
    #[must_use]
    fn from(e: LedgerHeaderFlags) -> Self {
        e as Self
    }
}

impl ReadXdr for LedgerHeaderFlags {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerHeaderFlags {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LedgerHeaderExtensionV1Ext is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LedgerHeaderExtensionV1Ext {
    V0,
}

impl LedgerHeaderExtensionV1Ext {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for LedgerHeaderExtensionV1Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerHeaderExtensionV1Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerHeaderExtensionV1Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerHeaderExtensionV1Ext {}

impl ReadXdr for LedgerHeaderExtensionV1Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerHeaderExtensionV1Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerHeaderExtensionV1 is an XDR Struct defines as:
///
/// ```text
/// struct LedgerHeaderExtensionV1
/// {
///     uint32 flags; // LedgerHeaderFlags
///
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerHeaderExtensionV1 {
    pub flags: u32,
    pub ext: LedgerHeaderExtensionV1Ext,
}

impl ReadXdr for LedgerHeaderExtensionV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                flags: u32::read_xdr(r)?,
                ext: LedgerHeaderExtensionV1Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerHeaderExtensionV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.flags.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerHeaderExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         LedgerHeaderExtensionV1 v1;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LedgerHeaderExt {
    V0,
    V1(LedgerHeaderExtensionV1),
}

impl LedgerHeaderExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for LedgerHeaderExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerHeaderExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerHeaderExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerHeaderExt {}

impl ReadXdr for LedgerHeaderExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                1 => Self::V1(LedgerHeaderExtensionV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerHeaderExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerHeader is an XDR Struct defines as:
///
/// ```text
/// struct LedgerHeader
/// {
///     uint32 ledgerVersion;    // the protocol version of the ledger
///     Hash previousLedgerHash; // hash of the previous ledger header
///     StellarValue scpValue;   // what consensus agreed to
///     Hash txSetResultHash;    // the TransactionResultSet that led to this ledger
///     Hash bucketListHash;     // hash of the ledger state
///
///     uint32 ledgerSeq; // sequence number of this ledger
///
///     int64 totalCoins; // total number of stroops in existence.
///                       // 10,000,000 stroops in 1 XLM
///
///     int64 feePool;       // fees burned since last inflation run
///     uint32 inflationSeq; // inflation sequence number
///
///     uint64 idPool; // last used global ID, used for generating objects
///
///     uint32 baseFee;     // base fee per operation in stroops
///     uint32 baseReserve; // account base reserve in stroops
///
///     uint32 maxTxSetSize; // maximum size a transaction set can be
///
///     Hash skipList[4]; // hashes of ledgers in the past. allows you to jump back
///                       // in time without walking the chain back ledger by ledger
///                       // each slot contains the oldest ledger that is mod of
///                       // either 50  5000  50000 or 500000 depending on index
///                       // skipList[0] mod(50), skipList[1] mod(5000), etc
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         LedgerHeaderExtensionV1 v1;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerHeader {
    pub ledger_version: u32,
    pub previous_ledger_hash: Hash,
    pub scp_value: StellarValue,
    pub tx_set_result_hash: Hash,
    pub bucket_list_hash: Hash,
    pub ledger_seq: u32,
    pub total_coins: i64,
    pub fee_pool: i64,
    pub inflation_seq: u32,
    pub id_pool: u64,
    pub base_fee: u32,
    pub base_reserve: u32,
    pub max_tx_set_size: u32,
    pub skip_list: [Hash; 4],
    pub ext: LedgerHeaderExt,
}

impl ReadXdr for LedgerHeader {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_version: u32::read_xdr(r)?,
                previous_ledger_hash: Hash::read_xdr(r)?,
                scp_value: StellarValue::read_xdr(r)?,
                tx_set_result_hash: Hash::read_xdr(r)?,
                bucket_list_hash: Hash::read_xdr(r)?,
                ledger_seq: u32::read_xdr(r)?,
                total_coins: i64::read_xdr(r)?,
                fee_pool: i64::read_xdr(r)?,
                inflation_seq: u32::read_xdr(r)?,
                id_pool: u64::read_xdr(r)?,
                base_fee: u32::read_xdr(r)?,
                base_reserve: u32::read_xdr(r)?,
                max_tx_set_size: u32::read_xdr(r)?,
                skip_list: <[Hash; 4]>::read_xdr(r)?,
                ext: LedgerHeaderExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerHeader {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ledger_version.write_xdr(w)?;
            self.previous_ledger_hash.write_xdr(w)?;
            self.scp_value.write_xdr(w)?;
            self.tx_set_result_hash.write_xdr(w)?;
            self.bucket_list_hash.write_xdr(w)?;
            self.ledger_seq.write_xdr(w)?;
            self.total_coins.write_xdr(w)?;
            self.fee_pool.write_xdr(w)?;
            self.inflation_seq.write_xdr(w)?;
            self.id_pool.write_xdr(w)?;
            self.base_fee.write_xdr(w)?;
            self.base_reserve.write_xdr(w)?;
            self.max_tx_set_size.write_xdr(w)?;
            self.skip_list.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerUpgradeType is an XDR Enum defines as:
///
/// ```text
/// enum LedgerUpgradeType
/// {
///     LEDGER_UPGRADE_VERSION = 1,
///     LEDGER_UPGRADE_BASE_FEE = 2,
///     LEDGER_UPGRADE_MAX_TX_SET_SIZE = 3,
///     LEDGER_UPGRADE_BASE_RESERVE = 4,
///     LEDGER_UPGRADE_FLAGS = 5,
///     LEDGER_UPGRADE_CONFIG = 6,
///     LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE = 7
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum LedgerUpgradeType {
    Version = 1,
    BaseFee = 2,
    MaxTxSetSize = 3,
    BaseReserve = 4,
    Flags = 5,
    Config = 6,
    MaxSorobanTxSetSize = 7,
}

impl LedgerUpgradeType {
    pub const VARIANTS: [LedgerUpgradeType; 7] = [
        LedgerUpgradeType::Version,
        LedgerUpgradeType::BaseFee,
        LedgerUpgradeType::MaxTxSetSize,
        LedgerUpgradeType::BaseReserve,
        LedgerUpgradeType::Flags,
        LedgerUpgradeType::Config,
        LedgerUpgradeType::MaxSorobanTxSetSize,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "Version",
        "BaseFee",
        "MaxTxSetSize",
        "BaseReserve",
        "Flags",
        "Config",
        "MaxSorobanTxSetSize",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Version => "Version",
            Self::BaseFee => "BaseFee",
            Self::MaxTxSetSize => "MaxTxSetSize",
            Self::BaseReserve => "BaseReserve",
            Self::Flags => "Flags",
            Self::Config => "Config",
            Self::MaxSorobanTxSetSize => "MaxSorobanTxSetSize",
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerUpgradeType; 7] {
        Self::VARIANTS
    }
}

impl Name for LedgerUpgradeType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LedgerUpgradeType> for LedgerUpgradeType {
    fn variants() -> slice::Iter<'static, LedgerUpgradeType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LedgerUpgradeType {}

impl fmt::Display for LedgerUpgradeType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LedgerUpgradeType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            1 => LedgerUpgradeType::Version,
            2 => LedgerUpgradeType::BaseFee,
            3 => LedgerUpgradeType::MaxTxSetSize,
            4 => LedgerUpgradeType::BaseReserve,
            5 => LedgerUpgradeType::Flags,
            6 => LedgerUpgradeType::Config,
            7 => LedgerUpgradeType::MaxSorobanTxSetSize,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LedgerUpgradeType> for i32 {
    #[must_use]
    fn from(e: LedgerUpgradeType) -> Self {
        e as Self
    }
}

impl ReadXdr for LedgerUpgradeType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerUpgradeType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ConfigUpgradeSetKey is an XDR Struct defines as:
///
/// ```text
/// struct ConfigUpgradeSetKey {
///     Hash contractID;
///     Hash contentHash;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ConfigUpgradeSetKey {
    pub contract_id: Hash,
    pub content_hash: Hash,
}

impl ReadXdr for ConfigUpgradeSetKey {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                contract_id: Hash::read_xdr(r)?,
                content_hash: Hash::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigUpgradeSetKey {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.contract_id.write_xdr(w)?;
            self.content_hash.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerUpgrade is an XDR Union defines as:
///
/// ```text
/// union LedgerUpgrade switch (LedgerUpgradeType type)
/// {
/// case LEDGER_UPGRADE_VERSION:
///     uint32 newLedgerVersion; // update ledgerVersion
/// case LEDGER_UPGRADE_BASE_FEE:
///     uint32 newBaseFee; // update baseFee
/// case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
///     uint32 newMaxTxSetSize; // update maxTxSetSize
/// case LEDGER_UPGRADE_BASE_RESERVE:
///     uint32 newBaseReserve; // update baseReserve
/// case LEDGER_UPGRADE_FLAGS:
///     uint32 newFlags; // update flags
/// case LEDGER_UPGRADE_CONFIG:
///     // Update arbitrary `ConfigSetting` entries identified by the key.
///     ConfigUpgradeSetKey newConfig;
/// case LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE:
///     // Update ConfigSettingContractExecutionLanesV0.ledgerMaxTxCount without
///     // using `LEDGER_UPGRADE_CONFIG`.
///     uint32 newMaxSorobanTxSetSize;
/// };
/// ```
///
// union with discriminant LedgerUpgradeType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LedgerUpgrade {
    Version(u32),
    BaseFee(u32),
    MaxTxSetSize(u32),
    BaseReserve(u32),
    Flags(u32),
    Config(ConfigUpgradeSetKey),
    MaxSorobanTxSetSize(u32),
}

impl LedgerUpgrade {
    pub const VARIANTS: [LedgerUpgradeType; 7] = [
        LedgerUpgradeType::Version,
        LedgerUpgradeType::BaseFee,
        LedgerUpgradeType::MaxTxSetSize,
        LedgerUpgradeType::BaseReserve,
        LedgerUpgradeType::Flags,
        LedgerUpgradeType::Config,
        LedgerUpgradeType::MaxSorobanTxSetSize,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "Version",
        "BaseFee",
        "MaxTxSetSize",
        "BaseReserve",
        "Flags",
        "Config",
        "MaxSorobanTxSetSize",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Version(_) => "Version",
            Self::BaseFee(_) => "BaseFee",
            Self::MaxTxSetSize(_) => "MaxTxSetSize",
            Self::BaseReserve(_) => "BaseReserve",
            Self::Flags(_) => "Flags",
            Self::Config(_) => "Config",
            Self::MaxSorobanTxSetSize(_) => "MaxSorobanTxSetSize",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LedgerUpgradeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Version(_) => LedgerUpgradeType::Version,
            Self::BaseFee(_) => LedgerUpgradeType::BaseFee,
            Self::MaxTxSetSize(_) => LedgerUpgradeType::MaxTxSetSize,
            Self::BaseReserve(_) => LedgerUpgradeType::BaseReserve,
            Self::Flags(_) => LedgerUpgradeType::Flags,
            Self::Config(_) => LedgerUpgradeType::Config,
            Self::MaxSorobanTxSetSize(_) => LedgerUpgradeType::MaxSorobanTxSetSize,
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerUpgradeType; 7] {
        Self::VARIANTS
    }
}

impl Name for LedgerUpgrade {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LedgerUpgradeType> for LedgerUpgrade {
    #[must_use]
    fn discriminant(&self) -> LedgerUpgradeType {
        Self::discriminant(self)
    }
}

impl Variants<LedgerUpgradeType> for LedgerUpgrade {
    fn variants() -> slice::Iter<'static, LedgerUpgradeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LedgerUpgradeType> for LedgerUpgrade {}

impl ReadXdr for LedgerUpgrade {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: LedgerUpgradeType = <LedgerUpgradeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LedgerUpgradeType::Version => Self::Version(u32::read_xdr(r)?),
                LedgerUpgradeType::BaseFee => Self::BaseFee(u32::read_xdr(r)?),
                LedgerUpgradeType::MaxTxSetSize => Self::MaxTxSetSize(u32::read_xdr(r)?),
                LedgerUpgradeType::BaseReserve => Self::BaseReserve(u32::read_xdr(r)?),
                LedgerUpgradeType::Flags => Self::Flags(u32::read_xdr(r)?),
                LedgerUpgradeType::Config => Self::Config(ConfigUpgradeSetKey::read_xdr(r)?),
                LedgerUpgradeType::MaxSorobanTxSetSize => {
                    Self::MaxSorobanTxSetSize(u32::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerUpgrade {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Version(v) => v.write_xdr(w)?,
                Self::BaseFee(v) => v.write_xdr(w)?,
                Self::MaxTxSetSize(v) => v.write_xdr(w)?,
                Self::BaseReserve(v) => v.write_xdr(w)?,
                Self::Flags(v) => v.write_xdr(w)?,
                Self::Config(v) => v.write_xdr(w)?,
                Self::MaxSorobanTxSetSize(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ConfigUpgradeSet is an XDR Struct defines as:
///
/// ```text
/// struct ConfigUpgradeSet {
///     ConfigSettingEntry updatedEntry<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ConfigUpgradeSet {
    pub updated_entry: VecM<ConfigSettingEntry>,
}

impl ReadXdr for ConfigUpgradeSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                updated_entry: VecM::<ConfigSettingEntry>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ConfigUpgradeSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.updated_entry.write_xdr(w)?;
            Ok(())
        })
    }
}

/// BucketEntryType is an XDR Enum defines as:
///
/// ```text
/// enum BucketEntryType
/// {
///     METAENTRY =
///         -1, // At-and-after protocol 11: bucket metadata, should come first.
///     LIVEENTRY = 0, // Before protocol 11: created-or-updated;
///                    // At-and-after protocol 11: only updated.
///     DEADENTRY = 1,
///     INITENTRY = 2 // At-and-after protocol 11: only created.
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum BucketEntryType {
    Metaentry = -1,
    Liveentry = 0,
    Deadentry = 1,
    Initentry = 2,
}

impl BucketEntryType {
    pub const VARIANTS: [BucketEntryType; 4] = [
        BucketEntryType::Metaentry,
        BucketEntryType::Liveentry,
        BucketEntryType::Deadentry,
        BucketEntryType::Initentry,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Metaentry", "Liveentry", "Deadentry", "Initentry"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Metaentry => "Metaentry",
            Self::Liveentry => "Liveentry",
            Self::Deadentry => "Deadentry",
            Self::Initentry => "Initentry",
        }
    }

    #[must_use]
    pub const fn variants() -> [BucketEntryType; 4] {
        Self::VARIANTS
    }
}

impl Name for BucketEntryType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<BucketEntryType> for BucketEntryType {
    fn variants() -> slice::Iter<'static, BucketEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for BucketEntryType {}

impl fmt::Display for BucketEntryType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for BucketEntryType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            -1 => BucketEntryType::Metaentry,
            0 => BucketEntryType::Liveentry,
            1 => BucketEntryType::Deadentry,
            2 => BucketEntryType::Initentry,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<BucketEntryType> for i32 {
    #[must_use]
    fn from(e: BucketEntryType) -> Self {
        e as Self
    }
}

impl ReadXdr for BucketEntryType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for BucketEntryType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// BucketMetadataExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum BucketMetadataExt {
    V0,
}

impl BucketMetadataExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for BucketMetadataExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for BucketMetadataExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for BucketMetadataExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for BucketMetadataExt {}

impl ReadXdr for BucketMetadataExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for BucketMetadataExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// BucketMetadata is an XDR Struct defines as:
///
/// ```text
/// struct BucketMetadata
/// {
///     // Indicates the protocol version used to create / merge this bucket.
///     uint32 ledgerVersion;
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct BucketMetadata {
    pub ledger_version: u32,
    pub ext: BucketMetadataExt,
}

impl ReadXdr for BucketMetadata {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_version: u32::read_xdr(r)?,
                ext: BucketMetadataExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for BucketMetadata {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ledger_version.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// BucketEntry is an XDR Union defines as:
///
/// ```text
/// union BucketEntry switch (BucketEntryType type)
/// {
/// case LIVEENTRY:
/// case INITENTRY:
///     LedgerEntry liveEntry;
///
/// case DEADENTRY:
///     LedgerKey deadEntry;
/// case METAENTRY:
///     BucketMetadata metaEntry;
/// };
/// ```
///
// union with discriminant BucketEntryType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum BucketEntry {
    Liveentry(LedgerEntry),
    Initentry(LedgerEntry),
    Deadentry(LedgerKey),
    Metaentry(BucketMetadata),
}

impl BucketEntry {
    pub const VARIANTS: [BucketEntryType; 4] = [
        BucketEntryType::Liveentry,
        BucketEntryType::Initentry,
        BucketEntryType::Deadentry,
        BucketEntryType::Metaentry,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Liveentry", "Initentry", "Deadentry", "Metaentry"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Liveentry(_) => "Liveentry",
            Self::Initentry(_) => "Initentry",
            Self::Deadentry(_) => "Deadentry",
            Self::Metaentry(_) => "Metaentry",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> BucketEntryType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Liveentry(_) => BucketEntryType::Liveentry,
            Self::Initentry(_) => BucketEntryType::Initentry,
            Self::Deadentry(_) => BucketEntryType::Deadentry,
            Self::Metaentry(_) => BucketEntryType::Metaentry,
        }
    }

    #[must_use]
    pub const fn variants() -> [BucketEntryType; 4] {
        Self::VARIANTS
    }
}

impl Name for BucketEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<BucketEntryType> for BucketEntry {
    #[must_use]
    fn discriminant(&self) -> BucketEntryType {
        Self::discriminant(self)
    }
}

impl Variants<BucketEntryType> for BucketEntry {
    fn variants() -> slice::Iter<'static, BucketEntryType> {
        Self::VARIANTS.iter()
    }
}

impl Union<BucketEntryType> for BucketEntry {}

impl ReadXdr for BucketEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: BucketEntryType = <BucketEntryType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                BucketEntryType::Liveentry => Self::Liveentry(LedgerEntry::read_xdr(r)?),
                BucketEntryType::Initentry => Self::Initentry(LedgerEntry::read_xdr(r)?),
                BucketEntryType::Deadentry => Self::Deadentry(LedgerKey::read_xdr(r)?),
                BucketEntryType::Metaentry => Self::Metaentry(BucketMetadata::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for BucketEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Liveentry(v) => v.write_xdr(w)?,
                Self::Initentry(v) => v.write_xdr(w)?,
                Self::Deadentry(v) => v.write_xdr(w)?,
                Self::Metaentry(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TxSetComponentType is an XDR Enum defines as:
///
/// ```text
/// enum TxSetComponentType
/// {
///   // txs with effective fee <= bid derived from a base fee (if any).
///   // If base fee is not specified, no discount is applied.
///   TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE = 0
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum TxSetComponentType {
    TxsetCompTxsMaybeDiscountedFee = 0,
}

impl TxSetComponentType {
    pub const VARIANTS: [TxSetComponentType; 1] =
        [TxSetComponentType::TxsetCompTxsMaybeDiscountedFee];
    pub const VARIANTS_STR: [&'static str; 1] = ["TxsetCompTxsMaybeDiscountedFee"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxsetCompTxsMaybeDiscountedFee => "TxsetCompTxsMaybeDiscountedFee",
        }
    }

    #[must_use]
    pub const fn variants() -> [TxSetComponentType; 1] {
        Self::VARIANTS
    }
}

impl Name for TxSetComponentType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TxSetComponentType> for TxSetComponentType {
    fn variants() -> slice::Iter<'static, TxSetComponentType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for TxSetComponentType {}

impl fmt::Display for TxSetComponentType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for TxSetComponentType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => TxSetComponentType::TxsetCompTxsMaybeDiscountedFee,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<TxSetComponentType> for i32 {
    #[must_use]
    fn from(e: TxSetComponentType) -> Self {
        e as Self
    }
}

impl ReadXdr for TxSetComponentType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for TxSetComponentType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// TxSetComponentTxsMaybeDiscountedFee is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///   {
///     int64* baseFee;
///     TransactionEnvelope txs<>;
///   }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TxSetComponentTxsMaybeDiscountedFee {
    pub base_fee: Option<i64>,
    pub txs: VecM<TransactionEnvelope>,
}

impl ReadXdr for TxSetComponentTxsMaybeDiscountedFee {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                base_fee: Option::<i64>::read_xdr(r)?,
                txs: VecM::<TransactionEnvelope>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TxSetComponentTxsMaybeDiscountedFee {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.base_fee.write_xdr(w)?;
            self.txs.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TxSetComponent is an XDR Union defines as:
///
/// ```text
/// union TxSetComponent switch (TxSetComponentType type)
/// {
/// case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
///   struct
///   {
///     int64* baseFee;
///     TransactionEnvelope txs<>;
///   } txsMaybeDiscountedFee;
/// };
/// ```
///
// union with discriminant TxSetComponentType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TxSetComponent {
    TxsetCompTxsMaybeDiscountedFee(TxSetComponentTxsMaybeDiscountedFee),
}

impl TxSetComponent {
    pub const VARIANTS: [TxSetComponentType; 1] =
        [TxSetComponentType::TxsetCompTxsMaybeDiscountedFee];
    pub const VARIANTS_STR: [&'static str; 1] = ["TxsetCompTxsMaybeDiscountedFee"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxsetCompTxsMaybeDiscountedFee(_) => "TxsetCompTxsMaybeDiscountedFee",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> TxSetComponentType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::TxsetCompTxsMaybeDiscountedFee(_) => {
                TxSetComponentType::TxsetCompTxsMaybeDiscountedFee
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [TxSetComponentType; 1] {
        Self::VARIANTS
    }
}

impl Name for TxSetComponent {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<TxSetComponentType> for TxSetComponent {
    #[must_use]
    fn discriminant(&self) -> TxSetComponentType {
        Self::discriminant(self)
    }
}

impl Variants<TxSetComponentType> for TxSetComponent {
    fn variants() -> slice::Iter<'static, TxSetComponentType> {
        Self::VARIANTS.iter()
    }
}

impl Union<TxSetComponentType> for TxSetComponent {}

impl ReadXdr for TxSetComponent {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: TxSetComponentType = <TxSetComponentType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                TxSetComponentType::TxsetCompTxsMaybeDiscountedFee => {
                    Self::TxsetCompTxsMaybeDiscountedFee(
                        TxSetComponentTxsMaybeDiscountedFee::read_xdr(r)?,
                    )
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TxSetComponent {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::TxsetCompTxsMaybeDiscountedFee(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionPhase is an XDR Union defines as:
///
/// ```text
/// union TransactionPhase switch (int v)
/// {
/// case 0:
///     TxSetComponent v0Components<>;
/// };
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TransactionPhase {
    V0(VecM<TxSetComponent>),
}

impl TransactionPhase {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for TransactionPhase {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionPhase {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionPhase {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionPhase {}

impl ReadXdr for TransactionPhase {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(VecM::<TxSetComponent>::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionPhase {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionSet is an XDR Struct defines as:
///
/// ```text
/// struct TransactionSet
/// {
///     Hash previousLedgerHash;
///     TransactionEnvelope txs<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionSet {
    pub previous_ledger_hash: Hash,
    pub txs: VecM<TransactionEnvelope>,
}

impl ReadXdr for TransactionSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                previous_ledger_hash: Hash::read_xdr(r)?,
                txs: VecM::<TransactionEnvelope>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.previous_ledger_hash.write_xdr(w)?;
            self.txs.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionSetV1 is an XDR Struct defines as:
///
/// ```text
/// struct TransactionSetV1
/// {
///     Hash previousLedgerHash;
///     TransactionPhase phases<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionSetV1 {
    pub previous_ledger_hash: Hash,
    pub phases: VecM<TransactionPhase>,
}

impl ReadXdr for TransactionSetV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                previous_ledger_hash: Hash::read_xdr(r)?,
                phases: VecM::<TransactionPhase>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionSetV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.previous_ledger_hash.write_xdr(w)?;
            self.phases.write_xdr(w)?;
            Ok(())
        })
    }
}

/// GeneralizedTransactionSet is an XDR Union defines as:
///
/// ```text
/// union GeneralizedTransactionSet switch (int v)
/// {
/// // We consider the legacy TransactionSet to be v0.
/// case 1:
///     TransactionSetV1 v1TxSet;
/// };
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum GeneralizedTransactionSet {
    V1(TransactionSetV1),
}

impl GeneralizedTransactionSet {
    pub const VARIANTS: [i32; 1] = [1];
    pub const VARIANTS_STR: [&'static str; 1] = ["V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for GeneralizedTransactionSet {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for GeneralizedTransactionSet {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for GeneralizedTransactionSet {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for GeneralizedTransactionSet {}

impl ReadXdr for GeneralizedTransactionSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                1 => Self::V1(TransactionSetV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for GeneralizedTransactionSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionResultPair is an XDR Struct defines as:
///
/// ```text
/// struct TransactionResultPair
/// {
///     Hash transactionHash;
///     TransactionResult result; // result for the transaction
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionResultPair {
    pub transaction_hash: Hash,
    pub result: TransactionResult,
}

impl ReadXdr for TransactionResultPair {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                transaction_hash: Hash::read_xdr(r)?,
                result: TransactionResult::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionResultPair {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.transaction_hash.write_xdr(w)?;
            self.result.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionResultSet is an XDR Struct defines as:
///
/// ```text
/// struct TransactionResultSet
/// {
///     TransactionResultPair results<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionResultSet {
    pub results: VecM<TransactionResultPair>,
}

impl ReadXdr for TransactionResultSet {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                results: VecM::<TransactionResultPair>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionResultSet {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.results.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionHistoryEntryExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         GeneralizedTransactionSet generalizedTxSet;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TransactionHistoryEntryExt {
    V0,
    V1(GeneralizedTransactionSet),
}

impl TransactionHistoryEntryExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for TransactionHistoryEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionHistoryEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionHistoryEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionHistoryEntryExt {}

impl ReadXdr for TransactionHistoryEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                1 => Self::V1(GeneralizedTransactionSet::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionHistoryEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionHistoryEntry is an XDR Struct defines as:
///
/// ```text
/// struct TransactionHistoryEntry
/// {
///     uint32 ledgerSeq;
///     TransactionSet txSet;
///
///     // when v != 0, txSet must be empty
///     union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         GeneralizedTransactionSet generalizedTxSet;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionHistoryEntry {
    pub ledger_seq: u32,
    pub tx_set: TransactionSet,
    pub ext: TransactionHistoryEntryExt,
}

impl ReadXdr for TransactionHistoryEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_seq: u32::read_xdr(r)?,
                tx_set: TransactionSet::read_xdr(r)?,
                ext: TransactionHistoryEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionHistoryEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ledger_seq.write_xdr(w)?;
            self.tx_set.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionHistoryResultEntryExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TransactionHistoryResultEntryExt {
    V0,
}

impl TransactionHistoryResultEntryExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for TransactionHistoryResultEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionHistoryResultEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionHistoryResultEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionHistoryResultEntryExt {}

impl ReadXdr for TransactionHistoryResultEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionHistoryResultEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionHistoryResultEntry is an XDR Struct defines as:
///
/// ```text
/// struct TransactionHistoryResultEntry
/// {
///     uint32 ledgerSeq;
///     TransactionResultSet txResultSet;
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionHistoryResultEntry {
    pub ledger_seq: u32,
    pub tx_result_set: TransactionResultSet,
    pub ext: TransactionHistoryResultEntryExt,
}

impl ReadXdr for TransactionHistoryResultEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_seq: u32::read_xdr(r)?,
                tx_result_set: TransactionResultSet::read_xdr(r)?,
                ext: TransactionHistoryResultEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionHistoryResultEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ledger_seq.write_xdr(w)?;
            self.tx_result_set.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerHeaderHistoryEntryExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LedgerHeaderHistoryEntryExt {
    V0,
}

impl LedgerHeaderHistoryEntryExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for LedgerHeaderHistoryEntryExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerHeaderHistoryEntryExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerHeaderHistoryEntryExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerHeaderHistoryEntryExt {}

impl ReadXdr for LedgerHeaderHistoryEntryExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerHeaderHistoryEntryExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerHeaderHistoryEntry is an XDR Struct defines as:
///
/// ```text
/// struct LedgerHeaderHistoryEntry
/// {
///     Hash hash;
///     LedgerHeader header;
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerHeaderHistoryEntry {
    pub hash: Hash,
    pub header: LedgerHeader,
    pub ext: LedgerHeaderHistoryEntryExt,
}

impl ReadXdr for LedgerHeaderHistoryEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hash: Hash::read_xdr(r)?,
                header: LedgerHeader::read_xdr(r)?,
                ext: LedgerHeaderHistoryEntryExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerHeaderHistoryEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.hash.write_xdr(w)?;
            self.header.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerScpMessages is an XDR Struct defines as:
///
/// ```text
/// struct LedgerSCPMessages
/// {
///     uint32 ledgerSeq;
///     SCPEnvelope messages<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerScpMessages {
    pub ledger_seq: u32,
    pub messages: VecM<ScpEnvelope>,
}

impl ReadXdr for LedgerScpMessages {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_seq: u32::read_xdr(r)?,
                messages: VecM::<ScpEnvelope>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerScpMessages {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ledger_seq.write_xdr(w)?;
            self.messages.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScpHistoryEntryV0 is an XDR Struct defines as:
///
/// ```text
/// struct SCPHistoryEntryV0
/// {
///     SCPQuorumSet quorumSets<>; // additional quorum sets used by ledgerMessages
///     LedgerSCPMessages ledgerMessages;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ScpHistoryEntryV0 {
    pub quorum_sets: VecM<ScpQuorumSet>,
    pub ledger_messages: LedgerScpMessages,
}

impl ReadXdr for ScpHistoryEntryV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                quorum_sets: VecM::<ScpQuorumSet>::read_xdr(r)?,
                ledger_messages: LedgerScpMessages::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ScpHistoryEntryV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.quorum_sets.write_xdr(w)?;
            self.ledger_messages.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ScpHistoryEntry is an XDR Union defines as:
///
/// ```text
/// union SCPHistoryEntry switch (int v)
/// {
/// case 0:
///     SCPHistoryEntryV0 v0;
/// };
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ScpHistoryEntry {
    V0(ScpHistoryEntryV0),
}

impl ScpHistoryEntry {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for ScpHistoryEntry {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ScpHistoryEntry {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ScpHistoryEntry {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ScpHistoryEntry {}

impl ReadXdr for ScpHistoryEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(ScpHistoryEntryV0::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ScpHistoryEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerEntryChangeType is an XDR Enum defines as:
///
/// ```text
/// enum LedgerEntryChangeType
/// {
///     LEDGER_ENTRY_CREATED = 0, // entry was added to the ledger
///     LEDGER_ENTRY_UPDATED = 1, // entry was modified in the ledger
///     LEDGER_ENTRY_REMOVED = 2, // entry was removed from the ledger
///     LEDGER_ENTRY_STATE = 3    // value of the entry
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum LedgerEntryChangeType {
    Created = 0,
    Updated = 1,
    Removed = 2,
    State = 3,
}

impl LedgerEntryChangeType {
    pub const VARIANTS: [LedgerEntryChangeType; 4] = [
        LedgerEntryChangeType::Created,
        LedgerEntryChangeType::Updated,
        LedgerEntryChangeType::Removed,
        LedgerEntryChangeType::State,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = ["Created", "Updated", "Removed", "State"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Created => "Created",
            Self::Updated => "Updated",
            Self::Removed => "Removed",
            Self::State => "State",
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerEntryChangeType; 4] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryChangeType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LedgerEntryChangeType> for LedgerEntryChangeType {
    fn variants() -> slice::Iter<'static, LedgerEntryChangeType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LedgerEntryChangeType {}

impl fmt::Display for LedgerEntryChangeType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LedgerEntryChangeType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => LedgerEntryChangeType::Created,
            1 => LedgerEntryChangeType::Updated,
            2 => LedgerEntryChangeType::Removed,
            3 => LedgerEntryChangeType::State,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LedgerEntryChangeType> for i32 {
    #[must_use]
    fn from(e: LedgerEntryChangeType) -> Self {
        e as Self
    }
}

impl ReadXdr for LedgerEntryChangeType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryChangeType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LedgerEntryChange is an XDR Union defines as:
///
/// ```text
/// union LedgerEntryChange switch (LedgerEntryChangeType type)
/// {
/// case LEDGER_ENTRY_CREATED:
///     LedgerEntry created;
/// case LEDGER_ENTRY_UPDATED:
///     LedgerEntry updated;
/// case LEDGER_ENTRY_REMOVED:
///     LedgerKey removed;
/// case LEDGER_ENTRY_STATE:
///     LedgerEntry state;
/// };
/// ```
///
// union with discriminant LedgerEntryChangeType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LedgerEntryChange {
    Created(LedgerEntry),
    Updated(LedgerEntry),
    Removed(LedgerKey),
    State(LedgerEntry),
}

impl LedgerEntryChange {
    pub const VARIANTS: [LedgerEntryChangeType; 4] = [
        LedgerEntryChangeType::Created,
        LedgerEntryChangeType::Updated,
        LedgerEntryChangeType::Removed,
        LedgerEntryChangeType::State,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = ["Created", "Updated", "Removed", "State"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Created(_) => "Created",
            Self::Updated(_) => "Updated",
            Self::Removed(_) => "Removed",
            Self::State(_) => "State",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LedgerEntryChangeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Created(_) => LedgerEntryChangeType::Created,
            Self::Updated(_) => LedgerEntryChangeType::Updated,
            Self::Removed(_) => LedgerEntryChangeType::Removed,
            Self::State(_) => LedgerEntryChangeType::State,
        }
    }

    #[must_use]
    pub const fn variants() -> [LedgerEntryChangeType; 4] {
        Self::VARIANTS
    }
}

impl Name for LedgerEntryChange {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LedgerEntryChangeType> for LedgerEntryChange {
    #[must_use]
    fn discriminant(&self) -> LedgerEntryChangeType {
        Self::discriminant(self)
    }
}

impl Variants<LedgerEntryChangeType> for LedgerEntryChange {
    fn variants() -> slice::Iter<'static, LedgerEntryChangeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LedgerEntryChangeType> for LedgerEntryChange {}

impl ReadXdr for LedgerEntryChange {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: LedgerEntryChangeType = <LedgerEntryChangeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LedgerEntryChangeType::Created => Self::Created(LedgerEntry::read_xdr(r)?),
                LedgerEntryChangeType::Updated => Self::Updated(LedgerEntry::read_xdr(r)?),
                LedgerEntryChangeType::Removed => Self::Removed(LedgerKey::read_xdr(r)?),
                LedgerEntryChangeType::State => Self::State(LedgerEntry::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryChange {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Created(v) => v.write_xdr(w)?,
                Self::Updated(v) => v.write_xdr(w)?,
                Self::Removed(v) => v.write_xdr(w)?,
                Self::State(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerEntryChanges is an XDR Typedef defines as:
///
/// ```text
/// typedef LedgerEntryChange LedgerEntryChanges<>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct LedgerEntryChanges(pub VecM<LedgerEntryChange>);

impl From<LedgerEntryChanges> for VecM<LedgerEntryChange> {
    #[must_use]
    fn from(x: LedgerEntryChanges) -> Self {
        x.0
    }
}

impl From<VecM<LedgerEntryChange>> for LedgerEntryChanges {
    #[must_use]
    fn from(x: VecM<LedgerEntryChange>) -> Self {
        LedgerEntryChanges(x)
    }
}

impl AsRef<VecM<LedgerEntryChange>> for LedgerEntryChanges {
    #[must_use]
    fn as_ref(&self) -> &VecM<LedgerEntryChange> {
        &self.0
    }
}

impl ReadXdr for LedgerEntryChanges {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = VecM::<LedgerEntryChange>::read_xdr(r)?;
            let v = LedgerEntryChanges(i);
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerEntryChanges {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for LedgerEntryChanges {
    type Target = VecM<LedgerEntryChange>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<LedgerEntryChanges> for Vec<LedgerEntryChange> {
    #[must_use]
    fn from(x: LedgerEntryChanges) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<LedgerEntryChange>> for LedgerEntryChanges {
    type Error = Error;
    fn try_from(x: Vec<LedgerEntryChange>) -> Result<Self> {
        Ok(LedgerEntryChanges(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<LedgerEntryChange>> for LedgerEntryChanges {
    type Error = Error;
    fn try_from(x: &Vec<LedgerEntryChange>) -> Result<Self> {
        Ok(LedgerEntryChanges(x.try_into()?))
    }
}

impl AsRef<Vec<LedgerEntryChange>> for LedgerEntryChanges {
    #[must_use]
    fn as_ref(&self) -> &Vec<LedgerEntryChange> {
        &self.0 .0
    }
}

impl AsRef<[LedgerEntryChange]> for LedgerEntryChanges {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[LedgerEntryChange] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[LedgerEntryChange] {
        self.0 .0
    }
}

/// OperationMeta is an XDR Struct defines as:
///
/// ```text
/// struct OperationMeta
/// {
///     LedgerEntryChanges changes;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct OperationMeta {
    pub changes: LedgerEntryChanges,
}

impl ReadXdr for OperationMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                changes: LedgerEntryChanges::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for OperationMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.changes.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionMetaV1 is an XDR Struct defines as:
///
/// ```text
/// struct TransactionMetaV1
/// {
///     LedgerEntryChanges txChanges; // tx level changes if any
///     OperationMeta operations<>;   // meta for each operation
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionMetaV1 {
    pub tx_changes: LedgerEntryChanges,
    pub operations: VecM<OperationMeta>,
}

impl ReadXdr for TransactionMetaV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_changes: LedgerEntryChanges::read_xdr(r)?,
                operations: VecM::<OperationMeta>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionMetaV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.tx_changes.write_xdr(w)?;
            self.operations.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionMetaV2 is an XDR Struct defines as:
///
/// ```text
/// struct TransactionMetaV2
/// {
///     LedgerEntryChanges txChangesBefore; // tx level changes before operations
///                                         // are applied if any
///     OperationMeta operations<>;         // meta for each operation
///     LedgerEntryChanges txChangesAfter;  // tx level changes after operations are
///                                         // applied if any
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionMetaV2 {
    pub tx_changes_before: LedgerEntryChanges,
    pub operations: VecM<OperationMeta>,
    pub tx_changes_after: LedgerEntryChanges,
}

impl ReadXdr for TransactionMetaV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_changes_before: LedgerEntryChanges::read_xdr(r)?,
                operations: VecM::<OperationMeta>::read_xdr(r)?,
                tx_changes_after: LedgerEntryChanges::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionMetaV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.tx_changes_before.write_xdr(w)?;
            self.operations.write_xdr(w)?;
            self.tx_changes_after.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ContractEventType is an XDR Enum defines as:
///
/// ```text
/// enum ContractEventType
/// {
///     SYSTEM = 0,
///     CONTRACT = 1,
///     DIAGNOSTIC = 2
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ContractEventType {
    System = 0,
    Contract = 1,
    Diagnostic = 2,
}

impl ContractEventType {
    pub const VARIANTS: [ContractEventType; 3] = [
        ContractEventType::System,
        ContractEventType::Contract,
        ContractEventType::Diagnostic,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["System", "Contract", "Diagnostic"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::System => "System",
            Self::Contract => "Contract",
            Self::Diagnostic => "Diagnostic",
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractEventType; 3] {
        Self::VARIANTS
    }
}

impl Name for ContractEventType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ContractEventType> for ContractEventType {
    fn variants() -> slice::Iter<'static, ContractEventType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ContractEventType {}

impl fmt::Display for ContractEventType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ContractEventType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ContractEventType::System,
            1 => ContractEventType::Contract,
            2 => ContractEventType::Diagnostic,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ContractEventType> for i32 {
    #[must_use]
    fn from(e: ContractEventType) -> Self {
        e as Self
    }
}

impl ReadXdr for ContractEventType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ContractEventType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractEventV0 is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///         {
///             SCVal topics<>;
///             SCVal data;
///         }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ContractEventV0 {
    pub topics: VecM<ScVal>,
    pub data: ScVal,
}

impl ReadXdr for ContractEventV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                topics: VecM::<ScVal>::read_xdr(r)?,
                data: ScVal::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractEventV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.topics.write_xdr(w)?;
            self.data.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ContractEventBody is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         struct
///         {
///             SCVal topics<>;
///             SCVal data;
///         } v0;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ContractEventBody {
    V0(ContractEventV0),
}

impl ContractEventBody {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for ContractEventBody {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ContractEventBody {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ContractEventBody {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ContractEventBody {}

impl ReadXdr for ContractEventBody {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(ContractEventV0::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ContractEventBody {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ContractEvent is an XDR Struct defines as:
///
/// ```text
/// struct ContractEvent
/// {
///     // We can use this to add more fields, or because it
///     // is first, to change ContractEvent into a union.
///     ExtensionPoint ext;
///
///     Hash* contractID;
///     ContractEventType type;
///
///     union switch (int v)
///     {
///     case 0:
///         struct
///         {
///             SCVal topics<>;
///             SCVal data;
///         } v0;
///     }
///     body;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ContractEvent {
    pub ext: ExtensionPoint,
    pub contract_id: Option<Hash>,
    pub type_: ContractEventType,
    pub body: ContractEventBody,
}

impl ReadXdr for ContractEvent {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
                contract_id: Option::<Hash>::read_xdr(r)?,
                type_: ContractEventType::read_xdr(r)?,
                body: ContractEventBody::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractEvent {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.contract_id.write_xdr(w)?;
            self.type_.write_xdr(w)?;
            self.body.write_xdr(w)?;
            Ok(())
        })
    }
}

/// DiagnosticEvent is an XDR Struct defines as:
///
/// ```text
/// struct DiagnosticEvent
/// {
///     bool inSuccessfulContractCall;
///     ContractEvent event;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct DiagnosticEvent {
    pub in_successful_contract_call: bool,
    pub event: ContractEvent,
}

impl ReadXdr for DiagnosticEvent {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                in_successful_contract_call: bool::read_xdr(r)?,
                event: ContractEvent::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for DiagnosticEvent {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.in_successful_contract_call.write_xdr(w)?;
            self.event.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SorobanTransactionMetaExtV1 is an XDR Struct defines as:
///
/// ```text
/// struct SorobanTransactionMetaExtV1
/// {
///     ExtensionPoint ext;
///
///     // The following are the components of the overall Soroban resource fee
///     // charged for the transaction.
///     // The following relation holds:
///     // `resourceFeeCharged = totalNonRefundableResourceFeeCharged + totalRefundableResourceFeeCharged`
///     // where `resourceFeeCharged` is the overall fee charged for the
///     // transaction. Also, `resourceFeeCharged` <= `sorobanData.resourceFee`
///     // i.e.we never charge more than the declared resource fee.
///     // The inclusion fee for charged the Soroban transaction can be found using
///     // the following equation:
///     // `result.feeCharged = resourceFeeCharged + inclusionFeeCharged`.
///
///     // Total amount (in stroops) that has been charged for non-refundable
///     // Soroban resources.
///     // Non-refundable resources are charged based on the usage declared in
///     // the transaction envelope (such as `instructions`, `readBytes` etc.) and
///     // is charged regardless of the success of the transaction.
///     int64 totalNonRefundableResourceFeeCharged;
///     // Total amount (in stroops) that has been charged for refundable
///     // Soroban resource fees.
///     // Currently this comprises the rent fee (`rentFeeCharged`) and the
///     // fee for the events and return value.
///     // Refundable resources are charged based on the actual resources usage.
///     // Since currently refundable resources are only used for the successful
///     // transactions, this will be `0` for failed transactions.
///     int64 totalRefundableResourceFeeCharged;
///     // Amount (in stroops) that has been charged for rent.
///     // This is a part of `totalNonRefundableResourceFeeCharged`.
///     int64 rentFeeCharged;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SorobanTransactionMetaExtV1 {
    pub ext: ExtensionPoint,
    pub total_non_refundable_resource_fee_charged: i64,
    pub total_refundable_resource_fee_charged: i64,
    pub rent_fee_charged: i64,
}

impl ReadXdr for SorobanTransactionMetaExtV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
                total_non_refundable_resource_fee_charged: i64::read_xdr(r)?,
                total_refundable_resource_fee_charged: i64::read_xdr(r)?,
                rent_fee_charged: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanTransactionMetaExtV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.total_non_refundable_resource_fee_charged
                .write_xdr(w)?;
            self.total_refundable_resource_fee_charged.write_xdr(w)?;
            self.rent_fee_charged.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SorobanTransactionMetaExt is an XDR Union defines as:
///
/// ```text
/// union SorobanTransactionMetaExt switch (int v)
/// {
/// case 0:
///     void;
/// case 1:
///     SorobanTransactionMetaExtV1 v1;
/// };
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum SorobanTransactionMetaExt {
    V0,
    V1(SorobanTransactionMetaExtV1),
}

impl SorobanTransactionMetaExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for SorobanTransactionMetaExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for SorobanTransactionMetaExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for SorobanTransactionMetaExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for SorobanTransactionMetaExt {}

impl ReadXdr for SorobanTransactionMetaExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                1 => Self::V1(SorobanTransactionMetaExtV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanTransactionMetaExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SorobanTransactionMeta is an XDR Struct defines as:
///
/// ```text
/// struct SorobanTransactionMeta
/// {
///     SorobanTransactionMetaExt ext;
///
///     ContractEvent events<>;             // custom events populated by the
///                                         // contracts themselves.
///     SCVal returnValue;                  // return value of the host fn invocation
///
///     // Diagnostics events that are not hashed.
///     // This will contain all contract and diagnostic events. Even ones
///     // that were emitted in a failed contract call.
///     DiagnosticEvent diagnosticEvents<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SorobanTransactionMeta {
    pub ext: SorobanTransactionMetaExt,
    pub events: VecM<ContractEvent>,
    pub return_value: ScVal,
    pub diagnostic_events: VecM<DiagnosticEvent>,
}

impl ReadXdr for SorobanTransactionMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: SorobanTransactionMetaExt::read_xdr(r)?,
                events: VecM::<ContractEvent>::read_xdr(r)?,
                return_value: ScVal::read_xdr(r)?,
                diagnostic_events: VecM::<DiagnosticEvent>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanTransactionMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.events.write_xdr(w)?;
            self.return_value.write_xdr(w)?;
            self.diagnostic_events.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionMetaV3 is an XDR Struct defines as:
///
/// ```text
/// struct TransactionMetaV3
/// {
///     ExtensionPoint ext;
///
///     LedgerEntryChanges txChangesBefore;  // tx level changes before operations
///                                          // are applied if any
///     OperationMeta operations<>;          // meta for each operation
///     LedgerEntryChanges txChangesAfter;   // tx level changes after operations are
///                                          // applied if any
///     SorobanTransactionMeta* sorobanMeta; // Soroban-specific meta (only for
///                                          // Soroban transactions).
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionMetaV3 {
    pub ext: ExtensionPoint,
    pub tx_changes_before: LedgerEntryChanges,
    pub operations: VecM<OperationMeta>,
    pub tx_changes_after: LedgerEntryChanges,
    pub soroban_meta: Option<SorobanTransactionMeta>,
}

impl ReadXdr for TransactionMetaV3 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
                tx_changes_before: LedgerEntryChanges::read_xdr(r)?,
                operations: VecM::<OperationMeta>::read_xdr(r)?,
                tx_changes_after: LedgerEntryChanges::read_xdr(r)?,
                soroban_meta: Option::<SorobanTransactionMeta>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionMetaV3 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.tx_changes_before.write_xdr(w)?;
            self.operations.write_xdr(w)?;
            self.tx_changes_after.write_xdr(w)?;
            self.soroban_meta.write_xdr(w)?;
            Ok(())
        })
    }
}

/// InvokeHostFunctionSuccessPreImage is an XDR Struct defines as:
///
/// ```text
/// struct InvokeHostFunctionSuccessPreImage
/// {
///     SCVal returnValue;
///     ContractEvent events<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct InvokeHostFunctionSuccessPreImage {
    pub return_value: ScVal,
    pub events: VecM<ContractEvent>,
}

impl ReadXdr for InvokeHostFunctionSuccessPreImage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                return_value: ScVal::read_xdr(r)?,
                events: VecM::<ContractEvent>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InvokeHostFunctionSuccessPreImage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.return_value.write_xdr(w)?;
            self.events.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionMeta is an XDR Union defines as:
///
/// ```text
/// union TransactionMeta switch (int v)
/// {
/// case 0:
///     OperationMeta operations<>;
/// case 1:
///     TransactionMetaV1 v1;
/// case 2:
///     TransactionMetaV2 v2;
/// case 3:
///     TransactionMetaV3 v3;
/// };
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TransactionMeta {
    V0(VecM<OperationMeta>),
    V1(TransactionMetaV1),
    V2(TransactionMetaV2),
    V3(TransactionMetaV3),
}

impl TransactionMeta {
    pub const VARIANTS: [i32; 4] = [0, 1, 2, 3];
    pub const VARIANTS_STR: [&'static str; 4] = ["V0", "V1", "V2", "V3"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
            Self::V1(_) => "V1",
            Self::V2(_) => "V2",
            Self::V3(_) => "V3",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,
            Self::V1(_) => 1,
            Self::V2(_) => 2,
            Self::V3(_) => 3,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 4] {
        Self::VARIANTS
    }
}

impl Name for TransactionMeta {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionMeta {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionMeta {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionMeta {}

impl ReadXdr for TransactionMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(VecM::<OperationMeta>::read_xdr(r)?),
                1 => Self::V1(TransactionMetaV1::read_xdr(r)?),
                2 => Self::V2(TransactionMetaV2::read_xdr(r)?),
                3 => Self::V3(TransactionMetaV3::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
                Self::V2(v) => v.write_xdr(w)?,
                Self::V3(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionResultMeta is an XDR Struct defines as:
///
/// ```text
/// struct TransactionResultMeta
/// {
///     TransactionResultPair result;
///     LedgerEntryChanges feeProcessing;
///     TransactionMeta txApplyProcessing;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionResultMeta {
    pub result: TransactionResultPair,
    pub fee_processing: LedgerEntryChanges,
    pub tx_apply_processing: TransactionMeta,
}

impl ReadXdr for TransactionResultMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                result: TransactionResultPair::read_xdr(r)?,
                fee_processing: LedgerEntryChanges::read_xdr(r)?,
                tx_apply_processing: TransactionMeta::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionResultMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.result.write_xdr(w)?;
            self.fee_processing.write_xdr(w)?;
            self.tx_apply_processing.write_xdr(w)?;
            Ok(())
        })
    }
}

/// UpgradeEntryMeta is an XDR Struct defines as:
///
/// ```text
/// struct UpgradeEntryMeta
/// {
///     LedgerUpgrade upgrade;
///     LedgerEntryChanges changes;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct UpgradeEntryMeta {
    pub upgrade: LedgerUpgrade,
    pub changes: LedgerEntryChanges,
}

impl ReadXdr for UpgradeEntryMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                upgrade: LedgerUpgrade::read_xdr(r)?,
                changes: LedgerEntryChanges::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for UpgradeEntryMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.upgrade.write_xdr(w)?;
            self.changes.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerCloseMetaV0 is an XDR Struct defines as:
///
/// ```text
/// struct LedgerCloseMetaV0
/// {
///     LedgerHeaderHistoryEntry ledgerHeader;
///     // NB: txSet is sorted in "Hash order"
///     TransactionSet txSet;
///
///     // NB: transactions are sorted in apply order here
///     // fees for all transactions are processed first
///     // followed by applying transactions
///     TransactionResultMeta txProcessing<>;
///
///     // upgrades are applied last
///     UpgradeEntryMeta upgradesProcessing<>;
///
///     // other misc information attached to the ledger close
///     SCPHistoryEntry scpInfo<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerCloseMetaV0 {
    pub ledger_header: LedgerHeaderHistoryEntry,
    pub tx_set: TransactionSet,
    pub tx_processing: VecM<TransactionResultMeta>,
    pub upgrades_processing: VecM<UpgradeEntryMeta>,
    pub scp_info: VecM<ScpHistoryEntry>,
}

impl ReadXdr for LedgerCloseMetaV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_header: LedgerHeaderHistoryEntry::read_xdr(r)?,
                tx_set: TransactionSet::read_xdr(r)?,
                tx_processing: VecM::<TransactionResultMeta>::read_xdr(r)?,
                upgrades_processing: VecM::<UpgradeEntryMeta>::read_xdr(r)?,
                scp_info: VecM::<ScpHistoryEntry>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerCloseMetaV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ledger_header.write_xdr(w)?;
            self.tx_set.write_xdr(w)?;
            self.tx_processing.write_xdr(w)?;
            self.upgrades_processing.write_xdr(w)?;
            self.scp_info.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerCloseMetaExtV1 is an XDR Struct defines as:
///
/// ```text
/// struct LedgerCloseMetaExtV1
/// {
///     ExtensionPoint ext;
///     int64 sorobanFeeWrite1KB;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerCloseMetaExtV1 {
    pub ext: ExtensionPoint,
    pub soroban_fee_write1_kb: i64,
}

impl ReadXdr for LedgerCloseMetaExtV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
                soroban_fee_write1_kb: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerCloseMetaExtV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.soroban_fee_write1_kb.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerCloseMetaExt is an XDR Union defines as:
///
/// ```text
/// union LedgerCloseMetaExt switch (int v)
/// {
/// case 0:
///     void;
/// case 1:
///     LedgerCloseMetaExtV1 v1;
/// };
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LedgerCloseMetaExt {
    V0,
    V1(LedgerCloseMetaExtV1),
}

impl LedgerCloseMetaExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for LedgerCloseMetaExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerCloseMetaExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerCloseMetaExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerCloseMetaExt {}

impl ReadXdr for LedgerCloseMetaExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                1 => Self::V1(LedgerCloseMetaExtV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerCloseMetaExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerCloseMetaV1 is an XDR Struct defines as:
///
/// ```text
/// struct LedgerCloseMetaV1
/// {
///     LedgerCloseMetaExt ext;
///
///     LedgerHeaderHistoryEntry ledgerHeader;
///
///     GeneralizedTransactionSet txSet;
///
///     // NB: transactions are sorted in apply order here
///     // fees for all transactions are processed first
///     // followed by applying transactions
///     TransactionResultMeta txProcessing<>;
///
///     // upgrades are applied last
///     UpgradeEntryMeta upgradesProcessing<>;
///
///     // other misc information attached to the ledger close
///     SCPHistoryEntry scpInfo<>;
///
///     // Size in bytes of BucketList, to support downstream
///     // systems calculating storage fees correctly.
///     uint64 totalByteSizeOfBucketList;
///
///     // Temp keys that are being evicted at this ledger.
///     LedgerKey evictedTemporaryLedgerKeys<>;
///
///     // Archived restorable ledger entries that are being
///     // evicted at this ledger.
///     LedgerEntry evictedPersistentLedgerEntries<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerCloseMetaV1 {
    pub ext: LedgerCloseMetaExt,
    pub ledger_header: LedgerHeaderHistoryEntry,
    pub tx_set: GeneralizedTransactionSet,
    pub tx_processing: VecM<TransactionResultMeta>,
    pub upgrades_processing: VecM<UpgradeEntryMeta>,
    pub scp_info: VecM<ScpHistoryEntry>,
    pub total_byte_size_of_bucket_list: u64,
    pub evicted_temporary_ledger_keys: VecM<LedgerKey>,
    pub evicted_persistent_ledger_entries: VecM<LedgerEntry>,
}

impl ReadXdr for LedgerCloseMetaV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: LedgerCloseMetaExt::read_xdr(r)?,
                ledger_header: LedgerHeaderHistoryEntry::read_xdr(r)?,
                tx_set: GeneralizedTransactionSet::read_xdr(r)?,
                tx_processing: VecM::<TransactionResultMeta>::read_xdr(r)?,
                upgrades_processing: VecM::<UpgradeEntryMeta>::read_xdr(r)?,
                scp_info: VecM::<ScpHistoryEntry>::read_xdr(r)?,
                total_byte_size_of_bucket_list: u64::read_xdr(r)?,
                evicted_temporary_ledger_keys: VecM::<LedgerKey>::read_xdr(r)?,
                evicted_persistent_ledger_entries: VecM::<LedgerEntry>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerCloseMetaV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.ledger_header.write_xdr(w)?;
            self.tx_set.write_xdr(w)?;
            self.tx_processing.write_xdr(w)?;
            self.upgrades_processing.write_xdr(w)?;
            self.scp_info.write_xdr(w)?;
            self.total_byte_size_of_bucket_list.write_xdr(w)?;
            self.evicted_temporary_ledger_keys.write_xdr(w)?;
            self.evicted_persistent_ledger_entries.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerCloseMeta is an XDR Union defines as:
///
/// ```text
/// union LedgerCloseMeta switch (int v)
/// {
/// case 0:
///     LedgerCloseMetaV0 v0;
/// case 1:
///     LedgerCloseMetaV1 v1;
/// };
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LedgerCloseMeta {
    V0(LedgerCloseMetaV0),
    V1(LedgerCloseMetaV1),
}

impl LedgerCloseMeta {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for LedgerCloseMeta {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for LedgerCloseMeta {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for LedgerCloseMeta {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for LedgerCloseMeta {}

impl ReadXdr for LedgerCloseMeta {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(LedgerCloseMetaV0::read_xdr(r)?),
                1 => Self::V1(LedgerCloseMetaV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LedgerCloseMeta {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ErrorCode is an XDR Enum defines as:
///
/// ```text
/// enum ErrorCode
/// {
///     ERR_MISC = 0, // Unspecific error
///     ERR_DATA = 1, // Malformed data
///     ERR_CONF = 2, // Misconfiguration error
///     ERR_AUTH = 3, // Authentication failure
///     ERR_LOAD = 4  // System overloaded
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ErrorCode {
    Misc = 0,
    Data = 1,
    Conf = 2,
    Auth = 3,
    Load = 4,
}

impl ErrorCode {
    pub const VARIANTS: [ErrorCode; 5] = [
        ErrorCode::Misc,
        ErrorCode::Data,
        ErrorCode::Conf,
        ErrorCode::Auth,
        ErrorCode::Load,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = ["Misc", "Data", "Conf", "Auth", "Load"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Misc => "Misc",
            Self::Data => "Data",
            Self::Conf => "Conf",
            Self::Auth => "Auth",
            Self::Load => "Load",
        }
    }

    #[must_use]
    pub const fn variants() -> [ErrorCode; 5] {
        Self::VARIANTS
    }
}

impl Name for ErrorCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ErrorCode> for ErrorCode {
    fn variants() -> slice::Iter<'static, ErrorCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ErrorCode {}

impl fmt::Display for ErrorCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ErrorCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ErrorCode::Misc,
            1 => ErrorCode::Data,
            2 => ErrorCode::Conf,
            3 => ErrorCode::Auth,
            4 => ErrorCode::Load,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ErrorCode> for i32 {
    #[must_use]
    fn from(e: ErrorCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ErrorCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ErrorCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SError is an XDR Struct defines as:
///
/// ```text
/// struct Error
/// {
///     ErrorCode code;
///     string msg<100>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SError {
    pub code: ErrorCode,
    pub msg: StringM<100>,
}

impl ReadXdr for SError {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                code: ErrorCode::read_xdr(r)?,
                msg: StringM::<100>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SError {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.code.write_xdr(w)?;
            self.msg.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SendMore is an XDR Struct defines as:
///
/// ```text
/// struct SendMore
/// {
///     uint32 numMessages;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SendMore {
    pub num_messages: u32,
}

impl ReadXdr for SendMore {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                num_messages: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SendMore {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.num_messages.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SendMoreExtended is an XDR Struct defines as:
///
/// ```text
/// struct SendMoreExtended
/// {
///     uint32 numMessages;
///     uint32 numBytes;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SendMoreExtended {
    pub num_messages: u32,
    pub num_bytes: u32,
}

impl ReadXdr for SendMoreExtended {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                num_messages: u32::read_xdr(r)?,
                num_bytes: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SendMoreExtended {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.num_messages.write_xdr(w)?;
            self.num_bytes.write_xdr(w)?;
            Ok(())
        })
    }
}

/// AuthCert is an XDR Struct defines as:
///
/// ```text
/// struct AuthCert
/// {
///     Curve25519Public pubkey;
///     uint64 expiration;
///     Signature sig;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct AuthCert {
    pub pubkey: Curve25519Public,
    pub expiration: u64,
    pub sig: Signature,
}

impl ReadXdr for AuthCert {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                pubkey: Curve25519Public::read_xdr(r)?,
                expiration: u64::read_xdr(r)?,
                sig: Signature::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AuthCert {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.pubkey.write_xdr(w)?;
            self.expiration.write_xdr(w)?;
            self.sig.write_xdr(w)?;
            Ok(())
        })
    }
}

/// Hello is an XDR Struct defines as:
///
/// ```text
/// struct Hello
/// {
///     uint32 ledgerVersion;
///     uint32 overlayVersion;
///     uint32 overlayMinVersion;
///     Hash networkID;
///     string versionStr<100>;
///     int listeningPort;
///     NodeID peerID;
///     AuthCert cert;
///     uint256 nonce;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Hello {
    pub ledger_version: u32,
    pub overlay_version: u32,
    pub overlay_min_version: u32,
    pub network_id: Hash,
    pub version_str: StringM<100>,
    pub listening_port: i32,
    pub peer_id: NodeId,
    pub cert: AuthCert,
    pub nonce: Uint256,
}

impl ReadXdr for Hello {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ledger_version: u32::read_xdr(r)?,
                overlay_version: u32::read_xdr(r)?,
                overlay_min_version: u32::read_xdr(r)?,
                network_id: Hash::read_xdr(r)?,
                version_str: StringM::<100>::read_xdr(r)?,
                listening_port: i32::read_xdr(r)?,
                peer_id: NodeId::read_xdr(r)?,
                cert: AuthCert::read_xdr(r)?,
                nonce: Uint256::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Hello {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ledger_version.write_xdr(w)?;
            self.overlay_version.write_xdr(w)?;
            self.overlay_min_version.write_xdr(w)?;
            self.network_id.write_xdr(w)?;
            self.version_str.write_xdr(w)?;
            self.listening_port.write_xdr(w)?;
            self.peer_id.write_xdr(w)?;
            self.cert.write_xdr(w)?;
            self.nonce.write_xdr(w)?;
            Ok(())
        })
    }
}

/// AuthMsgFlagFlowControlBytesRequested is an XDR Const defines as:
///
/// ```text
/// const AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED = 200;
/// ```
///
pub const AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED: u64 = 200;

/// Auth is an XDR Struct defines as:
///
/// ```text
/// struct Auth
/// {
///     int flags;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Auth {
    pub flags: i32,
}

impl ReadXdr for Auth {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                flags: i32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Auth {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.flags.write_xdr(w)?;
            Ok(())
        })
    }
}

/// IpAddrType is an XDR Enum defines as:
///
/// ```text
/// enum IPAddrType
/// {
///     IPv4 = 0,
///     IPv6 = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum IpAddrType {
    IPv4 = 0,
    IPv6 = 1,
}

impl IpAddrType {
    pub const VARIANTS: [IpAddrType; 2] = [IpAddrType::IPv4, IpAddrType::IPv6];
    pub const VARIANTS_STR: [&'static str; 2] = ["IPv4", "IPv6"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::IPv4 => "IPv4",
            Self::IPv6 => "IPv6",
        }
    }

    #[must_use]
    pub const fn variants() -> [IpAddrType; 2] {
        Self::VARIANTS
    }
}

impl Name for IpAddrType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<IpAddrType> for IpAddrType {
    fn variants() -> slice::Iter<'static, IpAddrType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for IpAddrType {}

impl fmt::Display for IpAddrType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for IpAddrType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => IpAddrType::IPv4,
            1 => IpAddrType::IPv6,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<IpAddrType> for i32 {
    #[must_use]
    fn from(e: IpAddrType) -> Self {
        e as Self
    }
}

impl ReadXdr for IpAddrType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for IpAddrType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// PeerAddressIp is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (IPAddrType type)
///     {
///     case IPv4:
///         opaque ipv4[4];
///     case IPv6:
///         opaque ipv6[16];
///     }
/// ```
///
// union with discriminant IpAddrType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum PeerAddressIp {
    IPv4([u8; 4]),
    IPv6([u8; 16]),
}

impl PeerAddressIp {
    pub const VARIANTS: [IpAddrType; 2] = [IpAddrType::IPv4, IpAddrType::IPv6];
    pub const VARIANTS_STR: [&'static str; 2] = ["IPv4", "IPv6"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::IPv4(_) => "IPv4",
            Self::IPv6(_) => "IPv6",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> IpAddrType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::IPv4(_) => IpAddrType::IPv4,
            Self::IPv6(_) => IpAddrType::IPv6,
        }
    }

    #[must_use]
    pub const fn variants() -> [IpAddrType; 2] {
        Self::VARIANTS
    }
}

impl Name for PeerAddressIp {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<IpAddrType> for PeerAddressIp {
    #[must_use]
    fn discriminant(&self) -> IpAddrType {
        Self::discriminant(self)
    }
}

impl Variants<IpAddrType> for PeerAddressIp {
    fn variants() -> slice::Iter<'static, IpAddrType> {
        Self::VARIANTS.iter()
    }
}

impl Union<IpAddrType> for PeerAddressIp {}

impl ReadXdr for PeerAddressIp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: IpAddrType = <IpAddrType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                IpAddrType::IPv4 => Self::IPv4(<[u8; 4]>::read_xdr(r)?),
                IpAddrType::IPv6 => Self::IPv6(<[u8; 16]>::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PeerAddressIp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::IPv4(v) => v.write_xdr(w)?,
                Self::IPv6(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// PeerAddress is an XDR Struct defines as:
///
/// ```text
/// struct PeerAddress
/// {
///     union switch (IPAddrType type)
///     {
///     case IPv4:
///         opaque ipv4[4];
///     case IPv6:
///         opaque ipv6[16];
///     }
///     ip;
///     uint32 port;
///     uint32 numFailures;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct PeerAddress {
    pub ip: PeerAddressIp,
    pub port: u32,
    pub num_failures: u32,
}

impl ReadXdr for PeerAddress {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ip: PeerAddressIp::read_xdr(r)?,
                port: u32::read_xdr(r)?,
                num_failures: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PeerAddress {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ip.write_xdr(w)?;
            self.port.write_xdr(w)?;
            self.num_failures.write_xdr(w)?;
            Ok(())
        })
    }
}

/// MessageType is an XDR Enum defines as:
///
/// ```text
/// enum MessageType
/// {
///     ERROR_MSG = 0,
///     AUTH = 2,
///     DONT_HAVE = 3,
///
///     GET_PEERS = 4, // gets a list of peers this guy knows about
///     PEERS = 5,
///
///     GET_TX_SET = 6, // gets a particular txset by hash
///     TX_SET = 7,
///     GENERALIZED_TX_SET = 17,
///
///     TRANSACTION = 8, // pass on a tx you have heard about
///
///     // SCP
///     GET_SCP_QUORUMSET = 9,
///     SCP_QUORUMSET = 10,
///     SCP_MESSAGE = 11,
///     GET_SCP_STATE = 12,
///
///     // new messages
///     HELLO = 13,
///
///     SURVEY_REQUEST = 14,
///     SURVEY_RESPONSE = 15,
///
///     SEND_MORE = 16,
///     SEND_MORE_EXTENDED = 20,
///
///     FLOOD_ADVERT = 18,
///     FLOOD_DEMAND = 19
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum MessageType {
    ErrorMsg = 0,
    Auth = 2,
    DontHave = 3,
    GetPeers = 4,
    Peers = 5,
    GetTxSet = 6,
    TxSet = 7,
    GeneralizedTxSet = 17,
    Transaction = 8,
    GetScpQuorumset = 9,
    ScpQuorumset = 10,
    ScpMessage = 11,
    GetScpState = 12,
    Hello = 13,
    SurveyRequest = 14,
    SurveyResponse = 15,
    SendMore = 16,
    SendMoreExtended = 20,
    FloodAdvert = 18,
    FloodDemand = 19,
}

impl MessageType {
    pub const VARIANTS: [MessageType; 20] = [
        MessageType::ErrorMsg,
        MessageType::Auth,
        MessageType::DontHave,
        MessageType::GetPeers,
        MessageType::Peers,
        MessageType::GetTxSet,
        MessageType::TxSet,
        MessageType::GeneralizedTxSet,
        MessageType::Transaction,
        MessageType::GetScpQuorumset,
        MessageType::ScpQuorumset,
        MessageType::ScpMessage,
        MessageType::GetScpState,
        MessageType::Hello,
        MessageType::SurveyRequest,
        MessageType::SurveyResponse,
        MessageType::SendMore,
        MessageType::SendMoreExtended,
        MessageType::FloodAdvert,
        MessageType::FloodDemand,
    ];
    pub const VARIANTS_STR: [&'static str; 20] = [
        "ErrorMsg",
        "Auth",
        "DontHave",
        "GetPeers",
        "Peers",
        "GetTxSet",
        "TxSet",
        "GeneralizedTxSet",
        "Transaction",
        "GetScpQuorumset",
        "ScpQuorumset",
        "ScpMessage",
        "GetScpState",
        "Hello",
        "SurveyRequest",
        "SurveyResponse",
        "SendMore",
        "SendMoreExtended",
        "FloodAdvert",
        "FloodDemand",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ErrorMsg => "ErrorMsg",
            Self::Auth => "Auth",
            Self::DontHave => "DontHave",
            Self::GetPeers => "GetPeers",
            Self::Peers => "Peers",
            Self::GetTxSet => "GetTxSet",
            Self::TxSet => "TxSet",
            Self::GeneralizedTxSet => "GeneralizedTxSet",
            Self::Transaction => "Transaction",
            Self::GetScpQuorumset => "GetScpQuorumset",
            Self::ScpQuorumset => "ScpQuorumset",
            Self::ScpMessage => "ScpMessage",
            Self::GetScpState => "GetScpState",
            Self::Hello => "Hello",
            Self::SurveyRequest => "SurveyRequest",
            Self::SurveyResponse => "SurveyResponse",
            Self::SendMore => "SendMore",
            Self::SendMoreExtended => "SendMoreExtended",
            Self::FloodAdvert => "FloodAdvert",
            Self::FloodDemand => "FloodDemand",
        }
    }

    #[must_use]
    pub const fn variants() -> [MessageType; 20] {
        Self::VARIANTS
    }
}

impl Name for MessageType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<MessageType> for MessageType {
    fn variants() -> slice::Iter<'static, MessageType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for MessageType {}

impl fmt::Display for MessageType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for MessageType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => MessageType::ErrorMsg,
            2 => MessageType::Auth,
            3 => MessageType::DontHave,
            4 => MessageType::GetPeers,
            5 => MessageType::Peers,
            6 => MessageType::GetTxSet,
            7 => MessageType::TxSet,
            17 => MessageType::GeneralizedTxSet,
            8 => MessageType::Transaction,
            9 => MessageType::GetScpQuorumset,
            10 => MessageType::ScpQuorumset,
            11 => MessageType::ScpMessage,
            12 => MessageType::GetScpState,
            13 => MessageType::Hello,
            14 => MessageType::SurveyRequest,
            15 => MessageType::SurveyResponse,
            16 => MessageType::SendMore,
            20 => MessageType::SendMoreExtended,
            18 => MessageType::FloodAdvert,
            19 => MessageType::FloodDemand,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<MessageType> for i32 {
    #[must_use]
    fn from(e: MessageType) -> Self {
        e as Self
    }
}

impl ReadXdr for MessageType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for MessageType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// DontHave is an XDR Struct defines as:
///
/// ```text
/// struct DontHave
/// {
///     MessageType type;
///     uint256 reqHash;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct DontHave {
    pub type_: MessageType,
    pub req_hash: Uint256,
}

impl ReadXdr for DontHave {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                type_: MessageType::read_xdr(r)?,
                req_hash: Uint256::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for DontHave {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.type_.write_xdr(w)?;
            self.req_hash.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SurveyMessageCommandType is an XDR Enum defines as:
///
/// ```text
/// enum SurveyMessageCommandType
/// {
///     SURVEY_TOPOLOGY = 0
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum SurveyMessageCommandType {
    SurveyTopology = 0,
}

impl SurveyMessageCommandType {
    pub const VARIANTS: [SurveyMessageCommandType; 1] = [SurveyMessageCommandType::SurveyTopology];
    pub const VARIANTS_STR: [&'static str; 1] = ["SurveyTopology"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SurveyTopology => "SurveyTopology",
        }
    }

    #[must_use]
    pub const fn variants() -> [SurveyMessageCommandType; 1] {
        Self::VARIANTS
    }
}

impl Name for SurveyMessageCommandType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SurveyMessageCommandType> for SurveyMessageCommandType {
    fn variants() -> slice::Iter<'static, SurveyMessageCommandType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SurveyMessageCommandType {}

impl fmt::Display for SurveyMessageCommandType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SurveyMessageCommandType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => SurveyMessageCommandType::SurveyTopology,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SurveyMessageCommandType> for i32 {
    #[must_use]
    fn from(e: SurveyMessageCommandType) -> Self {
        e as Self
    }
}

impl ReadXdr for SurveyMessageCommandType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SurveyMessageCommandType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SurveyMessageResponseType is an XDR Enum defines as:
///
/// ```text
/// enum SurveyMessageResponseType
/// {
///     SURVEY_TOPOLOGY_RESPONSE_V0 = 0,
///     SURVEY_TOPOLOGY_RESPONSE_V1 = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum SurveyMessageResponseType {
    V0 = 0,
    V1 = 1,
}

impl SurveyMessageResponseType {
    pub const VARIANTS: [SurveyMessageResponseType; 2] =
        [SurveyMessageResponseType::V0, SurveyMessageResponseType::V1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V1 => "V1",
        }
    }

    #[must_use]
    pub const fn variants() -> [SurveyMessageResponseType; 2] {
        Self::VARIANTS
    }
}

impl Name for SurveyMessageResponseType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SurveyMessageResponseType> for SurveyMessageResponseType {
    fn variants() -> slice::Iter<'static, SurveyMessageResponseType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SurveyMessageResponseType {}

impl fmt::Display for SurveyMessageResponseType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SurveyMessageResponseType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => SurveyMessageResponseType::V0,
            1 => SurveyMessageResponseType::V1,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SurveyMessageResponseType> for i32 {
    #[must_use]
    fn from(e: SurveyMessageResponseType) -> Self {
        e as Self
    }
}

impl ReadXdr for SurveyMessageResponseType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SurveyMessageResponseType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SurveyRequestMessage is an XDR Struct defines as:
///
/// ```text
/// struct SurveyRequestMessage
/// {
///     NodeID surveyorPeerID;
///     NodeID surveyedPeerID;
///     uint32 ledgerNum;
///     Curve25519Public encryptionKey;
///     SurveyMessageCommandType commandType;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SurveyRequestMessage {
    pub surveyor_peer_id: NodeId,
    pub surveyed_peer_id: NodeId,
    pub ledger_num: u32,
    pub encryption_key: Curve25519Public,
    pub command_type: SurveyMessageCommandType,
}

impl ReadXdr for SurveyRequestMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                surveyor_peer_id: NodeId::read_xdr(r)?,
                surveyed_peer_id: NodeId::read_xdr(r)?,
                ledger_num: u32::read_xdr(r)?,
                encryption_key: Curve25519Public::read_xdr(r)?,
                command_type: SurveyMessageCommandType::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SurveyRequestMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.surveyor_peer_id.write_xdr(w)?;
            self.surveyed_peer_id.write_xdr(w)?;
            self.ledger_num.write_xdr(w)?;
            self.encryption_key.write_xdr(w)?;
            self.command_type.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SignedSurveyRequestMessage is an XDR Struct defines as:
///
/// ```text
/// struct SignedSurveyRequestMessage
/// {
///     Signature requestSignature;
///     SurveyRequestMessage request;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SignedSurveyRequestMessage {
    pub request_signature: Signature,
    pub request: SurveyRequestMessage,
}

impl ReadXdr for SignedSurveyRequestMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                request_signature: Signature::read_xdr(r)?,
                request: SurveyRequestMessage::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SignedSurveyRequestMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.request_signature.write_xdr(w)?;
            self.request.write_xdr(w)?;
            Ok(())
        })
    }
}

/// EncryptedBody is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque EncryptedBody<64000>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct EncryptedBody(pub BytesM<64000>);

impl From<EncryptedBody> for BytesM<64000> {
    #[must_use]
    fn from(x: EncryptedBody) -> Self {
        x.0
    }
}

impl From<BytesM<64000>> for EncryptedBody {
    #[must_use]
    fn from(x: BytesM<64000>) -> Self {
        EncryptedBody(x)
    }
}

impl AsRef<BytesM<64000>> for EncryptedBody {
    #[must_use]
    fn as_ref(&self) -> &BytesM<64000> {
        &self.0
    }
}

impl ReadXdr for EncryptedBody {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = BytesM::<64000>::read_xdr(r)?;
            let v = EncryptedBody(i);
            Ok(v)
        })
    }
}

impl WriteXdr for EncryptedBody {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for EncryptedBody {
    type Target = BytesM<64000>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<EncryptedBody> for Vec<u8> {
    #[must_use]
    fn from(x: EncryptedBody) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for EncryptedBody {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        Ok(EncryptedBody(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for EncryptedBody {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        Ok(EncryptedBody(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for EncryptedBody {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for EncryptedBody {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// SurveyResponseMessage is an XDR Struct defines as:
///
/// ```text
/// struct SurveyResponseMessage
/// {
///     NodeID surveyorPeerID;
///     NodeID surveyedPeerID;
///     uint32 ledgerNum;
///     SurveyMessageCommandType commandType;
///     EncryptedBody encryptedBody;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SurveyResponseMessage {
    pub surveyor_peer_id: NodeId,
    pub surveyed_peer_id: NodeId,
    pub ledger_num: u32,
    pub command_type: SurveyMessageCommandType,
    pub encrypted_body: EncryptedBody,
}

impl ReadXdr for SurveyResponseMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                surveyor_peer_id: NodeId::read_xdr(r)?,
                surveyed_peer_id: NodeId::read_xdr(r)?,
                ledger_num: u32::read_xdr(r)?,
                command_type: SurveyMessageCommandType::read_xdr(r)?,
                encrypted_body: EncryptedBody::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SurveyResponseMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.surveyor_peer_id.write_xdr(w)?;
            self.surveyed_peer_id.write_xdr(w)?;
            self.ledger_num.write_xdr(w)?;
            self.command_type.write_xdr(w)?;
            self.encrypted_body.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SignedSurveyResponseMessage is an XDR Struct defines as:
///
/// ```text
/// struct SignedSurveyResponseMessage
/// {
///     Signature responseSignature;
///     SurveyResponseMessage response;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SignedSurveyResponseMessage {
    pub response_signature: Signature,
    pub response: SurveyResponseMessage,
}

impl ReadXdr for SignedSurveyResponseMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                response_signature: Signature::read_xdr(r)?,
                response: SurveyResponseMessage::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SignedSurveyResponseMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.response_signature.write_xdr(w)?;
            self.response.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PeerStats is an XDR Struct defines as:
///
/// ```text
/// struct PeerStats
/// {
///     NodeID id;
///     string versionStr<100>;
///     uint64 messagesRead;
///     uint64 messagesWritten;
///     uint64 bytesRead;
///     uint64 bytesWritten;
///     uint64 secondsConnected;
///
///     uint64 uniqueFloodBytesRecv;
///     uint64 duplicateFloodBytesRecv;
///     uint64 uniqueFetchBytesRecv;
///     uint64 duplicateFetchBytesRecv;
///
///     uint64 uniqueFloodMessageRecv;
///     uint64 duplicateFloodMessageRecv;
///     uint64 uniqueFetchMessageRecv;
///     uint64 duplicateFetchMessageRecv;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct PeerStats {
    pub id: NodeId,
    pub version_str: StringM<100>,
    pub messages_read: u64,
    pub messages_written: u64,
    pub bytes_read: u64,
    pub bytes_written: u64,
    pub seconds_connected: u64,
    pub unique_flood_bytes_recv: u64,
    pub duplicate_flood_bytes_recv: u64,
    pub unique_fetch_bytes_recv: u64,
    pub duplicate_fetch_bytes_recv: u64,
    pub unique_flood_message_recv: u64,
    pub duplicate_flood_message_recv: u64,
    pub unique_fetch_message_recv: u64,
    pub duplicate_fetch_message_recv: u64,
}

impl ReadXdr for PeerStats {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                id: NodeId::read_xdr(r)?,
                version_str: StringM::<100>::read_xdr(r)?,
                messages_read: u64::read_xdr(r)?,
                messages_written: u64::read_xdr(r)?,
                bytes_read: u64::read_xdr(r)?,
                bytes_written: u64::read_xdr(r)?,
                seconds_connected: u64::read_xdr(r)?,
                unique_flood_bytes_recv: u64::read_xdr(r)?,
                duplicate_flood_bytes_recv: u64::read_xdr(r)?,
                unique_fetch_bytes_recv: u64::read_xdr(r)?,
                duplicate_fetch_bytes_recv: u64::read_xdr(r)?,
                unique_flood_message_recv: u64::read_xdr(r)?,
                duplicate_flood_message_recv: u64::read_xdr(r)?,
                unique_fetch_message_recv: u64::read_xdr(r)?,
                duplicate_fetch_message_recv: u64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PeerStats {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.id.write_xdr(w)?;
            self.version_str.write_xdr(w)?;
            self.messages_read.write_xdr(w)?;
            self.messages_written.write_xdr(w)?;
            self.bytes_read.write_xdr(w)?;
            self.bytes_written.write_xdr(w)?;
            self.seconds_connected.write_xdr(w)?;
            self.unique_flood_bytes_recv.write_xdr(w)?;
            self.duplicate_flood_bytes_recv.write_xdr(w)?;
            self.unique_fetch_bytes_recv.write_xdr(w)?;
            self.duplicate_fetch_bytes_recv.write_xdr(w)?;
            self.unique_flood_message_recv.write_xdr(w)?;
            self.duplicate_flood_message_recv.write_xdr(w)?;
            self.unique_fetch_message_recv.write_xdr(w)?;
            self.duplicate_fetch_message_recv.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PeerStatList is an XDR Typedef defines as:
///
/// ```text
/// typedef PeerStats PeerStatList<25>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct PeerStatList(pub VecM<PeerStats, 25>);

impl From<PeerStatList> for VecM<PeerStats, 25> {
    #[must_use]
    fn from(x: PeerStatList) -> Self {
        x.0
    }
}

impl From<VecM<PeerStats, 25>> for PeerStatList {
    #[must_use]
    fn from(x: VecM<PeerStats, 25>) -> Self {
        PeerStatList(x)
    }
}

impl AsRef<VecM<PeerStats, 25>> for PeerStatList {
    #[must_use]
    fn as_ref(&self) -> &VecM<PeerStats, 25> {
        &self.0
    }
}

impl ReadXdr for PeerStatList {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = VecM::<PeerStats, 25>::read_xdr(r)?;
            let v = PeerStatList(i);
            Ok(v)
        })
    }
}

impl WriteXdr for PeerStatList {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for PeerStatList {
    type Target = VecM<PeerStats, 25>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<PeerStatList> for Vec<PeerStats> {
    #[must_use]
    fn from(x: PeerStatList) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<PeerStats>> for PeerStatList {
    type Error = Error;
    fn try_from(x: Vec<PeerStats>) -> Result<Self> {
        Ok(PeerStatList(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<PeerStats>> for PeerStatList {
    type Error = Error;
    fn try_from(x: &Vec<PeerStats>) -> Result<Self> {
        Ok(PeerStatList(x.try_into()?))
    }
}

impl AsRef<Vec<PeerStats>> for PeerStatList {
    #[must_use]
    fn as_ref(&self) -> &Vec<PeerStats> {
        &self.0 .0
    }
}

impl AsRef<[PeerStats]> for PeerStatList {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[PeerStats] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[PeerStats] {
        self.0 .0
    }
}

/// TopologyResponseBodyV0 is an XDR Struct defines as:
///
/// ```text
/// struct TopologyResponseBodyV0
/// {
///     PeerStatList inboundPeers;
///     PeerStatList outboundPeers;
///
///     uint32 totalInboundPeerCount;
///     uint32 totalOutboundPeerCount;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TopologyResponseBodyV0 {
    pub inbound_peers: PeerStatList,
    pub outbound_peers: PeerStatList,
    pub total_inbound_peer_count: u32,
    pub total_outbound_peer_count: u32,
}

impl ReadXdr for TopologyResponseBodyV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                inbound_peers: PeerStatList::read_xdr(r)?,
                outbound_peers: PeerStatList::read_xdr(r)?,
                total_inbound_peer_count: u32::read_xdr(r)?,
                total_outbound_peer_count: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TopologyResponseBodyV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.inbound_peers.write_xdr(w)?;
            self.outbound_peers.write_xdr(w)?;
            self.total_inbound_peer_count.write_xdr(w)?;
            self.total_outbound_peer_count.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TopologyResponseBodyV1 is an XDR Struct defines as:
///
/// ```text
/// struct TopologyResponseBodyV1
/// {
///     PeerStatList inboundPeers;
///     PeerStatList outboundPeers;
///
///     uint32 totalInboundPeerCount;
///     uint32 totalOutboundPeerCount;
///
///     uint32 maxInboundPeerCount;
///     uint32 maxOutboundPeerCount;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TopologyResponseBodyV1 {
    pub inbound_peers: PeerStatList,
    pub outbound_peers: PeerStatList,
    pub total_inbound_peer_count: u32,
    pub total_outbound_peer_count: u32,
    pub max_inbound_peer_count: u32,
    pub max_outbound_peer_count: u32,
}

impl ReadXdr for TopologyResponseBodyV1 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                inbound_peers: PeerStatList::read_xdr(r)?,
                outbound_peers: PeerStatList::read_xdr(r)?,
                total_inbound_peer_count: u32::read_xdr(r)?,
                total_outbound_peer_count: u32::read_xdr(r)?,
                max_inbound_peer_count: u32::read_xdr(r)?,
                max_outbound_peer_count: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TopologyResponseBodyV1 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.inbound_peers.write_xdr(w)?;
            self.outbound_peers.write_xdr(w)?;
            self.total_inbound_peer_count.write_xdr(w)?;
            self.total_outbound_peer_count.write_xdr(w)?;
            self.max_inbound_peer_count.write_xdr(w)?;
            self.max_outbound_peer_count.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SurveyResponseBody is an XDR Union defines as:
///
/// ```text
/// union SurveyResponseBody switch (SurveyMessageResponseType type)
/// {
/// case SURVEY_TOPOLOGY_RESPONSE_V0:
///     TopologyResponseBodyV0 topologyResponseBodyV0;
/// case SURVEY_TOPOLOGY_RESPONSE_V1:
///     TopologyResponseBodyV1 topologyResponseBodyV1;
/// };
/// ```
///
// union with discriminant SurveyMessageResponseType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum SurveyResponseBody {
    V0(TopologyResponseBodyV0),
    V1(TopologyResponseBodyV1),
}

impl SurveyResponseBody {
    pub const VARIANTS: [SurveyMessageResponseType; 2] =
        [SurveyMessageResponseType::V0, SurveyMessageResponseType::V1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SurveyMessageResponseType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => SurveyMessageResponseType::V0,
            Self::V1(_) => SurveyMessageResponseType::V1,
        }
    }

    #[must_use]
    pub const fn variants() -> [SurveyMessageResponseType; 2] {
        Self::VARIANTS
    }
}

impl Name for SurveyResponseBody {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SurveyMessageResponseType> for SurveyResponseBody {
    #[must_use]
    fn discriminant(&self) -> SurveyMessageResponseType {
        Self::discriminant(self)
    }
}

impl Variants<SurveyMessageResponseType> for SurveyResponseBody {
    fn variants() -> slice::Iter<'static, SurveyMessageResponseType> {
        Self::VARIANTS.iter()
    }
}

impl Union<SurveyMessageResponseType> for SurveyResponseBody {}

impl ReadXdr for SurveyResponseBody {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: SurveyMessageResponseType =
                <SurveyMessageResponseType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                SurveyMessageResponseType::V0 => Self::V0(TopologyResponseBodyV0::read_xdr(r)?),
                SurveyMessageResponseType::V1 => Self::V1(TopologyResponseBodyV1::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SurveyResponseBody {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TxAdvertVectorMaxSize is an XDR Const defines as:
///
/// ```text
/// const TX_ADVERT_VECTOR_MAX_SIZE = 1000;
/// ```
///
pub const TX_ADVERT_VECTOR_MAX_SIZE: u64 = 1000;

/// TxAdvertVector is an XDR Typedef defines as:
///
/// ```text
/// typedef Hash TxAdvertVector<TX_ADVERT_VECTOR_MAX_SIZE>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct TxAdvertVector(pub VecM<Hash, 1000>);

impl From<TxAdvertVector> for VecM<Hash, 1000> {
    #[must_use]
    fn from(x: TxAdvertVector) -> Self {
        x.0
    }
}

impl From<VecM<Hash, 1000>> for TxAdvertVector {
    #[must_use]
    fn from(x: VecM<Hash, 1000>) -> Self {
        TxAdvertVector(x)
    }
}

impl AsRef<VecM<Hash, 1000>> for TxAdvertVector {
    #[must_use]
    fn as_ref(&self) -> &VecM<Hash, 1000> {
        &self.0
    }
}

impl ReadXdr for TxAdvertVector {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = VecM::<Hash, 1000>::read_xdr(r)?;
            let v = TxAdvertVector(i);
            Ok(v)
        })
    }
}

impl WriteXdr for TxAdvertVector {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for TxAdvertVector {
    type Target = VecM<Hash, 1000>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<TxAdvertVector> for Vec<Hash> {
    #[must_use]
    fn from(x: TxAdvertVector) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<Hash>> for TxAdvertVector {
    type Error = Error;
    fn try_from(x: Vec<Hash>) -> Result<Self> {
        Ok(TxAdvertVector(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<Hash>> for TxAdvertVector {
    type Error = Error;
    fn try_from(x: &Vec<Hash>) -> Result<Self> {
        Ok(TxAdvertVector(x.try_into()?))
    }
}

impl AsRef<Vec<Hash>> for TxAdvertVector {
    #[must_use]
    fn as_ref(&self) -> &Vec<Hash> {
        &self.0 .0
    }
}

impl AsRef<[Hash]> for TxAdvertVector {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[Hash] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[Hash] {
        self.0 .0
    }
}

/// FloodAdvert is an XDR Struct defines as:
///
/// ```text
/// struct FloodAdvert
/// {
///     TxAdvertVector txHashes;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct FloodAdvert {
    pub tx_hashes: TxAdvertVector,
}

impl ReadXdr for FloodAdvert {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_hashes: TxAdvertVector::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for FloodAdvert {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.tx_hashes.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TxDemandVectorMaxSize is an XDR Const defines as:
///
/// ```text
/// const TX_DEMAND_VECTOR_MAX_SIZE = 1000;
/// ```
///
pub const TX_DEMAND_VECTOR_MAX_SIZE: u64 = 1000;

/// TxDemandVector is an XDR Typedef defines as:
///
/// ```text
/// typedef Hash TxDemandVector<TX_DEMAND_VECTOR_MAX_SIZE>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct TxDemandVector(pub VecM<Hash, 1000>);

impl From<TxDemandVector> for VecM<Hash, 1000> {
    #[must_use]
    fn from(x: TxDemandVector) -> Self {
        x.0
    }
}

impl From<VecM<Hash, 1000>> for TxDemandVector {
    #[must_use]
    fn from(x: VecM<Hash, 1000>) -> Self {
        TxDemandVector(x)
    }
}

impl AsRef<VecM<Hash, 1000>> for TxDemandVector {
    #[must_use]
    fn as_ref(&self) -> &VecM<Hash, 1000> {
        &self.0
    }
}

impl ReadXdr for TxDemandVector {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = VecM::<Hash, 1000>::read_xdr(r)?;
            let v = TxDemandVector(i);
            Ok(v)
        })
    }
}

impl WriteXdr for TxDemandVector {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for TxDemandVector {
    type Target = VecM<Hash, 1000>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<TxDemandVector> for Vec<Hash> {
    #[must_use]
    fn from(x: TxDemandVector) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<Hash>> for TxDemandVector {
    type Error = Error;
    fn try_from(x: Vec<Hash>) -> Result<Self> {
        Ok(TxDemandVector(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<Hash>> for TxDemandVector {
    type Error = Error;
    fn try_from(x: &Vec<Hash>) -> Result<Self> {
        Ok(TxDemandVector(x.try_into()?))
    }
}

impl AsRef<Vec<Hash>> for TxDemandVector {
    #[must_use]
    fn as_ref(&self) -> &Vec<Hash> {
        &self.0 .0
    }
}

impl AsRef<[Hash]> for TxDemandVector {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[Hash] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[Hash] {
        self.0 .0
    }
}

/// FloodDemand is an XDR Struct defines as:
///
/// ```text
/// struct FloodDemand
/// {
///     TxDemandVector txHashes;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct FloodDemand {
    pub tx_hashes: TxDemandVector,
}

impl ReadXdr for FloodDemand {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx_hashes: TxDemandVector::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for FloodDemand {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.tx_hashes.write_xdr(w)?;
            Ok(())
        })
    }
}

/// StellarMessage is an XDR Union defines as:
///
/// ```text
/// union StellarMessage switch (MessageType type)
/// {
/// case ERROR_MSG:
///     Error error;
/// case HELLO:
///     Hello hello;
/// case AUTH:
///     Auth auth;
/// case DONT_HAVE:
///     DontHave dontHave;
/// case GET_PEERS:
///     void;
/// case PEERS:
///     PeerAddress peers<100>;
///
/// case GET_TX_SET:
///     uint256 txSetHash;
/// case TX_SET:
///     TransactionSet txSet;
/// case GENERALIZED_TX_SET:
///     GeneralizedTransactionSet generalizedTxSet;
///
/// case TRANSACTION:
///     TransactionEnvelope transaction;
///
/// case SURVEY_REQUEST:
///     SignedSurveyRequestMessage signedSurveyRequestMessage;
///
/// case SURVEY_RESPONSE:
///     SignedSurveyResponseMessage signedSurveyResponseMessage;
///
/// // SCP
/// case GET_SCP_QUORUMSET:
///     uint256 qSetHash;
/// case SCP_QUORUMSET:
///     SCPQuorumSet qSet;
/// case SCP_MESSAGE:
///     SCPEnvelope envelope;
/// case GET_SCP_STATE:
///     uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest
/// case SEND_MORE:
///     SendMore sendMoreMessage;
/// case SEND_MORE_EXTENDED:
///     SendMoreExtended sendMoreExtendedMessage;
/// // Pull mode
/// case FLOOD_ADVERT:
///      FloodAdvert floodAdvert;
/// case FLOOD_DEMAND:
///      FloodDemand floodDemand;
/// };
/// ```
///
// union with discriminant MessageType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum StellarMessage {
    ErrorMsg(SError),
    Hello(Hello),
    Auth(Auth),
    DontHave(DontHave),
    GetPeers,
    Peers(VecM<PeerAddress, 100>),
    GetTxSet(Uint256),
    TxSet(TransactionSet),
    GeneralizedTxSet(GeneralizedTransactionSet),
    Transaction(TransactionEnvelope),
    SurveyRequest(SignedSurveyRequestMessage),
    SurveyResponse(SignedSurveyResponseMessage),
    GetScpQuorumset(Uint256),
    ScpQuorumset(ScpQuorumSet),
    ScpMessage(ScpEnvelope),
    GetScpState(u32),
    SendMore(SendMore),
    SendMoreExtended(SendMoreExtended),
    FloodAdvert(FloodAdvert),
    FloodDemand(FloodDemand),
}

impl StellarMessage {
    pub const VARIANTS: [MessageType; 20] = [
        MessageType::ErrorMsg,
        MessageType::Hello,
        MessageType::Auth,
        MessageType::DontHave,
        MessageType::GetPeers,
        MessageType::Peers,
        MessageType::GetTxSet,
        MessageType::TxSet,
        MessageType::GeneralizedTxSet,
        MessageType::Transaction,
        MessageType::SurveyRequest,
        MessageType::SurveyResponse,
        MessageType::GetScpQuorumset,
        MessageType::ScpQuorumset,
        MessageType::ScpMessage,
        MessageType::GetScpState,
        MessageType::SendMore,
        MessageType::SendMoreExtended,
        MessageType::FloodAdvert,
        MessageType::FloodDemand,
    ];
    pub const VARIANTS_STR: [&'static str; 20] = [
        "ErrorMsg",
        "Hello",
        "Auth",
        "DontHave",
        "GetPeers",
        "Peers",
        "GetTxSet",
        "TxSet",
        "GeneralizedTxSet",
        "Transaction",
        "SurveyRequest",
        "SurveyResponse",
        "GetScpQuorumset",
        "ScpQuorumset",
        "ScpMessage",
        "GetScpState",
        "SendMore",
        "SendMoreExtended",
        "FloodAdvert",
        "FloodDemand",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ErrorMsg(_) => "ErrorMsg",
            Self::Hello(_) => "Hello",
            Self::Auth(_) => "Auth",
            Self::DontHave(_) => "DontHave",
            Self::GetPeers => "GetPeers",
            Self::Peers(_) => "Peers",
            Self::GetTxSet(_) => "GetTxSet",
            Self::TxSet(_) => "TxSet",
            Self::GeneralizedTxSet(_) => "GeneralizedTxSet",
            Self::Transaction(_) => "Transaction",
            Self::SurveyRequest(_) => "SurveyRequest",
            Self::SurveyResponse(_) => "SurveyResponse",
            Self::GetScpQuorumset(_) => "GetScpQuorumset",
            Self::ScpQuorumset(_) => "ScpQuorumset",
            Self::ScpMessage(_) => "ScpMessage",
            Self::GetScpState(_) => "GetScpState",
            Self::SendMore(_) => "SendMore",
            Self::SendMoreExtended(_) => "SendMoreExtended",
            Self::FloodAdvert(_) => "FloodAdvert",
            Self::FloodDemand(_) => "FloodDemand",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> MessageType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ErrorMsg(_) => MessageType::ErrorMsg,
            Self::Hello(_) => MessageType::Hello,
            Self::Auth(_) => MessageType::Auth,
            Self::DontHave(_) => MessageType::DontHave,
            Self::GetPeers => MessageType::GetPeers,
            Self::Peers(_) => MessageType::Peers,
            Self::GetTxSet(_) => MessageType::GetTxSet,
            Self::TxSet(_) => MessageType::TxSet,
            Self::GeneralizedTxSet(_) => MessageType::GeneralizedTxSet,
            Self::Transaction(_) => MessageType::Transaction,
            Self::SurveyRequest(_) => MessageType::SurveyRequest,
            Self::SurveyResponse(_) => MessageType::SurveyResponse,
            Self::GetScpQuorumset(_) => MessageType::GetScpQuorumset,
            Self::ScpQuorumset(_) => MessageType::ScpQuorumset,
            Self::ScpMessage(_) => MessageType::ScpMessage,
            Self::GetScpState(_) => MessageType::GetScpState,
            Self::SendMore(_) => MessageType::SendMore,
            Self::SendMoreExtended(_) => MessageType::SendMoreExtended,
            Self::FloodAdvert(_) => MessageType::FloodAdvert,
            Self::FloodDemand(_) => MessageType::FloodDemand,
        }
    }

    #[must_use]
    pub const fn variants() -> [MessageType; 20] {
        Self::VARIANTS
    }
}

impl Name for StellarMessage {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<MessageType> for StellarMessage {
    #[must_use]
    fn discriminant(&self) -> MessageType {
        Self::discriminant(self)
    }
}

impl Variants<MessageType> for StellarMessage {
    fn variants() -> slice::Iter<'static, MessageType> {
        Self::VARIANTS.iter()
    }
}

impl Union<MessageType> for StellarMessage {}

impl ReadXdr for StellarMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: MessageType = <MessageType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                MessageType::ErrorMsg => Self::ErrorMsg(SError::read_xdr(r)?),
                MessageType::Hello => Self::Hello(Hello::read_xdr(r)?),
                MessageType::Auth => Self::Auth(Auth::read_xdr(r)?),
                MessageType::DontHave => Self::DontHave(DontHave::read_xdr(r)?),
                MessageType::GetPeers => Self::GetPeers,
                MessageType::Peers => Self::Peers(VecM::<PeerAddress, 100>::read_xdr(r)?),
                MessageType::GetTxSet => Self::GetTxSet(Uint256::read_xdr(r)?),
                MessageType::TxSet => Self::TxSet(TransactionSet::read_xdr(r)?),
                MessageType::GeneralizedTxSet => {
                    Self::GeneralizedTxSet(GeneralizedTransactionSet::read_xdr(r)?)
                }
                MessageType::Transaction => Self::Transaction(TransactionEnvelope::read_xdr(r)?),
                MessageType::SurveyRequest => {
                    Self::SurveyRequest(SignedSurveyRequestMessage::read_xdr(r)?)
                }
                MessageType::SurveyResponse => {
                    Self::SurveyResponse(SignedSurveyResponseMessage::read_xdr(r)?)
                }
                MessageType::GetScpQuorumset => Self::GetScpQuorumset(Uint256::read_xdr(r)?),
                MessageType::ScpQuorumset => Self::ScpQuorumset(ScpQuorumSet::read_xdr(r)?),
                MessageType::ScpMessage => Self::ScpMessage(ScpEnvelope::read_xdr(r)?),
                MessageType::GetScpState => Self::GetScpState(u32::read_xdr(r)?),
                MessageType::SendMore => Self::SendMore(SendMore::read_xdr(r)?),
                MessageType::SendMoreExtended => {
                    Self::SendMoreExtended(SendMoreExtended::read_xdr(r)?)
                }
                MessageType::FloodAdvert => Self::FloodAdvert(FloodAdvert::read_xdr(r)?),
                MessageType::FloodDemand => Self::FloodDemand(FloodDemand::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for StellarMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ErrorMsg(v) => v.write_xdr(w)?,
                Self::Hello(v) => v.write_xdr(w)?,
                Self::Auth(v) => v.write_xdr(w)?,
                Self::DontHave(v) => v.write_xdr(w)?,
                Self::GetPeers => ().write_xdr(w)?,
                Self::Peers(v) => v.write_xdr(w)?,
                Self::GetTxSet(v) => v.write_xdr(w)?,
                Self::TxSet(v) => v.write_xdr(w)?,
                Self::GeneralizedTxSet(v) => v.write_xdr(w)?,
                Self::Transaction(v) => v.write_xdr(w)?,
                Self::SurveyRequest(v) => v.write_xdr(w)?,
                Self::SurveyResponse(v) => v.write_xdr(w)?,
                Self::GetScpQuorumset(v) => v.write_xdr(w)?,
                Self::ScpQuorumset(v) => v.write_xdr(w)?,
                Self::ScpMessage(v) => v.write_xdr(w)?,
                Self::GetScpState(v) => v.write_xdr(w)?,
                Self::SendMore(v) => v.write_xdr(w)?,
                Self::SendMoreExtended(v) => v.write_xdr(w)?,
                Self::FloodAdvert(v) => v.write_xdr(w)?,
                Self::FloodDemand(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AuthenticatedMessageV0 is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         uint64 sequence;
///         StellarMessage message;
///         HmacSha256Mac mac;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct AuthenticatedMessageV0 {
    pub sequence: u64,
    pub message: StellarMessage,
    pub mac: HmacSha256Mac,
}

impl ReadXdr for AuthenticatedMessageV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                sequence: u64::read_xdr(r)?,
                message: StellarMessage::read_xdr(r)?,
                mac: HmacSha256Mac::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AuthenticatedMessageV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.sequence.write_xdr(w)?;
            self.message.write_xdr(w)?;
            self.mac.write_xdr(w)?;
            Ok(())
        })
    }
}

/// AuthenticatedMessage is an XDR Union defines as:
///
/// ```text
/// union AuthenticatedMessage switch (uint32 v)
/// {
/// case 0:
///     struct
///     {
///         uint64 sequence;
///         StellarMessage message;
///         HmacSha256Mac mac;
///     } v0;
/// };
/// ```
///
// union with discriminant u32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum AuthenticatedMessage {
    V0(AuthenticatedMessageV0),
}

impl AuthenticatedMessage {
    pub const VARIANTS: [u32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> u32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [u32; 1] {
        Self::VARIANTS
    }
}

impl Name for AuthenticatedMessage {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<u32> for AuthenticatedMessage {
    #[must_use]
    fn discriminant(&self) -> u32 {
        Self::discriminant(self)
    }
}

impl Variants<u32> for AuthenticatedMessage {
    fn variants() -> slice::Iter<'static, u32> {
        Self::VARIANTS.iter()
    }
}

impl Union<u32> for AuthenticatedMessage {}

impl ReadXdr for AuthenticatedMessage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: u32 = <u32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0(AuthenticatedMessageV0::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AuthenticatedMessage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// MaxOpsPerTx is an XDR Const defines as:
///
/// ```text
/// const MAX_OPS_PER_TX = 100;
/// ```
///
pub const MAX_OPS_PER_TX: u64 = 100;

/// LiquidityPoolParameters is an XDR Union defines as:
///
/// ```text
/// union LiquidityPoolParameters switch (LiquidityPoolType type)
/// {
/// case LIQUIDITY_POOL_CONSTANT_PRODUCT:
///     LiquidityPoolConstantProductParameters constantProduct;
/// };
/// ```
///
// union with discriminant LiquidityPoolType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LiquidityPoolParameters {
    LiquidityPoolConstantProduct(LiquidityPoolConstantProductParameters),
}

impl LiquidityPoolParameters {
    pub const VARIANTS: [LiquidityPoolType; 1] = [LiquidityPoolType::LiquidityPoolConstantProduct];
    pub const VARIANTS_STR: [&'static str; 1] = ["LiquidityPoolConstantProduct"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LiquidityPoolConstantProduct(_) => "LiquidityPoolConstantProduct",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LiquidityPoolType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::LiquidityPoolConstantProduct(_) => {
                LiquidityPoolType::LiquidityPoolConstantProduct
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolType; 1] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolParameters {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LiquidityPoolType> for LiquidityPoolParameters {
    #[must_use]
    fn discriminant(&self) -> LiquidityPoolType {
        Self::discriminant(self)
    }
}

impl Variants<LiquidityPoolType> for LiquidityPoolParameters {
    fn variants() -> slice::Iter<'static, LiquidityPoolType> {
        Self::VARIANTS.iter()
    }
}

impl Union<LiquidityPoolType> for LiquidityPoolParameters {}

impl ReadXdr for LiquidityPoolParameters {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: LiquidityPoolType = <LiquidityPoolType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LiquidityPoolType::LiquidityPoolConstantProduct => {
                    Self::LiquidityPoolConstantProduct(
                        LiquidityPoolConstantProductParameters::read_xdr(r)?,
                    )
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolParameters {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::LiquidityPoolConstantProduct(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// MuxedAccountMed25519 is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         uint64 id;
///         uint256 ed25519;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
pub struct MuxedAccountMed25519 {
    pub id: u64,
    pub ed25519: Uint256,
}

impl ReadXdr for MuxedAccountMed25519 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                id: u64::read_xdr(r)?,
                ed25519: Uint256::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for MuxedAccountMed25519 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.id.write_xdr(w)?;
            self.ed25519.write_xdr(w)?;
            Ok(())
        })
    }
}

/// MuxedAccount is an XDR Union defines as:
///
/// ```text
/// union MuxedAccount switch (CryptoKeyType type)
/// {
/// case KEY_TYPE_ED25519:
///     uint256 ed25519;
/// case KEY_TYPE_MUXED_ED25519:
///     struct
///     {
///         uint64 id;
///         uint256 ed25519;
///     } med25519;
/// };
/// ```
///
// union with discriminant CryptoKeyType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[allow(clippy::large_enum_variant)]
pub enum MuxedAccount {
    Ed25519(Uint256),
    MuxedEd25519(MuxedAccountMed25519),
}

impl MuxedAccount {
    pub const VARIANTS: [CryptoKeyType; 2] = [CryptoKeyType::Ed25519, CryptoKeyType::MuxedEd25519];
    pub const VARIANTS_STR: [&'static str; 2] = ["Ed25519", "MuxedEd25519"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Ed25519(_) => "Ed25519",
            Self::MuxedEd25519(_) => "MuxedEd25519",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> CryptoKeyType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Ed25519(_) => CryptoKeyType::Ed25519,
            Self::MuxedEd25519(_) => CryptoKeyType::MuxedEd25519,
        }
    }

    #[must_use]
    pub const fn variants() -> [CryptoKeyType; 2] {
        Self::VARIANTS
    }
}

impl Name for MuxedAccount {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<CryptoKeyType> for MuxedAccount {
    #[must_use]
    fn discriminant(&self) -> CryptoKeyType {
        Self::discriminant(self)
    }
}

impl Variants<CryptoKeyType> for MuxedAccount {
    fn variants() -> slice::Iter<'static, CryptoKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Union<CryptoKeyType> for MuxedAccount {}

impl ReadXdr for MuxedAccount {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: CryptoKeyType = <CryptoKeyType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                CryptoKeyType::Ed25519 => Self::Ed25519(Uint256::read_xdr(r)?),
                CryptoKeyType::MuxedEd25519 => {
                    Self::MuxedEd25519(MuxedAccountMed25519::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for MuxedAccount {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Ed25519(v) => v.write_xdr(w)?,
                Self::MuxedEd25519(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// DecoratedSignature is an XDR Struct defines as:
///
/// ```text
/// struct DecoratedSignature
/// {
///     SignatureHint hint;  // last 4 bytes of the public key, used as a hint
///     Signature signature; // actual signature
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct DecoratedSignature {
    pub hint: SignatureHint,
    pub signature: Signature,
}

impl ReadXdr for DecoratedSignature {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                hint: SignatureHint::read_xdr(r)?,
                signature: Signature::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for DecoratedSignature {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.hint.write_xdr(w)?;
            self.signature.write_xdr(w)?;
            Ok(())
        })
    }
}

/// OperationType is an XDR Enum defines as:
///
/// ```text
/// enum OperationType
/// {
///     CREATE_ACCOUNT = 0,
///     PAYMENT = 1,
///     PATH_PAYMENT_STRICT_RECEIVE = 2,
///     MANAGE_SELL_OFFER = 3,
///     CREATE_PASSIVE_SELL_OFFER = 4,
///     SET_OPTIONS = 5,
///     CHANGE_TRUST = 6,
///     ALLOW_TRUST = 7,
///     ACCOUNT_MERGE = 8,
///     INFLATION = 9,
///     MANAGE_DATA = 10,
///     BUMP_SEQUENCE = 11,
///     MANAGE_BUY_OFFER = 12,
///     PATH_PAYMENT_STRICT_SEND = 13,
///     CREATE_CLAIMABLE_BALANCE = 14,
///     CLAIM_CLAIMABLE_BALANCE = 15,
///     BEGIN_SPONSORING_FUTURE_RESERVES = 16,
///     END_SPONSORING_FUTURE_RESERVES = 17,
///     REVOKE_SPONSORSHIP = 18,
///     CLAWBACK = 19,
///     CLAWBACK_CLAIMABLE_BALANCE = 20,
///     SET_TRUST_LINE_FLAGS = 21,
///     LIQUIDITY_POOL_DEPOSIT = 22,
///     LIQUIDITY_POOL_WITHDRAW = 23,
///     INVOKE_HOST_FUNCTION = 24,
///     EXTEND_FOOTPRINT_TTL = 25,
///     RESTORE_FOOTPRINT = 26
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum OperationType {
    CreateAccount = 0,
    Payment = 1,
    PathPaymentStrictReceive = 2,
    ManageSellOffer = 3,
    CreatePassiveSellOffer = 4,
    SetOptions = 5,
    ChangeTrust = 6,
    AllowTrust = 7,
    AccountMerge = 8,
    Inflation = 9,
    ManageData = 10,
    BumpSequence = 11,
    ManageBuyOffer = 12,
    PathPaymentStrictSend = 13,
    CreateClaimableBalance = 14,
    ClaimClaimableBalance = 15,
    BeginSponsoringFutureReserves = 16,
    EndSponsoringFutureReserves = 17,
    RevokeSponsorship = 18,
    Clawback = 19,
    ClawbackClaimableBalance = 20,
    SetTrustLineFlags = 21,
    LiquidityPoolDeposit = 22,
    LiquidityPoolWithdraw = 23,
    InvokeHostFunction = 24,
    ExtendFootprintTtl = 25,
    RestoreFootprint = 26,
}

impl OperationType {
    pub const VARIANTS: [OperationType; 27] = [
        OperationType::CreateAccount,
        OperationType::Payment,
        OperationType::PathPaymentStrictReceive,
        OperationType::ManageSellOffer,
        OperationType::CreatePassiveSellOffer,
        OperationType::SetOptions,
        OperationType::ChangeTrust,
        OperationType::AllowTrust,
        OperationType::AccountMerge,
        OperationType::Inflation,
        OperationType::ManageData,
        OperationType::BumpSequence,
        OperationType::ManageBuyOffer,
        OperationType::PathPaymentStrictSend,
        OperationType::CreateClaimableBalance,
        OperationType::ClaimClaimableBalance,
        OperationType::BeginSponsoringFutureReserves,
        OperationType::EndSponsoringFutureReserves,
        OperationType::RevokeSponsorship,
        OperationType::Clawback,
        OperationType::ClawbackClaimableBalance,
        OperationType::SetTrustLineFlags,
        OperationType::LiquidityPoolDeposit,
        OperationType::LiquidityPoolWithdraw,
        OperationType::InvokeHostFunction,
        OperationType::ExtendFootprintTtl,
        OperationType::RestoreFootprint,
    ];
    pub const VARIANTS_STR: [&'static str; 27] = [
        "CreateAccount",
        "Payment",
        "PathPaymentStrictReceive",
        "ManageSellOffer",
        "CreatePassiveSellOffer",
        "SetOptions",
        "ChangeTrust",
        "AllowTrust",
        "AccountMerge",
        "Inflation",
        "ManageData",
        "BumpSequence",
        "ManageBuyOffer",
        "PathPaymentStrictSend",
        "CreateClaimableBalance",
        "ClaimClaimableBalance",
        "BeginSponsoringFutureReserves",
        "EndSponsoringFutureReserves",
        "RevokeSponsorship",
        "Clawback",
        "ClawbackClaimableBalance",
        "SetTrustLineFlags",
        "LiquidityPoolDeposit",
        "LiquidityPoolWithdraw",
        "InvokeHostFunction",
        "ExtendFootprintTtl",
        "RestoreFootprint",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::CreateAccount => "CreateAccount",
            Self::Payment => "Payment",
            Self::PathPaymentStrictReceive => "PathPaymentStrictReceive",
            Self::ManageSellOffer => "ManageSellOffer",
            Self::CreatePassiveSellOffer => "CreatePassiveSellOffer",
            Self::SetOptions => "SetOptions",
            Self::ChangeTrust => "ChangeTrust",
            Self::AllowTrust => "AllowTrust",
            Self::AccountMerge => "AccountMerge",
            Self::Inflation => "Inflation",
            Self::ManageData => "ManageData",
            Self::BumpSequence => "BumpSequence",
            Self::ManageBuyOffer => "ManageBuyOffer",
            Self::PathPaymentStrictSend => "PathPaymentStrictSend",
            Self::CreateClaimableBalance => "CreateClaimableBalance",
            Self::ClaimClaimableBalance => "ClaimClaimableBalance",
            Self::BeginSponsoringFutureReserves => "BeginSponsoringFutureReserves",
            Self::EndSponsoringFutureReserves => "EndSponsoringFutureReserves",
            Self::RevokeSponsorship => "RevokeSponsorship",
            Self::Clawback => "Clawback",
            Self::ClawbackClaimableBalance => "ClawbackClaimableBalance",
            Self::SetTrustLineFlags => "SetTrustLineFlags",
            Self::LiquidityPoolDeposit => "LiquidityPoolDeposit",
            Self::LiquidityPoolWithdraw => "LiquidityPoolWithdraw",
            Self::InvokeHostFunction => "InvokeHostFunction",
            Self::ExtendFootprintTtl => "ExtendFootprintTtl",
            Self::RestoreFootprint => "RestoreFootprint",
        }
    }

    #[must_use]
    pub const fn variants() -> [OperationType; 27] {
        Self::VARIANTS
    }
}

impl Name for OperationType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<OperationType> for OperationType {
    fn variants() -> slice::Iter<'static, OperationType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for OperationType {}

impl fmt::Display for OperationType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for OperationType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => OperationType::CreateAccount,
            1 => OperationType::Payment,
            2 => OperationType::PathPaymentStrictReceive,
            3 => OperationType::ManageSellOffer,
            4 => OperationType::CreatePassiveSellOffer,
            5 => OperationType::SetOptions,
            6 => OperationType::ChangeTrust,
            7 => OperationType::AllowTrust,
            8 => OperationType::AccountMerge,
            9 => OperationType::Inflation,
            10 => OperationType::ManageData,
            11 => OperationType::BumpSequence,
            12 => OperationType::ManageBuyOffer,
            13 => OperationType::PathPaymentStrictSend,
            14 => OperationType::CreateClaimableBalance,
            15 => OperationType::ClaimClaimableBalance,
            16 => OperationType::BeginSponsoringFutureReserves,
            17 => OperationType::EndSponsoringFutureReserves,
            18 => OperationType::RevokeSponsorship,
            19 => OperationType::Clawback,
            20 => OperationType::ClawbackClaimableBalance,
            21 => OperationType::SetTrustLineFlags,
            22 => OperationType::LiquidityPoolDeposit,
            23 => OperationType::LiquidityPoolWithdraw,
            24 => OperationType::InvokeHostFunction,
            25 => OperationType::ExtendFootprintTtl,
            26 => OperationType::RestoreFootprint,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<OperationType> for i32 {
    #[must_use]
    fn from(e: OperationType) -> Self {
        e as Self
    }
}

impl ReadXdr for OperationType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for OperationType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// CreateAccountOp is an XDR Struct defines as:
///
/// ```text
/// struct CreateAccountOp
/// {
///     AccountID destination; // account to create
///     int64 startingBalance; // amount they end up with
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct CreateAccountOp {
    pub destination: AccountId,
    pub starting_balance: i64,
}

impl ReadXdr for CreateAccountOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                destination: AccountId::read_xdr(r)?,
                starting_balance: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for CreateAccountOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.destination.write_xdr(w)?;
            self.starting_balance.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PaymentOp is an XDR Struct defines as:
///
/// ```text
/// struct PaymentOp
/// {
///     MuxedAccount destination; // recipient of the payment
///     Asset asset;              // what they end up with
///     int64 amount;             // amount they end up with
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct PaymentOp {
    pub destination: MuxedAccount,
    pub asset: Asset,
    pub amount: i64,
}

impl ReadXdr for PaymentOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                destination: MuxedAccount::read_xdr(r)?,
                asset: Asset::read_xdr(r)?,
                amount: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PaymentOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.destination.write_xdr(w)?;
            self.asset.write_xdr(w)?;
            self.amount.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PathPaymentStrictReceiveOp is an XDR Struct defines as:
///
/// ```text
/// struct PathPaymentStrictReceiveOp
/// {
///     Asset sendAsset; // asset we pay with
///     int64 sendMax;   // the maximum amount of sendAsset to
///                      // send (excluding fees).
///                      // The operation will fail if can't be met
///
///     MuxedAccount destination; // recipient of the payment
///     Asset destAsset;          // what they end up with
///     int64 destAmount;         // amount they end up with
///
///     Asset path<5>; // additional hops it must go through to get there
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct PathPaymentStrictReceiveOp {
    pub send_asset: Asset,
    pub send_max: i64,
    pub destination: MuxedAccount,
    pub dest_asset: Asset,
    pub dest_amount: i64,
    pub path: VecM<Asset, 5>,
}

impl ReadXdr for PathPaymentStrictReceiveOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                send_asset: Asset::read_xdr(r)?,
                send_max: i64::read_xdr(r)?,
                destination: MuxedAccount::read_xdr(r)?,
                dest_asset: Asset::read_xdr(r)?,
                dest_amount: i64::read_xdr(r)?,
                path: VecM::<Asset, 5>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PathPaymentStrictReceiveOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.send_asset.write_xdr(w)?;
            self.send_max.write_xdr(w)?;
            self.destination.write_xdr(w)?;
            self.dest_asset.write_xdr(w)?;
            self.dest_amount.write_xdr(w)?;
            self.path.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PathPaymentStrictSendOp is an XDR Struct defines as:
///
/// ```text
/// struct PathPaymentStrictSendOp
/// {
///     Asset sendAsset;  // asset we pay with
///     int64 sendAmount; // amount of sendAsset to send (excluding fees)
///
///     MuxedAccount destination; // recipient of the payment
///     Asset destAsset;          // what they end up with
///     int64 destMin;            // the minimum amount of dest asset to
///                               // be received
///                               // The operation will fail if it can't be met
///
///     Asset path<5>; // additional hops it must go through to get there
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct PathPaymentStrictSendOp {
    pub send_asset: Asset,
    pub send_amount: i64,
    pub destination: MuxedAccount,
    pub dest_asset: Asset,
    pub dest_min: i64,
    pub path: VecM<Asset, 5>,
}

impl ReadXdr for PathPaymentStrictSendOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                send_asset: Asset::read_xdr(r)?,
                send_amount: i64::read_xdr(r)?,
                destination: MuxedAccount::read_xdr(r)?,
                dest_asset: Asset::read_xdr(r)?,
                dest_min: i64::read_xdr(r)?,
                path: VecM::<Asset, 5>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PathPaymentStrictSendOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.send_asset.write_xdr(w)?;
            self.send_amount.write_xdr(w)?;
            self.destination.write_xdr(w)?;
            self.dest_asset.write_xdr(w)?;
            self.dest_min.write_xdr(w)?;
            self.path.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ManageSellOfferOp is an XDR Struct defines as:
///
/// ```text
/// struct ManageSellOfferOp
/// {
///     Asset selling;
///     Asset buying;
///     int64 amount; // amount being sold. if set to 0, delete the offer
///     Price price;  // price of thing being sold in terms of what you are buying
///
///     // 0=create a new offer, otherwise edit an existing offer
///     int64 offerID;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ManageSellOfferOp {
    pub selling: Asset,
    pub buying: Asset,
    pub amount: i64,
    pub price: Price,
    pub offer_id: i64,
}

impl ReadXdr for ManageSellOfferOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                selling: Asset::read_xdr(r)?,
                buying: Asset::read_xdr(r)?,
                amount: i64::read_xdr(r)?,
                price: Price::read_xdr(r)?,
                offer_id: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ManageSellOfferOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.selling.write_xdr(w)?;
            self.buying.write_xdr(w)?;
            self.amount.write_xdr(w)?;
            self.price.write_xdr(w)?;
            self.offer_id.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ManageBuyOfferOp is an XDR Struct defines as:
///
/// ```text
/// struct ManageBuyOfferOp
/// {
///     Asset selling;
///     Asset buying;
///     int64 buyAmount; // amount being bought. if set to 0, delete the offer
///     Price price;     // price of thing being bought in terms of what you are
///                      // selling
///
///     // 0=create a new offer, otherwise edit an existing offer
///     int64 offerID;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ManageBuyOfferOp {
    pub selling: Asset,
    pub buying: Asset,
    pub buy_amount: i64,
    pub price: Price,
    pub offer_id: i64,
}

impl ReadXdr for ManageBuyOfferOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                selling: Asset::read_xdr(r)?,
                buying: Asset::read_xdr(r)?,
                buy_amount: i64::read_xdr(r)?,
                price: Price::read_xdr(r)?,
                offer_id: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ManageBuyOfferOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.selling.write_xdr(w)?;
            self.buying.write_xdr(w)?;
            self.buy_amount.write_xdr(w)?;
            self.price.write_xdr(w)?;
            self.offer_id.write_xdr(w)?;
            Ok(())
        })
    }
}

/// CreatePassiveSellOfferOp is an XDR Struct defines as:
///
/// ```text
/// struct CreatePassiveSellOfferOp
/// {
///     Asset selling; // A
///     Asset buying;  // B
///     int64 amount;  // amount taker gets
///     Price price;   // cost of A in terms of B
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct CreatePassiveSellOfferOp {
    pub selling: Asset,
    pub buying: Asset,
    pub amount: i64,
    pub price: Price,
}

impl ReadXdr for CreatePassiveSellOfferOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                selling: Asset::read_xdr(r)?,
                buying: Asset::read_xdr(r)?,
                amount: i64::read_xdr(r)?,
                price: Price::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for CreatePassiveSellOfferOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.selling.write_xdr(w)?;
            self.buying.write_xdr(w)?;
            self.amount.write_xdr(w)?;
            self.price.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SetOptionsOp is an XDR Struct defines as:
///
/// ```text
/// struct SetOptionsOp
/// {
///     AccountID* inflationDest; // sets the inflation destination
///
///     uint32* clearFlags; // which flags to clear
///     uint32* setFlags;   // which flags to set
///
///     // account threshold manipulation
///     uint32* masterWeight; // weight of the master account
///     uint32* lowThreshold;
///     uint32* medThreshold;
///     uint32* highThreshold;
///
///     string32* homeDomain; // sets the home domain
///
///     // Add, update or remove a signer for the account
///     // signer is deleted if the weight is 0
///     Signer* signer;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SetOptionsOp {
    pub inflation_dest: Option<AccountId>,
    pub clear_flags: Option<u32>,
    pub set_flags: Option<u32>,
    pub master_weight: Option<u32>,
    pub low_threshold: Option<u32>,
    pub med_threshold: Option<u32>,
    pub high_threshold: Option<u32>,
    pub home_domain: Option<String32>,
    pub signer: Option<Signer>,
}

impl ReadXdr for SetOptionsOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                inflation_dest: Option::<AccountId>::read_xdr(r)?,
                clear_flags: Option::<u32>::read_xdr(r)?,
                set_flags: Option::<u32>::read_xdr(r)?,
                master_weight: Option::<u32>::read_xdr(r)?,
                low_threshold: Option::<u32>::read_xdr(r)?,
                med_threshold: Option::<u32>::read_xdr(r)?,
                high_threshold: Option::<u32>::read_xdr(r)?,
                home_domain: Option::<String32>::read_xdr(r)?,
                signer: Option::<Signer>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SetOptionsOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.inflation_dest.write_xdr(w)?;
            self.clear_flags.write_xdr(w)?;
            self.set_flags.write_xdr(w)?;
            self.master_weight.write_xdr(w)?;
            self.low_threshold.write_xdr(w)?;
            self.med_threshold.write_xdr(w)?;
            self.high_threshold.write_xdr(w)?;
            self.home_domain.write_xdr(w)?;
            self.signer.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ChangeTrustAsset is an XDR Union defines as:
///
/// ```text
/// union ChangeTrustAsset switch (AssetType type)
/// {
/// case ASSET_TYPE_NATIVE: // Not credit
///     void;
///
/// case ASSET_TYPE_CREDIT_ALPHANUM4:
///     AlphaNum4 alphaNum4;
///
/// case ASSET_TYPE_CREDIT_ALPHANUM12:
///     AlphaNum12 alphaNum12;
///
/// case ASSET_TYPE_POOL_SHARE:
///     LiquidityPoolParameters liquidityPool;
///
///     // add other asset types here in the future
/// };
/// ```
///
// union with discriminant AssetType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ChangeTrustAsset {
    Native,
    CreditAlphanum4(AlphaNum4),
    CreditAlphanum12(AlphaNum12),
    PoolShare(LiquidityPoolParameters),
}

impl ChangeTrustAsset {
    pub const VARIANTS: [AssetType; 4] = [
        AssetType::Native,
        AssetType::CreditAlphanum4,
        AssetType::CreditAlphanum12,
        AssetType::PoolShare,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Native", "CreditAlphanum4", "CreditAlphanum12", "PoolShare"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Native => "Native",
            Self::CreditAlphanum4(_) => "CreditAlphanum4",
            Self::CreditAlphanum12(_) => "CreditAlphanum12",
            Self::PoolShare(_) => "PoolShare",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AssetType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Native => AssetType::Native,
            Self::CreditAlphanum4(_) => AssetType::CreditAlphanum4,
            Self::CreditAlphanum12(_) => AssetType::CreditAlphanum12,
            Self::PoolShare(_) => AssetType::PoolShare,
        }
    }

    #[must_use]
    pub const fn variants() -> [AssetType; 4] {
        Self::VARIANTS
    }
}

impl Name for ChangeTrustAsset {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AssetType> for ChangeTrustAsset {
    #[must_use]
    fn discriminant(&self) -> AssetType {
        Self::discriminant(self)
    }
}

impl Variants<AssetType> for ChangeTrustAsset {
    fn variants() -> slice::Iter<'static, AssetType> {
        Self::VARIANTS.iter()
    }
}

impl Union<AssetType> for ChangeTrustAsset {}

impl ReadXdr for ChangeTrustAsset {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: AssetType = <AssetType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AssetType::Native => Self::Native,
                AssetType::CreditAlphanum4 => Self::CreditAlphanum4(AlphaNum4::read_xdr(r)?),
                AssetType::CreditAlphanum12 => Self::CreditAlphanum12(AlphaNum12::read_xdr(r)?),
                AssetType::PoolShare => Self::PoolShare(LiquidityPoolParameters::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ChangeTrustAsset {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Native => ().write_xdr(w)?,
                Self::CreditAlphanum4(v) => v.write_xdr(w)?,
                Self::CreditAlphanum12(v) => v.write_xdr(w)?,
                Self::PoolShare(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ChangeTrustOp is an XDR Struct defines as:
///
/// ```text
/// struct ChangeTrustOp
/// {
///     ChangeTrustAsset line;
///
///     // if limit is set to 0, deletes the trust line
///     int64 limit;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ChangeTrustOp {
    pub line: ChangeTrustAsset,
    pub limit: i64,
}

impl ReadXdr for ChangeTrustOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                line: ChangeTrustAsset::read_xdr(r)?,
                limit: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ChangeTrustOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.line.write_xdr(w)?;
            self.limit.write_xdr(w)?;
            Ok(())
        })
    }
}

/// AllowTrustOp is an XDR Struct defines as:
///
/// ```text
/// struct AllowTrustOp
/// {
///     AccountID trustor;
///     AssetCode asset;
///
///     // One of 0, AUTHORIZED_FLAG, or AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG
///     uint32 authorize;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct AllowTrustOp {
    pub trustor: AccountId,
    pub asset: AssetCode,
    pub authorize: u32,
}

impl ReadXdr for AllowTrustOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                trustor: AccountId::read_xdr(r)?,
                asset: AssetCode::read_xdr(r)?,
                authorize: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for AllowTrustOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.trustor.write_xdr(w)?;
            self.asset.write_xdr(w)?;
            self.authorize.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ManageDataOp is an XDR Struct defines as:
///
/// ```text
/// struct ManageDataOp
/// {
///     string64 dataName;
///     DataValue* dataValue; // set to null to clear
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ManageDataOp {
    pub data_name: String64,
    pub data_value: Option<DataValue>,
}

impl ReadXdr for ManageDataOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                data_name: String64::read_xdr(r)?,
                data_value: Option::<DataValue>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ManageDataOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.data_name.write_xdr(w)?;
            self.data_value.write_xdr(w)?;
            Ok(())
        })
    }
}

/// BumpSequenceOp is an XDR Struct defines as:
///
/// ```text
/// struct BumpSequenceOp
/// {
///     SequenceNumber bumpTo;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct BumpSequenceOp {
    pub bump_to: SequenceNumber,
}

impl ReadXdr for BumpSequenceOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                bump_to: SequenceNumber::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for BumpSequenceOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.bump_to.write_xdr(w)?;
            Ok(())
        })
    }
}

/// CreateClaimableBalanceOp is an XDR Struct defines as:
///
/// ```text
/// struct CreateClaimableBalanceOp
/// {
///     Asset asset;
///     int64 amount;
///     Claimant claimants<10>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct CreateClaimableBalanceOp {
    pub asset: Asset,
    pub amount: i64,
    pub claimants: VecM<Claimant, 10>,
}

impl ReadXdr for CreateClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                asset: Asset::read_xdr(r)?,
                amount: i64::read_xdr(r)?,
                claimants: VecM::<Claimant, 10>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for CreateClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.asset.write_xdr(w)?;
            self.amount.write_xdr(w)?;
            self.claimants.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ClaimClaimableBalanceOp is an XDR Struct defines as:
///
/// ```text
/// struct ClaimClaimableBalanceOp
/// {
///     ClaimableBalanceID balanceID;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ClaimClaimableBalanceOp {
    pub balance_id: ClaimableBalanceId,
}

impl ReadXdr for ClaimClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                balance_id: ClaimableBalanceId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.balance_id.write_xdr(w)?;
            Ok(())
        })
    }
}

/// BeginSponsoringFutureReservesOp is an XDR Struct defines as:
///
/// ```text
/// struct BeginSponsoringFutureReservesOp
/// {
///     AccountID sponsoredID;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct BeginSponsoringFutureReservesOp {
    pub sponsored_id: AccountId,
}

impl ReadXdr for BeginSponsoringFutureReservesOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                sponsored_id: AccountId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for BeginSponsoringFutureReservesOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.sponsored_id.write_xdr(w)?;
            Ok(())
        })
    }
}

/// RevokeSponsorshipType is an XDR Enum defines as:
///
/// ```text
/// enum RevokeSponsorshipType
/// {
///     REVOKE_SPONSORSHIP_LEDGER_ENTRY = 0,
///     REVOKE_SPONSORSHIP_SIGNER = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum RevokeSponsorshipType {
    LedgerEntry = 0,
    Signer = 1,
}

impl RevokeSponsorshipType {
    pub const VARIANTS: [RevokeSponsorshipType; 2] = [
        RevokeSponsorshipType::LedgerEntry,
        RevokeSponsorshipType::Signer,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["LedgerEntry", "Signer"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LedgerEntry => "LedgerEntry",
            Self::Signer => "Signer",
        }
    }

    #[must_use]
    pub const fn variants() -> [RevokeSponsorshipType; 2] {
        Self::VARIANTS
    }
}

impl Name for RevokeSponsorshipType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<RevokeSponsorshipType> for RevokeSponsorshipType {
    fn variants() -> slice::Iter<'static, RevokeSponsorshipType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for RevokeSponsorshipType {}

impl fmt::Display for RevokeSponsorshipType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for RevokeSponsorshipType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => RevokeSponsorshipType::LedgerEntry,
            1 => RevokeSponsorshipType::Signer,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<RevokeSponsorshipType> for i32 {
    #[must_use]
    fn from(e: RevokeSponsorshipType) -> Self {
        e as Self
    }
}

impl ReadXdr for RevokeSponsorshipType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for RevokeSponsorshipType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// RevokeSponsorshipOpSigner is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         AccountID accountID;
///         SignerKey signerKey;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct RevokeSponsorshipOpSigner {
    pub account_id: AccountId,
    pub signer_key: SignerKey,
}

impl ReadXdr for RevokeSponsorshipOpSigner {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                account_id: AccountId::read_xdr(r)?,
                signer_key: SignerKey::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for RevokeSponsorshipOpSigner {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.account_id.write_xdr(w)?;
            self.signer_key.write_xdr(w)?;
            Ok(())
        })
    }
}

/// RevokeSponsorshipOp is an XDR Union defines as:
///
/// ```text
/// union RevokeSponsorshipOp switch (RevokeSponsorshipType type)
/// {
/// case REVOKE_SPONSORSHIP_LEDGER_ENTRY:
///     LedgerKey ledgerKey;
/// case REVOKE_SPONSORSHIP_SIGNER:
///     struct
///     {
///         AccountID accountID;
///         SignerKey signerKey;
///     } signer;
/// };
/// ```
///
// union with discriminant RevokeSponsorshipType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum RevokeSponsorshipOp {
    LedgerEntry(LedgerKey),
    Signer(RevokeSponsorshipOpSigner),
}

impl RevokeSponsorshipOp {
    pub const VARIANTS: [RevokeSponsorshipType; 2] = [
        RevokeSponsorshipType::LedgerEntry,
        RevokeSponsorshipType::Signer,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["LedgerEntry", "Signer"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::LedgerEntry(_) => "LedgerEntry",
            Self::Signer(_) => "Signer",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> RevokeSponsorshipType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::LedgerEntry(_) => RevokeSponsorshipType::LedgerEntry,
            Self::Signer(_) => RevokeSponsorshipType::Signer,
        }
    }

    #[must_use]
    pub const fn variants() -> [RevokeSponsorshipType; 2] {
        Self::VARIANTS
    }
}

impl Name for RevokeSponsorshipOp {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<RevokeSponsorshipType> for RevokeSponsorshipOp {
    #[must_use]
    fn discriminant(&self) -> RevokeSponsorshipType {
        Self::discriminant(self)
    }
}

impl Variants<RevokeSponsorshipType> for RevokeSponsorshipOp {
    fn variants() -> slice::Iter<'static, RevokeSponsorshipType> {
        Self::VARIANTS.iter()
    }
}

impl Union<RevokeSponsorshipType> for RevokeSponsorshipOp {}

impl ReadXdr for RevokeSponsorshipOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: RevokeSponsorshipType = <RevokeSponsorshipType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                RevokeSponsorshipType::LedgerEntry => Self::LedgerEntry(LedgerKey::read_xdr(r)?),
                RevokeSponsorshipType::Signer => {
                    Self::Signer(RevokeSponsorshipOpSigner::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for RevokeSponsorshipOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::LedgerEntry(v) => v.write_xdr(w)?,
                Self::Signer(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClawbackOp is an XDR Struct defines as:
///
/// ```text
/// struct ClawbackOp
/// {
///     Asset asset;
///     MuxedAccount from;
///     int64 amount;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ClawbackOp {
    pub asset: Asset,
    pub from: MuxedAccount,
    pub amount: i64,
}

impl ReadXdr for ClawbackOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                asset: Asset::read_xdr(r)?,
                from: MuxedAccount::read_xdr(r)?,
                amount: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClawbackOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.asset.write_xdr(w)?;
            self.from.write_xdr(w)?;
            self.amount.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ClawbackClaimableBalanceOp is an XDR Struct defines as:
///
/// ```text
/// struct ClawbackClaimableBalanceOp
/// {
///     ClaimableBalanceID balanceID;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ClawbackClaimableBalanceOp {
    pub balance_id: ClaimableBalanceId,
}

impl ReadXdr for ClawbackClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                balance_id: ClaimableBalanceId::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClawbackClaimableBalanceOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.balance_id.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SetTrustLineFlagsOp is an XDR Struct defines as:
///
/// ```text
/// struct SetTrustLineFlagsOp
/// {
///     AccountID trustor;
///     Asset asset;
///
///     uint32 clearFlags; // which flags to clear
///     uint32 setFlags;   // which flags to set
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SetTrustLineFlagsOp {
    pub trustor: AccountId,
    pub asset: Asset,
    pub clear_flags: u32,
    pub set_flags: u32,
}

impl ReadXdr for SetTrustLineFlagsOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                trustor: AccountId::read_xdr(r)?,
                asset: Asset::read_xdr(r)?,
                clear_flags: u32::read_xdr(r)?,
                set_flags: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SetTrustLineFlagsOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.trustor.write_xdr(w)?;
            self.asset.write_xdr(w)?;
            self.clear_flags.write_xdr(w)?;
            self.set_flags.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LiquidityPoolFeeV18 is an XDR Const defines as:
///
/// ```text
/// const LIQUIDITY_POOL_FEE_V18 = 30;
/// ```
///
pub const LIQUIDITY_POOL_FEE_V18: u64 = 30;

/// LiquidityPoolDepositOp is an XDR Struct defines as:
///
/// ```text
/// struct LiquidityPoolDepositOp
/// {
///     PoolID liquidityPoolID;
///     int64 maxAmountA; // maximum amount of first asset to deposit
///     int64 maxAmountB; // maximum amount of second asset to deposit
///     Price minPrice;   // minimum depositA/depositB
///     Price maxPrice;   // maximum depositA/depositB
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LiquidityPoolDepositOp {
    pub liquidity_pool_id: PoolId,
    pub max_amount_a: i64,
    pub max_amount_b: i64,
    pub min_price: Price,
    pub max_price: Price,
}

impl ReadXdr for LiquidityPoolDepositOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_id: PoolId::read_xdr(r)?,
                max_amount_a: i64::read_xdr(r)?,
                max_amount_b: i64::read_xdr(r)?,
                min_price: Price::read_xdr(r)?,
                max_price: Price::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LiquidityPoolDepositOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_id.write_xdr(w)?;
            self.max_amount_a.write_xdr(w)?;
            self.max_amount_b.write_xdr(w)?;
            self.min_price.write_xdr(w)?;
            self.max_price.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LiquidityPoolWithdrawOp is an XDR Struct defines as:
///
/// ```text
/// struct LiquidityPoolWithdrawOp
/// {
///     PoolID liquidityPoolID;
///     int64 amount;     // amount of pool shares to withdraw
///     int64 minAmountA; // minimum amount of first asset to withdraw
///     int64 minAmountB; // minimum amount of second asset to withdraw
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LiquidityPoolWithdrawOp {
    pub liquidity_pool_id: PoolId,
    pub amount: i64,
    pub min_amount_a: i64,
    pub min_amount_b: i64,
}

impl ReadXdr for LiquidityPoolWithdrawOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_id: PoolId::read_xdr(r)?,
                amount: i64::read_xdr(r)?,
                min_amount_a: i64::read_xdr(r)?,
                min_amount_b: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LiquidityPoolWithdrawOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_id.write_xdr(w)?;
            self.amount.write_xdr(w)?;
            self.min_amount_a.write_xdr(w)?;
            self.min_amount_b.write_xdr(w)?;
            Ok(())
        })
    }
}

/// HostFunctionType is an XDR Enum defines as:
///
/// ```text
/// enum HostFunctionType
/// {
///     HOST_FUNCTION_TYPE_INVOKE_CONTRACT = 0,
///     HOST_FUNCTION_TYPE_CREATE_CONTRACT = 1,
///     HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM = 2
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum HostFunctionType {
    InvokeContract = 0,
    CreateContract = 1,
    UploadContractWasm = 2,
}

impl HostFunctionType {
    pub const VARIANTS: [HostFunctionType; 3] = [
        HostFunctionType::InvokeContract,
        HostFunctionType::CreateContract,
        HostFunctionType::UploadContractWasm,
    ];
    pub const VARIANTS_STR: [&'static str; 3] =
        ["InvokeContract", "CreateContract", "UploadContractWasm"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::InvokeContract => "InvokeContract",
            Self::CreateContract => "CreateContract",
            Self::UploadContractWasm => "UploadContractWasm",
        }
    }

    #[must_use]
    pub const fn variants() -> [HostFunctionType; 3] {
        Self::VARIANTS
    }
}

impl Name for HostFunctionType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<HostFunctionType> for HostFunctionType {
    fn variants() -> slice::Iter<'static, HostFunctionType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for HostFunctionType {}

impl fmt::Display for HostFunctionType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for HostFunctionType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => HostFunctionType::InvokeContract,
            1 => HostFunctionType::CreateContract,
            2 => HostFunctionType::UploadContractWasm,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<HostFunctionType> for i32 {
    #[must_use]
    fn from(e: HostFunctionType) -> Self {
        e as Self
    }
}

impl ReadXdr for HostFunctionType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for HostFunctionType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractIdPreimageType is an XDR Enum defines as:
///
/// ```text
/// enum ContractIDPreimageType
/// {
///     CONTRACT_ID_PREIMAGE_FROM_ADDRESS = 0,
///     CONTRACT_ID_PREIMAGE_FROM_ASSET = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ContractIdPreimageType {
    Address = 0,
    Asset = 1,
}

impl ContractIdPreimageType {
    pub const VARIANTS: [ContractIdPreimageType; 2] = [
        ContractIdPreimageType::Address,
        ContractIdPreimageType::Asset,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["Address", "Asset"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Address => "Address",
            Self::Asset => "Asset",
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractIdPreimageType; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractIdPreimageType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ContractIdPreimageType> for ContractIdPreimageType {
    fn variants() -> slice::Iter<'static, ContractIdPreimageType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ContractIdPreimageType {}

impl fmt::Display for ContractIdPreimageType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ContractIdPreimageType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ContractIdPreimageType::Address,
            1 => ContractIdPreimageType::Asset,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ContractIdPreimageType> for i32 {
    #[must_use]
    fn from(e: ContractIdPreimageType) -> Self {
        e as Self
    }
}

impl ReadXdr for ContractIdPreimageType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ContractIdPreimageType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ContractIdPreimageFromAddress is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         SCAddress address;
///         uint256 salt;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ContractIdPreimageFromAddress {
    pub address: ScAddress,
    pub salt: Uint256,
}

impl ReadXdr for ContractIdPreimageFromAddress {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                address: ScAddress::read_xdr(r)?,
                salt: Uint256::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ContractIdPreimageFromAddress {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.address.write_xdr(w)?;
            self.salt.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ContractIdPreimage is an XDR Union defines as:
///
/// ```text
/// union ContractIDPreimage switch (ContractIDPreimageType type)
/// {
/// case CONTRACT_ID_PREIMAGE_FROM_ADDRESS:
///     struct
///     {
///         SCAddress address;
///         uint256 salt;
///     } fromAddress;
/// case CONTRACT_ID_PREIMAGE_FROM_ASSET:
///     Asset fromAsset;
/// };
/// ```
///
// union with discriminant ContractIdPreimageType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ContractIdPreimage {
    Address(ContractIdPreimageFromAddress),
    Asset(Asset),
}

impl ContractIdPreimage {
    pub const VARIANTS: [ContractIdPreimageType; 2] = [
        ContractIdPreimageType::Address,
        ContractIdPreimageType::Asset,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["Address", "Asset"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Address(_) => "Address",
            Self::Asset(_) => "Asset",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ContractIdPreimageType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Address(_) => ContractIdPreimageType::Address,
            Self::Asset(_) => ContractIdPreimageType::Asset,
        }
    }

    #[must_use]
    pub const fn variants() -> [ContractIdPreimageType; 2] {
        Self::VARIANTS
    }
}

impl Name for ContractIdPreimage {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ContractIdPreimageType> for ContractIdPreimage {
    #[must_use]
    fn discriminant(&self) -> ContractIdPreimageType {
        Self::discriminant(self)
    }
}

impl Variants<ContractIdPreimageType> for ContractIdPreimage {
    fn variants() -> slice::Iter<'static, ContractIdPreimageType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ContractIdPreimageType> for ContractIdPreimage {}

impl ReadXdr for ContractIdPreimage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ContractIdPreimageType = <ContractIdPreimageType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ContractIdPreimageType::Address => {
                    Self::Address(ContractIdPreimageFromAddress::read_xdr(r)?)
                }
                ContractIdPreimageType::Asset => Self::Asset(Asset::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ContractIdPreimage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Address(v) => v.write_xdr(w)?,
                Self::Asset(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// CreateContractArgs is an XDR Struct defines as:
///
/// ```text
/// struct CreateContractArgs
/// {
///     ContractIDPreimage contractIDPreimage;
///     ContractExecutable executable;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct CreateContractArgs {
    pub contract_id_preimage: ContractIdPreimage,
    pub executable: ContractExecutable,
}

impl ReadXdr for CreateContractArgs {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                contract_id_preimage: ContractIdPreimage::read_xdr(r)?,
                executable: ContractExecutable::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for CreateContractArgs {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.contract_id_preimage.write_xdr(w)?;
            self.executable.write_xdr(w)?;
            Ok(())
        })
    }
}

/// InvokeContractArgs is an XDR Struct defines as:
///
/// ```text
/// struct InvokeContractArgs {
///     SCAddress contractAddress;
///     SCSymbol functionName;
///     SCVal args<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct InvokeContractArgs {
    pub contract_address: ScAddress,
    pub function_name: ScSymbol,
    pub args: VecM<ScVal>,
}

impl ReadXdr for InvokeContractArgs {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                contract_address: ScAddress::read_xdr(r)?,
                function_name: ScSymbol::read_xdr(r)?,
                args: VecM::<ScVal>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InvokeContractArgs {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.contract_address.write_xdr(w)?;
            self.function_name.write_xdr(w)?;
            self.args.write_xdr(w)?;
            Ok(())
        })
    }
}

/// HostFunction is an XDR Union defines as:
///
/// ```text
/// union HostFunction switch (HostFunctionType type)
/// {
/// case HOST_FUNCTION_TYPE_INVOKE_CONTRACT:
///     InvokeContractArgs invokeContract;
/// case HOST_FUNCTION_TYPE_CREATE_CONTRACT:
///     CreateContractArgs createContract;
/// case HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM:
///     opaque wasm<>;
/// };
/// ```
///
// union with discriminant HostFunctionType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum HostFunction {
    InvokeContract(InvokeContractArgs),
    CreateContract(CreateContractArgs),
    UploadContractWasm(BytesM),
}

impl HostFunction {
    pub const VARIANTS: [HostFunctionType; 3] = [
        HostFunctionType::InvokeContract,
        HostFunctionType::CreateContract,
        HostFunctionType::UploadContractWasm,
    ];
    pub const VARIANTS_STR: [&'static str; 3] =
        ["InvokeContract", "CreateContract", "UploadContractWasm"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::InvokeContract(_) => "InvokeContract",
            Self::CreateContract(_) => "CreateContract",
            Self::UploadContractWasm(_) => "UploadContractWasm",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> HostFunctionType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::InvokeContract(_) => HostFunctionType::InvokeContract,
            Self::CreateContract(_) => HostFunctionType::CreateContract,
            Self::UploadContractWasm(_) => HostFunctionType::UploadContractWasm,
        }
    }

    #[must_use]
    pub const fn variants() -> [HostFunctionType; 3] {
        Self::VARIANTS
    }
}

impl Name for HostFunction {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<HostFunctionType> for HostFunction {
    #[must_use]
    fn discriminant(&self) -> HostFunctionType {
        Self::discriminant(self)
    }
}

impl Variants<HostFunctionType> for HostFunction {
    fn variants() -> slice::Iter<'static, HostFunctionType> {
        Self::VARIANTS.iter()
    }
}

impl Union<HostFunctionType> for HostFunction {}

impl ReadXdr for HostFunction {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: HostFunctionType = <HostFunctionType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                HostFunctionType::InvokeContract => {
                    Self::InvokeContract(InvokeContractArgs::read_xdr(r)?)
                }
                HostFunctionType::CreateContract => {
                    Self::CreateContract(CreateContractArgs::read_xdr(r)?)
                }
                HostFunctionType::UploadContractWasm => {
                    Self::UploadContractWasm(BytesM::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for HostFunction {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::InvokeContract(v) => v.write_xdr(w)?,
                Self::CreateContract(v) => v.write_xdr(w)?,
                Self::UploadContractWasm(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SorobanAuthorizedFunctionType is an XDR Enum defines as:
///
/// ```text
/// enum SorobanAuthorizedFunctionType
/// {
///     SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN = 0,
///     SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum SorobanAuthorizedFunctionType {
    ContractFn = 0,
    CreateContractHostFn = 1,
}

impl SorobanAuthorizedFunctionType {
    pub const VARIANTS: [SorobanAuthorizedFunctionType; 2] = [
        SorobanAuthorizedFunctionType::ContractFn,
        SorobanAuthorizedFunctionType::CreateContractHostFn,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["ContractFn", "CreateContractHostFn"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ContractFn => "ContractFn",
            Self::CreateContractHostFn => "CreateContractHostFn",
        }
    }

    #[must_use]
    pub const fn variants() -> [SorobanAuthorizedFunctionType; 2] {
        Self::VARIANTS
    }
}

impl Name for SorobanAuthorizedFunctionType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SorobanAuthorizedFunctionType> for SorobanAuthorizedFunctionType {
    fn variants() -> slice::Iter<'static, SorobanAuthorizedFunctionType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SorobanAuthorizedFunctionType {}

impl fmt::Display for SorobanAuthorizedFunctionType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SorobanAuthorizedFunctionType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => SorobanAuthorizedFunctionType::ContractFn,
            1 => SorobanAuthorizedFunctionType::CreateContractHostFn,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SorobanAuthorizedFunctionType> for i32 {
    #[must_use]
    fn from(e: SorobanAuthorizedFunctionType) -> Self {
        e as Self
    }
}

impl ReadXdr for SorobanAuthorizedFunctionType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanAuthorizedFunctionType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SorobanAuthorizedFunction is an XDR Union defines as:
///
/// ```text
/// union SorobanAuthorizedFunction switch (SorobanAuthorizedFunctionType type)
/// {
/// case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN:
///     InvokeContractArgs contractFn;
/// case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN:
///     CreateContractArgs createContractHostFn;
/// };
/// ```
///
// union with discriminant SorobanAuthorizedFunctionType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum SorobanAuthorizedFunction {
    ContractFn(InvokeContractArgs),
    CreateContractHostFn(CreateContractArgs),
}

impl SorobanAuthorizedFunction {
    pub const VARIANTS: [SorobanAuthorizedFunctionType; 2] = [
        SorobanAuthorizedFunctionType::ContractFn,
        SorobanAuthorizedFunctionType::CreateContractHostFn,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["ContractFn", "CreateContractHostFn"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::ContractFn(_) => "ContractFn",
            Self::CreateContractHostFn(_) => "CreateContractHostFn",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SorobanAuthorizedFunctionType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::ContractFn(_) => SorobanAuthorizedFunctionType::ContractFn,
            Self::CreateContractHostFn(_) => SorobanAuthorizedFunctionType::CreateContractHostFn,
        }
    }

    #[must_use]
    pub const fn variants() -> [SorobanAuthorizedFunctionType; 2] {
        Self::VARIANTS
    }
}

impl Name for SorobanAuthorizedFunction {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SorobanAuthorizedFunctionType> for SorobanAuthorizedFunction {
    #[must_use]
    fn discriminant(&self) -> SorobanAuthorizedFunctionType {
        Self::discriminant(self)
    }
}

impl Variants<SorobanAuthorizedFunctionType> for SorobanAuthorizedFunction {
    fn variants() -> slice::Iter<'static, SorobanAuthorizedFunctionType> {
        Self::VARIANTS.iter()
    }
}

impl Union<SorobanAuthorizedFunctionType> for SorobanAuthorizedFunction {}

impl ReadXdr for SorobanAuthorizedFunction {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: SorobanAuthorizedFunctionType =
                <SorobanAuthorizedFunctionType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                SorobanAuthorizedFunctionType::ContractFn => {
                    Self::ContractFn(InvokeContractArgs::read_xdr(r)?)
                }
                SorobanAuthorizedFunctionType::CreateContractHostFn => {
                    Self::CreateContractHostFn(CreateContractArgs::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanAuthorizedFunction {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::ContractFn(v) => v.write_xdr(w)?,
                Self::CreateContractHostFn(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SorobanAuthorizedInvocation is an XDR Struct defines as:
///
/// ```text
/// struct SorobanAuthorizedInvocation
/// {
///     SorobanAuthorizedFunction function;
///     SorobanAuthorizedInvocation subInvocations<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SorobanAuthorizedInvocation {
    pub function: SorobanAuthorizedFunction,
    pub sub_invocations: VecM<SorobanAuthorizedInvocation>,
}

impl ReadXdr for SorobanAuthorizedInvocation {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                function: SorobanAuthorizedFunction::read_xdr(r)?,
                sub_invocations: VecM::<SorobanAuthorizedInvocation>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanAuthorizedInvocation {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.function.write_xdr(w)?;
            self.sub_invocations.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SorobanAddressCredentials is an XDR Struct defines as:
///
/// ```text
/// struct SorobanAddressCredentials
/// {
///     SCAddress address;
///     int64 nonce;
///     uint32 signatureExpirationLedger;    
///     SCVal signature;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SorobanAddressCredentials {
    pub address: ScAddress,
    pub nonce: i64,
    pub signature_expiration_ledger: u32,
    pub signature: ScVal,
}

impl ReadXdr for SorobanAddressCredentials {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                address: ScAddress::read_xdr(r)?,
                nonce: i64::read_xdr(r)?,
                signature_expiration_ledger: u32::read_xdr(r)?,
                signature: ScVal::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanAddressCredentials {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.address.write_xdr(w)?;
            self.nonce.write_xdr(w)?;
            self.signature_expiration_ledger.write_xdr(w)?;
            self.signature.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SorobanCredentialsType is an XDR Enum defines as:
///
/// ```text
/// enum SorobanCredentialsType
/// {
///     SOROBAN_CREDENTIALS_SOURCE_ACCOUNT = 0,
///     SOROBAN_CREDENTIALS_ADDRESS = 1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum SorobanCredentialsType {
    SourceAccount = 0,
    Address = 1,
}

impl SorobanCredentialsType {
    pub const VARIANTS: [SorobanCredentialsType; 2] = [
        SorobanCredentialsType::SourceAccount,
        SorobanCredentialsType::Address,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["SourceAccount", "Address"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SourceAccount => "SourceAccount",
            Self::Address => "Address",
        }
    }

    #[must_use]
    pub const fn variants() -> [SorobanCredentialsType; 2] {
        Self::VARIANTS
    }
}

impl Name for SorobanCredentialsType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SorobanCredentialsType> for SorobanCredentialsType {
    fn variants() -> slice::Iter<'static, SorobanCredentialsType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SorobanCredentialsType {}

impl fmt::Display for SorobanCredentialsType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SorobanCredentialsType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => SorobanCredentialsType::SourceAccount,
            1 => SorobanCredentialsType::Address,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SorobanCredentialsType> for i32 {
    #[must_use]
    fn from(e: SorobanCredentialsType) -> Self {
        e as Self
    }
}

impl ReadXdr for SorobanCredentialsType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanCredentialsType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SorobanCredentials is an XDR Union defines as:
///
/// ```text
/// union SorobanCredentials switch (SorobanCredentialsType type)
/// {
/// case SOROBAN_CREDENTIALS_SOURCE_ACCOUNT:
///     void;
/// case SOROBAN_CREDENTIALS_ADDRESS:
///     SorobanAddressCredentials address;
/// };
/// ```
///
// union with discriminant SorobanCredentialsType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum SorobanCredentials {
    SourceAccount,
    Address(SorobanAddressCredentials),
}

impl SorobanCredentials {
    pub const VARIANTS: [SorobanCredentialsType; 2] = [
        SorobanCredentialsType::SourceAccount,
        SorobanCredentialsType::Address,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["SourceAccount", "Address"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::SourceAccount => "SourceAccount",
            Self::Address(_) => "Address",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SorobanCredentialsType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::SourceAccount => SorobanCredentialsType::SourceAccount,
            Self::Address(_) => SorobanCredentialsType::Address,
        }
    }

    #[must_use]
    pub const fn variants() -> [SorobanCredentialsType; 2] {
        Self::VARIANTS
    }
}

impl Name for SorobanCredentials {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SorobanCredentialsType> for SorobanCredentials {
    #[must_use]
    fn discriminant(&self) -> SorobanCredentialsType {
        Self::discriminant(self)
    }
}

impl Variants<SorobanCredentialsType> for SorobanCredentials {
    fn variants() -> slice::Iter<'static, SorobanCredentialsType> {
        Self::VARIANTS.iter()
    }
}

impl Union<SorobanCredentialsType> for SorobanCredentials {}

impl ReadXdr for SorobanCredentials {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: SorobanCredentialsType = <SorobanCredentialsType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                SorobanCredentialsType::SourceAccount => Self::SourceAccount,
                SorobanCredentialsType::Address => {
                    Self::Address(SorobanAddressCredentials::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SorobanCredentials {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::SourceAccount => ().write_xdr(w)?,
                Self::Address(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SorobanAuthorizationEntry is an XDR Struct defines as:
///
/// ```text
/// struct SorobanAuthorizationEntry
/// {
///     SorobanCredentials credentials;
///     SorobanAuthorizedInvocation rootInvocation;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SorobanAuthorizationEntry {
    pub credentials: SorobanCredentials,
    pub root_invocation: SorobanAuthorizedInvocation,
}

impl ReadXdr for SorobanAuthorizationEntry {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                credentials: SorobanCredentials::read_xdr(r)?,
                root_invocation: SorobanAuthorizedInvocation::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanAuthorizationEntry {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.credentials.write_xdr(w)?;
            self.root_invocation.write_xdr(w)?;
            Ok(())
        })
    }
}

/// InvokeHostFunctionOp is an XDR Struct defines as:
///
/// ```text
/// struct InvokeHostFunctionOp
/// {
///     // Host function to invoke.
///     HostFunction hostFunction;
///     // Per-address authorizations for this host function.
///     SorobanAuthorizationEntry auth<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct InvokeHostFunctionOp {
    pub host_function: HostFunction,
    pub auth: VecM<SorobanAuthorizationEntry>,
}

impl ReadXdr for InvokeHostFunctionOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                host_function: HostFunction::read_xdr(r)?,
                auth: VecM::<SorobanAuthorizationEntry>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InvokeHostFunctionOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.host_function.write_xdr(w)?;
            self.auth.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ExtendFootprintTtlOp is an XDR Struct defines as:
///
/// ```text
/// struct ExtendFootprintTTLOp
/// {
///     ExtensionPoint ext;
///     uint32 extendTo;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ExtendFootprintTtlOp {
    pub ext: ExtensionPoint,
    pub extend_to: u32,
}

impl ReadXdr for ExtendFootprintTtlOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
                extend_to: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ExtendFootprintTtlOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.extend_to.write_xdr(w)?;
            Ok(())
        })
    }
}

/// RestoreFootprintOp is an XDR Struct defines as:
///
/// ```text
/// struct RestoreFootprintOp
/// {
///     ExtensionPoint ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct RestoreFootprintOp {
    pub ext: ExtensionPoint,
}

impl ReadXdr for RestoreFootprintOp {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for RestoreFootprintOp {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// OperationBody is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (OperationType type)
///     {
///     case CREATE_ACCOUNT:
///         CreateAccountOp createAccountOp;
///     case PAYMENT:
///         PaymentOp paymentOp;
///     case PATH_PAYMENT_STRICT_RECEIVE:
///         PathPaymentStrictReceiveOp pathPaymentStrictReceiveOp;
///     case MANAGE_SELL_OFFER:
///         ManageSellOfferOp manageSellOfferOp;
///     case CREATE_PASSIVE_SELL_OFFER:
///         CreatePassiveSellOfferOp createPassiveSellOfferOp;
///     case SET_OPTIONS:
///         SetOptionsOp setOptionsOp;
///     case CHANGE_TRUST:
///         ChangeTrustOp changeTrustOp;
///     case ALLOW_TRUST:
///         AllowTrustOp allowTrustOp;
///     case ACCOUNT_MERGE:
///         MuxedAccount destination;
///     case INFLATION:
///         void;
///     case MANAGE_DATA:
///         ManageDataOp manageDataOp;
///     case BUMP_SEQUENCE:
///         BumpSequenceOp bumpSequenceOp;
///     case MANAGE_BUY_OFFER:
///         ManageBuyOfferOp manageBuyOfferOp;
///     case PATH_PAYMENT_STRICT_SEND:
///         PathPaymentStrictSendOp pathPaymentStrictSendOp;
///     case CREATE_CLAIMABLE_BALANCE:
///         CreateClaimableBalanceOp createClaimableBalanceOp;
///     case CLAIM_CLAIMABLE_BALANCE:
///         ClaimClaimableBalanceOp claimClaimableBalanceOp;
///     case BEGIN_SPONSORING_FUTURE_RESERVES:
///         BeginSponsoringFutureReservesOp beginSponsoringFutureReservesOp;
///     case END_SPONSORING_FUTURE_RESERVES:
///         void;
///     case REVOKE_SPONSORSHIP:
///         RevokeSponsorshipOp revokeSponsorshipOp;
///     case CLAWBACK:
///         ClawbackOp clawbackOp;
///     case CLAWBACK_CLAIMABLE_BALANCE:
///         ClawbackClaimableBalanceOp clawbackClaimableBalanceOp;
///     case SET_TRUST_LINE_FLAGS:
///         SetTrustLineFlagsOp setTrustLineFlagsOp;
///     case LIQUIDITY_POOL_DEPOSIT:
///         LiquidityPoolDepositOp liquidityPoolDepositOp;
///     case LIQUIDITY_POOL_WITHDRAW:
///         LiquidityPoolWithdrawOp liquidityPoolWithdrawOp;
///     case INVOKE_HOST_FUNCTION:
///         InvokeHostFunctionOp invokeHostFunctionOp;
///     case EXTEND_FOOTPRINT_TTL:
///         ExtendFootprintTTLOp extendFootprintTTLOp;
///     case RESTORE_FOOTPRINT:
///         RestoreFootprintOp restoreFootprintOp;
///     }
/// ```
///
// union with discriminant OperationType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum OperationBody {
    CreateAccount(CreateAccountOp),
    Payment(PaymentOp),
    PathPaymentStrictReceive(PathPaymentStrictReceiveOp),
    ManageSellOffer(ManageSellOfferOp),
    CreatePassiveSellOffer(CreatePassiveSellOfferOp),
    SetOptions(SetOptionsOp),
    ChangeTrust(ChangeTrustOp),
    AllowTrust(AllowTrustOp),
    AccountMerge(MuxedAccount),
    Inflation,
    ManageData(ManageDataOp),
    BumpSequence(BumpSequenceOp),
    ManageBuyOffer(ManageBuyOfferOp),
    PathPaymentStrictSend(PathPaymentStrictSendOp),
    CreateClaimableBalance(CreateClaimableBalanceOp),
    ClaimClaimableBalance(ClaimClaimableBalanceOp),
    BeginSponsoringFutureReserves(BeginSponsoringFutureReservesOp),
    EndSponsoringFutureReserves,
    RevokeSponsorship(RevokeSponsorshipOp),
    Clawback(ClawbackOp),
    ClawbackClaimableBalance(ClawbackClaimableBalanceOp),
    SetTrustLineFlags(SetTrustLineFlagsOp),
    LiquidityPoolDeposit(LiquidityPoolDepositOp),
    LiquidityPoolWithdraw(LiquidityPoolWithdrawOp),
    InvokeHostFunction(InvokeHostFunctionOp),
    ExtendFootprintTtl(ExtendFootprintTtlOp),
    RestoreFootprint(RestoreFootprintOp),
}

impl OperationBody {
    pub const VARIANTS: [OperationType; 27] = [
        OperationType::CreateAccount,
        OperationType::Payment,
        OperationType::PathPaymentStrictReceive,
        OperationType::ManageSellOffer,
        OperationType::CreatePassiveSellOffer,
        OperationType::SetOptions,
        OperationType::ChangeTrust,
        OperationType::AllowTrust,
        OperationType::AccountMerge,
        OperationType::Inflation,
        OperationType::ManageData,
        OperationType::BumpSequence,
        OperationType::ManageBuyOffer,
        OperationType::PathPaymentStrictSend,
        OperationType::CreateClaimableBalance,
        OperationType::ClaimClaimableBalance,
        OperationType::BeginSponsoringFutureReserves,
        OperationType::EndSponsoringFutureReserves,
        OperationType::RevokeSponsorship,
        OperationType::Clawback,
        OperationType::ClawbackClaimableBalance,
        OperationType::SetTrustLineFlags,
        OperationType::LiquidityPoolDeposit,
        OperationType::LiquidityPoolWithdraw,
        OperationType::InvokeHostFunction,
        OperationType::ExtendFootprintTtl,
        OperationType::RestoreFootprint,
    ];
    pub const VARIANTS_STR: [&'static str; 27] = [
        "CreateAccount",
        "Payment",
        "PathPaymentStrictReceive",
        "ManageSellOffer",
        "CreatePassiveSellOffer",
        "SetOptions",
        "ChangeTrust",
        "AllowTrust",
        "AccountMerge",
        "Inflation",
        "ManageData",
        "BumpSequence",
        "ManageBuyOffer",
        "PathPaymentStrictSend",
        "CreateClaimableBalance",
        "ClaimClaimableBalance",
        "BeginSponsoringFutureReserves",
        "EndSponsoringFutureReserves",
        "RevokeSponsorship",
        "Clawback",
        "ClawbackClaimableBalance",
        "SetTrustLineFlags",
        "LiquidityPoolDeposit",
        "LiquidityPoolWithdraw",
        "InvokeHostFunction",
        "ExtendFootprintTtl",
        "RestoreFootprint",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::CreateAccount(_) => "CreateAccount",
            Self::Payment(_) => "Payment",
            Self::PathPaymentStrictReceive(_) => "PathPaymentStrictReceive",
            Self::ManageSellOffer(_) => "ManageSellOffer",
            Self::CreatePassiveSellOffer(_) => "CreatePassiveSellOffer",
            Self::SetOptions(_) => "SetOptions",
            Self::ChangeTrust(_) => "ChangeTrust",
            Self::AllowTrust(_) => "AllowTrust",
            Self::AccountMerge(_) => "AccountMerge",
            Self::Inflation => "Inflation",
            Self::ManageData(_) => "ManageData",
            Self::BumpSequence(_) => "BumpSequence",
            Self::ManageBuyOffer(_) => "ManageBuyOffer",
            Self::PathPaymentStrictSend(_) => "PathPaymentStrictSend",
            Self::CreateClaimableBalance(_) => "CreateClaimableBalance",
            Self::ClaimClaimableBalance(_) => "ClaimClaimableBalance",
            Self::BeginSponsoringFutureReserves(_) => "BeginSponsoringFutureReserves",
            Self::EndSponsoringFutureReserves => "EndSponsoringFutureReserves",
            Self::RevokeSponsorship(_) => "RevokeSponsorship",
            Self::Clawback(_) => "Clawback",
            Self::ClawbackClaimableBalance(_) => "ClawbackClaimableBalance",
            Self::SetTrustLineFlags(_) => "SetTrustLineFlags",
            Self::LiquidityPoolDeposit(_) => "LiquidityPoolDeposit",
            Self::LiquidityPoolWithdraw(_) => "LiquidityPoolWithdraw",
            Self::InvokeHostFunction(_) => "InvokeHostFunction",
            Self::ExtendFootprintTtl(_) => "ExtendFootprintTtl",
            Self::RestoreFootprint(_) => "RestoreFootprint",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> OperationType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::CreateAccount(_) => OperationType::CreateAccount,
            Self::Payment(_) => OperationType::Payment,
            Self::PathPaymentStrictReceive(_) => OperationType::PathPaymentStrictReceive,
            Self::ManageSellOffer(_) => OperationType::ManageSellOffer,
            Self::CreatePassiveSellOffer(_) => OperationType::CreatePassiveSellOffer,
            Self::SetOptions(_) => OperationType::SetOptions,
            Self::ChangeTrust(_) => OperationType::ChangeTrust,
            Self::AllowTrust(_) => OperationType::AllowTrust,
            Self::AccountMerge(_) => OperationType::AccountMerge,
            Self::Inflation => OperationType::Inflation,
            Self::ManageData(_) => OperationType::ManageData,
            Self::BumpSequence(_) => OperationType::BumpSequence,
            Self::ManageBuyOffer(_) => OperationType::ManageBuyOffer,
            Self::PathPaymentStrictSend(_) => OperationType::PathPaymentStrictSend,
            Self::CreateClaimableBalance(_) => OperationType::CreateClaimableBalance,
            Self::ClaimClaimableBalance(_) => OperationType::ClaimClaimableBalance,
            Self::BeginSponsoringFutureReserves(_) => OperationType::BeginSponsoringFutureReserves,
            Self::EndSponsoringFutureReserves => OperationType::EndSponsoringFutureReserves,
            Self::RevokeSponsorship(_) => OperationType::RevokeSponsorship,
            Self::Clawback(_) => OperationType::Clawback,
            Self::ClawbackClaimableBalance(_) => OperationType::ClawbackClaimableBalance,
            Self::SetTrustLineFlags(_) => OperationType::SetTrustLineFlags,
            Self::LiquidityPoolDeposit(_) => OperationType::LiquidityPoolDeposit,
            Self::LiquidityPoolWithdraw(_) => OperationType::LiquidityPoolWithdraw,
            Self::InvokeHostFunction(_) => OperationType::InvokeHostFunction,
            Self::ExtendFootprintTtl(_) => OperationType::ExtendFootprintTtl,
            Self::RestoreFootprint(_) => OperationType::RestoreFootprint,
        }
    }

    #[must_use]
    pub const fn variants() -> [OperationType; 27] {
        Self::VARIANTS
    }
}

impl Name for OperationBody {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<OperationType> for OperationBody {
    #[must_use]
    fn discriminant(&self) -> OperationType {
        Self::discriminant(self)
    }
}

impl Variants<OperationType> for OperationBody {
    fn variants() -> slice::Iter<'static, OperationType> {
        Self::VARIANTS.iter()
    }
}

impl Union<OperationType> for OperationBody {}

impl ReadXdr for OperationBody {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: OperationType = <OperationType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                OperationType::CreateAccount => Self::CreateAccount(CreateAccountOp::read_xdr(r)?),
                OperationType::Payment => Self::Payment(PaymentOp::read_xdr(r)?),
                OperationType::PathPaymentStrictReceive => {
                    Self::PathPaymentStrictReceive(PathPaymentStrictReceiveOp::read_xdr(r)?)
                }
                OperationType::ManageSellOffer => {
                    Self::ManageSellOffer(ManageSellOfferOp::read_xdr(r)?)
                }
                OperationType::CreatePassiveSellOffer => {
                    Self::CreatePassiveSellOffer(CreatePassiveSellOfferOp::read_xdr(r)?)
                }
                OperationType::SetOptions => Self::SetOptions(SetOptionsOp::read_xdr(r)?),
                OperationType::ChangeTrust => Self::ChangeTrust(ChangeTrustOp::read_xdr(r)?),
                OperationType::AllowTrust => Self::AllowTrust(AllowTrustOp::read_xdr(r)?),
                OperationType::AccountMerge => Self::AccountMerge(MuxedAccount::read_xdr(r)?),
                OperationType::Inflation => Self::Inflation,
                OperationType::ManageData => Self::ManageData(ManageDataOp::read_xdr(r)?),
                OperationType::BumpSequence => Self::BumpSequence(BumpSequenceOp::read_xdr(r)?),
                OperationType::ManageBuyOffer => {
                    Self::ManageBuyOffer(ManageBuyOfferOp::read_xdr(r)?)
                }
                OperationType::PathPaymentStrictSend => {
                    Self::PathPaymentStrictSend(PathPaymentStrictSendOp::read_xdr(r)?)
                }
                OperationType::CreateClaimableBalance => {
                    Self::CreateClaimableBalance(CreateClaimableBalanceOp::read_xdr(r)?)
                }
                OperationType::ClaimClaimableBalance => {
                    Self::ClaimClaimableBalance(ClaimClaimableBalanceOp::read_xdr(r)?)
                }
                OperationType::BeginSponsoringFutureReserves => {
                    Self::BeginSponsoringFutureReserves(BeginSponsoringFutureReservesOp::read_xdr(
                        r,
                    )?)
                }
                OperationType::EndSponsoringFutureReserves => Self::EndSponsoringFutureReserves,
                OperationType::RevokeSponsorship => {
                    Self::RevokeSponsorship(RevokeSponsorshipOp::read_xdr(r)?)
                }
                OperationType::Clawback => Self::Clawback(ClawbackOp::read_xdr(r)?),
                OperationType::ClawbackClaimableBalance => {
                    Self::ClawbackClaimableBalance(ClawbackClaimableBalanceOp::read_xdr(r)?)
                }
                OperationType::SetTrustLineFlags => {
                    Self::SetTrustLineFlags(SetTrustLineFlagsOp::read_xdr(r)?)
                }
                OperationType::LiquidityPoolDeposit => {
                    Self::LiquidityPoolDeposit(LiquidityPoolDepositOp::read_xdr(r)?)
                }
                OperationType::LiquidityPoolWithdraw => {
                    Self::LiquidityPoolWithdraw(LiquidityPoolWithdrawOp::read_xdr(r)?)
                }
                OperationType::InvokeHostFunction => {
                    Self::InvokeHostFunction(InvokeHostFunctionOp::read_xdr(r)?)
                }
                OperationType::ExtendFootprintTtl => {
                    Self::ExtendFootprintTtl(ExtendFootprintTtlOp::read_xdr(r)?)
                }
                OperationType::RestoreFootprint => {
                    Self::RestoreFootprint(RestoreFootprintOp::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for OperationBody {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::CreateAccount(v) => v.write_xdr(w)?,
                Self::Payment(v) => v.write_xdr(w)?,
                Self::PathPaymentStrictReceive(v) => v.write_xdr(w)?,
                Self::ManageSellOffer(v) => v.write_xdr(w)?,
                Self::CreatePassiveSellOffer(v) => v.write_xdr(w)?,
                Self::SetOptions(v) => v.write_xdr(w)?,
                Self::ChangeTrust(v) => v.write_xdr(w)?,
                Self::AllowTrust(v) => v.write_xdr(w)?,
                Self::AccountMerge(v) => v.write_xdr(w)?,
                Self::Inflation => ().write_xdr(w)?,
                Self::ManageData(v) => v.write_xdr(w)?,
                Self::BumpSequence(v) => v.write_xdr(w)?,
                Self::ManageBuyOffer(v) => v.write_xdr(w)?,
                Self::PathPaymentStrictSend(v) => v.write_xdr(w)?,
                Self::CreateClaimableBalance(v) => v.write_xdr(w)?,
                Self::ClaimClaimableBalance(v) => v.write_xdr(w)?,
                Self::BeginSponsoringFutureReserves(v) => v.write_xdr(w)?,
                Self::EndSponsoringFutureReserves => ().write_xdr(w)?,
                Self::RevokeSponsorship(v) => v.write_xdr(w)?,
                Self::Clawback(v) => v.write_xdr(w)?,
                Self::ClawbackClaimableBalance(v) => v.write_xdr(w)?,
                Self::SetTrustLineFlags(v) => v.write_xdr(w)?,
                Self::LiquidityPoolDeposit(v) => v.write_xdr(w)?,
                Self::LiquidityPoolWithdraw(v) => v.write_xdr(w)?,
                Self::InvokeHostFunction(v) => v.write_xdr(w)?,
                Self::ExtendFootprintTtl(v) => v.write_xdr(w)?,
                Self::RestoreFootprint(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// Operation is an XDR Struct defines as:
///
/// ```text
/// struct Operation
/// {
///     // sourceAccount is the account used to run the operation
///     // if not set, the runtime defaults to "sourceAccount" specified at
///     // the transaction level
///     MuxedAccount* sourceAccount;
///
///     union switch (OperationType type)
///     {
///     case CREATE_ACCOUNT:
///         CreateAccountOp createAccountOp;
///     case PAYMENT:
///         PaymentOp paymentOp;
///     case PATH_PAYMENT_STRICT_RECEIVE:
///         PathPaymentStrictReceiveOp pathPaymentStrictReceiveOp;
///     case MANAGE_SELL_OFFER:
///         ManageSellOfferOp manageSellOfferOp;
///     case CREATE_PASSIVE_SELL_OFFER:
///         CreatePassiveSellOfferOp createPassiveSellOfferOp;
///     case SET_OPTIONS:
///         SetOptionsOp setOptionsOp;
///     case CHANGE_TRUST:
///         ChangeTrustOp changeTrustOp;
///     case ALLOW_TRUST:
///         AllowTrustOp allowTrustOp;
///     case ACCOUNT_MERGE:
///         MuxedAccount destination;
///     case INFLATION:
///         void;
///     case MANAGE_DATA:
///         ManageDataOp manageDataOp;
///     case BUMP_SEQUENCE:
///         BumpSequenceOp bumpSequenceOp;
///     case MANAGE_BUY_OFFER:
///         ManageBuyOfferOp manageBuyOfferOp;
///     case PATH_PAYMENT_STRICT_SEND:
///         PathPaymentStrictSendOp pathPaymentStrictSendOp;
///     case CREATE_CLAIMABLE_BALANCE:
///         CreateClaimableBalanceOp createClaimableBalanceOp;
///     case CLAIM_CLAIMABLE_BALANCE:
///         ClaimClaimableBalanceOp claimClaimableBalanceOp;
///     case BEGIN_SPONSORING_FUTURE_RESERVES:
///         BeginSponsoringFutureReservesOp beginSponsoringFutureReservesOp;
///     case END_SPONSORING_FUTURE_RESERVES:
///         void;
///     case REVOKE_SPONSORSHIP:
///         RevokeSponsorshipOp revokeSponsorshipOp;
///     case CLAWBACK:
///         ClawbackOp clawbackOp;
///     case CLAWBACK_CLAIMABLE_BALANCE:
///         ClawbackClaimableBalanceOp clawbackClaimableBalanceOp;
///     case SET_TRUST_LINE_FLAGS:
///         SetTrustLineFlagsOp setTrustLineFlagsOp;
///     case LIQUIDITY_POOL_DEPOSIT:
///         LiquidityPoolDepositOp liquidityPoolDepositOp;
///     case LIQUIDITY_POOL_WITHDRAW:
///         LiquidityPoolWithdrawOp liquidityPoolWithdrawOp;
///     case INVOKE_HOST_FUNCTION:
///         InvokeHostFunctionOp invokeHostFunctionOp;
///     case EXTEND_FOOTPRINT_TTL:
///         ExtendFootprintTTLOp extendFootprintTTLOp;
///     case RESTORE_FOOTPRINT:
///         RestoreFootprintOp restoreFootprintOp;
///     }
///     body;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Operation {
    pub source_account: Option<MuxedAccount>,
    pub body: OperationBody,
}

impl ReadXdr for Operation {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                source_account: Option::<MuxedAccount>::read_xdr(r)?,
                body: OperationBody::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Operation {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.source_account.write_xdr(w)?;
            self.body.write_xdr(w)?;
            Ok(())
        })
    }
}

/// HashIdPreimageOperationId is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         AccountID sourceAccount;
///         SequenceNumber seqNum;
///         uint32 opNum;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct HashIdPreimageOperationId {
    pub source_account: AccountId,
    pub seq_num: SequenceNumber,
    pub op_num: u32,
}

impl ReadXdr for HashIdPreimageOperationId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                source_account: AccountId::read_xdr(r)?,
                seq_num: SequenceNumber::read_xdr(r)?,
                op_num: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HashIdPreimageOperationId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.source_account.write_xdr(w)?;
            self.seq_num.write_xdr(w)?;
            self.op_num.write_xdr(w)?;
            Ok(())
        })
    }
}

/// HashIdPreimageRevokeId is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         AccountID sourceAccount;
///         SequenceNumber seqNum;
///         uint32 opNum;
///         PoolID liquidityPoolID;
///         Asset asset;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct HashIdPreimageRevokeId {
    pub source_account: AccountId,
    pub seq_num: SequenceNumber,
    pub op_num: u32,
    pub liquidity_pool_id: PoolId,
    pub asset: Asset,
}

impl ReadXdr for HashIdPreimageRevokeId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                source_account: AccountId::read_xdr(r)?,
                seq_num: SequenceNumber::read_xdr(r)?,
                op_num: u32::read_xdr(r)?,
                liquidity_pool_id: PoolId::read_xdr(r)?,
                asset: Asset::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HashIdPreimageRevokeId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.source_account.write_xdr(w)?;
            self.seq_num.write_xdr(w)?;
            self.op_num.write_xdr(w)?;
            self.liquidity_pool_id.write_xdr(w)?;
            self.asset.write_xdr(w)?;
            Ok(())
        })
    }
}

/// HashIdPreimageContractId is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         Hash networkID;
///         ContractIDPreimage contractIDPreimage;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct HashIdPreimageContractId {
    pub network_id: Hash,
    pub contract_id_preimage: ContractIdPreimage,
}

impl ReadXdr for HashIdPreimageContractId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                network_id: Hash::read_xdr(r)?,
                contract_id_preimage: ContractIdPreimage::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HashIdPreimageContractId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.network_id.write_xdr(w)?;
            self.contract_id_preimage.write_xdr(w)?;
            Ok(())
        })
    }
}

/// HashIdPreimageSorobanAuthorization is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         Hash networkID;
///         int64 nonce;
///         uint32 signatureExpirationLedger;
///         SorobanAuthorizedInvocation invocation;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct HashIdPreimageSorobanAuthorization {
    pub network_id: Hash,
    pub nonce: i64,
    pub signature_expiration_ledger: u32,
    pub invocation: SorobanAuthorizedInvocation,
}

impl ReadXdr for HashIdPreimageSorobanAuthorization {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                network_id: Hash::read_xdr(r)?,
                nonce: i64::read_xdr(r)?,
                signature_expiration_ledger: u32::read_xdr(r)?,
                invocation: SorobanAuthorizedInvocation::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HashIdPreimageSorobanAuthorization {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.network_id.write_xdr(w)?;
            self.nonce.write_xdr(w)?;
            self.signature_expiration_ledger.write_xdr(w)?;
            self.invocation.write_xdr(w)?;
            Ok(())
        })
    }
}

/// HashIdPreimage is an XDR Union defines as:
///
/// ```text
/// union HashIDPreimage switch (EnvelopeType type)
/// {
/// case ENVELOPE_TYPE_OP_ID:
///     struct
///     {
///         AccountID sourceAccount;
///         SequenceNumber seqNum;
///         uint32 opNum;
///     } operationID;
/// case ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
///     struct
///     {
///         AccountID sourceAccount;
///         SequenceNumber seqNum;
///         uint32 opNum;
///         PoolID liquidityPoolID;
///         Asset asset;
///     } revokeID;
/// case ENVELOPE_TYPE_CONTRACT_ID:
///     struct
///     {
///         Hash networkID;
///         ContractIDPreimage contractIDPreimage;
///     } contractID;
/// case ENVELOPE_TYPE_SOROBAN_AUTHORIZATION:
///     struct
///     {
///         Hash networkID;
///         int64 nonce;
///         uint32 signatureExpirationLedger;
///         SorobanAuthorizedInvocation invocation;
///     } sorobanAuthorization;
/// };
/// ```
///
// union with discriminant EnvelopeType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum HashIdPreimage {
    OpId(HashIdPreimageOperationId),
    PoolRevokeOpId(HashIdPreimageRevokeId),
    ContractId(HashIdPreimageContractId),
    SorobanAuthorization(HashIdPreimageSorobanAuthorization),
}

impl HashIdPreimage {
    pub const VARIANTS: [EnvelopeType; 4] = [
        EnvelopeType::OpId,
        EnvelopeType::PoolRevokeOpId,
        EnvelopeType::ContractId,
        EnvelopeType::SorobanAuthorization,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "OpId",
        "PoolRevokeOpId",
        "ContractId",
        "SorobanAuthorization",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::OpId(_) => "OpId",
            Self::PoolRevokeOpId(_) => "PoolRevokeOpId",
            Self::ContractId(_) => "ContractId",
            Self::SorobanAuthorization(_) => "SorobanAuthorization",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> EnvelopeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::OpId(_) => EnvelopeType::OpId,
            Self::PoolRevokeOpId(_) => EnvelopeType::PoolRevokeOpId,
            Self::ContractId(_) => EnvelopeType::ContractId,
            Self::SorobanAuthorization(_) => EnvelopeType::SorobanAuthorization,
        }
    }

    #[must_use]
    pub const fn variants() -> [EnvelopeType; 4] {
        Self::VARIANTS
    }
}

impl Name for HashIdPreimage {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<EnvelopeType> for HashIdPreimage {
    #[must_use]
    fn discriminant(&self) -> EnvelopeType {
        Self::discriminant(self)
    }
}

impl Variants<EnvelopeType> for HashIdPreimage {
    fn variants() -> slice::Iter<'static, EnvelopeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<EnvelopeType> for HashIdPreimage {}

impl ReadXdr for HashIdPreimage {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: EnvelopeType = <EnvelopeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                EnvelopeType::OpId => Self::OpId(HashIdPreimageOperationId::read_xdr(r)?),
                EnvelopeType::PoolRevokeOpId => {
                    Self::PoolRevokeOpId(HashIdPreimageRevokeId::read_xdr(r)?)
                }
                EnvelopeType::ContractId => {
                    Self::ContractId(HashIdPreimageContractId::read_xdr(r)?)
                }
                EnvelopeType::SorobanAuthorization => {
                    Self::SorobanAuthorization(HashIdPreimageSorobanAuthorization::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for HashIdPreimage {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::OpId(v) => v.write_xdr(w)?,
                Self::PoolRevokeOpId(v) => v.write_xdr(w)?,
                Self::ContractId(v) => v.write_xdr(w)?,
                Self::SorobanAuthorization(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// MemoType is an XDR Enum defines as:
///
/// ```text
/// enum MemoType
/// {
///     MEMO_NONE = 0,
///     MEMO_TEXT = 1,
///     MEMO_ID = 2,
///     MEMO_HASH = 3,
///     MEMO_RETURN = 4
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum MemoType {
    None = 0,
    Text = 1,
    Id = 2,
    Hash = 3,
    Return = 4,
}

impl MemoType {
    pub const VARIANTS: [MemoType; 5] = [
        MemoType::None,
        MemoType::Text,
        MemoType::Id,
        MemoType::Hash,
        MemoType::Return,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = ["None", "Text", "Id", "Hash", "Return"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::None => "None",
            Self::Text => "Text",
            Self::Id => "Id",
            Self::Hash => "Hash",
            Self::Return => "Return",
        }
    }

    #[must_use]
    pub const fn variants() -> [MemoType; 5] {
        Self::VARIANTS
    }
}

impl Name for MemoType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<MemoType> for MemoType {
    fn variants() -> slice::Iter<'static, MemoType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for MemoType {}

impl fmt::Display for MemoType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for MemoType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => MemoType::None,
            1 => MemoType::Text,
            2 => MemoType::Id,
            3 => MemoType::Hash,
            4 => MemoType::Return,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<MemoType> for i32 {
    #[must_use]
    fn from(e: MemoType) -> Self {
        e as Self
    }
}

impl ReadXdr for MemoType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for MemoType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// Memo is an XDR Union defines as:
///
/// ```text
/// union Memo switch (MemoType type)
/// {
/// case MEMO_NONE:
///     void;
/// case MEMO_TEXT:
///     string text<28>;
/// case MEMO_ID:
///     uint64 id;
/// case MEMO_HASH:
///     Hash hash; // the hash of what to pull from the content server
/// case MEMO_RETURN:
///     Hash retHash; // the hash of the tx you are rejecting
/// };
/// ```
///
// union with discriminant MemoType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum Memo {
    None,
    Text(StringM<28>),
    Id(u64),
    Hash(Hash),
    Return(Hash),
}

impl Memo {
    pub const VARIANTS: [MemoType; 5] = [
        MemoType::None,
        MemoType::Text,
        MemoType::Id,
        MemoType::Hash,
        MemoType::Return,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = ["None", "Text", "Id", "Hash", "Return"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::None => "None",
            Self::Text(_) => "Text",
            Self::Id(_) => "Id",
            Self::Hash(_) => "Hash",
            Self::Return(_) => "Return",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> MemoType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::None => MemoType::None,
            Self::Text(_) => MemoType::Text,
            Self::Id(_) => MemoType::Id,
            Self::Hash(_) => MemoType::Hash,
            Self::Return(_) => MemoType::Return,
        }
    }

    #[must_use]
    pub const fn variants() -> [MemoType; 5] {
        Self::VARIANTS
    }
}

impl Name for Memo {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<MemoType> for Memo {
    #[must_use]
    fn discriminant(&self) -> MemoType {
        Self::discriminant(self)
    }
}

impl Variants<MemoType> for Memo {
    fn variants() -> slice::Iter<'static, MemoType> {
        Self::VARIANTS.iter()
    }
}

impl Union<MemoType> for Memo {}

impl ReadXdr for Memo {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: MemoType = <MemoType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                MemoType::None => Self::None,
                MemoType::Text => Self::Text(StringM::<28>::read_xdr(r)?),
                MemoType::Id => Self::Id(u64::read_xdr(r)?),
                MemoType::Hash => Self::Hash(Hash::read_xdr(r)?),
                MemoType::Return => Self::Return(Hash::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for Memo {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::None => ().write_xdr(w)?,
                Self::Text(v) => v.write_xdr(w)?,
                Self::Id(v) => v.write_xdr(w)?,
                Self::Hash(v) => v.write_xdr(w)?,
                Self::Return(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TimeBounds is an XDR Struct defines as:
///
/// ```text
/// struct TimeBounds
/// {
///     TimePoint minTime;
///     TimePoint maxTime; // 0 here means no maxTime
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TimeBounds {
    pub min_time: TimePoint,
    pub max_time: TimePoint,
}

impl ReadXdr for TimeBounds {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                min_time: TimePoint::read_xdr(r)?,
                max_time: TimePoint::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TimeBounds {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.min_time.write_xdr(w)?;
            self.max_time.write_xdr(w)?;
            Ok(())
        })
    }
}

/// LedgerBounds is an XDR Struct defines as:
///
/// ```text
/// struct LedgerBounds
/// {
///     uint32 minLedger;
///     uint32 maxLedger; // 0 here means no maxLedger
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerBounds {
    pub min_ledger: u32,
    pub max_ledger: u32,
}

impl ReadXdr for LedgerBounds {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                min_ledger: u32::read_xdr(r)?,
                max_ledger: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerBounds {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.min_ledger.write_xdr(w)?;
            self.max_ledger.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PreconditionsV2 is an XDR Struct defines as:
///
/// ```text
/// struct PreconditionsV2
/// {
///     TimeBounds* timeBounds;
///
///     // Transaction only valid for ledger numbers n such that
///     // minLedger <= n < maxLedger (if maxLedger == 0, then
///     // only minLedger is checked)
///     LedgerBounds* ledgerBounds;
///
///     // If NULL, only valid when sourceAccount's sequence number
///     // is seqNum - 1.  Otherwise, valid when sourceAccount's
///     // sequence number n satisfies minSeqNum <= n < tx.seqNum.
///     // Note that after execution the account's sequence number
///     // is always raised to tx.seqNum, and a transaction is not
///     // valid if tx.seqNum is too high to ensure replay protection.
///     SequenceNumber* minSeqNum;
///
///     // For the transaction to be valid, the current ledger time must
///     // be at least minSeqAge greater than sourceAccount's seqTime.
///     Duration minSeqAge;
///
///     // For the transaction to be valid, the current ledger number
///     // must be at least minSeqLedgerGap greater than sourceAccount's
///     // seqLedger.
///     uint32 minSeqLedgerGap;
///
///     // For the transaction to be valid, there must be a signature
///     // corresponding to every Signer in this array, even if the
///     // signature is not otherwise required by the sourceAccount or
///     // operations.
///     SignerKey extraSigners<2>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct PreconditionsV2 {
    pub time_bounds: Option<TimeBounds>,
    pub ledger_bounds: Option<LedgerBounds>,
    pub min_seq_num: Option<SequenceNumber>,
    pub min_seq_age: Duration,
    pub min_seq_ledger_gap: u32,
    pub extra_signers: VecM<SignerKey, 2>,
}

impl ReadXdr for PreconditionsV2 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                time_bounds: Option::<TimeBounds>::read_xdr(r)?,
                ledger_bounds: Option::<LedgerBounds>::read_xdr(r)?,
                min_seq_num: Option::<SequenceNumber>::read_xdr(r)?,
                min_seq_age: Duration::read_xdr(r)?,
                min_seq_ledger_gap: u32::read_xdr(r)?,
                extra_signers: VecM::<SignerKey, 2>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PreconditionsV2 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.time_bounds.write_xdr(w)?;
            self.ledger_bounds.write_xdr(w)?;
            self.min_seq_num.write_xdr(w)?;
            self.min_seq_age.write_xdr(w)?;
            self.min_seq_ledger_gap.write_xdr(w)?;
            self.extra_signers.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PreconditionType is an XDR Enum defines as:
///
/// ```text
/// enum PreconditionType
/// {
///     PRECOND_NONE = 0,
///     PRECOND_TIME = 1,
///     PRECOND_V2 = 2
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum PreconditionType {
    None = 0,
    Time = 1,
    V2 = 2,
}

impl PreconditionType {
    pub const VARIANTS: [PreconditionType; 3] = [
        PreconditionType::None,
        PreconditionType::Time,
        PreconditionType::V2,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["None", "Time", "V2"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::None => "None",
            Self::Time => "Time",
            Self::V2 => "V2",
        }
    }

    #[must_use]
    pub const fn variants() -> [PreconditionType; 3] {
        Self::VARIANTS
    }
}

impl Name for PreconditionType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<PreconditionType> for PreconditionType {
    fn variants() -> slice::Iter<'static, PreconditionType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for PreconditionType {}

impl fmt::Display for PreconditionType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for PreconditionType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => PreconditionType::None,
            1 => PreconditionType::Time,
            2 => PreconditionType::V2,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<PreconditionType> for i32 {
    #[must_use]
    fn from(e: PreconditionType) -> Self {
        e as Self
    }
}

impl ReadXdr for PreconditionType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for PreconditionType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// Preconditions is an XDR Union defines as:
///
/// ```text
/// union Preconditions switch (PreconditionType type)
/// {
/// case PRECOND_NONE:
///     void;
/// case PRECOND_TIME:
///     TimeBounds timeBounds;
/// case PRECOND_V2:
///     PreconditionsV2 v2;
/// };
/// ```
///
// union with discriminant PreconditionType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum Preconditions {
    None,
    Time(TimeBounds),
    V2(PreconditionsV2),
}

impl Preconditions {
    pub const VARIANTS: [PreconditionType; 3] = [
        PreconditionType::None,
        PreconditionType::Time,
        PreconditionType::V2,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["None", "Time", "V2"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::None => "None",
            Self::Time(_) => "Time",
            Self::V2(_) => "V2",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> PreconditionType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::None => PreconditionType::None,
            Self::Time(_) => PreconditionType::Time,
            Self::V2(_) => PreconditionType::V2,
        }
    }

    #[must_use]
    pub const fn variants() -> [PreconditionType; 3] {
        Self::VARIANTS
    }
}

impl Name for Preconditions {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<PreconditionType> for Preconditions {
    #[must_use]
    fn discriminant(&self) -> PreconditionType {
        Self::discriminant(self)
    }
}

impl Variants<PreconditionType> for Preconditions {
    fn variants() -> slice::Iter<'static, PreconditionType> {
        Self::VARIANTS.iter()
    }
}

impl Union<PreconditionType> for Preconditions {}

impl ReadXdr for Preconditions {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: PreconditionType = <PreconditionType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                PreconditionType::None => Self::None,
                PreconditionType::Time => Self::Time(TimeBounds::read_xdr(r)?),
                PreconditionType::V2 => Self::V2(PreconditionsV2::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for Preconditions {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::None => ().write_xdr(w)?,
                Self::Time(v) => v.write_xdr(w)?,
                Self::V2(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LedgerFootprint is an XDR Struct defines as:
///
/// ```text
/// struct LedgerFootprint
/// {
///     LedgerKey readOnly<>;
///     LedgerKey readWrite<>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct LedgerFootprint {
    pub read_only: VecM<LedgerKey>,
    pub read_write: VecM<LedgerKey>,
}

impl ReadXdr for LedgerFootprint {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                read_only: VecM::<LedgerKey>::read_xdr(r)?,
                read_write: VecM::<LedgerKey>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for LedgerFootprint {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.read_only.write_xdr(w)?;
            self.read_write.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SorobanResources is an XDR Struct defines as:
///
/// ```text
/// struct SorobanResources
/// {   
///     // The ledger footprint of the transaction.
///     LedgerFootprint footprint;
///     // The maximum number of instructions this transaction can use
///     uint32 instructions;
///
///     // The maximum number of bytes this transaction can read from ledger
///     uint32 readBytes;
///     // The maximum number of bytes this transaction can write to ledger
///     uint32 writeBytes;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SorobanResources {
    pub footprint: LedgerFootprint,
    pub instructions: u32,
    pub read_bytes: u32,
    pub write_bytes: u32,
}

impl ReadXdr for SorobanResources {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                footprint: LedgerFootprint::read_xdr(r)?,
                instructions: u32::read_xdr(r)?,
                read_bytes: u32::read_xdr(r)?,
                write_bytes: u32::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanResources {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.footprint.write_xdr(w)?;
            self.instructions.write_xdr(w)?;
            self.read_bytes.write_xdr(w)?;
            self.write_bytes.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SorobanTransactionData is an XDR Struct defines as:
///
/// ```text
/// struct SorobanTransactionData
/// {
///     ExtensionPoint ext;
///     SorobanResources resources;
///     // Amount of the transaction `fee` allocated to the Soroban resource fees.
///     // The fraction of `resourceFee` corresponding to `resources` specified
///     // above is *not* refundable (i.e. fees for instructions, ledger I/O), as
///     // well as fees for the transaction size.
///     // The remaining part of the fee is refundable and the charged value is
///     // based on the actual consumption of refundable resources (events, ledger
///     // rent bumps).
///     // The `inclusionFee` used for prioritization of the transaction is defined
///     // as `tx.fee - resourceFee`.
///     int64 resourceFee;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SorobanTransactionData {
    pub ext: ExtensionPoint,
    pub resources: SorobanResources,
    pub resource_fee: i64,
}

impl ReadXdr for SorobanTransactionData {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ext: ExtensionPoint::read_xdr(r)?,
                resources: SorobanResources::read_xdr(r)?,
                resource_fee: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SorobanTransactionData {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ext.write_xdr(w)?;
            self.resources.write_xdr(w)?;
            self.resource_fee.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionV0Ext is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TransactionV0Ext {
    V0,
}

impl TransactionV0Ext {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for TransactionV0Ext {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionV0Ext {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionV0Ext {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionV0Ext {}

impl ReadXdr for TransactionV0Ext {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionV0Ext {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionV0 is an XDR Struct defines as:
///
/// ```text
/// struct TransactionV0
/// {
///     uint256 sourceAccountEd25519;
///     uint32 fee;
///     SequenceNumber seqNum;
///     TimeBounds* timeBounds;
///     Memo memo;
///     Operation operations<MAX_OPS_PER_TX>;
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionV0 {
    pub source_account_ed25519: Uint256,
    pub fee: u32,
    pub seq_num: SequenceNumber,
    pub time_bounds: Option<TimeBounds>,
    pub memo: Memo,
    pub operations: VecM<Operation, 100>,
    pub ext: TransactionV0Ext,
}

impl ReadXdr for TransactionV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                source_account_ed25519: Uint256::read_xdr(r)?,
                fee: u32::read_xdr(r)?,
                seq_num: SequenceNumber::read_xdr(r)?,
                time_bounds: Option::<TimeBounds>::read_xdr(r)?,
                memo: Memo::read_xdr(r)?,
                operations: VecM::<Operation, 100>::read_xdr(r)?,
                ext: TransactionV0Ext::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.source_account_ed25519.write_xdr(w)?;
            self.fee.write_xdr(w)?;
            self.seq_num.write_xdr(w)?;
            self.time_bounds.write_xdr(w)?;
            self.memo.write_xdr(w)?;
            self.operations.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionV0Envelope is an XDR Struct defines as:
///
/// ```text
/// struct TransactionV0Envelope
/// {
///     TransactionV0 tx;
///     /* Each decorated signature is a signature over the SHA256 hash of
///      * a TransactionSignaturePayload */
///     DecoratedSignature signatures<20>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionV0Envelope {
    pub tx: TransactionV0,
    pub signatures: VecM<DecoratedSignature, 20>,
}

impl ReadXdr for TransactionV0Envelope {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx: TransactionV0::read_xdr(r)?,
                signatures: VecM::<DecoratedSignature, 20>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionV0Envelope {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.tx.write_xdr(w)?;
            self.signatures.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         SorobanTransactionData sorobanData;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TransactionExt {
    V0,
    V1(SorobanTransactionData),
}

impl TransactionExt {
    pub const VARIANTS: [i32; 2] = [0, 1];
    pub const VARIANTS_STR: [&'static str; 2] = ["V0", "V1"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::V1(_) => "V1",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
            Self::V1(_) => 1,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 2] {
        Self::VARIANTS
    }
}

impl Name for TransactionExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionExt {}

impl ReadXdr for TransactionExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                1 => Self::V1(SorobanTransactionData::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
                Self::V1(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// Transaction is an XDR Struct defines as:
///
/// ```text
/// struct Transaction
/// {
///     // account used to run the transaction
///     MuxedAccount sourceAccount;
///
///     // the fee the sourceAccount will pay
///     uint32 fee;
///
///     // sequence number to consume in the account
///     SequenceNumber seqNum;
///
///     // validity conditions
///     Preconditions cond;
///
///     Memo memo;
///
///     Operation operations<MAX_OPS_PER_TX>;
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     case 1:
///         SorobanTransactionData sorobanData;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Transaction {
    pub source_account: MuxedAccount,
    pub fee: u32,
    pub seq_num: SequenceNumber,
    pub cond: Preconditions,
    pub memo: Memo,
    pub operations: VecM<Operation, 100>,
    pub ext: TransactionExt,
}

impl ReadXdr for Transaction {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                source_account: MuxedAccount::read_xdr(r)?,
                fee: u32::read_xdr(r)?,
                seq_num: SequenceNumber::read_xdr(r)?,
                cond: Preconditions::read_xdr(r)?,
                memo: Memo::read_xdr(r)?,
                operations: VecM::<Operation, 100>::read_xdr(r)?,
                ext: TransactionExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Transaction {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.source_account.write_xdr(w)?;
            self.fee.write_xdr(w)?;
            self.seq_num.write_xdr(w)?;
            self.cond.write_xdr(w)?;
            self.memo.write_xdr(w)?;
            self.operations.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionV1Envelope is an XDR Struct defines as:
///
/// ```text
/// struct TransactionV1Envelope
/// {
///     Transaction tx;
///     /* Each decorated signature is a signature over the SHA256 hash of
///      * a TransactionSignaturePayload */
///     DecoratedSignature signatures<20>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionV1Envelope {
    pub tx: Transaction,
    pub signatures: VecM<DecoratedSignature, 20>,
}

impl ReadXdr for TransactionV1Envelope {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx: Transaction::read_xdr(r)?,
                signatures: VecM::<DecoratedSignature, 20>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionV1Envelope {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.tx.write_xdr(w)?;
            self.signatures.write_xdr(w)?;
            Ok(())
        })
    }
}

/// FeeBumpTransactionInnerTx is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (EnvelopeType type)
///     {
///     case ENVELOPE_TYPE_TX:
///         TransactionV1Envelope v1;
///     }
/// ```
///
// union with discriminant EnvelopeType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum FeeBumpTransactionInnerTx {
    Tx(TransactionV1Envelope),
}

impl FeeBumpTransactionInnerTx {
    pub const VARIANTS: [EnvelopeType; 1] = [EnvelopeType::Tx];
    pub const VARIANTS_STR: [&'static str; 1] = ["Tx"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Tx(_) => "Tx",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> EnvelopeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Tx(_) => EnvelopeType::Tx,
        }
    }

    #[must_use]
    pub const fn variants() -> [EnvelopeType; 1] {
        Self::VARIANTS
    }
}

impl Name for FeeBumpTransactionInnerTx {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<EnvelopeType> for FeeBumpTransactionInnerTx {
    #[must_use]
    fn discriminant(&self) -> EnvelopeType {
        Self::discriminant(self)
    }
}

impl Variants<EnvelopeType> for FeeBumpTransactionInnerTx {
    fn variants() -> slice::Iter<'static, EnvelopeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<EnvelopeType> for FeeBumpTransactionInnerTx {}

impl ReadXdr for FeeBumpTransactionInnerTx {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: EnvelopeType = <EnvelopeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                EnvelopeType::Tx => Self::Tx(TransactionV1Envelope::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for FeeBumpTransactionInnerTx {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Tx(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// FeeBumpTransactionExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum FeeBumpTransactionExt {
    V0,
}

impl FeeBumpTransactionExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for FeeBumpTransactionExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for FeeBumpTransactionExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for FeeBumpTransactionExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for FeeBumpTransactionExt {}

impl ReadXdr for FeeBumpTransactionExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for FeeBumpTransactionExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// FeeBumpTransaction is an XDR Struct defines as:
///
/// ```text
/// struct FeeBumpTransaction
/// {
///     MuxedAccount feeSource;
///     int64 fee;
///     union switch (EnvelopeType type)
///     {
///     case ENVELOPE_TYPE_TX:
///         TransactionV1Envelope v1;
///     }
///     innerTx;
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct FeeBumpTransaction {
    pub fee_source: MuxedAccount,
    pub fee: i64,
    pub inner_tx: FeeBumpTransactionInnerTx,
    pub ext: FeeBumpTransactionExt,
}

impl ReadXdr for FeeBumpTransaction {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                fee_source: MuxedAccount::read_xdr(r)?,
                fee: i64::read_xdr(r)?,
                inner_tx: FeeBumpTransactionInnerTx::read_xdr(r)?,
                ext: FeeBumpTransactionExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for FeeBumpTransaction {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.fee_source.write_xdr(w)?;
            self.fee.write_xdr(w)?;
            self.inner_tx.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// FeeBumpTransactionEnvelope is an XDR Struct defines as:
///
/// ```text
/// struct FeeBumpTransactionEnvelope
/// {
///     FeeBumpTransaction tx;
///     /* Each decorated signature is a signature over the SHA256 hash of
///      * a TransactionSignaturePayload */
///     DecoratedSignature signatures<20>;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct FeeBumpTransactionEnvelope {
    pub tx: FeeBumpTransaction,
    pub signatures: VecM<DecoratedSignature, 20>,
}

impl ReadXdr for FeeBumpTransactionEnvelope {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                tx: FeeBumpTransaction::read_xdr(r)?,
                signatures: VecM::<DecoratedSignature, 20>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for FeeBumpTransactionEnvelope {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.tx.write_xdr(w)?;
            self.signatures.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionEnvelope is an XDR Union defines as:
///
/// ```text
/// union TransactionEnvelope switch (EnvelopeType type)
/// {
/// case ENVELOPE_TYPE_TX_V0:
///     TransactionV0Envelope v0;
/// case ENVELOPE_TYPE_TX:
///     TransactionV1Envelope v1;
/// case ENVELOPE_TYPE_TX_FEE_BUMP:
///     FeeBumpTransactionEnvelope feeBump;
/// };
/// ```
///
// union with discriminant EnvelopeType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TransactionEnvelope {
    TxV0(TransactionV0Envelope),
    Tx(TransactionV1Envelope),
    TxFeeBump(FeeBumpTransactionEnvelope),
}

impl TransactionEnvelope {
    pub const VARIANTS: [EnvelopeType; 3] = [
        EnvelopeType::TxV0,
        EnvelopeType::Tx,
        EnvelopeType::TxFeeBump,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["TxV0", "Tx", "TxFeeBump"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxV0(_) => "TxV0",
            Self::Tx(_) => "Tx",
            Self::TxFeeBump(_) => "TxFeeBump",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> EnvelopeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::TxV0(_) => EnvelopeType::TxV0,
            Self::Tx(_) => EnvelopeType::Tx,
            Self::TxFeeBump(_) => EnvelopeType::TxFeeBump,
        }
    }

    #[must_use]
    pub const fn variants() -> [EnvelopeType; 3] {
        Self::VARIANTS
    }
}

impl Name for TransactionEnvelope {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<EnvelopeType> for TransactionEnvelope {
    #[must_use]
    fn discriminant(&self) -> EnvelopeType {
        Self::discriminant(self)
    }
}

impl Variants<EnvelopeType> for TransactionEnvelope {
    fn variants() -> slice::Iter<'static, EnvelopeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<EnvelopeType> for TransactionEnvelope {}

impl ReadXdr for TransactionEnvelope {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: EnvelopeType = <EnvelopeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                EnvelopeType::TxV0 => Self::TxV0(TransactionV0Envelope::read_xdr(r)?),
                EnvelopeType::Tx => Self::Tx(TransactionV1Envelope::read_xdr(r)?),
                EnvelopeType::TxFeeBump => {
                    Self::TxFeeBump(FeeBumpTransactionEnvelope::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionEnvelope {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::TxV0(v) => v.write_xdr(w)?,
                Self::Tx(v) => v.write_xdr(w)?,
                Self::TxFeeBump(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionSignaturePayloadTaggedTransaction is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (EnvelopeType type)
///     {
///     // Backwards Compatibility: Use ENVELOPE_TYPE_TX to sign ENVELOPE_TYPE_TX_V0
///     case ENVELOPE_TYPE_TX:
///         Transaction tx;
///     case ENVELOPE_TYPE_TX_FEE_BUMP:
///         FeeBumpTransaction feeBump;
///     }
/// ```
///
// union with discriminant EnvelopeType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TransactionSignaturePayloadTaggedTransaction {
    Tx(Transaction),
    TxFeeBump(FeeBumpTransaction),
}

impl TransactionSignaturePayloadTaggedTransaction {
    pub const VARIANTS: [EnvelopeType; 2] = [EnvelopeType::Tx, EnvelopeType::TxFeeBump];
    pub const VARIANTS_STR: [&'static str; 2] = ["Tx", "TxFeeBump"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Tx(_) => "Tx",
            Self::TxFeeBump(_) => "TxFeeBump",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> EnvelopeType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Tx(_) => EnvelopeType::Tx,
            Self::TxFeeBump(_) => EnvelopeType::TxFeeBump,
        }
    }

    #[must_use]
    pub const fn variants() -> [EnvelopeType; 2] {
        Self::VARIANTS
    }
}

impl Name for TransactionSignaturePayloadTaggedTransaction {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<EnvelopeType> for TransactionSignaturePayloadTaggedTransaction {
    #[must_use]
    fn discriminant(&self) -> EnvelopeType {
        Self::discriminant(self)
    }
}

impl Variants<EnvelopeType> for TransactionSignaturePayloadTaggedTransaction {
    fn variants() -> slice::Iter<'static, EnvelopeType> {
        Self::VARIANTS.iter()
    }
}

impl Union<EnvelopeType> for TransactionSignaturePayloadTaggedTransaction {}

impl ReadXdr for TransactionSignaturePayloadTaggedTransaction {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: EnvelopeType = <EnvelopeType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                EnvelopeType::Tx => Self::Tx(Transaction::read_xdr(r)?),
                EnvelopeType::TxFeeBump => Self::TxFeeBump(FeeBumpTransaction::read_xdr(r)?),
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionSignaturePayloadTaggedTransaction {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Tx(v) => v.write_xdr(w)?,
                Self::TxFeeBump(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionSignaturePayload is an XDR Struct defines as:
///
/// ```text
/// struct TransactionSignaturePayload
/// {
///     Hash networkId;
///     union switch (EnvelopeType type)
///     {
///     // Backwards Compatibility: Use ENVELOPE_TYPE_TX to sign ENVELOPE_TYPE_TX_V0
///     case ENVELOPE_TYPE_TX:
///         Transaction tx;
///     case ENVELOPE_TYPE_TX_FEE_BUMP:
///         FeeBumpTransaction feeBump;
///     }
///     taggedTransaction;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionSignaturePayload {
    pub network_id: Hash,
    pub tagged_transaction: TransactionSignaturePayloadTaggedTransaction,
}

impl ReadXdr for TransactionSignaturePayload {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                network_id: Hash::read_xdr(r)?,
                tagged_transaction: TransactionSignaturePayloadTaggedTransaction::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionSignaturePayload {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.network_id.write_xdr(w)?;
            self.tagged_transaction.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ClaimAtomType is an XDR Enum defines as:
///
/// ```text
/// enum ClaimAtomType
/// {
///     CLAIM_ATOM_TYPE_V0 = 0,
///     CLAIM_ATOM_TYPE_ORDER_BOOK = 1,
///     CLAIM_ATOM_TYPE_LIQUIDITY_POOL = 2
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ClaimAtomType {
    V0 = 0,
    OrderBook = 1,
    LiquidityPool = 2,
}

impl ClaimAtomType {
    pub const VARIANTS: [ClaimAtomType; 3] = [
        ClaimAtomType::V0,
        ClaimAtomType::OrderBook,
        ClaimAtomType::LiquidityPool,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["V0", "OrderBook", "LiquidityPool"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
            Self::OrderBook => "OrderBook",
            Self::LiquidityPool => "LiquidityPool",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimAtomType; 3] {
        Self::VARIANTS
    }
}

impl Name for ClaimAtomType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimAtomType> for ClaimAtomType {
    fn variants() -> slice::Iter<'static, ClaimAtomType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimAtomType {}

impl fmt::Display for ClaimAtomType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimAtomType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ClaimAtomType::V0,
            1 => ClaimAtomType::OrderBook,
            2 => ClaimAtomType::LiquidityPool,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimAtomType> for i32 {
    #[must_use]
    fn from(e: ClaimAtomType) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimAtomType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimAtomType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClaimOfferAtomV0 is an XDR Struct defines as:
///
/// ```text
/// struct ClaimOfferAtomV0
/// {
///     // emitted to identify the offer
///     uint256 sellerEd25519; // Account that owns the offer
///     int64 offerID;
///
///     // amount and asset taken from the owner
///     Asset assetSold;
///     int64 amountSold;
///
///     // amount and asset sent to the owner
///     Asset assetBought;
///     int64 amountBought;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ClaimOfferAtomV0 {
    pub seller_ed25519: Uint256,
    pub offer_id: i64,
    pub asset_sold: Asset,
    pub amount_sold: i64,
    pub asset_bought: Asset,
    pub amount_bought: i64,
}

impl ReadXdr for ClaimOfferAtomV0 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                seller_ed25519: Uint256::read_xdr(r)?,
                offer_id: i64::read_xdr(r)?,
                asset_sold: Asset::read_xdr(r)?,
                amount_sold: i64::read_xdr(r)?,
                asset_bought: Asset::read_xdr(r)?,
                amount_bought: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimOfferAtomV0 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.seller_ed25519.write_xdr(w)?;
            self.offer_id.write_xdr(w)?;
            self.asset_sold.write_xdr(w)?;
            self.amount_sold.write_xdr(w)?;
            self.asset_bought.write_xdr(w)?;
            self.amount_bought.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ClaimOfferAtom is an XDR Struct defines as:
///
/// ```text
/// struct ClaimOfferAtom
/// {
///     // emitted to identify the offer
///     AccountID sellerID; // Account that owns the offer
///     int64 offerID;
///
///     // amount and asset taken from the owner
///     Asset assetSold;
///     int64 amountSold;
///
///     // amount and asset sent to the owner
///     Asset assetBought;
///     int64 amountBought;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ClaimOfferAtom {
    pub seller_id: AccountId,
    pub offer_id: i64,
    pub asset_sold: Asset,
    pub amount_sold: i64,
    pub asset_bought: Asset,
    pub amount_bought: i64,
}

impl ReadXdr for ClaimOfferAtom {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                seller_id: AccountId::read_xdr(r)?,
                offer_id: i64::read_xdr(r)?,
                asset_sold: Asset::read_xdr(r)?,
                amount_sold: i64::read_xdr(r)?,
                asset_bought: Asset::read_xdr(r)?,
                amount_bought: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimOfferAtom {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.seller_id.write_xdr(w)?;
            self.offer_id.write_xdr(w)?;
            self.asset_sold.write_xdr(w)?;
            self.amount_sold.write_xdr(w)?;
            self.asset_bought.write_xdr(w)?;
            self.amount_bought.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ClaimLiquidityAtom is an XDR Struct defines as:
///
/// ```text
/// struct ClaimLiquidityAtom
/// {
///     PoolID liquidityPoolID;
///
///     // amount and asset taken from the pool
///     Asset assetSold;
///     int64 amountSold;
///
///     // amount and asset sent to the pool
///     Asset assetBought;
///     int64 amountBought;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ClaimLiquidityAtom {
    pub liquidity_pool_id: PoolId,
    pub asset_sold: Asset,
    pub amount_sold: i64,
    pub asset_bought: Asset,
    pub amount_bought: i64,
}

impl ReadXdr for ClaimLiquidityAtom {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                liquidity_pool_id: PoolId::read_xdr(r)?,
                asset_sold: Asset::read_xdr(r)?,
                amount_sold: i64::read_xdr(r)?,
                asset_bought: Asset::read_xdr(r)?,
                amount_bought: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ClaimLiquidityAtom {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.liquidity_pool_id.write_xdr(w)?;
            self.asset_sold.write_xdr(w)?;
            self.amount_sold.write_xdr(w)?;
            self.asset_bought.write_xdr(w)?;
            self.amount_bought.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ClaimAtom is an XDR Union defines as:
///
/// ```text
/// union ClaimAtom switch (ClaimAtomType type)
/// {
/// case CLAIM_ATOM_TYPE_V0:
///     ClaimOfferAtomV0 v0;
/// case CLAIM_ATOM_TYPE_ORDER_BOOK:
///     ClaimOfferAtom orderBook;
/// case CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
///     ClaimLiquidityAtom liquidityPool;
/// };
/// ```
///
// union with discriminant ClaimAtomType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ClaimAtom {
    V0(ClaimOfferAtomV0),
    OrderBook(ClaimOfferAtom),
    LiquidityPool(ClaimLiquidityAtom),
}

impl ClaimAtom {
    pub const VARIANTS: [ClaimAtomType; 3] = [
        ClaimAtomType::V0,
        ClaimAtomType::OrderBook,
        ClaimAtomType::LiquidityPool,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["V0", "OrderBook", "LiquidityPool"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0(_) => "V0",
            Self::OrderBook(_) => "OrderBook",
            Self::LiquidityPool(_) => "LiquidityPool",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClaimAtomType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0(_) => ClaimAtomType::V0,
            Self::OrderBook(_) => ClaimAtomType::OrderBook,
            Self::LiquidityPool(_) => ClaimAtomType::LiquidityPool,
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimAtomType; 3] {
        Self::VARIANTS
    }
}

impl Name for ClaimAtom {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClaimAtomType> for ClaimAtom {
    #[must_use]
    fn discriminant(&self) -> ClaimAtomType {
        Self::discriminant(self)
    }
}

impl Variants<ClaimAtomType> for ClaimAtom {
    fn variants() -> slice::Iter<'static, ClaimAtomType> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClaimAtomType> for ClaimAtom {}

impl ReadXdr for ClaimAtom {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ClaimAtomType = <ClaimAtomType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClaimAtomType::V0 => Self::V0(ClaimOfferAtomV0::read_xdr(r)?),
                ClaimAtomType::OrderBook => Self::OrderBook(ClaimOfferAtom::read_xdr(r)?),
                ClaimAtomType::LiquidityPool => {
                    Self::LiquidityPool(ClaimLiquidityAtom::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimAtom {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0(v) => v.write_xdr(w)?,
                Self::OrderBook(v) => v.write_xdr(w)?,
                Self::LiquidityPool(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// CreateAccountResultCode is an XDR Enum defines as:
///
/// ```text
/// enum CreateAccountResultCode
/// {
///     // codes considered as "success" for the operation
///     CREATE_ACCOUNT_SUCCESS = 0, // account was created
///
///     // codes considered as "failure" for the operation
///     CREATE_ACCOUNT_MALFORMED = -1,   // invalid destination
///     CREATE_ACCOUNT_UNDERFUNDED = -2, // not enough funds in source account
///     CREATE_ACCOUNT_LOW_RESERVE =
///         -3, // would create an account below the min reserve
///     CREATE_ACCOUNT_ALREADY_EXIST = -4 // account already exists
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum CreateAccountResultCode {
    Success = 0,
    Malformed = -1,
    Underfunded = -2,
    LowReserve = -3,
    AlreadyExist = -4,
}

impl CreateAccountResultCode {
    pub const VARIANTS: [CreateAccountResultCode; 5] = [
        CreateAccountResultCode::Success,
        CreateAccountResultCode::Malformed,
        CreateAccountResultCode::Underfunded,
        CreateAccountResultCode::LowReserve,
        CreateAccountResultCode::AlreadyExist,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "Success",
        "Malformed",
        "Underfunded",
        "LowReserve",
        "AlreadyExist",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::Underfunded => "Underfunded",
            Self::LowReserve => "LowReserve",
            Self::AlreadyExist => "AlreadyExist",
        }
    }

    #[must_use]
    pub const fn variants() -> [CreateAccountResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for CreateAccountResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<CreateAccountResultCode> for CreateAccountResultCode {
    fn variants() -> slice::Iter<'static, CreateAccountResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for CreateAccountResultCode {}

impl fmt::Display for CreateAccountResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for CreateAccountResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => CreateAccountResultCode::Success,
            -1 => CreateAccountResultCode::Malformed,
            -2 => CreateAccountResultCode::Underfunded,
            -3 => CreateAccountResultCode::LowReserve,
            -4 => CreateAccountResultCode::AlreadyExist,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<CreateAccountResultCode> for i32 {
    #[must_use]
    fn from(e: CreateAccountResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for CreateAccountResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for CreateAccountResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// CreateAccountResult is an XDR Union defines as:
///
/// ```text
/// union CreateAccountResult switch (CreateAccountResultCode code)
/// {
/// case CREATE_ACCOUNT_SUCCESS:
///     void;
/// case CREATE_ACCOUNT_MALFORMED:
/// case CREATE_ACCOUNT_UNDERFUNDED:
/// case CREATE_ACCOUNT_LOW_RESERVE:
/// case CREATE_ACCOUNT_ALREADY_EXIST:
///     void;
/// };
/// ```
///
// union with discriminant CreateAccountResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum CreateAccountResult {
    Success,
    Malformed,
    Underfunded,
    LowReserve,
    AlreadyExist,
}

impl CreateAccountResult {
    pub const VARIANTS: [CreateAccountResultCode; 5] = [
        CreateAccountResultCode::Success,
        CreateAccountResultCode::Malformed,
        CreateAccountResultCode::Underfunded,
        CreateAccountResultCode::LowReserve,
        CreateAccountResultCode::AlreadyExist,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "Success",
        "Malformed",
        "Underfunded",
        "LowReserve",
        "AlreadyExist",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::Underfunded => "Underfunded",
            Self::LowReserve => "LowReserve",
            Self::AlreadyExist => "AlreadyExist",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> CreateAccountResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => CreateAccountResultCode::Success,
            Self::Malformed => CreateAccountResultCode::Malformed,
            Self::Underfunded => CreateAccountResultCode::Underfunded,
            Self::LowReserve => CreateAccountResultCode::LowReserve,
            Self::AlreadyExist => CreateAccountResultCode::AlreadyExist,
        }
    }

    #[must_use]
    pub const fn variants() -> [CreateAccountResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for CreateAccountResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<CreateAccountResultCode> for CreateAccountResult {
    #[must_use]
    fn discriminant(&self) -> CreateAccountResultCode {
        Self::discriminant(self)
    }
}

impl Variants<CreateAccountResultCode> for CreateAccountResult {
    fn variants() -> slice::Iter<'static, CreateAccountResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<CreateAccountResultCode> for CreateAccountResult {}

impl ReadXdr for CreateAccountResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: CreateAccountResultCode = <CreateAccountResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                CreateAccountResultCode::Success => Self::Success,
                CreateAccountResultCode::Malformed => Self::Malformed,
                CreateAccountResultCode::Underfunded => Self::Underfunded,
                CreateAccountResultCode::LowReserve => Self::LowReserve,
                CreateAccountResultCode::AlreadyExist => Self::AlreadyExist,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for CreateAccountResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::Underfunded => ().write_xdr(w)?,
                Self::LowReserve => ().write_xdr(w)?,
                Self::AlreadyExist => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// PaymentResultCode is an XDR Enum defines as:
///
/// ```text
/// enum PaymentResultCode
/// {
///     // codes considered as "success" for the operation
///     PAYMENT_SUCCESS = 0, // payment successfully completed
///
///     // codes considered as "failure" for the operation
///     PAYMENT_MALFORMED = -1,          // bad input
///     PAYMENT_UNDERFUNDED = -2,        // not enough funds in source account
///     PAYMENT_SRC_NO_TRUST = -3,       // no trust line on source account
///     PAYMENT_SRC_NOT_AUTHORIZED = -4, // source not authorized to transfer
///     PAYMENT_NO_DESTINATION = -5,     // destination account does not exist
///     PAYMENT_NO_TRUST = -6,       // destination missing a trust line for asset
///     PAYMENT_NOT_AUTHORIZED = -7, // destination not authorized to hold asset
///     PAYMENT_LINE_FULL = -8,      // destination would go above their limit
///     PAYMENT_NO_ISSUER = -9       // missing issuer on asset
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum PaymentResultCode {
    Success = 0,
    Malformed = -1,
    Underfunded = -2,
    SrcNoTrust = -3,
    SrcNotAuthorized = -4,
    NoDestination = -5,
    NoTrust = -6,
    NotAuthorized = -7,
    LineFull = -8,
    NoIssuer = -9,
}

impl PaymentResultCode {
    pub const VARIANTS: [PaymentResultCode; 10] = [
        PaymentResultCode::Success,
        PaymentResultCode::Malformed,
        PaymentResultCode::Underfunded,
        PaymentResultCode::SrcNoTrust,
        PaymentResultCode::SrcNotAuthorized,
        PaymentResultCode::NoDestination,
        PaymentResultCode::NoTrust,
        PaymentResultCode::NotAuthorized,
        PaymentResultCode::LineFull,
        PaymentResultCode::NoIssuer,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "Success",
        "Malformed",
        "Underfunded",
        "SrcNoTrust",
        "SrcNotAuthorized",
        "NoDestination",
        "NoTrust",
        "NotAuthorized",
        "LineFull",
        "NoIssuer",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::Underfunded => "Underfunded",
            Self::SrcNoTrust => "SrcNoTrust",
            Self::SrcNotAuthorized => "SrcNotAuthorized",
            Self::NoDestination => "NoDestination",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
            Self::LineFull => "LineFull",
            Self::NoIssuer => "NoIssuer",
        }
    }

    #[must_use]
    pub const fn variants() -> [PaymentResultCode; 10] {
        Self::VARIANTS
    }
}

impl Name for PaymentResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<PaymentResultCode> for PaymentResultCode {
    fn variants() -> slice::Iter<'static, PaymentResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for PaymentResultCode {}

impl fmt::Display for PaymentResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for PaymentResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => PaymentResultCode::Success,
            -1 => PaymentResultCode::Malformed,
            -2 => PaymentResultCode::Underfunded,
            -3 => PaymentResultCode::SrcNoTrust,
            -4 => PaymentResultCode::SrcNotAuthorized,
            -5 => PaymentResultCode::NoDestination,
            -6 => PaymentResultCode::NoTrust,
            -7 => PaymentResultCode::NotAuthorized,
            -8 => PaymentResultCode::LineFull,
            -9 => PaymentResultCode::NoIssuer,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<PaymentResultCode> for i32 {
    #[must_use]
    fn from(e: PaymentResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for PaymentResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for PaymentResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// PaymentResult is an XDR Union defines as:
///
/// ```text
/// union PaymentResult switch (PaymentResultCode code)
/// {
/// case PAYMENT_SUCCESS:
///     void;
/// case PAYMENT_MALFORMED:
/// case PAYMENT_UNDERFUNDED:
/// case PAYMENT_SRC_NO_TRUST:
/// case PAYMENT_SRC_NOT_AUTHORIZED:
/// case PAYMENT_NO_DESTINATION:
/// case PAYMENT_NO_TRUST:
/// case PAYMENT_NOT_AUTHORIZED:
/// case PAYMENT_LINE_FULL:
/// case PAYMENT_NO_ISSUER:
///     void;
/// };
/// ```
///
// union with discriminant PaymentResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum PaymentResult {
    Success,
    Malformed,
    Underfunded,
    SrcNoTrust,
    SrcNotAuthorized,
    NoDestination,
    NoTrust,
    NotAuthorized,
    LineFull,
    NoIssuer,
}

impl PaymentResult {
    pub const VARIANTS: [PaymentResultCode; 10] = [
        PaymentResultCode::Success,
        PaymentResultCode::Malformed,
        PaymentResultCode::Underfunded,
        PaymentResultCode::SrcNoTrust,
        PaymentResultCode::SrcNotAuthorized,
        PaymentResultCode::NoDestination,
        PaymentResultCode::NoTrust,
        PaymentResultCode::NotAuthorized,
        PaymentResultCode::LineFull,
        PaymentResultCode::NoIssuer,
    ];
    pub const VARIANTS_STR: [&'static str; 10] = [
        "Success",
        "Malformed",
        "Underfunded",
        "SrcNoTrust",
        "SrcNotAuthorized",
        "NoDestination",
        "NoTrust",
        "NotAuthorized",
        "LineFull",
        "NoIssuer",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::Underfunded => "Underfunded",
            Self::SrcNoTrust => "SrcNoTrust",
            Self::SrcNotAuthorized => "SrcNotAuthorized",
            Self::NoDestination => "NoDestination",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
            Self::LineFull => "LineFull",
            Self::NoIssuer => "NoIssuer",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> PaymentResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => PaymentResultCode::Success,
            Self::Malformed => PaymentResultCode::Malformed,
            Self::Underfunded => PaymentResultCode::Underfunded,
            Self::SrcNoTrust => PaymentResultCode::SrcNoTrust,
            Self::SrcNotAuthorized => PaymentResultCode::SrcNotAuthorized,
            Self::NoDestination => PaymentResultCode::NoDestination,
            Self::NoTrust => PaymentResultCode::NoTrust,
            Self::NotAuthorized => PaymentResultCode::NotAuthorized,
            Self::LineFull => PaymentResultCode::LineFull,
            Self::NoIssuer => PaymentResultCode::NoIssuer,
        }
    }

    #[must_use]
    pub const fn variants() -> [PaymentResultCode; 10] {
        Self::VARIANTS
    }
}

impl Name for PaymentResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<PaymentResultCode> for PaymentResult {
    #[must_use]
    fn discriminant(&self) -> PaymentResultCode {
        Self::discriminant(self)
    }
}

impl Variants<PaymentResultCode> for PaymentResult {
    fn variants() -> slice::Iter<'static, PaymentResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<PaymentResultCode> for PaymentResult {}

impl ReadXdr for PaymentResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: PaymentResultCode = <PaymentResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                PaymentResultCode::Success => Self::Success,
                PaymentResultCode::Malformed => Self::Malformed,
                PaymentResultCode::Underfunded => Self::Underfunded,
                PaymentResultCode::SrcNoTrust => Self::SrcNoTrust,
                PaymentResultCode::SrcNotAuthorized => Self::SrcNotAuthorized,
                PaymentResultCode::NoDestination => Self::NoDestination,
                PaymentResultCode::NoTrust => Self::NoTrust,
                PaymentResultCode::NotAuthorized => Self::NotAuthorized,
                PaymentResultCode::LineFull => Self::LineFull,
                PaymentResultCode::NoIssuer => Self::NoIssuer,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PaymentResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::Underfunded => ().write_xdr(w)?,
                Self::SrcNoTrust => ().write_xdr(w)?,
                Self::SrcNotAuthorized => ().write_xdr(w)?,
                Self::NoDestination => ().write_xdr(w)?,
                Self::NoTrust => ().write_xdr(w)?,
                Self::NotAuthorized => ().write_xdr(w)?,
                Self::LineFull => ().write_xdr(w)?,
                Self::NoIssuer => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// PathPaymentStrictReceiveResultCode is an XDR Enum defines as:
///
/// ```text
/// enum PathPaymentStrictReceiveResultCode
/// {
///     // codes considered as "success" for the operation
///     PATH_PAYMENT_STRICT_RECEIVE_SUCCESS = 0, // success
///
///     // codes considered as "failure" for the operation
///     PATH_PAYMENT_STRICT_RECEIVE_MALFORMED = -1, // bad input
///     PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED =
///         -2, // not enough funds in source account
///     PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST =
///         -3, // no trust line on source account
///     PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED =
///         -4, // source not authorized to transfer
///     PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION =
///         -5, // destination account does not exist
///     PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST =
///         -6, // dest missing a trust line for asset
///     PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED =
///         -7, // dest not authorized to hold asset
///     PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL =
///         -8, // dest would go above their limit
///     PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER = -9, // missing issuer on one asset
///     PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS =
///         -10, // not enough offers to satisfy path
///     PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF =
///         -11, // would cross one of its own offers
///     PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX = -12 // could not satisfy sendmax
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum PathPaymentStrictReceiveResultCode {
    Success = 0,
    Malformed = -1,
    Underfunded = -2,
    SrcNoTrust = -3,
    SrcNotAuthorized = -4,
    NoDestination = -5,
    NoTrust = -6,
    NotAuthorized = -7,
    LineFull = -8,
    NoIssuer = -9,
    TooFewOffers = -10,
    OfferCrossSelf = -11,
    OverSendmax = -12,
}

impl PathPaymentStrictReceiveResultCode {
    pub const VARIANTS: [PathPaymentStrictReceiveResultCode; 13] = [
        PathPaymentStrictReceiveResultCode::Success,
        PathPaymentStrictReceiveResultCode::Malformed,
        PathPaymentStrictReceiveResultCode::Underfunded,
        PathPaymentStrictReceiveResultCode::SrcNoTrust,
        PathPaymentStrictReceiveResultCode::SrcNotAuthorized,
        PathPaymentStrictReceiveResultCode::NoDestination,
        PathPaymentStrictReceiveResultCode::NoTrust,
        PathPaymentStrictReceiveResultCode::NotAuthorized,
        PathPaymentStrictReceiveResultCode::LineFull,
        PathPaymentStrictReceiveResultCode::NoIssuer,
        PathPaymentStrictReceiveResultCode::TooFewOffers,
        PathPaymentStrictReceiveResultCode::OfferCrossSelf,
        PathPaymentStrictReceiveResultCode::OverSendmax,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "Success",
        "Malformed",
        "Underfunded",
        "SrcNoTrust",
        "SrcNotAuthorized",
        "NoDestination",
        "NoTrust",
        "NotAuthorized",
        "LineFull",
        "NoIssuer",
        "TooFewOffers",
        "OfferCrossSelf",
        "OverSendmax",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::Underfunded => "Underfunded",
            Self::SrcNoTrust => "SrcNoTrust",
            Self::SrcNotAuthorized => "SrcNotAuthorized",
            Self::NoDestination => "NoDestination",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
            Self::LineFull => "LineFull",
            Self::NoIssuer => "NoIssuer",
            Self::TooFewOffers => "TooFewOffers",
            Self::OfferCrossSelf => "OfferCrossSelf",
            Self::OverSendmax => "OverSendmax",
        }
    }

    #[must_use]
    pub const fn variants() -> [PathPaymentStrictReceiveResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for PathPaymentStrictReceiveResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<PathPaymentStrictReceiveResultCode> for PathPaymentStrictReceiveResultCode {
    fn variants() -> slice::Iter<'static, PathPaymentStrictReceiveResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for PathPaymentStrictReceiveResultCode {}

impl fmt::Display for PathPaymentStrictReceiveResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for PathPaymentStrictReceiveResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => PathPaymentStrictReceiveResultCode::Success,
            -1 => PathPaymentStrictReceiveResultCode::Malformed,
            -2 => PathPaymentStrictReceiveResultCode::Underfunded,
            -3 => PathPaymentStrictReceiveResultCode::SrcNoTrust,
            -4 => PathPaymentStrictReceiveResultCode::SrcNotAuthorized,
            -5 => PathPaymentStrictReceiveResultCode::NoDestination,
            -6 => PathPaymentStrictReceiveResultCode::NoTrust,
            -7 => PathPaymentStrictReceiveResultCode::NotAuthorized,
            -8 => PathPaymentStrictReceiveResultCode::LineFull,
            -9 => PathPaymentStrictReceiveResultCode::NoIssuer,
            -10 => PathPaymentStrictReceiveResultCode::TooFewOffers,
            -11 => PathPaymentStrictReceiveResultCode::OfferCrossSelf,
            -12 => PathPaymentStrictReceiveResultCode::OverSendmax,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<PathPaymentStrictReceiveResultCode> for i32 {
    #[must_use]
    fn from(e: PathPaymentStrictReceiveResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for PathPaymentStrictReceiveResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for PathPaymentStrictReceiveResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SimplePaymentResult is an XDR Struct defines as:
///
/// ```text
/// struct SimplePaymentResult
/// {
///     AccountID destination;
///     Asset asset;
///     int64 amount;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct SimplePaymentResult {
    pub destination: AccountId,
    pub asset: Asset,
    pub amount: i64,
}

impl ReadXdr for SimplePaymentResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                destination: AccountId::read_xdr(r)?,
                asset: Asset::read_xdr(r)?,
                amount: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SimplePaymentResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.destination.write_xdr(w)?;
            self.asset.write_xdr(w)?;
            self.amount.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PathPaymentStrictReceiveResultSuccess is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         ClaimAtom offers<>;
///         SimplePaymentResult last;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct PathPaymentStrictReceiveResultSuccess {
    pub offers: VecM<ClaimAtom>,
    pub last: SimplePaymentResult,
}

impl ReadXdr for PathPaymentStrictReceiveResultSuccess {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                offers: VecM::<ClaimAtom>::read_xdr(r)?,
                last: SimplePaymentResult::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PathPaymentStrictReceiveResultSuccess {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.offers.write_xdr(w)?;
            self.last.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PathPaymentStrictReceiveResult is an XDR Union defines as:
///
/// ```text
/// union PathPaymentStrictReceiveResult switch (
///     PathPaymentStrictReceiveResultCode code)
/// {
/// case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
///     struct
///     {
///         ClaimAtom offers<>;
///         SimplePaymentResult last;
///     } success;
/// case PATH_PAYMENT_STRICT_RECEIVE_MALFORMED:
/// case PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED:
/// case PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST:
/// case PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED:
/// case PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION:
/// case PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST:
/// case PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED:
/// case PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL:
///     void;
/// case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
///     Asset noIssuer; // the asset that caused the error
/// case PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS:
/// case PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF:
/// case PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
///     void;
/// };
/// ```
///
// union with discriminant PathPaymentStrictReceiveResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum PathPaymentStrictReceiveResult {
    Success(PathPaymentStrictReceiveResultSuccess),
    Malformed,
    Underfunded,
    SrcNoTrust,
    SrcNotAuthorized,
    NoDestination,
    NoTrust,
    NotAuthorized,
    LineFull,
    NoIssuer(Asset),
    TooFewOffers,
    OfferCrossSelf,
    OverSendmax,
}

impl PathPaymentStrictReceiveResult {
    pub const VARIANTS: [PathPaymentStrictReceiveResultCode; 13] = [
        PathPaymentStrictReceiveResultCode::Success,
        PathPaymentStrictReceiveResultCode::Malformed,
        PathPaymentStrictReceiveResultCode::Underfunded,
        PathPaymentStrictReceiveResultCode::SrcNoTrust,
        PathPaymentStrictReceiveResultCode::SrcNotAuthorized,
        PathPaymentStrictReceiveResultCode::NoDestination,
        PathPaymentStrictReceiveResultCode::NoTrust,
        PathPaymentStrictReceiveResultCode::NotAuthorized,
        PathPaymentStrictReceiveResultCode::LineFull,
        PathPaymentStrictReceiveResultCode::NoIssuer,
        PathPaymentStrictReceiveResultCode::TooFewOffers,
        PathPaymentStrictReceiveResultCode::OfferCrossSelf,
        PathPaymentStrictReceiveResultCode::OverSendmax,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "Success",
        "Malformed",
        "Underfunded",
        "SrcNoTrust",
        "SrcNotAuthorized",
        "NoDestination",
        "NoTrust",
        "NotAuthorized",
        "LineFull",
        "NoIssuer",
        "TooFewOffers",
        "OfferCrossSelf",
        "OverSendmax",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success(_) => "Success",
            Self::Malformed => "Malformed",
            Self::Underfunded => "Underfunded",
            Self::SrcNoTrust => "SrcNoTrust",
            Self::SrcNotAuthorized => "SrcNotAuthorized",
            Self::NoDestination => "NoDestination",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
            Self::LineFull => "LineFull",
            Self::NoIssuer(_) => "NoIssuer",
            Self::TooFewOffers => "TooFewOffers",
            Self::OfferCrossSelf => "OfferCrossSelf",
            Self::OverSendmax => "OverSendmax",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> PathPaymentStrictReceiveResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success(_) => PathPaymentStrictReceiveResultCode::Success,
            Self::Malformed => PathPaymentStrictReceiveResultCode::Malformed,
            Self::Underfunded => PathPaymentStrictReceiveResultCode::Underfunded,
            Self::SrcNoTrust => PathPaymentStrictReceiveResultCode::SrcNoTrust,
            Self::SrcNotAuthorized => PathPaymentStrictReceiveResultCode::SrcNotAuthorized,
            Self::NoDestination => PathPaymentStrictReceiveResultCode::NoDestination,
            Self::NoTrust => PathPaymentStrictReceiveResultCode::NoTrust,
            Self::NotAuthorized => PathPaymentStrictReceiveResultCode::NotAuthorized,
            Self::LineFull => PathPaymentStrictReceiveResultCode::LineFull,
            Self::NoIssuer(_) => PathPaymentStrictReceiveResultCode::NoIssuer,
            Self::TooFewOffers => PathPaymentStrictReceiveResultCode::TooFewOffers,
            Self::OfferCrossSelf => PathPaymentStrictReceiveResultCode::OfferCrossSelf,
            Self::OverSendmax => PathPaymentStrictReceiveResultCode::OverSendmax,
        }
    }

    #[must_use]
    pub const fn variants() -> [PathPaymentStrictReceiveResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for PathPaymentStrictReceiveResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<PathPaymentStrictReceiveResultCode> for PathPaymentStrictReceiveResult {
    #[must_use]
    fn discriminant(&self) -> PathPaymentStrictReceiveResultCode {
        Self::discriminant(self)
    }
}

impl Variants<PathPaymentStrictReceiveResultCode> for PathPaymentStrictReceiveResult {
    fn variants() -> slice::Iter<'static, PathPaymentStrictReceiveResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<PathPaymentStrictReceiveResultCode> for PathPaymentStrictReceiveResult {}

impl ReadXdr for PathPaymentStrictReceiveResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: PathPaymentStrictReceiveResultCode =
                <PathPaymentStrictReceiveResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                PathPaymentStrictReceiveResultCode::Success => {
                    Self::Success(PathPaymentStrictReceiveResultSuccess::read_xdr(r)?)
                }
                PathPaymentStrictReceiveResultCode::Malformed => Self::Malformed,
                PathPaymentStrictReceiveResultCode::Underfunded => Self::Underfunded,
                PathPaymentStrictReceiveResultCode::SrcNoTrust => Self::SrcNoTrust,
                PathPaymentStrictReceiveResultCode::SrcNotAuthorized => Self::SrcNotAuthorized,
                PathPaymentStrictReceiveResultCode::NoDestination => Self::NoDestination,
                PathPaymentStrictReceiveResultCode::NoTrust => Self::NoTrust,
                PathPaymentStrictReceiveResultCode::NotAuthorized => Self::NotAuthorized,
                PathPaymentStrictReceiveResultCode::LineFull => Self::LineFull,
                PathPaymentStrictReceiveResultCode::NoIssuer => Self::NoIssuer(Asset::read_xdr(r)?),
                PathPaymentStrictReceiveResultCode::TooFewOffers => Self::TooFewOffers,
                PathPaymentStrictReceiveResultCode::OfferCrossSelf => Self::OfferCrossSelf,
                PathPaymentStrictReceiveResultCode::OverSendmax => Self::OverSendmax,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PathPaymentStrictReceiveResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success(v) => v.write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::Underfunded => ().write_xdr(w)?,
                Self::SrcNoTrust => ().write_xdr(w)?,
                Self::SrcNotAuthorized => ().write_xdr(w)?,
                Self::NoDestination => ().write_xdr(w)?,
                Self::NoTrust => ().write_xdr(w)?,
                Self::NotAuthorized => ().write_xdr(w)?,
                Self::LineFull => ().write_xdr(w)?,
                Self::NoIssuer(v) => v.write_xdr(w)?,
                Self::TooFewOffers => ().write_xdr(w)?,
                Self::OfferCrossSelf => ().write_xdr(w)?,
                Self::OverSendmax => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// PathPaymentStrictSendResultCode is an XDR Enum defines as:
///
/// ```text
/// enum PathPaymentStrictSendResultCode
/// {
///     // codes considered as "success" for the operation
///     PATH_PAYMENT_STRICT_SEND_SUCCESS = 0, // success
///
///     // codes considered as "failure" for the operation
///     PATH_PAYMENT_STRICT_SEND_MALFORMED = -1, // bad input
///     PATH_PAYMENT_STRICT_SEND_UNDERFUNDED =
///         -2, // not enough funds in source account
///     PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST =
///         -3, // no trust line on source account
///     PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED =
///         -4, // source not authorized to transfer
///     PATH_PAYMENT_STRICT_SEND_NO_DESTINATION =
///         -5, // destination account does not exist
///     PATH_PAYMENT_STRICT_SEND_NO_TRUST =
///         -6, // dest missing a trust line for asset
///     PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED =
///         -7, // dest not authorized to hold asset
///     PATH_PAYMENT_STRICT_SEND_LINE_FULL = -8, // dest would go above their limit
///     PATH_PAYMENT_STRICT_SEND_NO_ISSUER = -9, // missing issuer on one asset
///     PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS =
///         -10, // not enough offers to satisfy path
///     PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF =
///         -11, // would cross one of its own offers
///     PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN = -12 // could not satisfy destMin
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum PathPaymentStrictSendResultCode {
    Success = 0,
    Malformed = -1,
    Underfunded = -2,
    SrcNoTrust = -3,
    SrcNotAuthorized = -4,
    NoDestination = -5,
    NoTrust = -6,
    NotAuthorized = -7,
    LineFull = -8,
    NoIssuer = -9,
    TooFewOffers = -10,
    OfferCrossSelf = -11,
    UnderDestmin = -12,
}

impl PathPaymentStrictSendResultCode {
    pub const VARIANTS: [PathPaymentStrictSendResultCode; 13] = [
        PathPaymentStrictSendResultCode::Success,
        PathPaymentStrictSendResultCode::Malformed,
        PathPaymentStrictSendResultCode::Underfunded,
        PathPaymentStrictSendResultCode::SrcNoTrust,
        PathPaymentStrictSendResultCode::SrcNotAuthorized,
        PathPaymentStrictSendResultCode::NoDestination,
        PathPaymentStrictSendResultCode::NoTrust,
        PathPaymentStrictSendResultCode::NotAuthorized,
        PathPaymentStrictSendResultCode::LineFull,
        PathPaymentStrictSendResultCode::NoIssuer,
        PathPaymentStrictSendResultCode::TooFewOffers,
        PathPaymentStrictSendResultCode::OfferCrossSelf,
        PathPaymentStrictSendResultCode::UnderDestmin,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "Success",
        "Malformed",
        "Underfunded",
        "SrcNoTrust",
        "SrcNotAuthorized",
        "NoDestination",
        "NoTrust",
        "NotAuthorized",
        "LineFull",
        "NoIssuer",
        "TooFewOffers",
        "OfferCrossSelf",
        "UnderDestmin",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::Underfunded => "Underfunded",
            Self::SrcNoTrust => "SrcNoTrust",
            Self::SrcNotAuthorized => "SrcNotAuthorized",
            Self::NoDestination => "NoDestination",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
            Self::LineFull => "LineFull",
            Self::NoIssuer => "NoIssuer",
            Self::TooFewOffers => "TooFewOffers",
            Self::OfferCrossSelf => "OfferCrossSelf",
            Self::UnderDestmin => "UnderDestmin",
        }
    }

    #[must_use]
    pub const fn variants() -> [PathPaymentStrictSendResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for PathPaymentStrictSendResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<PathPaymentStrictSendResultCode> for PathPaymentStrictSendResultCode {
    fn variants() -> slice::Iter<'static, PathPaymentStrictSendResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for PathPaymentStrictSendResultCode {}

impl fmt::Display for PathPaymentStrictSendResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for PathPaymentStrictSendResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => PathPaymentStrictSendResultCode::Success,
            -1 => PathPaymentStrictSendResultCode::Malformed,
            -2 => PathPaymentStrictSendResultCode::Underfunded,
            -3 => PathPaymentStrictSendResultCode::SrcNoTrust,
            -4 => PathPaymentStrictSendResultCode::SrcNotAuthorized,
            -5 => PathPaymentStrictSendResultCode::NoDestination,
            -6 => PathPaymentStrictSendResultCode::NoTrust,
            -7 => PathPaymentStrictSendResultCode::NotAuthorized,
            -8 => PathPaymentStrictSendResultCode::LineFull,
            -9 => PathPaymentStrictSendResultCode::NoIssuer,
            -10 => PathPaymentStrictSendResultCode::TooFewOffers,
            -11 => PathPaymentStrictSendResultCode::OfferCrossSelf,
            -12 => PathPaymentStrictSendResultCode::UnderDestmin,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<PathPaymentStrictSendResultCode> for i32 {
    #[must_use]
    fn from(e: PathPaymentStrictSendResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for PathPaymentStrictSendResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for PathPaymentStrictSendResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// PathPaymentStrictSendResultSuccess is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         ClaimAtom offers<>;
///         SimplePaymentResult last;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct PathPaymentStrictSendResultSuccess {
    pub offers: VecM<ClaimAtom>,
    pub last: SimplePaymentResult,
}

impl ReadXdr for PathPaymentStrictSendResultSuccess {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                offers: VecM::<ClaimAtom>::read_xdr(r)?,
                last: SimplePaymentResult::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for PathPaymentStrictSendResultSuccess {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.offers.write_xdr(w)?;
            self.last.write_xdr(w)?;
            Ok(())
        })
    }
}

/// PathPaymentStrictSendResult is an XDR Union defines as:
///
/// ```text
/// union PathPaymentStrictSendResult switch (PathPaymentStrictSendResultCode code)
/// {
/// case PATH_PAYMENT_STRICT_SEND_SUCCESS:
///     struct
///     {
///         ClaimAtom offers<>;
///         SimplePaymentResult last;
///     } success;
/// case PATH_PAYMENT_STRICT_SEND_MALFORMED:
/// case PATH_PAYMENT_STRICT_SEND_UNDERFUNDED:
/// case PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST:
/// case PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED:
/// case PATH_PAYMENT_STRICT_SEND_NO_DESTINATION:
/// case PATH_PAYMENT_STRICT_SEND_NO_TRUST:
/// case PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED:
/// case PATH_PAYMENT_STRICT_SEND_LINE_FULL:
///     void;
/// case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
///     Asset noIssuer; // the asset that caused the error
/// case PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS:
/// case PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF:
/// case PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
///     void;
/// };
/// ```
///
// union with discriminant PathPaymentStrictSendResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum PathPaymentStrictSendResult {
    Success(PathPaymentStrictSendResultSuccess),
    Malformed,
    Underfunded,
    SrcNoTrust,
    SrcNotAuthorized,
    NoDestination,
    NoTrust,
    NotAuthorized,
    LineFull,
    NoIssuer(Asset),
    TooFewOffers,
    OfferCrossSelf,
    UnderDestmin,
}

impl PathPaymentStrictSendResult {
    pub const VARIANTS: [PathPaymentStrictSendResultCode; 13] = [
        PathPaymentStrictSendResultCode::Success,
        PathPaymentStrictSendResultCode::Malformed,
        PathPaymentStrictSendResultCode::Underfunded,
        PathPaymentStrictSendResultCode::SrcNoTrust,
        PathPaymentStrictSendResultCode::SrcNotAuthorized,
        PathPaymentStrictSendResultCode::NoDestination,
        PathPaymentStrictSendResultCode::NoTrust,
        PathPaymentStrictSendResultCode::NotAuthorized,
        PathPaymentStrictSendResultCode::LineFull,
        PathPaymentStrictSendResultCode::NoIssuer,
        PathPaymentStrictSendResultCode::TooFewOffers,
        PathPaymentStrictSendResultCode::OfferCrossSelf,
        PathPaymentStrictSendResultCode::UnderDestmin,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "Success",
        "Malformed",
        "Underfunded",
        "SrcNoTrust",
        "SrcNotAuthorized",
        "NoDestination",
        "NoTrust",
        "NotAuthorized",
        "LineFull",
        "NoIssuer",
        "TooFewOffers",
        "OfferCrossSelf",
        "UnderDestmin",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success(_) => "Success",
            Self::Malformed => "Malformed",
            Self::Underfunded => "Underfunded",
            Self::SrcNoTrust => "SrcNoTrust",
            Self::SrcNotAuthorized => "SrcNotAuthorized",
            Self::NoDestination => "NoDestination",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
            Self::LineFull => "LineFull",
            Self::NoIssuer(_) => "NoIssuer",
            Self::TooFewOffers => "TooFewOffers",
            Self::OfferCrossSelf => "OfferCrossSelf",
            Self::UnderDestmin => "UnderDestmin",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> PathPaymentStrictSendResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success(_) => PathPaymentStrictSendResultCode::Success,
            Self::Malformed => PathPaymentStrictSendResultCode::Malformed,
            Self::Underfunded => PathPaymentStrictSendResultCode::Underfunded,
            Self::SrcNoTrust => PathPaymentStrictSendResultCode::SrcNoTrust,
            Self::SrcNotAuthorized => PathPaymentStrictSendResultCode::SrcNotAuthorized,
            Self::NoDestination => PathPaymentStrictSendResultCode::NoDestination,
            Self::NoTrust => PathPaymentStrictSendResultCode::NoTrust,
            Self::NotAuthorized => PathPaymentStrictSendResultCode::NotAuthorized,
            Self::LineFull => PathPaymentStrictSendResultCode::LineFull,
            Self::NoIssuer(_) => PathPaymentStrictSendResultCode::NoIssuer,
            Self::TooFewOffers => PathPaymentStrictSendResultCode::TooFewOffers,
            Self::OfferCrossSelf => PathPaymentStrictSendResultCode::OfferCrossSelf,
            Self::UnderDestmin => PathPaymentStrictSendResultCode::UnderDestmin,
        }
    }

    #[must_use]
    pub const fn variants() -> [PathPaymentStrictSendResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for PathPaymentStrictSendResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<PathPaymentStrictSendResultCode> for PathPaymentStrictSendResult {
    #[must_use]
    fn discriminant(&self) -> PathPaymentStrictSendResultCode {
        Self::discriminant(self)
    }
}

impl Variants<PathPaymentStrictSendResultCode> for PathPaymentStrictSendResult {
    fn variants() -> slice::Iter<'static, PathPaymentStrictSendResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<PathPaymentStrictSendResultCode> for PathPaymentStrictSendResult {}

impl ReadXdr for PathPaymentStrictSendResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: PathPaymentStrictSendResultCode =
                <PathPaymentStrictSendResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                PathPaymentStrictSendResultCode::Success => {
                    Self::Success(PathPaymentStrictSendResultSuccess::read_xdr(r)?)
                }
                PathPaymentStrictSendResultCode::Malformed => Self::Malformed,
                PathPaymentStrictSendResultCode::Underfunded => Self::Underfunded,
                PathPaymentStrictSendResultCode::SrcNoTrust => Self::SrcNoTrust,
                PathPaymentStrictSendResultCode::SrcNotAuthorized => Self::SrcNotAuthorized,
                PathPaymentStrictSendResultCode::NoDestination => Self::NoDestination,
                PathPaymentStrictSendResultCode::NoTrust => Self::NoTrust,
                PathPaymentStrictSendResultCode::NotAuthorized => Self::NotAuthorized,
                PathPaymentStrictSendResultCode::LineFull => Self::LineFull,
                PathPaymentStrictSendResultCode::NoIssuer => Self::NoIssuer(Asset::read_xdr(r)?),
                PathPaymentStrictSendResultCode::TooFewOffers => Self::TooFewOffers,
                PathPaymentStrictSendResultCode::OfferCrossSelf => Self::OfferCrossSelf,
                PathPaymentStrictSendResultCode::UnderDestmin => Self::UnderDestmin,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PathPaymentStrictSendResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success(v) => v.write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::Underfunded => ().write_xdr(w)?,
                Self::SrcNoTrust => ().write_xdr(w)?,
                Self::SrcNotAuthorized => ().write_xdr(w)?,
                Self::NoDestination => ().write_xdr(w)?,
                Self::NoTrust => ().write_xdr(w)?,
                Self::NotAuthorized => ().write_xdr(w)?,
                Self::LineFull => ().write_xdr(w)?,
                Self::NoIssuer(v) => v.write_xdr(w)?,
                Self::TooFewOffers => ().write_xdr(w)?,
                Self::OfferCrossSelf => ().write_xdr(w)?,
                Self::UnderDestmin => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ManageSellOfferResultCode is an XDR Enum defines as:
///
/// ```text
/// enum ManageSellOfferResultCode
/// {
///     // codes considered as "success" for the operation
///     MANAGE_SELL_OFFER_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     MANAGE_SELL_OFFER_MALFORMED = -1, // generated offer would be invalid
///     MANAGE_SELL_OFFER_SELL_NO_TRUST =
///         -2,                              // no trust line for what we're selling
///     MANAGE_SELL_OFFER_BUY_NO_TRUST = -3, // no trust line for what we're buying
///     MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell
///     MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy
///     MANAGE_SELL_OFFER_LINE_FULL = -6, // can't receive more of what it's buying
///     MANAGE_SELL_OFFER_UNDERFUNDED = -7, // doesn't hold what it's trying to sell
///     MANAGE_SELL_OFFER_CROSS_SELF =
///         -8, // would cross an offer from the same user
///     MANAGE_SELL_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling
///     MANAGE_SELL_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying
///
///     // update errors
///     MANAGE_SELL_OFFER_NOT_FOUND =
///         -11, // offerID does not match an existing offer
///
///     MANAGE_SELL_OFFER_LOW_RESERVE =
///         -12 // not enough funds to create a new Offer
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ManageSellOfferResultCode {
    Success = 0,
    Malformed = -1,
    SellNoTrust = -2,
    BuyNoTrust = -3,
    SellNotAuthorized = -4,
    BuyNotAuthorized = -5,
    LineFull = -6,
    Underfunded = -7,
    CrossSelf = -8,
    SellNoIssuer = -9,
    BuyNoIssuer = -10,
    NotFound = -11,
    LowReserve = -12,
}

impl ManageSellOfferResultCode {
    pub const VARIANTS: [ManageSellOfferResultCode; 13] = [
        ManageSellOfferResultCode::Success,
        ManageSellOfferResultCode::Malformed,
        ManageSellOfferResultCode::SellNoTrust,
        ManageSellOfferResultCode::BuyNoTrust,
        ManageSellOfferResultCode::SellNotAuthorized,
        ManageSellOfferResultCode::BuyNotAuthorized,
        ManageSellOfferResultCode::LineFull,
        ManageSellOfferResultCode::Underfunded,
        ManageSellOfferResultCode::CrossSelf,
        ManageSellOfferResultCode::SellNoIssuer,
        ManageSellOfferResultCode::BuyNoIssuer,
        ManageSellOfferResultCode::NotFound,
        ManageSellOfferResultCode::LowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "Success",
        "Malformed",
        "SellNoTrust",
        "BuyNoTrust",
        "SellNotAuthorized",
        "BuyNotAuthorized",
        "LineFull",
        "Underfunded",
        "CrossSelf",
        "SellNoIssuer",
        "BuyNoIssuer",
        "NotFound",
        "LowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::SellNoTrust => "SellNoTrust",
            Self::BuyNoTrust => "BuyNoTrust",
            Self::SellNotAuthorized => "SellNotAuthorized",
            Self::BuyNotAuthorized => "BuyNotAuthorized",
            Self::LineFull => "LineFull",
            Self::Underfunded => "Underfunded",
            Self::CrossSelf => "CrossSelf",
            Self::SellNoIssuer => "SellNoIssuer",
            Self::BuyNoIssuer => "BuyNoIssuer",
            Self::NotFound => "NotFound",
            Self::LowReserve => "LowReserve",
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageSellOfferResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for ManageSellOfferResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ManageSellOfferResultCode> for ManageSellOfferResultCode {
    fn variants() -> slice::Iter<'static, ManageSellOfferResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ManageSellOfferResultCode {}

impl fmt::Display for ManageSellOfferResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ManageSellOfferResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ManageSellOfferResultCode::Success,
            -1 => ManageSellOfferResultCode::Malformed,
            -2 => ManageSellOfferResultCode::SellNoTrust,
            -3 => ManageSellOfferResultCode::BuyNoTrust,
            -4 => ManageSellOfferResultCode::SellNotAuthorized,
            -5 => ManageSellOfferResultCode::BuyNotAuthorized,
            -6 => ManageSellOfferResultCode::LineFull,
            -7 => ManageSellOfferResultCode::Underfunded,
            -8 => ManageSellOfferResultCode::CrossSelf,
            -9 => ManageSellOfferResultCode::SellNoIssuer,
            -10 => ManageSellOfferResultCode::BuyNoIssuer,
            -11 => ManageSellOfferResultCode::NotFound,
            -12 => ManageSellOfferResultCode::LowReserve,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ManageSellOfferResultCode> for i32 {
    #[must_use]
    fn from(e: ManageSellOfferResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ManageSellOfferResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ManageSellOfferResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ManageOfferEffect is an XDR Enum defines as:
///
/// ```text
/// enum ManageOfferEffect
/// {
///     MANAGE_OFFER_CREATED = 0,
///     MANAGE_OFFER_UPDATED = 1,
///     MANAGE_OFFER_DELETED = 2
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ManageOfferEffect {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

impl ManageOfferEffect {
    pub const VARIANTS: [ManageOfferEffect; 3] = [
        ManageOfferEffect::Created,
        ManageOfferEffect::Updated,
        ManageOfferEffect::Deleted,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["Created", "Updated", "Deleted"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Created => "Created",
            Self::Updated => "Updated",
            Self::Deleted => "Deleted",
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageOfferEffect; 3] {
        Self::VARIANTS
    }
}

impl Name for ManageOfferEffect {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ManageOfferEffect> for ManageOfferEffect {
    fn variants() -> slice::Iter<'static, ManageOfferEffect> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ManageOfferEffect {}

impl fmt::Display for ManageOfferEffect {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ManageOfferEffect {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ManageOfferEffect::Created,
            1 => ManageOfferEffect::Updated,
            2 => ManageOfferEffect::Deleted,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ManageOfferEffect> for i32 {
    #[must_use]
    fn from(e: ManageOfferEffect) -> Self {
        e as Self
    }
}

impl ReadXdr for ManageOfferEffect {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ManageOfferEffect {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ManageOfferSuccessResultOffer is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (ManageOfferEffect effect)
///     {
///     case MANAGE_OFFER_CREATED:
///     case MANAGE_OFFER_UPDATED:
///         OfferEntry offer;
///     case MANAGE_OFFER_DELETED:
///         void;
///     }
/// ```
///
// union with discriminant ManageOfferEffect
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ManageOfferSuccessResultOffer {
    Created(OfferEntry),
    Updated(OfferEntry),
    Deleted,
}

impl ManageOfferSuccessResultOffer {
    pub const VARIANTS: [ManageOfferEffect; 3] = [
        ManageOfferEffect::Created,
        ManageOfferEffect::Updated,
        ManageOfferEffect::Deleted,
    ];
    pub const VARIANTS_STR: [&'static str; 3] = ["Created", "Updated", "Deleted"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Created(_) => "Created",
            Self::Updated(_) => "Updated",
            Self::Deleted => "Deleted",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ManageOfferEffect {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Created(_) => ManageOfferEffect::Created,
            Self::Updated(_) => ManageOfferEffect::Updated,
            Self::Deleted => ManageOfferEffect::Deleted,
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageOfferEffect; 3] {
        Self::VARIANTS
    }
}

impl Name for ManageOfferSuccessResultOffer {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ManageOfferEffect> for ManageOfferSuccessResultOffer {
    #[must_use]
    fn discriminant(&self) -> ManageOfferEffect {
        Self::discriminant(self)
    }
}

impl Variants<ManageOfferEffect> for ManageOfferSuccessResultOffer {
    fn variants() -> slice::Iter<'static, ManageOfferEffect> {
        Self::VARIANTS.iter()
    }
}

impl Union<ManageOfferEffect> for ManageOfferSuccessResultOffer {}

impl ReadXdr for ManageOfferSuccessResultOffer {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ManageOfferEffect = <ManageOfferEffect as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ManageOfferEffect::Created => Self::Created(OfferEntry::read_xdr(r)?),
                ManageOfferEffect::Updated => Self::Updated(OfferEntry::read_xdr(r)?),
                ManageOfferEffect::Deleted => Self::Deleted,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ManageOfferSuccessResultOffer {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Created(v) => v.write_xdr(w)?,
                Self::Updated(v) => v.write_xdr(w)?,
                Self::Deleted => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ManageOfferSuccessResult is an XDR Struct defines as:
///
/// ```text
/// struct ManageOfferSuccessResult
/// {
///     // offers that got claimed while creating this offer
///     ClaimAtom offersClaimed<>;
///
///     union switch (ManageOfferEffect effect)
///     {
///     case MANAGE_OFFER_CREATED:
///     case MANAGE_OFFER_UPDATED:
///         OfferEntry offer;
///     case MANAGE_OFFER_DELETED:
///         void;
///     }
///     offer;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct ManageOfferSuccessResult {
    pub offers_claimed: VecM<ClaimAtom>,
    pub offer: ManageOfferSuccessResultOffer,
}

impl ReadXdr for ManageOfferSuccessResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                offers_claimed: VecM::<ClaimAtom>::read_xdr(r)?,
                offer: ManageOfferSuccessResultOffer::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for ManageOfferSuccessResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.offers_claimed.write_xdr(w)?;
            self.offer.write_xdr(w)?;
            Ok(())
        })
    }
}

/// ManageSellOfferResult is an XDR Union defines as:
///
/// ```text
/// union ManageSellOfferResult switch (ManageSellOfferResultCode code)
/// {
/// case MANAGE_SELL_OFFER_SUCCESS:
///     ManageOfferSuccessResult success;
/// case MANAGE_SELL_OFFER_MALFORMED:
/// case MANAGE_SELL_OFFER_SELL_NO_TRUST:
/// case MANAGE_SELL_OFFER_BUY_NO_TRUST:
/// case MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED:
/// case MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED:
/// case MANAGE_SELL_OFFER_LINE_FULL:
/// case MANAGE_SELL_OFFER_UNDERFUNDED:
/// case MANAGE_SELL_OFFER_CROSS_SELF:
/// case MANAGE_SELL_OFFER_SELL_NO_ISSUER:
/// case MANAGE_SELL_OFFER_BUY_NO_ISSUER:
/// case MANAGE_SELL_OFFER_NOT_FOUND:
/// case MANAGE_SELL_OFFER_LOW_RESERVE:
///     void;
/// };
/// ```
///
// union with discriminant ManageSellOfferResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ManageSellOfferResult {
    Success(ManageOfferSuccessResult),
    Malformed,
    SellNoTrust,
    BuyNoTrust,
    SellNotAuthorized,
    BuyNotAuthorized,
    LineFull,
    Underfunded,
    CrossSelf,
    SellNoIssuer,
    BuyNoIssuer,
    NotFound,
    LowReserve,
}

impl ManageSellOfferResult {
    pub const VARIANTS: [ManageSellOfferResultCode; 13] = [
        ManageSellOfferResultCode::Success,
        ManageSellOfferResultCode::Malformed,
        ManageSellOfferResultCode::SellNoTrust,
        ManageSellOfferResultCode::BuyNoTrust,
        ManageSellOfferResultCode::SellNotAuthorized,
        ManageSellOfferResultCode::BuyNotAuthorized,
        ManageSellOfferResultCode::LineFull,
        ManageSellOfferResultCode::Underfunded,
        ManageSellOfferResultCode::CrossSelf,
        ManageSellOfferResultCode::SellNoIssuer,
        ManageSellOfferResultCode::BuyNoIssuer,
        ManageSellOfferResultCode::NotFound,
        ManageSellOfferResultCode::LowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "Success",
        "Malformed",
        "SellNoTrust",
        "BuyNoTrust",
        "SellNotAuthorized",
        "BuyNotAuthorized",
        "LineFull",
        "Underfunded",
        "CrossSelf",
        "SellNoIssuer",
        "BuyNoIssuer",
        "NotFound",
        "LowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success(_) => "Success",
            Self::Malformed => "Malformed",
            Self::SellNoTrust => "SellNoTrust",
            Self::BuyNoTrust => "BuyNoTrust",
            Self::SellNotAuthorized => "SellNotAuthorized",
            Self::BuyNotAuthorized => "BuyNotAuthorized",
            Self::LineFull => "LineFull",
            Self::Underfunded => "Underfunded",
            Self::CrossSelf => "CrossSelf",
            Self::SellNoIssuer => "SellNoIssuer",
            Self::BuyNoIssuer => "BuyNoIssuer",
            Self::NotFound => "NotFound",
            Self::LowReserve => "LowReserve",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ManageSellOfferResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success(_) => ManageSellOfferResultCode::Success,
            Self::Malformed => ManageSellOfferResultCode::Malformed,
            Self::SellNoTrust => ManageSellOfferResultCode::SellNoTrust,
            Self::BuyNoTrust => ManageSellOfferResultCode::BuyNoTrust,
            Self::SellNotAuthorized => ManageSellOfferResultCode::SellNotAuthorized,
            Self::BuyNotAuthorized => ManageSellOfferResultCode::BuyNotAuthorized,
            Self::LineFull => ManageSellOfferResultCode::LineFull,
            Self::Underfunded => ManageSellOfferResultCode::Underfunded,
            Self::CrossSelf => ManageSellOfferResultCode::CrossSelf,
            Self::SellNoIssuer => ManageSellOfferResultCode::SellNoIssuer,
            Self::BuyNoIssuer => ManageSellOfferResultCode::BuyNoIssuer,
            Self::NotFound => ManageSellOfferResultCode::NotFound,
            Self::LowReserve => ManageSellOfferResultCode::LowReserve,
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageSellOfferResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for ManageSellOfferResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ManageSellOfferResultCode> for ManageSellOfferResult {
    #[must_use]
    fn discriminant(&self) -> ManageSellOfferResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ManageSellOfferResultCode> for ManageSellOfferResult {
    fn variants() -> slice::Iter<'static, ManageSellOfferResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ManageSellOfferResultCode> for ManageSellOfferResult {}

impl ReadXdr for ManageSellOfferResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ManageSellOfferResultCode =
                <ManageSellOfferResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ManageSellOfferResultCode::Success => {
                    Self::Success(ManageOfferSuccessResult::read_xdr(r)?)
                }
                ManageSellOfferResultCode::Malformed => Self::Malformed,
                ManageSellOfferResultCode::SellNoTrust => Self::SellNoTrust,
                ManageSellOfferResultCode::BuyNoTrust => Self::BuyNoTrust,
                ManageSellOfferResultCode::SellNotAuthorized => Self::SellNotAuthorized,
                ManageSellOfferResultCode::BuyNotAuthorized => Self::BuyNotAuthorized,
                ManageSellOfferResultCode::LineFull => Self::LineFull,
                ManageSellOfferResultCode::Underfunded => Self::Underfunded,
                ManageSellOfferResultCode::CrossSelf => Self::CrossSelf,
                ManageSellOfferResultCode::SellNoIssuer => Self::SellNoIssuer,
                ManageSellOfferResultCode::BuyNoIssuer => Self::BuyNoIssuer,
                ManageSellOfferResultCode::NotFound => Self::NotFound,
                ManageSellOfferResultCode::LowReserve => Self::LowReserve,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ManageSellOfferResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success(v) => v.write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::SellNoTrust => ().write_xdr(w)?,
                Self::BuyNoTrust => ().write_xdr(w)?,
                Self::SellNotAuthorized => ().write_xdr(w)?,
                Self::BuyNotAuthorized => ().write_xdr(w)?,
                Self::LineFull => ().write_xdr(w)?,
                Self::Underfunded => ().write_xdr(w)?,
                Self::CrossSelf => ().write_xdr(w)?,
                Self::SellNoIssuer => ().write_xdr(w)?,
                Self::BuyNoIssuer => ().write_xdr(w)?,
                Self::NotFound => ().write_xdr(w)?,
                Self::LowReserve => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ManageBuyOfferResultCode is an XDR Enum defines as:
///
/// ```text
/// enum ManageBuyOfferResultCode
/// {
///     // codes considered as "success" for the operation
///     MANAGE_BUY_OFFER_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     MANAGE_BUY_OFFER_MALFORMED = -1,     // generated offer would be invalid
///     MANAGE_BUY_OFFER_SELL_NO_TRUST = -2, // no trust line for what we're selling
///     MANAGE_BUY_OFFER_BUY_NO_TRUST = -3,  // no trust line for what we're buying
///     MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell
///     MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy
///     MANAGE_BUY_OFFER_LINE_FULL = -6,   // can't receive more of what it's buying
///     MANAGE_BUY_OFFER_UNDERFUNDED = -7, // doesn't hold what it's trying to sell
///     MANAGE_BUY_OFFER_CROSS_SELF = -8, // would cross an offer from the same user
///     MANAGE_BUY_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling
///     MANAGE_BUY_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying
///
///     // update errors
///     MANAGE_BUY_OFFER_NOT_FOUND =
///         -11, // offerID does not match an existing offer
///
///     MANAGE_BUY_OFFER_LOW_RESERVE = -12 // not enough funds to create a new Offer
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ManageBuyOfferResultCode {
    Success = 0,
    Malformed = -1,
    SellNoTrust = -2,
    BuyNoTrust = -3,
    SellNotAuthorized = -4,
    BuyNotAuthorized = -5,
    LineFull = -6,
    Underfunded = -7,
    CrossSelf = -8,
    SellNoIssuer = -9,
    BuyNoIssuer = -10,
    NotFound = -11,
    LowReserve = -12,
}

impl ManageBuyOfferResultCode {
    pub const VARIANTS: [ManageBuyOfferResultCode; 13] = [
        ManageBuyOfferResultCode::Success,
        ManageBuyOfferResultCode::Malformed,
        ManageBuyOfferResultCode::SellNoTrust,
        ManageBuyOfferResultCode::BuyNoTrust,
        ManageBuyOfferResultCode::SellNotAuthorized,
        ManageBuyOfferResultCode::BuyNotAuthorized,
        ManageBuyOfferResultCode::LineFull,
        ManageBuyOfferResultCode::Underfunded,
        ManageBuyOfferResultCode::CrossSelf,
        ManageBuyOfferResultCode::SellNoIssuer,
        ManageBuyOfferResultCode::BuyNoIssuer,
        ManageBuyOfferResultCode::NotFound,
        ManageBuyOfferResultCode::LowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "Success",
        "Malformed",
        "SellNoTrust",
        "BuyNoTrust",
        "SellNotAuthorized",
        "BuyNotAuthorized",
        "LineFull",
        "Underfunded",
        "CrossSelf",
        "SellNoIssuer",
        "BuyNoIssuer",
        "NotFound",
        "LowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::SellNoTrust => "SellNoTrust",
            Self::BuyNoTrust => "BuyNoTrust",
            Self::SellNotAuthorized => "SellNotAuthorized",
            Self::BuyNotAuthorized => "BuyNotAuthorized",
            Self::LineFull => "LineFull",
            Self::Underfunded => "Underfunded",
            Self::CrossSelf => "CrossSelf",
            Self::SellNoIssuer => "SellNoIssuer",
            Self::BuyNoIssuer => "BuyNoIssuer",
            Self::NotFound => "NotFound",
            Self::LowReserve => "LowReserve",
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageBuyOfferResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for ManageBuyOfferResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ManageBuyOfferResultCode> for ManageBuyOfferResultCode {
    fn variants() -> slice::Iter<'static, ManageBuyOfferResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ManageBuyOfferResultCode {}

impl fmt::Display for ManageBuyOfferResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ManageBuyOfferResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ManageBuyOfferResultCode::Success,
            -1 => ManageBuyOfferResultCode::Malformed,
            -2 => ManageBuyOfferResultCode::SellNoTrust,
            -3 => ManageBuyOfferResultCode::BuyNoTrust,
            -4 => ManageBuyOfferResultCode::SellNotAuthorized,
            -5 => ManageBuyOfferResultCode::BuyNotAuthorized,
            -6 => ManageBuyOfferResultCode::LineFull,
            -7 => ManageBuyOfferResultCode::Underfunded,
            -8 => ManageBuyOfferResultCode::CrossSelf,
            -9 => ManageBuyOfferResultCode::SellNoIssuer,
            -10 => ManageBuyOfferResultCode::BuyNoIssuer,
            -11 => ManageBuyOfferResultCode::NotFound,
            -12 => ManageBuyOfferResultCode::LowReserve,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ManageBuyOfferResultCode> for i32 {
    #[must_use]
    fn from(e: ManageBuyOfferResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ManageBuyOfferResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ManageBuyOfferResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ManageBuyOfferResult is an XDR Union defines as:
///
/// ```text
/// union ManageBuyOfferResult switch (ManageBuyOfferResultCode code)
/// {
/// case MANAGE_BUY_OFFER_SUCCESS:
///     ManageOfferSuccessResult success;
/// case MANAGE_BUY_OFFER_MALFORMED:
/// case MANAGE_BUY_OFFER_SELL_NO_TRUST:
/// case MANAGE_BUY_OFFER_BUY_NO_TRUST:
/// case MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED:
/// case MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED:
/// case MANAGE_BUY_OFFER_LINE_FULL:
/// case MANAGE_BUY_OFFER_UNDERFUNDED:
/// case MANAGE_BUY_OFFER_CROSS_SELF:
/// case MANAGE_BUY_OFFER_SELL_NO_ISSUER:
/// case MANAGE_BUY_OFFER_BUY_NO_ISSUER:
/// case MANAGE_BUY_OFFER_NOT_FOUND:
/// case MANAGE_BUY_OFFER_LOW_RESERVE:
///     void;
/// };
/// ```
///
// union with discriminant ManageBuyOfferResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ManageBuyOfferResult {
    Success(ManageOfferSuccessResult),
    Malformed,
    SellNoTrust,
    BuyNoTrust,
    SellNotAuthorized,
    BuyNotAuthorized,
    LineFull,
    Underfunded,
    CrossSelf,
    SellNoIssuer,
    BuyNoIssuer,
    NotFound,
    LowReserve,
}

impl ManageBuyOfferResult {
    pub const VARIANTS: [ManageBuyOfferResultCode; 13] = [
        ManageBuyOfferResultCode::Success,
        ManageBuyOfferResultCode::Malformed,
        ManageBuyOfferResultCode::SellNoTrust,
        ManageBuyOfferResultCode::BuyNoTrust,
        ManageBuyOfferResultCode::SellNotAuthorized,
        ManageBuyOfferResultCode::BuyNotAuthorized,
        ManageBuyOfferResultCode::LineFull,
        ManageBuyOfferResultCode::Underfunded,
        ManageBuyOfferResultCode::CrossSelf,
        ManageBuyOfferResultCode::SellNoIssuer,
        ManageBuyOfferResultCode::BuyNoIssuer,
        ManageBuyOfferResultCode::NotFound,
        ManageBuyOfferResultCode::LowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 13] = [
        "Success",
        "Malformed",
        "SellNoTrust",
        "BuyNoTrust",
        "SellNotAuthorized",
        "BuyNotAuthorized",
        "LineFull",
        "Underfunded",
        "CrossSelf",
        "SellNoIssuer",
        "BuyNoIssuer",
        "NotFound",
        "LowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success(_) => "Success",
            Self::Malformed => "Malformed",
            Self::SellNoTrust => "SellNoTrust",
            Self::BuyNoTrust => "BuyNoTrust",
            Self::SellNotAuthorized => "SellNotAuthorized",
            Self::BuyNotAuthorized => "BuyNotAuthorized",
            Self::LineFull => "LineFull",
            Self::Underfunded => "Underfunded",
            Self::CrossSelf => "CrossSelf",
            Self::SellNoIssuer => "SellNoIssuer",
            Self::BuyNoIssuer => "BuyNoIssuer",
            Self::NotFound => "NotFound",
            Self::LowReserve => "LowReserve",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ManageBuyOfferResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success(_) => ManageBuyOfferResultCode::Success,
            Self::Malformed => ManageBuyOfferResultCode::Malformed,
            Self::SellNoTrust => ManageBuyOfferResultCode::SellNoTrust,
            Self::BuyNoTrust => ManageBuyOfferResultCode::BuyNoTrust,
            Self::SellNotAuthorized => ManageBuyOfferResultCode::SellNotAuthorized,
            Self::BuyNotAuthorized => ManageBuyOfferResultCode::BuyNotAuthorized,
            Self::LineFull => ManageBuyOfferResultCode::LineFull,
            Self::Underfunded => ManageBuyOfferResultCode::Underfunded,
            Self::CrossSelf => ManageBuyOfferResultCode::CrossSelf,
            Self::SellNoIssuer => ManageBuyOfferResultCode::SellNoIssuer,
            Self::BuyNoIssuer => ManageBuyOfferResultCode::BuyNoIssuer,
            Self::NotFound => ManageBuyOfferResultCode::NotFound,
            Self::LowReserve => ManageBuyOfferResultCode::LowReserve,
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageBuyOfferResultCode; 13] {
        Self::VARIANTS
    }
}

impl Name for ManageBuyOfferResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ManageBuyOfferResultCode> for ManageBuyOfferResult {
    #[must_use]
    fn discriminant(&self) -> ManageBuyOfferResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ManageBuyOfferResultCode> for ManageBuyOfferResult {
    fn variants() -> slice::Iter<'static, ManageBuyOfferResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ManageBuyOfferResultCode> for ManageBuyOfferResult {}

impl ReadXdr for ManageBuyOfferResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ManageBuyOfferResultCode = <ManageBuyOfferResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ManageBuyOfferResultCode::Success => {
                    Self::Success(ManageOfferSuccessResult::read_xdr(r)?)
                }
                ManageBuyOfferResultCode::Malformed => Self::Malformed,
                ManageBuyOfferResultCode::SellNoTrust => Self::SellNoTrust,
                ManageBuyOfferResultCode::BuyNoTrust => Self::BuyNoTrust,
                ManageBuyOfferResultCode::SellNotAuthorized => Self::SellNotAuthorized,
                ManageBuyOfferResultCode::BuyNotAuthorized => Self::BuyNotAuthorized,
                ManageBuyOfferResultCode::LineFull => Self::LineFull,
                ManageBuyOfferResultCode::Underfunded => Self::Underfunded,
                ManageBuyOfferResultCode::CrossSelf => Self::CrossSelf,
                ManageBuyOfferResultCode::SellNoIssuer => Self::SellNoIssuer,
                ManageBuyOfferResultCode::BuyNoIssuer => Self::BuyNoIssuer,
                ManageBuyOfferResultCode::NotFound => Self::NotFound,
                ManageBuyOfferResultCode::LowReserve => Self::LowReserve,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ManageBuyOfferResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success(v) => v.write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::SellNoTrust => ().write_xdr(w)?,
                Self::BuyNoTrust => ().write_xdr(w)?,
                Self::SellNotAuthorized => ().write_xdr(w)?,
                Self::BuyNotAuthorized => ().write_xdr(w)?,
                Self::LineFull => ().write_xdr(w)?,
                Self::Underfunded => ().write_xdr(w)?,
                Self::CrossSelf => ().write_xdr(w)?,
                Self::SellNoIssuer => ().write_xdr(w)?,
                Self::BuyNoIssuer => ().write_xdr(w)?,
                Self::NotFound => ().write_xdr(w)?,
                Self::LowReserve => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SetOptionsResultCode is an XDR Enum defines as:
///
/// ```text
/// enum SetOptionsResultCode
/// {
///     // codes considered as "success" for the operation
///     SET_OPTIONS_SUCCESS = 0,
///     // codes considered as "failure" for the operation
///     SET_OPTIONS_LOW_RESERVE = -1,      // not enough funds to add a signer
///     SET_OPTIONS_TOO_MANY_SIGNERS = -2, // max number of signers already reached
///     SET_OPTIONS_BAD_FLAGS = -3,        // invalid combination of clear/set flags
///     SET_OPTIONS_INVALID_INFLATION = -4,      // inflation account does not exist
///     SET_OPTIONS_CANT_CHANGE = -5,            // can no longer change this option
///     SET_OPTIONS_UNKNOWN_FLAG = -6,           // can't set an unknown flag
///     SET_OPTIONS_THRESHOLD_OUT_OF_RANGE = -7, // bad value for weight/threshold
///     SET_OPTIONS_BAD_SIGNER = -8,             // signer cannot be masterkey
///     SET_OPTIONS_INVALID_HOME_DOMAIN = -9,    // malformed home domain
///     SET_OPTIONS_AUTH_REVOCABLE_REQUIRED =
///         -10 // auth revocable is required for clawback
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum SetOptionsResultCode {
    Success = 0,
    LowReserve = -1,
    TooManySigners = -2,
    BadFlags = -3,
    InvalidInflation = -4,
    CantChange = -5,
    UnknownFlag = -6,
    ThresholdOutOfRange = -7,
    BadSigner = -8,
    InvalidHomeDomain = -9,
    AuthRevocableRequired = -10,
}

impl SetOptionsResultCode {
    pub const VARIANTS: [SetOptionsResultCode; 11] = [
        SetOptionsResultCode::Success,
        SetOptionsResultCode::LowReserve,
        SetOptionsResultCode::TooManySigners,
        SetOptionsResultCode::BadFlags,
        SetOptionsResultCode::InvalidInflation,
        SetOptionsResultCode::CantChange,
        SetOptionsResultCode::UnknownFlag,
        SetOptionsResultCode::ThresholdOutOfRange,
        SetOptionsResultCode::BadSigner,
        SetOptionsResultCode::InvalidHomeDomain,
        SetOptionsResultCode::AuthRevocableRequired,
    ];
    pub const VARIANTS_STR: [&'static str; 11] = [
        "Success",
        "LowReserve",
        "TooManySigners",
        "BadFlags",
        "InvalidInflation",
        "CantChange",
        "UnknownFlag",
        "ThresholdOutOfRange",
        "BadSigner",
        "InvalidHomeDomain",
        "AuthRevocableRequired",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::LowReserve => "LowReserve",
            Self::TooManySigners => "TooManySigners",
            Self::BadFlags => "BadFlags",
            Self::InvalidInflation => "InvalidInflation",
            Self::CantChange => "CantChange",
            Self::UnknownFlag => "UnknownFlag",
            Self::ThresholdOutOfRange => "ThresholdOutOfRange",
            Self::BadSigner => "BadSigner",
            Self::InvalidHomeDomain => "InvalidHomeDomain",
            Self::AuthRevocableRequired => "AuthRevocableRequired",
        }
    }

    #[must_use]
    pub const fn variants() -> [SetOptionsResultCode; 11] {
        Self::VARIANTS
    }
}

impl Name for SetOptionsResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SetOptionsResultCode> for SetOptionsResultCode {
    fn variants() -> slice::Iter<'static, SetOptionsResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SetOptionsResultCode {}

impl fmt::Display for SetOptionsResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SetOptionsResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => SetOptionsResultCode::Success,
            -1 => SetOptionsResultCode::LowReserve,
            -2 => SetOptionsResultCode::TooManySigners,
            -3 => SetOptionsResultCode::BadFlags,
            -4 => SetOptionsResultCode::InvalidInflation,
            -5 => SetOptionsResultCode::CantChange,
            -6 => SetOptionsResultCode::UnknownFlag,
            -7 => SetOptionsResultCode::ThresholdOutOfRange,
            -8 => SetOptionsResultCode::BadSigner,
            -9 => SetOptionsResultCode::InvalidHomeDomain,
            -10 => SetOptionsResultCode::AuthRevocableRequired,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SetOptionsResultCode> for i32 {
    #[must_use]
    fn from(e: SetOptionsResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for SetOptionsResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SetOptionsResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SetOptionsResult is an XDR Union defines as:
///
/// ```text
/// union SetOptionsResult switch (SetOptionsResultCode code)
/// {
/// case SET_OPTIONS_SUCCESS:
///     void;
/// case SET_OPTIONS_LOW_RESERVE:
/// case SET_OPTIONS_TOO_MANY_SIGNERS:
/// case SET_OPTIONS_BAD_FLAGS:
/// case SET_OPTIONS_INVALID_INFLATION:
/// case SET_OPTIONS_CANT_CHANGE:
/// case SET_OPTIONS_UNKNOWN_FLAG:
/// case SET_OPTIONS_THRESHOLD_OUT_OF_RANGE:
/// case SET_OPTIONS_BAD_SIGNER:
/// case SET_OPTIONS_INVALID_HOME_DOMAIN:
/// case SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
///     void;
/// };
/// ```
///
// union with discriminant SetOptionsResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum SetOptionsResult {
    Success,
    LowReserve,
    TooManySigners,
    BadFlags,
    InvalidInflation,
    CantChange,
    UnknownFlag,
    ThresholdOutOfRange,
    BadSigner,
    InvalidHomeDomain,
    AuthRevocableRequired,
}

impl SetOptionsResult {
    pub const VARIANTS: [SetOptionsResultCode; 11] = [
        SetOptionsResultCode::Success,
        SetOptionsResultCode::LowReserve,
        SetOptionsResultCode::TooManySigners,
        SetOptionsResultCode::BadFlags,
        SetOptionsResultCode::InvalidInflation,
        SetOptionsResultCode::CantChange,
        SetOptionsResultCode::UnknownFlag,
        SetOptionsResultCode::ThresholdOutOfRange,
        SetOptionsResultCode::BadSigner,
        SetOptionsResultCode::InvalidHomeDomain,
        SetOptionsResultCode::AuthRevocableRequired,
    ];
    pub const VARIANTS_STR: [&'static str; 11] = [
        "Success",
        "LowReserve",
        "TooManySigners",
        "BadFlags",
        "InvalidInflation",
        "CantChange",
        "UnknownFlag",
        "ThresholdOutOfRange",
        "BadSigner",
        "InvalidHomeDomain",
        "AuthRevocableRequired",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::LowReserve => "LowReserve",
            Self::TooManySigners => "TooManySigners",
            Self::BadFlags => "BadFlags",
            Self::InvalidInflation => "InvalidInflation",
            Self::CantChange => "CantChange",
            Self::UnknownFlag => "UnknownFlag",
            Self::ThresholdOutOfRange => "ThresholdOutOfRange",
            Self::BadSigner => "BadSigner",
            Self::InvalidHomeDomain => "InvalidHomeDomain",
            Self::AuthRevocableRequired => "AuthRevocableRequired",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SetOptionsResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => SetOptionsResultCode::Success,
            Self::LowReserve => SetOptionsResultCode::LowReserve,
            Self::TooManySigners => SetOptionsResultCode::TooManySigners,
            Self::BadFlags => SetOptionsResultCode::BadFlags,
            Self::InvalidInflation => SetOptionsResultCode::InvalidInflation,
            Self::CantChange => SetOptionsResultCode::CantChange,
            Self::UnknownFlag => SetOptionsResultCode::UnknownFlag,
            Self::ThresholdOutOfRange => SetOptionsResultCode::ThresholdOutOfRange,
            Self::BadSigner => SetOptionsResultCode::BadSigner,
            Self::InvalidHomeDomain => SetOptionsResultCode::InvalidHomeDomain,
            Self::AuthRevocableRequired => SetOptionsResultCode::AuthRevocableRequired,
        }
    }

    #[must_use]
    pub const fn variants() -> [SetOptionsResultCode; 11] {
        Self::VARIANTS
    }
}

impl Name for SetOptionsResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SetOptionsResultCode> for SetOptionsResult {
    #[must_use]
    fn discriminant(&self) -> SetOptionsResultCode {
        Self::discriminant(self)
    }
}

impl Variants<SetOptionsResultCode> for SetOptionsResult {
    fn variants() -> slice::Iter<'static, SetOptionsResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<SetOptionsResultCode> for SetOptionsResult {}

impl ReadXdr for SetOptionsResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: SetOptionsResultCode = <SetOptionsResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                SetOptionsResultCode::Success => Self::Success,
                SetOptionsResultCode::LowReserve => Self::LowReserve,
                SetOptionsResultCode::TooManySigners => Self::TooManySigners,
                SetOptionsResultCode::BadFlags => Self::BadFlags,
                SetOptionsResultCode::InvalidInflation => Self::InvalidInflation,
                SetOptionsResultCode::CantChange => Self::CantChange,
                SetOptionsResultCode::UnknownFlag => Self::UnknownFlag,
                SetOptionsResultCode::ThresholdOutOfRange => Self::ThresholdOutOfRange,
                SetOptionsResultCode::BadSigner => Self::BadSigner,
                SetOptionsResultCode::InvalidHomeDomain => Self::InvalidHomeDomain,
                SetOptionsResultCode::AuthRevocableRequired => Self::AuthRevocableRequired,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SetOptionsResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::LowReserve => ().write_xdr(w)?,
                Self::TooManySigners => ().write_xdr(w)?,
                Self::BadFlags => ().write_xdr(w)?,
                Self::InvalidInflation => ().write_xdr(w)?,
                Self::CantChange => ().write_xdr(w)?,
                Self::UnknownFlag => ().write_xdr(w)?,
                Self::ThresholdOutOfRange => ().write_xdr(w)?,
                Self::BadSigner => ().write_xdr(w)?,
                Self::InvalidHomeDomain => ().write_xdr(w)?,
                Self::AuthRevocableRequired => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ChangeTrustResultCode is an XDR Enum defines as:
///
/// ```text
/// enum ChangeTrustResultCode
/// {
///     // codes considered as "success" for the operation
///     CHANGE_TRUST_SUCCESS = 0,
///     // codes considered as "failure" for the operation
///     CHANGE_TRUST_MALFORMED = -1,     // bad input
///     CHANGE_TRUST_NO_ISSUER = -2,     // could not find issuer
///     CHANGE_TRUST_INVALID_LIMIT = -3, // cannot drop limit below balance
///                                      // cannot create with a limit of 0
///     CHANGE_TRUST_LOW_RESERVE =
///         -4, // not enough funds to create a new trust line,
///     CHANGE_TRUST_SELF_NOT_ALLOWED = -5,   // trusting self is not allowed
///     CHANGE_TRUST_TRUST_LINE_MISSING = -6, // Asset trustline is missing for pool
///     CHANGE_TRUST_CANNOT_DELETE =
///         -7, // Asset trustline is still referenced in a pool
///     CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES =
///         -8 // Asset trustline is deauthorized
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ChangeTrustResultCode {
    Success = 0,
    Malformed = -1,
    NoIssuer = -2,
    InvalidLimit = -3,
    LowReserve = -4,
    SelfNotAllowed = -5,
    TrustLineMissing = -6,
    CannotDelete = -7,
    NotAuthMaintainLiabilities = -8,
}

impl ChangeTrustResultCode {
    pub const VARIANTS: [ChangeTrustResultCode; 9] = [
        ChangeTrustResultCode::Success,
        ChangeTrustResultCode::Malformed,
        ChangeTrustResultCode::NoIssuer,
        ChangeTrustResultCode::InvalidLimit,
        ChangeTrustResultCode::LowReserve,
        ChangeTrustResultCode::SelfNotAllowed,
        ChangeTrustResultCode::TrustLineMissing,
        ChangeTrustResultCode::CannotDelete,
        ChangeTrustResultCode::NotAuthMaintainLiabilities,
    ];
    pub const VARIANTS_STR: [&'static str; 9] = [
        "Success",
        "Malformed",
        "NoIssuer",
        "InvalidLimit",
        "LowReserve",
        "SelfNotAllowed",
        "TrustLineMissing",
        "CannotDelete",
        "NotAuthMaintainLiabilities",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NoIssuer => "NoIssuer",
            Self::InvalidLimit => "InvalidLimit",
            Self::LowReserve => "LowReserve",
            Self::SelfNotAllowed => "SelfNotAllowed",
            Self::TrustLineMissing => "TrustLineMissing",
            Self::CannotDelete => "CannotDelete",
            Self::NotAuthMaintainLiabilities => "NotAuthMaintainLiabilities",
        }
    }

    #[must_use]
    pub const fn variants() -> [ChangeTrustResultCode; 9] {
        Self::VARIANTS
    }
}

impl Name for ChangeTrustResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ChangeTrustResultCode> for ChangeTrustResultCode {
    fn variants() -> slice::Iter<'static, ChangeTrustResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ChangeTrustResultCode {}

impl fmt::Display for ChangeTrustResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ChangeTrustResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ChangeTrustResultCode::Success,
            -1 => ChangeTrustResultCode::Malformed,
            -2 => ChangeTrustResultCode::NoIssuer,
            -3 => ChangeTrustResultCode::InvalidLimit,
            -4 => ChangeTrustResultCode::LowReserve,
            -5 => ChangeTrustResultCode::SelfNotAllowed,
            -6 => ChangeTrustResultCode::TrustLineMissing,
            -7 => ChangeTrustResultCode::CannotDelete,
            -8 => ChangeTrustResultCode::NotAuthMaintainLiabilities,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ChangeTrustResultCode> for i32 {
    #[must_use]
    fn from(e: ChangeTrustResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ChangeTrustResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ChangeTrustResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ChangeTrustResult is an XDR Union defines as:
///
/// ```text
/// union ChangeTrustResult switch (ChangeTrustResultCode code)
/// {
/// case CHANGE_TRUST_SUCCESS:
///     void;
/// case CHANGE_TRUST_MALFORMED:
/// case CHANGE_TRUST_NO_ISSUER:
/// case CHANGE_TRUST_INVALID_LIMIT:
/// case CHANGE_TRUST_LOW_RESERVE:
/// case CHANGE_TRUST_SELF_NOT_ALLOWED:
/// case CHANGE_TRUST_TRUST_LINE_MISSING:
/// case CHANGE_TRUST_CANNOT_DELETE:
/// case CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
///     void;
/// };
/// ```
///
// union with discriminant ChangeTrustResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ChangeTrustResult {
    Success,
    Malformed,
    NoIssuer,
    InvalidLimit,
    LowReserve,
    SelfNotAllowed,
    TrustLineMissing,
    CannotDelete,
    NotAuthMaintainLiabilities,
}

impl ChangeTrustResult {
    pub const VARIANTS: [ChangeTrustResultCode; 9] = [
        ChangeTrustResultCode::Success,
        ChangeTrustResultCode::Malformed,
        ChangeTrustResultCode::NoIssuer,
        ChangeTrustResultCode::InvalidLimit,
        ChangeTrustResultCode::LowReserve,
        ChangeTrustResultCode::SelfNotAllowed,
        ChangeTrustResultCode::TrustLineMissing,
        ChangeTrustResultCode::CannotDelete,
        ChangeTrustResultCode::NotAuthMaintainLiabilities,
    ];
    pub const VARIANTS_STR: [&'static str; 9] = [
        "Success",
        "Malformed",
        "NoIssuer",
        "InvalidLimit",
        "LowReserve",
        "SelfNotAllowed",
        "TrustLineMissing",
        "CannotDelete",
        "NotAuthMaintainLiabilities",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NoIssuer => "NoIssuer",
            Self::InvalidLimit => "InvalidLimit",
            Self::LowReserve => "LowReserve",
            Self::SelfNotAllowed => "SelfNotAllowed",
            Self::TrustLineMissing => "TrustLineMissing",
            Self::CannotDelete => "CannotDelete",
            Self::NotAuthMaintainLiabilities => "NotAuthMaintainLiabilities",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ChangeTrustResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => ChangeTrustResultCode::Success,
            Self::Malformed => ChangeTrustResultCode::Malformed,
            Self::NoIssuer => ChangeTrustResultCode::NoIssuer,
            Self::InvalidLimit => ChangeTrustResultCode::InvalidLimit,
            Self::LowReserve => ChangeTrustResultCode::LowReserve,
            Self::SelfNotAllowed => ChangeTrustResultCode::SelfNotAllowed,
            Self::TrustLineMissing => ChangeTrustResultCode::TrustLineMissing,
            Self::CannotDelete => ChangeTrustResultCode::CannotDelete,
            Self::NotAuthMaintainLiabilities => ChangeTrustResultCode::NotAuthMaintainLiabilities,
        }
    }

    #[must_use]
    pub const fn variants() -> [ChangeTrustResultCode; 9] {
        Self::VARIANTS
    }
}

impl Name for ChangeTrustResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ChangeTrustResultCode> for ChangeTrustResult {
    #[must_use]
    fn discriminant(&self) -> ChangeTrustResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ChangeTrustResultCode> for ChangeTrustResult {
    fn variants() -> slice::Iter<'static, ChangeTrustResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ChangeTrustResultCode> for ChangeTrustResult {}

impl ReadXdr for ChangeTrustResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ChangeTrustResultCode = <ChangeTrustResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ChangeTrustResultCode::Success => Self::Success,
                ChangeTrustResultCode::Malformed => Self::Malformed,
                ChangeTrustResultCode::NoIssuer => Self::NoIssuer,
                ChangeTrustResultCode::InvalidLimit => Self::InvalidLimit,
                ChangeTrustResultCode::LowReserve => Self::LowReserve,
                ChangeTrustResultCode::SelfNotAllowed => Self::SelfNotAllowed,
                ChangeTrustResultCode::TrustLineMissing => Self::TrustLineMissing,
                ChangeTrustResultCode::CannotDelete => Self::CannotDelete,
                ChangeTrustResultCode::NotAuthMaintainLiabilities => {
                    Self::NotAuthMaintainLiabilities
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ChangeTrustResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::NoIssuer => ().write_xdr(w)?,
                Self::InvalidLimit => ().write_xdr(w)?,
                Self::LowReserve => ().write_xdr(w)?,
                Self::SelfNotAllowed => ().write_xdr(w)?,
                Self::TrustLineMissing => ().write_xdr(w)?,
                Self::CannotDelete => ().write_xdr(w)?,
                Self::NotAuthMaintainLiabilities => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AllowTrustResultCode is an XDR Enum defines as:
///
/// ```text
/// enum AllowTrustResultCode
/// {
///     // codes considered as "success" for the operation
///     ALLOW_TRUST_SUCCESS = 0,
///     // codes considered as "failure" for the operation
///     ALLOW_TRUST_MALFORMED = -1,     // asset is not ASSET_TYPE_ALPHANUM
///     ALLOW_TRUST_NO_TRUST_LINE = -2, // trustor does not have a trustline
///                                     // source account does not require trust
///     ALLOW_TRUST_TRUST_NOT_REQUIRED = -3,
///     ALLOW_TRUST_CANT_REVOKE = -4,      // source account can't revoke trust,
///     ALLOW_TRUST_SELF_NOT_ALLOWED = -5, // trusting self is not allowed
///     ALLOW_TRUST_LOW_RESERVE = -6       // claimable balances can't be created
///                                        // on revoke due to low reserves
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum AllowTrustResultCode {
    Success = 0,
    Malformed = -1,
    NoTrustLine = -2,
    TrustNotRequired = -3,
    CantRevoke = -4,
    SelfNotAllowed = -5,
    LowReserve = -6,
}

impl AllowTrustResultCode {
    pub const VARIANTS: [AllowTrustResultCode; 7] = [
        AllowTrustResultCode::Success,
        AllowTrustResultCode::Malformed,
        AllowTrustResultCode::NoTrustLine,
        AllowTrustResultCode::TrustNotRequired,
        AllowTrustResultCode::CantRevoke,
        AllowTrustResultCode::SelfNotAllowed,
        AllowTrustResultCode::LowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "Success",
        "Malformed",
        "NoTrustLine",
        "TrustNotRequired",
        "CantRevoke",
        "SelfNotAllowed",
        "LowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NoTrustLine => "NoTrustLine",
            Self::TrustNotRequired => "TrustNotRequired",
            Self::CantRevoke => "CantRevoke",
            Self::SelfNotAllowed => "SelfNotAllowed",
            Self::LowReserve => "LowReserve",
        }
    }

    #[must_use]
    pub const fn variants() -> [AllowTrustResultCode; 7] {
        Self::VARIANTS
    }
}

impl Name for AllowTrustResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<AllowTrustResultCode> for AllowTrustResultCode {
    fn variants() -> slice::Iter<'static, AllowTrustResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for AllowTrustResultCode {}

impl fmt::Display for AllowTrustResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for AllowTrustResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => AllowTrustResultCode::Success,
            -1 => AllowTrustResultCode::Malformed,
            -2 => AllowTrustResultCode::NoTrustLine,
            -3 => AllowTrustResultCode::TrustNotRequired,
            -4 => AllowTrustResultCode::CantRevoke,
            -5 => AllowTrustResultCode::SelfNotAllowed,
            -6 => AllowTrustResultCode::LowReserve,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<AllowTrustResultCode> for i32 {
    #[must_use]
    fn from(e: AllowTrustResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for AllowTrustResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for AllowTrustResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// AllowTrustResult is an XDR Union defines as:
///
/// ```text
/// union AllowTrustResult switch (AllowTrustResultCode code)
/// {
/// case ALLOW_TRUST_SUCCESS:
///     void;
/// case ALLOW_TRUST_MALFORMED:
/// case ALLOW_TRUST_NO_TRUST_LINE:
/// case ALLOW_TRUST_TRUST_NOT_REQUIRED:
/// case ALLOW_TRUST_CANT_REVOKE:
/// case ALLOW_TRUST_SELF_NOT_ALLOWED:
/// case ALLOW_TRUST_LOW_RESERVE:
///     void;
/// };
/// ```
///
// union with discriminant AllowTrustResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum AllowTrustResult {
    Success,
    Malformed,
    NoTrustLine,
    TrustNotRequired,
    CantRevoke,
    SelfNotAllowed,
    LowReserve,
}

impl AllowTrustResult {
    pub const VARIANTS: [AllowTrustResultCode; 7] = [
        AllowTrustResultCode::Success,
        AllowTrustResultCode::Malformed,
        AllowTrustResultCode::NoTrustLine,
        AllowTrustResultCode::TrustNotRequired,
        AllowTrustResultCode::CantRevoke,
        AllowTrustResultCode::SelfNotAllowed,
        AllowTrustResultCode::LowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "Success",
        "Malformed",
        "NoTrustLine",
        "TrustNotRequired",
        "CantRevoke",
        "SelfNotAllowed",
        "LowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NoTrustLine => "NoTrustLine",
            Self::TrustNotRequired => "TrustNotRequired",
            Self::CantRevoke => "CantRevoke",
            Self::SelfNotAllowed => "SelfNotAllowed",
            Self::LowReserve => "LowReserve",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AllowTrustResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => AllowTrustResultCode::Success,
            Self::Malformed => AllowTrustResultCode::Malformed,
            Self::NoTrustLine => AllowTrustResultCode::NoTrustLine,
            Self::TrustNotRequired => AllowTrustResultCode::TrustNotRequired,
            Self::CantRevoke => AllowTrustResultCode::CantRevoke,
            Self::SelfNotAllowed => AllowTrustResultCode::SelfNotAllowed,
            Self::LowReserve => AllowTrustResultCode::LowReserve,
        }
    }

    #[must_use]
    pub const fn variants() -> [AllowTrustResultCode; 7] {
        Self::VARIANTS
    }
}

impl Name for AllowTrustResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AllowTrustResultCode> for AllowTrustResult {
    #[must_use]
    fn discriminant(&self) -> AllowTrustResultCode {
        Self::discriminant(self)
    }
}

impl Variants<AllowTrustResultCode> for AllowTrustResult {
    fn variants() -> slice::Iter<'static, AllowTrustResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<AllowTrustResultCode> for AllowTrustResult {}

impl ReadXdr for AllowTrustResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: AllowTrustResultCode = <AllowTrustResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AllowTrustResultCode::Success => Self::Success,
                AllowTrustResultCode::Malformed => Self::Malformed,
                AllowTrustResultCode::NoTrustLine => Self::NoTrustLine,
                AllowTrustResultCode::TrustNotRequired => Self::TrustNotRequired,
                AllowTrustResultCode::CantRevoke => Self::CantRevoke,
                AllowTrustResultCode::SelfNotAllowed => Self::SelfNotAllowed,
                AllowTrustResultCode::LowReserve => Self::LowReserve,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AllowTrustResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::NoTrustLine => ().write_xdr(w)?,
                Self::TrustNotRequired => ().write_xdr(w)?,
                Self::CantRevoke => ().write_xdr(w)?,
                Self::SelfNotAllowed => ().write_xdr(w)?,
                Self::LowReserve => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// AccountMergeResultCode is an XDR Enum defines as:
///
/// ```text
/// enum AccountMergeResultCode
/// {
///     // codes considered as "success" for the operation
///     ACCOUNT_MERGE_SUCCESS = 0,
///     // codes considered as "failure" for the operation
///     ACCOUNT_MERGE_MALFORMED = -1,       // can't merge onto itself
///     ACCOUNT_MERGE_NO_ACCOUNT = -2,      // destination does not exist
///     ACCOUNT_MERGE_IMMUTABLE_SET = -3,   // source account has AUTH_IMMUTABLE set
///     ACCOUNT_MERGE_HAS_SUB_ENTRIES = -4, // account has trust lines/offers
///     ACCOUNT_MERGE_SEQNUM_TOO_FAR = -5,  // sequence number is over max allowed
///     ACCOUNT_MERGE_DEST_FULL = -6,       // can't add source balance to
///                                         // destination balance
///     ACCOUNT_MERGE_IS_SPONSOR = -7       // can't merge account that is a sponsor
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum AccountMergeResultCode {
    Success = 0,
    Malformed = -1,
    NoAccount = -2,
    ImmutableSet = -3,
    HasSubEntries = -4,
    SeqnumTooFar = -5,
    DestFull = -6,
    IsSponsor = -7,
}

impl AccountMergeResultCode {
    pub const VARIANTS: [AccountMergeResultCode; 8] = [
        AccountMergeResultCode::Success,
        AccountMergeResultCode::Malformed,
        AccountMergeResultCode::NoAccount,
        AccountMergeResultCode::ImmutableSet,
        AccountMergeResultCode::HasSubEntries,
        AccountMergeResultCode::SeqnumTooFar,
        AccountMergeResultCode::DestFull,
        AccountMergeResultCode::IsSponsor,
    ];
    pub const VARIANTS_STR: [&'static str; 8] = [
        "Success",
        "Malformed",
        "NoAccount",
        "ImmutableSet",
        "HasSubEntries",
        "SeqnumTooFar",
        "DestFull",
        "IsSponsor",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NoAccount => "NoAccount",
            Self::ImmutableSet => "ImmutableSet",
            Self::HasSubEntries => "HasSubEntries",
            Self::SeqnumTooFar => "SeqnumTooFar",
            Self::DestFull => "DestFull",
            Self::IsSponsor => "IsSponsor",
        }
    }

    #[must_use]
    pub const fn variants() -> [AccountMergeResultCode; 8] {
        Self::VARIANTS
    }
}

impl Name for AccountMergeResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<AccountMergeResultCode> for AccountMergeResultCode {
    fn variants() -> slice::Iter<'static, AccountMergeResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for AccountMergeResultCode {}

impl fmt::Display for AccountMergeResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for AccountMergeResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => AccountMergeResultCode::Success,
            -1 => AccountMergeResultCode::Malformed,
            -2 => AccountMergeResultCode::NoAccount,
            -3 => AccountMergeResultCode::ImmutableSet,
            -4 => AccountMergeResultCode::HasSubEntries,
            -5 => AccountMergeResultCode::SeqnumTooFar,
            -6 => AccountMergeResultCode::DestFull,
            -7 => AccountMergeResultCode::IsSponsor,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<AccountMergeResultCode> for i32 {
    #[must_use]
    fn from(e: AccountMergeResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for AccountMergeResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for AccountMergeResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// AccountMergeResult is an XDR Union defines as:
///
/// ```text
/// union AccountMergeResult switch (AccountMergeResultCode code)
/// {
/// case ACCOUNT_MERGE_SUCCESS:
///     int64 sourceAccountBalance; // how much got transferred from source account
/// case ACCOUNT_MERGE_MALFORMED:
/// case ACCOUNT_MERGE_NO_ACCOUNT:
/// case ACCOUNT_MERGE_IMMUTABLE_SET:
/// case ACCOUNT_MERGE_HAS_SUB_ENTRIES:
/// case ACCOUNT_MERGE_SEQNUM_TOO_FAR:
/// case ACCOUNT_MERGE_DEST_FULL:
/// case ACCOUNT_MERGE_IS_SPONSOR:
///     void;
/// };
/// ```
///
// union with discriminant AccountMergeResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum AccountMergeResult {
    Success(i64),
    Malformed,
    NoAccount,
    ImmutableSet,
    HasSubEntries,
    SeqnumTooFar,
    DestFull,
    IsSponsor,
}

impl AccountMergeResult {
    pub const VARIANTS: [AccountMergeResultCode; 8] = [
        AccountMergeResultCode::Success,
        AccountMergeResultCode::Malformed,
        AccountMergeResultCode::NoAccount,
        AccountMergeResultCode::ImmutableSet,
        AccountMergeResultCode::HasSubEntries,
        AccountMergeResultCode::SeqnumTooFar,
        AccountMergeResultCode::DestFull,
        AccountMergeResultCode::IsSponsor,
    ];
    pub const VARIANTS_STR: [&'static str; 8] = [
        "Success",
        "Malformed",
        "NoAccount",
        "ImmutableSet",
        "HasSubEntries",
        "SeqnumTooFar",
        "DestFull",
        "IsSponsor",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success(_) => "Success",
            Self::Malformed => "Malformed",
            Self::NoAccount => "NoAccount",
            Self::ImmutableSet => "ImmutableSet",
            Self::HasSubEntries => "HasSubEntries",
            Self::SeqnumTooFar => "SeqnumTooFar",
            Self::DestFull => "DestFull",
            Self::IsSponsor => "IsSponsor",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> AccountMergeResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success(_) => AccountMergeResultCode::Success,
            Self::Malformed => AccountMergeResultCode::Malformed,
            Self::NoAccount => AccountMergeResultCode::NoAccount,
            Self::ImmutableSet => AccountMergeResultCode::ImmutableSet,
            Self::HasSubEntries => AccountMergeResultCode::HasSubEntries,
            Self::SeqnumTooFar => AccountMergeResultCode::SeqnumTooFar,
            Self::DestFull => AccountMergeResultCode::DestFull,
            Self::IsSponsor => AccountMergeResultCode::IsSponsor,
        }
    }

    #[must_use]
    pub const fn variants() -> [AccountMergeResultCode; 8] {
        Self::VARIANTS
    }
}

impl Name for AccountMergeResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<AccountMergeResultCode> for AccountMergeResult {
    #[must_use]
    fn discriminant(&self) -> AccountMergeResultCode {
        Self::discriminant(self)
    }
}

impl Variants<AccountMergeResultCode> for AccountMergeResult {
    fn variants() -> slice::Iter<'static, AccountMergeResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<AccountMergeResultCode> for AccountMergeResult {}

impl ReadXdr for AccountMergeResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: AccountMergeResultCode = <AccountMergeResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                AccountMergeResultCode::Success => Self::Success(i64::read_xdr(r)?),
                AccountMergeResultCode::Malformed => Self::Malformed,
                AccountMergeResultCode::NoAccount => Self::NoAccount,
                AccountMergeResultCode::ImmutableSet => Self::ImmutableSet,
                AccountMergeResultCode::HasSubEntries => Self::HasSubEntries,
                AccountMergeResultCode::SeqnumTooFar => Self::SeqnumTooFar,
                AccountMergeResultCode::DestFull => Self::DestFull,
                AccountMergeResultCode::IsSponsor => Self::IsSponsor,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for AccountMergeResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success(v) => v.write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::NoAccount => ().write_xdr(w)?,
                Self::ImmutableSet => ().write_xdr(w)?,
                Self::HasSubEntries => ().write_xdr(w)?,
                Self::SeqnumTooFar => ().write_xdr(w)?,
                Self::DestFull => ().write_xdr(w)?,
                Self::IsSponsor => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// InflationResultCode is an XDR Enum defines as:
///
/// ```text
/// enum InflationResultCode
/// {
///     // codes considered as "success" for the operation
///     INFLATION_SUCCESS = 0,
///     // codes considered as "failure" for the operation
///     INFLATION_NOT_TIME = -1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum InflationResultCode {
    Success = 0,
    NotTime = -1,
}

impl InflationResultCode {
    pub const VARIANTS: [InflationResultCode; 2] =
        [InflationResultCode::Success, InflationResultCode::NotTime];
    pub const VARIANTS_STR: [&'static str; 2] = ["Success", "NotTime"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::NotTime => "NotTime",
        }
    }

    #[must_use]
    pub const fn variants() -> [InflationResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for InflationResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<InflationResultCode> for InflationResultCode {
    fn variants() -> slice::Iter<'static, InflationResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for InflationResultCode {}

impl fmt::Display for InflationResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for InflationResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => InflationResultCode::Success,
            -1 => InflationResultCode::NotTime,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<InflationResultCode> for i32 {
    #[must_use]
    fn from(e: InflationResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for InflationResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for InflationResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// InflationPayout is an XDR Struct defines as:
///
/// ```text
/// struct InflationPayout // or use PaymentResultAtom to limit types?
/// {
///     AccountID destination;
///     int64 amount;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct InflationPayout {
    pub destination: AccountId,
    pub amount: i64,
}

impl ReadXdr for InflationPayout {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                destination: AccountId::read_xdr(r)?,
                amount: i64::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InflationPayout {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.destination.write_xdr(w)?;
            self.amount.write_xdr(w)?;
            Ok(())
        })
    }
}

/// InflationResult is an XDR Union defines as:
///
/// ```text
/// union InflationResult switch (InflationResultCode code)
/// {
/// case INFLATION_SUCCESS:
///     InflationPayout payouts<>;
/// case INFLATION_NOT_TIME:
///     void;
/// };
/// ```
///
// union with discriminant InflationResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum InflationResult {
    Success(VecM<InflationPayout>),
    NotTime,
}

impl InflationResult {
    pub const VARIANTS: [InflationResultCode; 2] =
        [InflationResultCode::Success, InflationResultCode::NotTime];
    pub const VARIANTS_STR: [&'static str; 2] = ["Success", "NotTime"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success(_) => "Success",
            Self::NotTime => "NotTime",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> InflationResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success(_) => InflationResultCode::Success,
            Self::NotTime => InflationResultCode::NotTime,
        }
    }

    #[must_use]
    pub const fn variants() -> [InflationResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for InflationResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<InflationResultCode> for InflationResult {
    #[must_use]
    fn discriminant(&self) -> InflationResultCode {
        Self::discriminant(self)
    }
}

impl Variants<InflationResultCode> for InflationResult {
    fn variants() -> slice::Iter<'static, InflationResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<InflationResultCode> for InflationResult {}

impl ReadXdr for InflationResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: InflationResultCode = <InflationResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                InflationResultCode::Success => {
                    Self::Success(VecM::<InflationPayout>::read_xdr(r)?)
                }
                InflationResultCode::NotTime => Self::NotTime,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for InflationResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success(v) => v.write_xdr(w)?,
                Self::NotTime => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ManageDataResultCode is an XDR Enum defines as:
///
/// ```text
/// enum ManageDataResultCode
/// {
///     // codes considered as "success" for the operation
///     MANAGE_DATA_SUCCESS = 0,
///     // codes considered as "failure" for the operation
///     MANAGE_DATA_NOT_SUPPORTED_YET =
///         -1, // The network hasn't moved to this protocol change yet
///     MANAGE_DATA_NAME_NOT_FOUND =
///         -2, // Trying to remove a Data Entry that isn't there
///     MANAGE_DATA_LOW_RESERVE = -3, // not enough funds to create a new Data Entry
///     MANAGE_DATA_INVALID_NAME = -4 // Name not a valid string
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ManageDataResultCode {
    Success = 0,
    NotSupportedYet = -1,
    NameNotFound = -2,
    LowReserve = -3,
    InvalidName = -4,
}

impl ManageDataResultCode {
    pub const VARIANTS: [ManageDataResultCode; 5] = [
        ManageDataResultCode::Success,
        ManageDataResultCode::NotSupportedYet,
        ManageDataResultCode::NameNotFound,
        ManageDataResultCode::LowReserve,
        ManageDataResultCode::InvalidName,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "Success",
        "NotSupportedYet",
        "NameNotFound",
        "LowReserve",
        "InvalidName",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::NotSupportedYet => "NotSupportedYet",
            Self::NameNotFound => "NameNotFound",
            Self::LowReserve => "LowReserve",
            Self::InvalidName => "InvalidName",
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageDataResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for ManageDataResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ManageDataResultCode> for ManageDataResultCode {
    fn variants() -> slice::Iter<'static, ManageDataResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ManageDataResultCode {}

impl fmt::Display for ManageDataResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ManageDataResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ManageDataResultCode::Success,
            -1 => ManageDataResultCode::NotSupportedYet,
            -2 => ManageDataResultCode::NameNotFound,
            -3 => ManageDataResultCode::LowReserve,
            -4 => ManageDataResultCode::InvalidName,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ManageDataResultCode> for i32 {
    #[must_use]
    fn from(e: ManageDataResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ManageDataResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ManageDataResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ManageDataResult is an XDR Union defines as:
///
/// ```text
/// union ManageDataResult switch (ManageDataResultCode code)
/// {
/// case MANAGE_DATA_SUCCESS:
///     void;
/// case MANAGE_DATA_NOT_SUPPORTED_YET:
/// case MANAGE_DATA_NAME_NOT_FOUND:
/// case MANAGE_DATA_LOW_RESERVE:
/// case MANAGE_DATA_INVALID_NAME:
///     void;
/// };
/// ```
///
// union with discriminant ManageDataResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ManageDataResult {
    Success,
    NotSupportedYet,
    NameNotFound,
    LowReserve,
    InvalidName,
}

impl ManageDataResult {
    pub const VARIANTS: [ManageDataResultCode; 5] = [
        ManageDataResultCode::Success,
        ManageDataResultCode::NotSupportedYet,
        ManageDataResultCode::NameNotFound,
        ManageDataResultCode::LowReserve,
        ManageDataResultCode::InvalidName,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "Success",
        "NotSupportedYet",
        "NameNotFound",
        "LowReserve",
        "InvalidName",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::NotSupportedYet => "NotSupportedYet",
            Self::NameNotFound => "NameNotFound",
            Self::LowReserve => "LowReserve",
            Self::InvalidName => "InvalidName",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ManageDataResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => ManageDataResultCode::Success,
            Self::NotSupportedYet => ManageDataResultCode::NotSupportedYet,
            Self::NameNotFound => ManageDataResultCode::NameNotFound,
            Self::LowReserve => ManageDataResultCode::LowReserve,
            Self::InvalidName => ManageDataResultCode::InvalidName,
        }
    }

    #[must_use]
    pub const fn variants() -> [ManageDataResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for ManageDataResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ManageDataResultCode> for ManageDataResult {
    #[must_use]
    fn discriminant(&self) -> ManageDataResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ManageDataResultCode> for ManageDataResult {
    fn variants() -> slice::Iter<'static, ManageDataResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ManageDataResultCode> for ManageDataResult {}

impl ReadXdr for ManageDataResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ManageDataResultCode = <ManageDataResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ManageDataResultCode::Success => Self::Success,
                ManageDataResultCode::NotSupportedYet => Self::NotSupportedYet,
                ManageDataResultCode::NameNotFound => Self::NameNotFound,
                ManageDataResultCode::LowReserve => Self::LowReserve,
                ManageDataResultCode::InvalidName => Self::InvalidName,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ManageDataResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::NotSupportedYet => ().write_xdr(w)?,
                Self::NameNotFound => ().write_xdr(w)?,
                Self::LowReserve => ().write_xdr(w)?,
                Self::InvalidName => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// BumpSequenceResultCode is an XDR Enum defines as:
///
/// ```text
/// enum BumpSequenceResultCode
/// {
///     // codes considered as "success" for the operation
///     BUMP_SEQUENCE_SUCCESS = 0,
///     // codes considered as "failure" for the operation
///     BUMP_SEQUENCE_BAD_SEQ = -1 // `bumpTo` is not within bounds
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum BumpSequenceResultCode {
    Success = 0,
    BadSeq = -1,
}

impl BumpSequenceResultCode {
    pub const VARIANTS: [BumpSequenceResultCode; 2] = [
        BumpSequenceResultCode::Success,
        BumpSequenceResultCode::BadSeq,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["Success", "BadSeq"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::BadSeq => "BadSeq",
        }
    }

    #[must_use]
    pub const fn variants() -> [BumpSequenceResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for BumpSequenceResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<BumpSequenceResultCode> for BumpSequenceResultCode {
    fn variants() -> slice::Iter<'static, BumpSequenceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for BumpSequenceResultCode {}

impl fmt::Display for BumpSequenceResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for BumpSequenceResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => BumpSequenceResultCode::Success,
            -1 => BumpSequenceResultCode::BadSeq,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<BumpSequenceResultCode> for i32 {
    #[must_use]
    fn from(e: BumpSequenceResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for BumpSequenceResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for BumpSequenceResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// BumpSequenceResult is an XDR Union defines as:
///
/// ```text
/// union BumpSequenceResult switch (BumpSequenceResultCode code)
/// {
/// case BUMP_SEQUENCE_SUCCESS:
///     void;
/// case BUMP_SEQUENCE_BAD_SEQ:
///     void;
/// };
/// ```
///
// union with discriminant BumpSequenceResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum BumpSequenceResult {
    Success,
    BadSeq,
}

impl BumpSequenceResult {
    pub const VARIANTS: [BumpSequenceResultCode; 2] = [
        BumpSequenceResultCode::Success,
        BumpSequenceResultCode::BadSeq,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["Success", "BadSeq"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::BadSeq => "BadSeq",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> BumpSequenceResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => BumpSequenceResultCode::Success,
            Self::BadSeq => BumpSequenceResultCode::BadSeq,
        }
    }

    #[must_use]
    pub const fn variants() -> [BumpSequenceResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for BumpSequenceResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<BumpSequenceResultCode> for BumpSequenceResult {
    #[must_use]
    fn discriminant(&self) -> BumpSequenceResultCode {
        Self::discriminant(self)
    }
}

impl Variants<BumpSequenceResultCode> for BumpSequenceResult {
    fn variants() -> slice::Iter<'static, BumpSequenceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<BumpSequenceResultCode> for BumpSequenceResult {}

impl ReadXdr for BumpSequenceResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: BumpSequenceResultCode = <BumpSequenceResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                BumpSequenceResultCode::Success => Self::Success,
                BumpSequenceResultCode::BadSeq => Self::BadSeq,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for BumpSequenceResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::BadSeq => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// CreateClaimableBalanceResultCode is an XDR Enum defines as:
///
/// ```text
/// enum CreateClaimableBalanceResultCode
/// {
///     CREATE_CLAIMABLE_BALANCE_SUCCESS = 0,
///     CREATE_CLAIMABLE_BALANCE_MALFORMED = -1,
///     CREATE_CLAIMABLE_BALANCE_LOW_RESERVE = -2,
///     CREATE_CLAIMABLE_BALANCE_NO_TRUST = -3,
///     CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED = -4,
///     CREATE_CLAIMABLE_BALANCE_UNDERFUNDED = -5
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum CreateClaimableBalanceResultCode {
    Success = 0,
    Malformed = -1,
    LowReserve = -2,
    NoTrust = -3,
    NotAuthorized = -4,
    Underfunded = -5,
}

impl CreateClaimableBalanceResultCode {
    pub const VARIANTS: [CreateClaimableBalanceResultCode; 6] = [
        CreateClaimableBalanceResultCode::Success,
        CreateClaimableBalanceResultCode::Malformed,
        CreateClaimableBalanceResultCode::LowReserve,
        CreateClaimableBalanceResultCode::NoTrust,
        CreateClaimableBalanceResultCode::NotAuthorized,
        CreateClaimableBalanceResultCode::Underfunded,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "Malformed",
        "LowReserve",
        "NoTrust",
        "NotAuthorized",
        "Underfunded",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::LowReserve => "LowReserve",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
            Self::Underfunded => "Underfunded",
        }
    }

    #[must_use]
    pub const fn variants() -> [CreateClaimableBalanceResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for CreateClaimableBalanceResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<CreateClaimableBalanceResultCode> for CreateClaimableBalanceResultCode {
    fn variants() -> slice::Iter<'static, CreateClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for CreateClaimableBalanceResultCode {}

impl fmt::Display for CreateClaimableBalanceResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for CreateClaimableBalanceResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => CreateClaimableBalanceResultCode::Success,
            -1 => CreateClaimableBalanceResultCode::Malformed,
            -2 => CreateClaimableBalanceResultCode::LowReserve,
            -3 => CreateClaimableBalanceResultCode::NoTrust,
            -4 => CreateClaimableBalanceResultCode::NotAuthorized,
            -5 => CreateClaimableBalanceResultCode::Underfunded,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<CreateClaimableBalanceResultCode> for i32 {
    #[must_use]
    fn from(e: CreateClaimableBalanceResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for CreateClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for CreateClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// CreateClaimableBalanceResult is an XDR Union defines as:
///
/// ```text
/// union CreateClaimableBalanceResult switch (
///     CreateClaimableBalanceResultCode code)
/// {
/// case CREATE_CLAIMABLE_BALANCE_SUCCESS:
///     ClaimableBalanceID balanceID;
/// case CREATE_CLAIMABLE_BALANCE_MALFORMED:
/// case CREATE_CLAIMABLE_BALANCE_LOW_RESERVE:
/// case CREATE_CLAIMABLE_BALANCE_NO_TRUST:
/// case CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
/// case CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
///     void;
/// };
/// ```
///
// union with discriminant CreateClaimableBalanceResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum CreateClaimableBalanceResult {
    Success(ClaimableBalanceId),
    Malformed,
    LowReserve,
    NoTrust,
    NotAuthorized,
    Underfunded,
}

impl CreateClaimableBalanceResult {
    pub const VARIANTS: [CreateClaimableBalanceResultCode; 6] = [
        CreateClaimableBalanceResultCode::Success,
        CreateClaimableBalanceResultCode::Malformed,
        CreateClaimableBalanceResultCode::LowReserve,
        CreateClaimableBalanceResultCode::NoTrust,
        CreateClaimableBalanceResultCode::NotAuthorized,
        CreateClaimableBalanceResultCode::Underfunded,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "Malformed",
        "LowReserve",
        "NoTrust",
        "NotAuthorized",
        "Underfunded",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success(_) => "Success",
            Self::Malformed => "Malformed",
            Self::LowReserve => "LowReserve",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
            Self::Underfunded => "Underfunded",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> CreateClaimableBalanceResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success(_) => CreateClaimableBalanceResultCode::Success,
            Self::Malformed => CreateClaimableBalanceResultCode::Malformed,
            Self::LowReserve => CreateClaimableBalanceResultCode::LowReserve,
            Self::NoTrust => CreateClaimableBalanceResultCode::NoTrust,
            Self::NotAuthorized => CreateClaimableBalanceResultCode::NotAuthorized,
            Self::Underfunded => CreateClaimableBalanceResultCode::Underfunded,
        }
    }

    #[must_use]
    pub const fn variants() -> [CreateClaimableBalanceResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for CreateClaimableBalanceResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<CreateClaimableBalanceResultCode> for CreateClaimableBalanceResult {
    #[must_use]
    fn discriminant(&self) -> CreateClaimableBalanceResultCode {
        Self::discriminant(self)
    }
}

impl Variants<CreateClaimableBalanceResultCode> for CreateClaimableBalanceResult {
    fn variants() -> slice::Iter<'static, CreateClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<CreateClaimableBalanceResultCode> for CreateClaimableBalanceResult {}

impl ReadXdr for CreateClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: CreateClaimableBalanceResultCode =
                <CreateClaimableBalanceResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                CreateClaimableBalanceResultCode::Success => {
                    Self::Success(ClaimableBalanceId::read_xdr(r)?)
                }
                CreateClaimableBalanceResultCode::Malformed => Self::Malformed,
                CreateClaimableBalanceResultCode::LowReserve => Self::LowReserve,
                CreateClaimableBalanceResultCode::NoTrust => Self::NoTrust,
                CreateClaimableBalanceResultCode::NotAuthorized => Self::NotAuthorized,
                CreateClaimableBalanceResultCode::Underfunded => Self::Underfunded,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for CreateClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success(v) => v.write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::LowReserve => ().write_xdr(w)?,
                Self::NoTrust => ().write_xdr(w)?,
                Self::NotAuthorized => ().write_xdr(w)?,
                Self::Underfunded => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClaimClaimableBalanceResultCode is an XDR Enum defines as:
///
/// ```text
/// enum ClaimClaimableBalanceResultCode
/// {
///     CLAIM_CLAIMABLE_BALANCE_SUCCESS = 0,
///     CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST = -1,
///     CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM = -2,
///     CLAIM_CLAIMABLE_BALANCE_LINE_FULL = -3,
///     CLAIM_CLAIMABLE_BALANCE_NO_TRUST = -4,
///     CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED = -5
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ClaimClaimableBalanceResultCode {
    Success = 0,
    DoesNotExist = -1,
    CannotClaim = -2,
    LineFull = -3,
    NoTrust = -4,
    NotAuthorized = -5,
}

impl ClaimClaimableBalanceResultCode {
    pub const VARIANTS: [ClaimClaimableBalanceResultCode; 6] = [
        ClaimClaimableBalanceResultCode::Success,
        ClaimClaimableBalanceResultCode::DoesNotExist,
        ClaimClaimableBalanceResultCode::CannotClaim,
        ClaimClaimableBalanceResultCode::LineFull,
        ClaimClaimableBalanceResultCode::NoTrust,
        ClaimClaimableBalanceResultCode::NotAuthorized,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "DoesNotExist",
        "CannotClaim",
        "LineFull",
        "NoTrust",
        "NotAuthorized",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::DoesNotExist => "DoesNotExist",
            Self::CannotClaim => "CannotClaim",
            Self::LineFull => "LineFull",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimClaimableBalanceResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for ClaimClaimableBalanceResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClaimClaimableBalanceResultCode> for ClaimClaimableBalanceResultCode {
    fn variants() -> slice::Iter<'static, ClaimClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClaimClaimableBalanceResultCode {}

impl fmt::Display for ClaimClaimableBalanceResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClaimClaimableBalanceResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ClaimClaimableBalanceResultCode::Success,
            -1 => ClaimClaimableBalanceResultCode::DoesNotExist,
            -2 => ClaimClaimableBalanceResultCode::CannotClaim,
            -3 => ClaimClaimableBalanceResultCode::LineFull,
            -4 => ClaimClaimableBalanceResultCode::NoTrust,
            -5 => ClaimClaimableBalanceResultCode::NotAuthorized,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClaimClaimableBalanceResultCode> for i32 {
    #[must_use]
    fn from(e: ClaimClaimableBalanceResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ClaimClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClaimClaimableBalanceResult is an XDR Union defines as:
///
/// ```text
/// union ClaimClaimableBalanceResult switch (ClaimClaimableBalanceResultCode code)
/// {
/// case CLAIM_CLAIMABLE_BALANCE_SUCCESS:
///     void;
/// case CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST:
/// case CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM:
/// case CLAIM_CLAIMABLE_BALANCE_LINE_FULL:
/// case CLAIM_CLAIMABLE_BALANCE_NO_TRUST:
/// case CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
///     void;
/// };
/// ```
///
// union with discriminant ClaimClaimableBalanceResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ClaimClaimableBalanceResult {
    Success,
    DoesNotExist,
    CannotClaim,
    LineFull,
    NoTrust,
    NotAuthorized,
}

impl ClaimClaimableBalanceResult {
    pub const VARIANTS: [ClaimClaimableBalanceResultCode; 6] = [
        ClaimClaimableBalanceResultCode::Success,
        ClaimClaimableBalanceResultCode::DoesNotExist,
        ClaimClaimableBalanceResultCode::CannotClaim,
        ClaimClaimableBalanceResultCode::LineFull,
        ClaimClaimableBalanceResultCode::NoTrust,
        ClaimClaimableBalanceResultCode::NotAuthorized,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "DoesNotExist",
        "CannotClaim",
        "LineFull",
        "NoTrust",
        "NotAuthorized",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::DoesNotExist => "DoesNotExist",
            Self::CannotClaim => "CannotClaim",
            Self::LineFull => "LineFull",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClaimClaimableBalanceResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => ClaimClaimableBalanceResultCode::Success,
            Self::DoesNotExist => ClaimClaimableBalanceResultCode::DoesNotExist,
            Self::CannotClaim => ClaimClaimableBalanceResultCode::CannotClaim,
            Self::LineFull => ClaimClaimableBalanceResultCode::LineFull,
            Self::NoTrust => ClaimClaimableBalanceResultCode::NoTrust,
            Self::NotAuthorized => ClaimClaimableBalanceResultCode::NotAuthorized,
        }
    }

    #[must_use]
    pub const fn variants() -> [ClaimClaimableBalanceResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for ClaimClaimableBalanceResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClaimClaimableBalanceResultCode> for ClaimClaimableBalanceResult {
    #[must_use]
    fn discriminant(&self) -> ClaimClaimableBalanceResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ClaimClaimableBalanceResultCode> for ClaimClaimableBalanceResult {
    fn variants() -> slice::Iter<'static, ClaimClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClaimClaimableBalanceResultCode> for ClaimClaimableBalanceResult {}

impl ReadXdr for ClaimClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ClaimClaimableBalanceResultCode =
                <ClaimClaimableBalanceResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClaimClaimableBalanceResultCode::Success => Self::Success,
                ClaimClaimableBalanceResultCode::DoesNotExist => Self::DoesNotExist,
                ClaimClaimableBalanceResultCode::CannotClaim => Self::CannotClaim,
                ClaimClaimableBalanceResultCode::LineFull => Self::LineFull,
                ClaimClaimableBalanceResultCode::NoTrust => Self::NoTrust,
                ClaimClaimableBalanceResultCode::NotAuthorized => Self::NotAuthorized,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClaimClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::DoesNotExist => ().write_xdr(w)?,
                Self::CannotClaim => ().write_xdr(w)?,
                Self::LineFull => ().write_xdr(w)?,
                Self::NoTrust => ().write_xdr(w)?,
                Self::NotAuthorized => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// BeginSponsoringFutureReservesResultCode is an XDR Enum defines as:
///
/// ```text
/// enum BeginSponsoringFutureReservesResultCode
/// {
///     // codes considered as "success" for the operation
///     BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED = -1,
///     BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED = -2,
///     BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE = -3
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum BeginSponsoringFutureReservesResultCode {
    Success = 0,
    Malformed = -1,
    AlreadySponsored = -2,
    Recursive = -3,
}

impl BeginSponsoringFutureReservesResultCode {
    pub const VARIANTS: [BeginSponsoringFutureReservesResultCode; 4] = [
        BeginSponsoringFutureReservesResultCode::Success,
        BeginSponsoringFutureReservesResultCode::Malformed,
        BeginSponsoringFutureReservesResultCode::AlreadySponsored,
        BeginSponsoringFutureReservesResultCode::Recursive,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Success", "Malformed", "AlreadySponsored", "Recursive"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::AlreadySponsored => "AlreadySponsored",
            Self::Recursive => "Recursive",
        }
    }

    #[must_use]
    pub const fn variants() -> [BeginSponsoringFutureReservesResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for BeginSponsoringFutureReservesResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<BeginSponsoringFutureReservesResultCode> for BeginSponsoringFutureReservesResultCode {
    fn variants() -> slice::Iter<'static, BeginSponsoringFutureReservesResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for BeginSponsoringFutureReservesResultCode {}

impl fmt::Display for BeginSponsoringFutureReservesResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for BeginSponsoringFutureReservesResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => BeginSponsoringFutureReservesResultCode::Success,
            -1 => BeginSponsoringFutureReservesResultCode::Malformed,
            -2 => BeginSponsoringFutureReservesResultCode::AlreadySponsored,
            -3 => BeginSponsoringFutureReservesResultCode::Recursive,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<BeginSponsoringFutureReservesResultCode> for i32 {
    #[must_use]
    fn from(e: BeginSponsoringFutureReservesResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for BeginSponsoringFutureReservesResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for BeginSponsoringFutureReservesResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// BeginSponsoringFutureReservesResult is an XDR Union defines as:
///
/// ```text
/// union BeginSponsoringFutureReservesResult switch (
///     BeginSponsoringFutureReservesResultCode code)
/// {
/// case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:
///     void;
/// case BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED:
/// case BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED:
/// case BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
///     void;
/// };
/// ```
///
// union with discriminant BeginSponsoringFutureReservesResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum BeginSponsoringFutureReservesResult {
    Success,
    Malformed,
    AlreadySponsored,
    Recursive,
}

impl BeginSponsoringFutureReservesResult {
    pub const VARIANTS: [BeginSponsoringFutureReservesResultCode; 4] = [
        BeginSponsoringFutureReservesResultCode::Success,
        BeginSponsoringFutureReservesResultCode::Malformed,
        BeginSponsoringFutureReservesResultCode::AlreadySponsored,
        BeginSponsoringFutureReservesResultCode::Recursive,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Success", "Malformed", "AlreadySponsored", "Recursive"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::AlreadySponsored => "AlreadySponsored",
            Self::Recursive => "Recursive",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> BeginSponsoringFutureReservesResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => BeginSponsoringFutureReservesResultCode::Success,
            Self::Malformed => BeginSponsoringFutureReservesResultCode::Malformed,
            Self::AlreadySponsored => BeginSponsoringFutureReservesResultCode::AlreadySponsored,
            Self::Recursive => BeginSponsoringFutureReservesResultCode::Recursive,
        }
    }

    #[must_use]
    pub const fn variants() -> [BeginSponsoringFutureReservesResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for BeginSponsoringFutureReservesResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<BeginSponsoringFutureReservesResultCode> for BeginSponsoringFutureReservesResult {
    #[must_use]
    fn discriminant(&self) -> BeginSponsoringFutureReservesResultCode {
        Self::discriminant(self)
    }
}

impl Variants<BeginSponsoringFutureReservesResultCode> for BeginSponsoringFutureReservesResult {
    fn variants() -> slice::Iter<'static, BeginSponsoringFutureReservesResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<BeginSponsoringFutureReservesResultCode> for BeginSponsoringFutureReservesResult {}

impl ReadXdr for BeginSponsoringFutureReservesResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: BeginSponsoringFutureReservesResultCode =
                <BeginSponsoringFutureReservesResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                BeginSponsoringFutureReservesResultCode::Success => Self::Success,
                BeginSponsoringFutureReservesResultCode::Malformed => Self::Malformed,
                BeginSponsoringFutureReservesResultCode::AlreadySponsored => Self::AlreadySponsored,
                BeginSponsoringFutureReservesResultCode::Recursive => Self::Recursive,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for BeginSponsoringFutureReservesResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::AlreadySponsored => ().write_xdr(w)?,
                Self::Recursive => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// EndSponsoringFutureReservesResultCode is an XDR Enum defines as:
///
/// ```text
/// enum EndSponsoringFutureReservesResultCode
/// {
///     // codes considered as "success" for the operation
///     END_SPONSORING_FUTURE_RESERVES_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED = -1
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum EndSponsoringFutureReservesResultCode {
    Success = 0,
    NotSponsored = -1,
}

impl EndSponsoringFutureReservesResultCode {
    pub const VARIANTS: [EndSponsoringFutureReservesResultCode; 2] = [
        EndSponsoringFutureReservesResultCode::Success,
        EndSponsoringFutureReservesResultCode::NotSponsored,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["Success", "NotSponsored"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::NotSponsored => "NotSponsored",
        }
    }

    #[must_use]
    pub const fn variants() -> [EndSponsoringFutureReservesResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for EndSponsoringFutureReservesResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<EndSponsoringFutureReservesResultCode> for EndSponsoringFutureReservesResultCode {
    fn variants() -> slice::Iter<'static, EndSponsoringFutureReservesResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for EndSponsoringFutureReservesResultCode {}

impl fmt::Display for EndSponsoringFutureReservesResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for EndSponsoringFutureReservesResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => EndSponsoringFutureReservesResultCode::Success,
            -1 => EndSponsoringFutureReservesResultCode::NotSponsored,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<EndSponsoringFutureReservesResultCode> for i32 {
    #[must_use]
    fn from(e: EndSponsoringFutureReservesResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for EndSponsoringFutureReservesResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for EndSponsoringFutureReservesResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// EndSponsoringFutureReservesResult is an XDR Union defines as:
///
/// ```text
/// union EndSponsoringFutureReservesResult switch (
///     EndSponsoringFutureReservesResultCode code)
/// {
/// case END_SPONSORING_FUTURE_RESERVES_SUCCESS:
///     void;
/// case END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
///     void;
/// };
/// ```
///
// union with discriminant EndSponsoringFutureReservesResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum EndSponsoringFutureReservesResult {
    Success,
    NotSponsored,
}

impl EndSponsoringFutureReservesResult {
    pub const VARIANTS: [EndSponsoringFutureReservesResultCode; 2] = [
        EndSponsoringFutureReservesResultCode::Success,
        EndSponsoringFutureReservesResultCode::NotSponsored,
    ];
    pub const VARIANTS_STR: [&'static str; 2] = ["Success", "NotSponsored"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::NotSponsored => "NotSponsored",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> EndSponsoringFutureReservesResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => EndSponsoringFutureReservesResultCode::Success,
            Self::NotSponsored => EndSponsoringFutureReservesResultCode::NotSponsored,
        }
    }

    #[must_use]
    pub const fn variants() -> [EndSponsoringFutureReservesResultCode; 2] {
        Self::VARIANTS
    }
}

impl Name for EndSponsoringFutureReservesResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<EndSponsoringFutureReservesResultCode> for EndSponsoringFutureReservesResult {
    #[must_use]
    fn discriminant(&self) -> EndSponsoringFutureReservesResultCode {
        Self::discriminant(self)
    }
}

impl Variants<EndSponsoringFutureReservesResultCode> for EndSponsoringFutureReservesResult {
    fn variants() -> slice::Iter<'static, EndSponsoringFutureReservesResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<EndSponsoringFutureReservesResultCode> for EndSponsoringFutureReservesResult {}

impl ReadXdr for EndSponsoringFutureReservesResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: EndSponsoringFutureReservesResultCode =
                <EndSponsoringFutureReservesResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                EndSponsoringFutureReservesResultCode::Success => Self::Success,
                EndSponsoringFutureReservesResultCode::NotSponsored => Self::NotSponsored,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for EndSponsoringFutureReservesResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::NotSponsored => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// RevokeSponsorshipResultCode is an XDR Enum defines as:
///
/// ```text
/// enum RevokeSponsorshipResultCode
/// {
///     // codes considered as "success" for the operation
///     REVOKE_SPONSORSHIP_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     REVOKE_SPONSORSHIP_DOES_NOT_EXIST = -1,
///     REVOKE_SPONSORSHIP_NOT_SPONSOR = -2,
///     REVOKE_SPONSORSHIP_LOW_RESERVE = -3,
///     REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE = -4,
///     REVOKE_SPONSORSHIP_MALFORMED = -5
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum RevokeSponsorshipResultCode {
    Success = 0,
    DoesNotExist = -1,
    NotSponsor = -2,
    LowReserve = -3,
    OnlyTransferable = -4,
    Malformed = -5,
}

impl RevokeSponsorshipResultCode {
    pub const VARIANTS: [RevokeSponsorshipResultCode; 6] = [
        RevokeSponsorshipResultCode::Success,
        RevokeSponsorshipResultCode::DoesNotExist,
        RevokeSponsorshipResultCode::NotSponsor,
        RevokeSponsorshipResultCode::LowReserve,
        RevokeSponsorshipResultCode::OnlyTransferable,
        RevokeSponsorshipResultCode::Malformed,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "DoesNotExist",
        "NotSponsor",
        "LowReserve",
        "OnlyTransferable",
        "Malformed",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::DoesNotExist => "DoesNotExist",
            Self::NotSponsor => "NotSponsor",
            Self::LowReserve => "LowReserve",
            Self::OnlyTransferable => "OnlyTransferable",
            Self::Malformed => "Malformed",
        }
    }

    #[must_use]
    pub const fn variants() -> [RevokeSponsorshipResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for RevokeSponsorshipResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<RevokeSponsorshipResultCode> for RevokeSponsorshipResultCode {
    fn variants() -> slice::Iter<'static, RevokeSponsorshipResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for RevokeSponsorshipResultCode {}

impl fmt::Display for RevokeSponsorshipResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for RevokeSponsorshipResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => RevokeSponsorshipResultCode::Success,
            -1 => RevokeSponsorshipResultCode::DoesNotExist,
            -2 => RevokeSponsorshipResultCode::NotSponsor,
            -3 => RevokeSponsorshipResultCode::LowReserve,
            -4 => RevokeSponsorshipResultCode::OnlyTransferable,
            -5 => RevokeSponsorshipResultCode::Malformed,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<RevokeSponsorshipResultCode> for i32 {
    #[must_use]
    fn from(e: RevokeSponsorshipResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for RevokeSponsorshipResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for RevokeSponsorshipResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// RevokeSponsorshipResult is an XDR Union defines as:
///
/// ```text
/// union RevokeSponsorshipResult switch (RevokeSponsorshipResultCode code)
/// {
/// case REVOKE_SPONSORSHIP_SUCCESS:
///     void;
/// case REVOKE_SPONSORSHIP_DOES_NOT_EXIST:
/// case REVOKE_SPONSORSHIP_NOT_SPONSOR:
/// case REVOKE_SPONSORSHIP_LOW_RESERVE:
/// case REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE:
/// case REVOKE_SPONSORSHIP_MALFORMED:
///     void;
/// };
/// ```
///
// union with discriminant RevokeSponsorshipResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum RevokeSponsorshipResult {
    Success,
    DoesNotExist,
    NotSponsor,
    LowReserve,
    OnlyTransferable,
    Malformed,
}

impl RevokeSponsorshipResult {
    pub const VARIANTS: [RevokeSponsorshipResultCode; 6] = [
        RevokeSponsorshipResultCode::Success,
        RevokeSponsorshipResultCode::DoesNotExist,
        RevokeSponsorshipResultCode::NotSponsor,
        RevokeSponsorshipResultCode::LowReserve,
        RevokeSponsorshipResultCode::OnlyTransferable,
        RevokeSponsorshipResultCode::Malformed,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "DoesNotExist",
        "NotSponsor",
        "LowReserve",
        "OnlyTransferable",
        "Malformed",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::DoesNotExist => "DoesNotExist",
            Self::NotSponsor => "NotSponsor",
            Self::LowReserve => "LowReserve",
            Self::OnlyTransferable => "OnlyTransferable",
            Self::Malformed => "Malformed",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> RevokeSponsorshipResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => RevokeSponsorshipResultCode::Success,
            Self::DoesNotExist => RevokeSponsorshipResultCode::DoesNotExist,
            Self::NotSponsor => RevokeSponsorshipResultCode::NotSponsor,
            Self::LowReserve => RevokeSponsorshipResultCode::LowReserve,
            Self::OnlyTransferable => RevokeSponsorshipResultCode::OnlyTransferable,
            Self::Malformed => RevokeSponsorshipResultCode::Malformed,
        }
    }

    #[must_use]
    pub const fn variants() -> [RevokeSponsorshipResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for RevokeSponsorshipResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<RevokeSponsorshipResultCode> for RevokeSponsorshipResult {
    #[must_use]
    fn discriminant(&self) -> RevokeSponsorshipResultCode {
        Self::discriminant(self)
    }
}

impl Variants<RevokeSponsorshipResultCode> for RevokeSponsorshipResult {
    fn variants() -> slice::Iter<'static, RevokeSponsorshipResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<RevokeSponsorshipResultCode> for RevokeSponsorshipResult {}

impl ReadXdr for RevokeSponsorshipResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: RevokeSponsorshipResultCode =
                <RevokeSponsorshipResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                RevokeSponsorshipResultCode::Success => Self::Success,
                RevokeSponsorshipResultCode::DoesNotExist => Self::DoesNotExist,
                RevokeSponsorshipResultCode::NotSponsor => Self::NotSponsor,
                RevokeSponsorshipResultCode::LowReserve => Self::LowReserve,
                RevokeSponsorshipResultCode::OnlyTransferable => Self::OnlyTransferable,
                RevokeSponsorshipResultCode::Malformed => Self::Malformed,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for RevokeSponsorshipResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::DoesNotExist => ().write_xdr(w)?,
                Self::NotSponsor => ().write_xdr(w)?,
                Self::LowReserve => ().write_xdr(w)?,
                Self::OnlyTransferable => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClawbackResultCode is an XDR Enum defines as:
///
/// ```text
/// enum ClawbackResultCode
/// {
///     // codes considered as "success" for the operation
///     CLAWBACK_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     CLAWBACK_MALFORMED = -1,
///     CLAWBACK_NOT_CLAWBACK_ENABLED = -2,
///     CLAWBACK_NO_TRUST = -3,
///     CLAWBACK_UNDERFUNDED = -4
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ClawbackResultCode {
    Success = 0,
    Malformed = -1,
    NotClawbackEnabled = -2,
    NoTrust = -3,
    Underfunded = -4,
}

impl ClawbackResultCode {
    pub const VARIANTS: [ClawbackResultCode; 5] = [
        ClawbackResultCode::Success,
        ClawbackResultCode::Malformed,
        ClawbackResultCode::NotClawbackEnabled,
        ClawbackResultCode::NoTrust,
        ClawbackResultCode::Underfunded,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "Success",
        "Malformed",
        "NotClawbackEnabled",
        "NoTrust",
        "Underfunded",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NotClawbackEnabled => "NotClawbackEnabled",
            Self::NoTrust => "NoTrust",
            Self::Underfunded => "Underfunded",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClawbackResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for ClawbackResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClawbackResultCode> for ClawbackResultCode {
    fn variants() -> slice::Iter<'static, ClawbackResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClawbackResultCode {}

impl fmt::Display for ClawbackResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClawbackResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ClawbackResultCode::Success,
            -1 => ClawbackResultCode::Malformed,
            -2 => ClawbackResultCode::NotClawbackEnabled,
            -3 => ClawbackResultCode::NoTrust,
            -4 => ClawbackResultCode::Underfunded,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClawbackResultCode> for i32 {
    #[must_use]
    fn from(e: ClawbackResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ClawbackResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClawbackResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClawbackResult is an XDR Union defines as:
///
/// ```text
/// union ClawbackResult switch (ClawbackResultCode code)
/// {
/// case CLAWBACK_SUCCESS:
///     void;
/// case CLAWBACK_MALFORMED:
/// case CLAWBACK_NOT_CLAWBACK_ENABLED:
/// case CLAWBACK_NO_TRUST:
/// case CLAWBACK_UNDERFUNDED:
///     void;
/// };
/// ```
///
// union with discriminant ClawbackResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ClawbackResult {
    Success,
    Malformed,
    NotClawbackEnabled,
    NoTrust,
    Underfunded,
}

impl ClawbackResult {
    pub const VARIANTS: [ClawbackResultCode; 5] = [
        ClawbackResultCode::Success,
        ClawbackResultCode::Malformed,
        ClawbackResultCode::NotClawbackEnabled,
        ClawbackResultCode::NoTrust,
        ClawbackResultCode::Underfunded,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "Success",
        "Malformed",
        "NotClawbackEnabled",
        "NoTrust",
        "Underfunded",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NotClawbackEnabled => "NotClawbackEnabled",
            Self::NoTrust => "NoTrust",
            Self::Underfunded => "Underfunded",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClawbackResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => ClawbackResultCode::Success,
            Self::Malformed => ClawbackResultCode::Malformed,
            Self::NotClawbackEnabled => ClawbackResultCode::NotClawbackEnabled,
            Self::NoTrust => ClawbackResultCode::NoTrust,
            Self::Underfunded => ClawbackResultCode::Underfunded,
        }
    }

    #[must_use]
    pub const fn variants() -> [ClawbackResultCode; 5] {
        Self::VARIANTS
    }
}

impl Name for ClawbackResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClawbackResultCode> for ClawbackResult {
    #[must_use]
    fn discriminant(&self) -> ClawbackResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ClawbackResultCode> for ClawbackResult {
    fn variants() -> slice::Iter<'static, ClawbackResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClawbackResultCode> for ClawbackResult {}

impl ReadXdr for ClawbackResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ClawbackResultCode = <ClawbackResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClawbackResultCode::Success => Self::Success,
                ClawbackResultCode::Malformed => Self::Malformed,
                ClawbackResultCode::NotClawbackEnabled => Self::NotClawbackEnabled,
                ClawbackResultCode::NoTrust => Self::NoTrust,
                ClawbackResultCode::Underfunded => Self::Underfunded,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClawbackResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::NotClawbackEnabled => ().write_xdr(w)?,
                Self::NoTrust => ().write_xdr(w)?,
                Self::Underfunded => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ClawbackClaimableBalanceResultCode is an XDR Enum defines as:
///
/// ```text
/// enum ClawbackClaimableBalanceResultCode
/// {
///     // codes considered as "success" for the operation
///     CLAWBACK_CLAIMABLE_BALANCE_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST = -1,
///     CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER = -2,
///     CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED = -3
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ClawbackClaimableBalanceResultCode {
    Success = 0,
    DoesNotExist = -1,
    NotIssuer = -2,
    NotClawbackEnabled = -3,
}

impl ClawbackClaimableBalanceResultCode {
    pub const VARIANTS: [ClawbackClaimableBalanceResultCode; 4] = [
        ClawbackClaimableBalanceResultCode::Success,
        ClawbackClaimableBalanceResultCode::DoesNotExist,
        ClawbackClaimableBalanceResultCode::NotIssuer,
        ClawbackClaimableBalanceResultCode::NotClawbackEnabled,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Success", "DoesNotExist", "NotIssuer", "NotClawbackEnabled"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::DoesNotExist => "DoesNotExist",
            Self::NotIssuer => "NotIssuer",
            Self::NotClawbackEnabled => "NotClawbackEnabled",
        }
    }

    #[must_use]
    pub const fn variants() -> [ClawbackClaimableBalanceResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for ClawbackClaimableBalanceResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ClawbackClaimableBalanceResultCode> for ClawbackClaimableBalanceResultCode {
    fn variants() -> slice::Iter<'static, ClawbackClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ClawbackClaimableBalanceResultCode {}

impl fmt::Display for ClawbackClaimableBalanceResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ClawbackClaimableBalanceResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ClawbackClaimableBalanceResultCode::Success,
            -1 => ClawbackClaimableBalanceResultCode::DoesNotExist,
            -2 => ClawbackClaimableBalanceResultCode::NotIssuer,
            -3 => ClawbackClaimableBalanceResultCode::NotClawbackEnabled,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ClawbackClaimableBalanceResultCode> for i32 {
    #[must_use]
    fn from(e: ClawbackClaimableBalanceResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ClawbackClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ClawbackClaimableBalanceResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ClawbackClaimableBalanceResult is an XDR Union defines as:
///
/// ```text
/// union ClawbackClaimableBalanceResult switch (
///     ClawbackClaimableBalanceResultCode code)
/// {
/// case CLAWBACK_CLAIMABLE_BALANCE_SUCCESS:
///     void;
/// case CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST:
/// case CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER:
/// case CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
///     void;
/// };
/// ```
///
// union with discriminant ClawbackClaimableBalanceResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ClawbackClaimableBalanceResult {
    Success,
    DoesNotExist,
    NotIssuer,
    NotClawbackEnabled,
}

impl ClawbackClaimableBalanceResult {
    pub const VARIANTS: [ClawbackClaimableBalanceResultCode; 4] = [
        ClawbackClaimableBalanceResultCode::Success,
        ClawbackClaimableBalanceResultCode::DoesNotExist,
        ClawbackClaimableBalanceResultCode::NotIssuer,
        ClawbackClaimableBalanceResultCode::NotClawbackEnabled,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Success", "DoesNotExist", "NotIssuer", "NotClawbackEnabled"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::DoesNotExist => "DoesNotExist",
            Self::NotIssuer => "NotIssuer",
            Self::NotClawbackEnabled => "NotClawbackEnabled",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ClawbackClaimableBalanceResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => ClawbackClaimableBalanceResultCode::Success,
            Self::DoesNotExist => ClawbackClaimableBalanceResultCode::DoesNotExist,
            Self::NotIssuer => ClawbackClaimableBalanceResultCode::NotIssuer,
            Self::NotClawbackEnabled => ClawbackClaimableBalanceResultCode::NotClawbackEnabled,
        }
    }

    #[must_use]
    pub const fn variants() -> [ClawbackClaimableBalanceResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for ClawbackClaimableBalanceResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ClawbackClaimableBalanceResultCode> for ClawbackClaimableBalanceResult {
    #[must_use]
    fn discriminant(&self) -> ClawbackClaimableBalanceResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ClawbackClaimableBalanceResultCode> for ClawbackClaimableBalanceResult {
    fn variants() -> slice::Iter<'static, ClawbackClaimableBalanceResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ClawbackClaimableBalanceResultCode> for ClawbackClaimableBalanceResult {}

impl ReadXdr for ClawbackClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ClawbackClaimableBalanceResultCode =
                <ClawbackClaimableBalanceResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ClawbackClaimableBalanceResultCode::Success => Self::Success,
                ClawbackClaimableBalanceResultCode::DoesNotExist => Self::DoesNotExist,
                ClawbackClaimableBalanceResultCode::NotIssuer => Self::NotIssuer,
                ClawbackClaimableBalanceResultCode::NotClawbackEnabled => Self::NotClawbackEnabled,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ClawbackClaimableBalanceResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::DoesNotExist => ().write_xdr(w)?,
                Self::NotIssuer => ().write_xdr(w)?,
                Self::NotClawbackEnabled => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SetTrustLineFlagsResultCode is an XDR Enum defines as:
///
/// ```text
/// enum SetTrustLineFlagsResultCode
/// {
///     // codes considered as "success" for the operation
///     SET_TRUST_LINE_FLAGS_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     SET_TRUST_LINE_FLAGS_MALFORMED = -1,
///     SET_TRUST_LINE_FLAGS_NO_TRUST_LINE = -2,
///     SET_TRUST_LINE_FLAGS_CANT_REVOKE = -3,
///     SET_TRUST_LINE_FLAGS_INVALID_STATE = -4,
///     SET_TRUST_LINE_FLAGS_LOW_RESERVE = -5 // claimable balances can't be created
///                                           // on revoke due to low reserves
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum SetTrustLineFlagsResultCode {
    Success = 0,
    Malformed = -1,
    NoTrustLine = -2,
    CantRevoke = -3,
    InvalidState = -4,
    LowReserve = -5,
}

impl SetTrustLineFlagsResultCode {
    pub const VARIANTS: [SetTrustLineFlagsResultCode; 6] = [
        SetTrustLineFlagsResultCode::Success,
        SetTrustLineFlagsResultCode::Malformed,
        SetTrustLineFlagsResultCode::NoTrustLine,
        SetTrustLineFlagsResultCode::CantRevoke,
        SetTrustLineFlagsResultCode::InvalidState,
        SetTrustLineFlagsResultCode::LowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "Malformed",
        "NoTrustLine",
        "CantRevoke",
        "InvalidState",
        "LowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NoTrustLine => "NoTrustLine",
            Self::CantRevoke => "CantRevoke",
            Self::InvalidState => "InvalidState",
            Self::LowReserve => "LowReserve",
        }
    }

    #[must_use]
    pub const fn variants() -> [SetTrustLineFlagsResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for SetTrustLineFlagsResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SetTrustLineFlagsResultCode> for SetTrustLineFlagsResultCode {
    fn variants() -> slice::Iter<'static, SetTrustLineFlagsResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SetTrustLineFlagsResultCode {}

impl fmt::Display for SetTrustLineFlagsResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SetTrustLineFlagsResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => SetTrustLineFlagsResultCode::Success,
            -1 => SetTrustLineFlagsResultCode::Malformed,
            -2 => SetTrustLineFlagsResultCode::NoTrustLine,
            -3 => SetTrustLineFlagsResultCode::CantRevoke,
            -4 => SetTrustLineFlagsResultCode::InvalidState,
            -5 => SetTrustLineFlagsResultCode::LowReserve,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SetTrustLineFlagsResultCode> for i32 {
    #[must_use]
    fn from(e: SetTrustLineFlagsResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for SetTrustLineFlagsResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SetTrustLineFlagsResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SetTrustLineFlagsResult is an XDR Union defines as:
///
/// ```text
/// union SetTrustLineFlagsResult switch (SetTrustLineFlagsResultCode code)
/// {
/// case SET_TRUST_LINE_FLAGS_SUCCESS:
///     void;
/// case SET_TRUST_LINE_FLAGS_MALFORMED:
/// case SET_TRUST_LINE_FLAGS_NO_TRUST_LINE:
/// case SET_TRUST_LINE_FLAGS_CANT_REVOKE:
/// case SET_TRUST_LINE_FLAGS_INVALID_STATE:
/// case SET_TRUST_LINE_FLAGS_LOW_RESERVE:
///     void;
/// };
/// ```
///
// union with discriminant SetTrustLineFlagsResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum SetTrustLineFlagsResult {
    Success,
    Malformed,
    NoTrustLine,
    CantRevoke,
    InvalidState,
    LowReserve,
}

impl SetTrustLineFlagsResult {
    pub const VARIANTS: [SetTrustLineFlagsResultCode; 6] = [
        SetTrustLineFlagsResultCode::Success,
        SetTrustLineFlagsResultCode::Malformed,
        SetTrustLineFlagsResultCode::NoTrustLine,
        SetTrustLineFlagsResultCode::CantRevoke,
        SetTrustLineFlagsResultCode::InvalidState,
        SetTrustLineFlagsResultCode::LowReserve,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "Malformed",
        "NoTrustLine",
        "CantRevoke",
        "InvalidState",
        "LowReserve",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NoTrustLine => "NoTrustLine",
            Self::CantRevoke => "CantRevoke",
            Self::InvalidState => "InvalidState",
            Self::LowReserve => "LowReserve",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SetTrustLineFlagsResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => SetTrustLineFlagsResultCode::Success,
            Self::Malformed => SetTrustLineFlagsResultCode::Malformed,
            Self::NoTrustLine => SetTrustLineFlagsResultCode::NoTrustLine,
            Self::CantRevoke => SetTrustLineFlagsResultCode::CantRevoke,
            Self::InvalidState => SetTrustLineFlagsResultCode::InvalidState,
            Self::LowReserve => SetTrustLineFlagsResultCode::LowReserve,
        }
    }

    #[must_use]
    pub const fn variants() -> [SetTrustLineFlagsResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for SetTrustLineFlagsResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SetTrustLineFlagsResultCode> for SetTrustLineFlagsResult {
    #[must_use]
    fn discriminant(&self) -> SetTrustLineFlagsResultCode {
        Self::discriminant(self)
    }
}

impl Variants<SetTrustLineFlagsResultCode> for SetTrustLineFlagsResult {
    fn variants() -> slice::Iter<'static, SetTrustLineFlagsResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<SetTrustLineFlagsResultCode> for SetTrustLineFlagsResult {}

impl ReadXdr for SetTrustLineFlagsResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: SetTrustLineFlagsResultCode =
                <SetTrustLineFlagsResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                SetTrustLineFlagsResultCode::Success => Self::Success,
                SetTrustLineFlagsResultCode::Malformed => Self::Malformed,
                SetTrustLineFlagsResultCode::NoTrustLine => Self::NoTrustLine,
                SetTrustLineFlagsResultCode::CantRevoke => Self::CantRevoke,
                SetTrustLineFlagsResultCode::InvalidState => Self::InvalidState,
                SetTrustLineFlagsResultCode::LowReserve => Self::LowReserve,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SetTrustLineFlagsResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::NoTrustLine => ().write_xdr(w)?,
                Self::CantRevoke => ().write_xdr(w)?,
                Self::InvalidState => ().write_xdr(w)?,
                Self::LowReserve => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LiquidityPoolDepositResultCode is an XDR Enum defines as:
///
/// ```text
/// enum LiquidityPoolDepositResultCode
/// {
///     // codes considered as "success" for the operation
///     LIQUIDITY_POOL_DEPOSIT_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     LIQUIDITY_POOL_DEPOSIT_MALFORMED = -1,      // bad input
///     LIQUIDITY_POOL_DEPOSIT_NO_TRUST = -2,       // no trust line for one of the
///                                                 // assets
///     LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED = -3, // not authorized for one of the
///                                                 // assets
///     LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED = -4,    // not enough balance for one of
///                                                 // the assets
///     LIQUIDITY_POOL_DEPOSIT_LINE_FULL = -5,      // pool share trust line doesn't
///                                                 // have sufficient limit
///     LIQUIDITY_POOL_DEPOSIT_BAD_PRICE = -6,      // deposit price outside bounds
///     LIQUIDITY_POOL_DEPOSIT_POOL_FULL = -7       // pool reserves are full
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum LiquidityPoolDepositResultCode {
    Success = 0,
    Malformed = -1,
    NoTrust = -2,
    NotAuthorized = -3,
    Underfunded = -4,
    LineFull = -5,
    BadPrice = -6,
    PoolFull = -7,
}

impl LiquidityPoolDepositResultCode {
    pub const VARIANTS: [LiquidityPoolDepositResultCode; 8] = [
        LiquidityPoolDepositResultCode::Success,
        LiquidityPoolDepositResultCode::Malformed,
        LiquidityPoolDepositResultCode::NoTrust,
        LiquidityPoolDepositResultCode::NotAuthorized,
        LiquidityPoolDepositResultCode::Underfunded,
        LiquidityPoolDepositResultCode::LineFull,
        LiquidityPoolDepositResultCode::BadPrice,
        LiquidityPoolDepositResultCode::PoolFull,
    ];
    pub const VARIANTS_STR: [&'static str; 8] = [
        "Success",
        "Malformed",
        "NoTrust",
        "NotAuthorized",
        "Underfunded",
        "LineFull",
        "BadPrice",
        "PoolFull",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
            Self::Underfunded => "Underfunded",
            Self::LineFull => "LineFull",
            Self::BadPrice => "BadPrice",
            Self::PoolFull => "PoolFull",
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolDepositResultCode; 8] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolDepositResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LiquidityPoolDepositResultCode> for LiquidityPoolDepositResultCode {
    fn variants() -> slice::Iter<'static, LiquidityPoolDepositResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LiquidityPoolDepositResultCode {}

impl fmt::Display for LiquidityPoolDepositResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LiquidityPoolDepositResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => LiquidityPoolDepositResultCode::Success,
            -1 => LiquidityPoolDepositResultCode::Malformed,
            -2 => LiquidityPoolDepositResultCode::NoTrust,
            -3 => LiquidityPoolDepositResultCode::NotAuthorized,
            -4 => LiquidityPoolDepositResultCode::Underfunded,
            -5 => LiquidityPoolDepositResultCode::LineFull,
            -6 => LiquidityPoolDepositResultCode::BadPrice,
            -7 => LiquidityPoolDepositResultCode::PoolFull,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LiquidityPoolDepositResultCode> for i32 {
    #[must_use]
    fn from(e: LiquidityPoolDepositResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for LiquidityPoolDepositResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolDepositResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LiquidityPoolDepositResult is an XDR Union defines as:
///
/// ```text
/// union LiquidityPoolDepositResult switch (LiquidityPoolDepositResultCode code)
/// {
/// case LIQUIDITY_POOL_DEPOSIT_SUCCESS:
///     void;
/// case LIQUIDITY_POOL_DEPOSIT_MALFORMED:
/// case LIQUIDITY_POOL_DEPOSIT_NO_TRUST:
/// case LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED:
/// case LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED:
/// case LIQUIDITY_POOL_DEPOSIT_LINE_FULL:
/// case LIQUIDITY_POOL_DEPOSIT_BAD_PRICE:
/// case LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
///     void;
/// };
/// ```
///
// union with discriminant LiquidityPoolDepositResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LiquidityPoolDepositResult {
    Success,
    Malformed,
    NoTrust,
    NotAuthorized,
    Underfunded,
    LineFull,
    BadPrice,
    PoolFull,
}

impl LiquidityPoolDepositResult {
    pub const VARIANTS: [LiquidityPoolDepositResultCode; 8] = [
        LiquidityPoolDepositResultCode::Success,
        LiquidityPoolDepositResultCode::Malformed,
        LiquidityPoolDepositResultCode::NoTrust,
        LiquidityPoolDepositResultCode::NotAuthorized,
        LiquidityPoolDepositResultCode::Underfunded,
        LiquidityPoolDepositResultCode::LineFull,
        LiquidityPoolDepositResultCode::BadPrice,
        LiquidityPoolDepositResultCode::PoolFull,
    ];
    pub const VARIANTS_STR: [&'static str; 8] = [
        "Success",
        "Malformed",
        "NoTrust",
        "NotAuthorized",
        "Underfunded",
        "LineFull",
        "BadPrice",
        "PoolFull",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NoTrust => "NoTrust",
            Self::NotAuthorized => "NotAuthorized",
            Self::Underfunded => "Underfunded",
            Self::LineFull => "LineFull",
            Self::BadPrice => "BadPrice",
            Self::PoolFull => "PoolFull",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LiquidityPoolDepositResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => LiquidityPoolDepositResultCode::Success,
            Self::Malformed => LiquidityPoolDepositResultCode::Malformed,
            Self::NoTrust => LiquidityPoolDepositResultCode::NoTrust,
            Self::NotAuthorized => LiquidityPoolDepositResultCode::NotAuthorized,
            Self::Underfunded => LiquidityPoolDepositResultCode::Underfunded,
            Self::LineFull => LiquidityPoolDepositResultCode::LineFull,
            Self::BadPrice => LiquidityPoolDepositResultCode::BadPrice,
            Self::PoolFull => LiquidityPoolDepositResultCode::PoolFull,
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolDepositResultCode; 8] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolDepositResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LiquidityPoolDepositResultCode> for LiquidityPoolDepositResult {
    #[must_use]
    fn discriminant(&self) -> LiquidityPoolDepositResultCode {
        Self::discriminant(self)
    }
}

impl Variants<LiquidityPoolDepositResultCode> for LiquidityPoolDepositResult {
    fn variants() -> slice::Iter<'static, LiquidityPoolDepositResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<LiquidityPoolDepositResultCode> for LiquidityPoolDepositResult {}

impl ReadXdr for LiquidityPoolDepositResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: LiquidityPoolDepositResultCode =
                <LiquidityPoolDepositResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LiquidityPoolDepositResultCode::Success => Self::Success,
                LiquidityPoolDepositResultCode::Malformed => Self::Malformed,
                LiquidityPoolDepositResultCode::NoTrust => Self::NoTrust,
                LiquidityPoolDepositResultCode::NotAuthorized => Self::NotAuthorized,
                LiquidityPoolDepositResultCode::Underfunded => Self::Underfunded,
                LiquidityPoolDepositResultCode::LineFull => Self::LineFull,
                LiquidityPoolDepositResultCode::BadPrice => Self::BadPrice,
                LiquidityPoolDepositResultCode::PoolFull => Self::PoolFull,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolDepositResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::NoTrust => ().write_xdr(w)?,
                Self::NotAuthorized => ().write_xdr(w)?,
                Self::Underfunded => ().write_xdr(w)?,
                Self::LineFull => ().write_xdr(w)?,
                Self::BadPrice => ().write_xdr(w)?,
                Self::PoolFull => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// LiquidityPoolWithdrawResultCode is an XDR Enum defines as:
///
/// ```text
/// enum LiquidityPoolWithdrawResultCode
/// {
///     // codes considered as "success" for the operation
///     LIQUIDITY_POOL_WITHDRAW_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     LIQUIDITY_POOL_WITHDRAW_MALFORMED = -1,    // bad input
///     LIQUIDITY_POOL_WITHDRAW_NO_TRUST = -2,     // no trust line for one of the
///                                                // assets
///     LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED = -3,  // not enough balance of the
///                                                // pool share
///     LIQUIDITY_POOL_WITHDRAW_LINE_FULL = -4,    // would go above limit for one
///                                                // of the assets
///     LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM = -5 // didn't withdraw enough
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum LiquidityPoolWithdrawResultCode {
    Success = 0,
    Malformed = -1,
    NoTrust = -2,
    Underfunded = -3,
    LineFull = -4,
    UnderMinimum = -5,
}

impl LiquidityPoolWithdrawResultCode {
    pub const VARIANTS: [LiquidityPoolWithdrawResultCode; 6] = [
        LiquidityPoolWithdrawResultCode::Success,
        LiquidityPoolWithdrawResultCode::Malformed,
        LiquidityPoolWithdrawResultCode::NoTrust,
        LiquidityPoolWithdrawResultCode::Underfunded,
        LiquidityPoolWithdrawResultCode::LineFull,
        LiquidityPoolWithdrawResultCode::UnderMinimum,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "Malformed",
        "NoTrust",
        "Underfunded",
        "LineFull",
        "UnderMinimum",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NoTrust => "NoTrust",
            Self::Underfunded => "Underfunded",
            Self::LineFull => "LineFull",
            Self::UnderMinimum => "UnderMinimum",
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolWithdrawResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolWithdrawResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<LiquidityPoolWithdrawResultCode> for LiquidityPoolWithdrawResultCode {
    fn variants() -> slice::Iter<'static, LiquidityPoolWithdrawResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for LiquidityPoolWithdrawResultCode {}

impl fmt::Display for LiquidityPoolWithdrawResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for LiquidityPoolWithdrawResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => LiquidityPoolWithdrawResultCode::Success,
            -1 => LiquidityPoolWithdrawResultCode::Malformed,
            -2 => LiquidityPoolWithdrawResultCode::NoTrust,
            -3 => LiquidityPoolWithdrawResultCode::Underfunded,
            -4 => LiquidityPoolWithdrawResultCode::LineFull,
            -5 => LiquidityPoolWithdrawResultCode::UnderMinimum,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<LiquidityPoolWithdrawResultCode> for i32 {
    #[must_use]
    fn from(e: LiquidityPoolWithdrawResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for LiquidityPoolWithdrawResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolWithdrawResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// LiquidityPoolWithdrawResult is an XDR Union defines as:
///
/// ```text
/// union LiquidityPoolWithdrawResult switch (LiquidityPoolWithdrawResultCode code)
/// {
/// case LIQUIDITY_POOL_WITHDRAW_SUCCESS:
///     void;
/// case LIQUIDITY_POOL_WITHDRAW_MALFORMED:
/// case LIQUIDITY_POOL_WITHDRAW_NO_TRUST:
/// case LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED:
/// case LIQUIDITY_POOL_WITHDRAW_LINE_FULL:
/// case LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
///     void;
/// };
/// ```
///
// union with discriminant LiquidityPoolWithdrawResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum LiquidityPoolWithdrawResult {
    Success,
    Malformed,
    NoTrust,
    Underfunded,
    LineFull,
    UnderMinimum,
}

impl LiquidityPoolWithdrawResult {
    pub const VARIANTS: [LiquidityPoolWithdrawResultCode; 6] = [
        LiquidityPoolWithdrawResultCode::Success,
        LiquidityPoolWithdrawResultCode::Malformed,
        LiquidityPoolWithdrawResultCode::NoTrust,
        LiquidityPoolWithdrawResultCode::Underfunded,
        LiquidityPoolWithdrawResultCode::LineFull,
        LiquidityPoolWithdrawResultCode::UnderMinimum,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "Malformed",
        "NoTrust",
        "Underfunded",
        "LineFull",
        "UnderMinimum",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::NoTrust => "NoTrust",
            Self::Underfunded => "Underfunded",
            Self::LineFull => "LineFull",
            Self::UnderMinimum => "UnderMinimum",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> LiquidityPoolWithdrawResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => LiquidityPoolWithdrawResultCode::Success,
            Self::Malformed => LiquidityPoolWithdrawResultCode::Malformed,
            Self::NoTrust => LiquidityPoolWithdrawResultCode::NoTrust,
            Self::Underfunded => LiquidityPoolWithdrawResultCode::Underfunded,
            Self::LineFull => LiquidityPoolWithdrawResultCode::LineFull,
            Self::UnderMinimum => LiquidityPoolWithdrawResultCode::UnderMinimum,
        }
    }

    #[must_use]
    pub const fn variants() -> [LiquidityPoolWithdrawResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for LiquidityPoolWithdrawResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<LiquidityPoolWithdrawResultCode> for LiquidityPoolWithdrawResult {
    #[must_use]
    fn discriminant(&self) -> LiquidityPoolWithdrawResultCode {
        Self::discriminant(self)
    }
}

impl Variants<LiquidityPoolWithdrawResultCode> for LiquidityPoolWithdrawResult {
    fn variants() -> slice::Iter<'static, LiquidityPoolWithdrawResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<LiquidityPoolWithdrawResultCode> for LiquidityPoolWithdrawResult {}

impl ReadXdr for LiquidityPoolWithdrawResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: LiquidityPoolWithdrawResultCode =
                <LiquidityPoolWithdrawResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                LiquidityPoolWithdrawResultCode::Success => Self::Success,
                LiquidityPoolWithdrawResultCode::Malformed => Self::Malformed,
                LiquidityPoolWithdrawResultCode::NoTrust => Self::NoTrust,
                LiquidityPoolWithdrawResultCode::Underfunded => Self::Underfunded,
                LiquidityPoolWithdrawResultCode::LineFull => Self::LineFull,
                LiquidityPoolWithdrawResultCode::UnderMinimum => Self::UnderMinimum,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for LiquidityPoolWithdrawResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::NoTrust => ().write_xdr(w)?,
                Self::Underfunded => ().write_xdr(w)?,
                Self::LineFull => ().write_xdr(w)?,
                Self::UnderMinimum => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// InvokeHostFunctionResultCode is an XDR Enum defines as:
///
/// ```text
/// enum InvokeHostFunctionResultCode
/// {
///     // codes considered as "success" for the operation
///     INVOKE_HOST_FUNCTION_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     INVOKE_HOST_FUNCTION_MALFORMED = -1,
///     INVOKE_HOST_FUNCTION_TRAPPED = -2,
///     INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED = -3,
///     INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED = -4,
///     INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE = -5
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum InvokeHostFunctionResultCode {
    Success = 0,
    Malformed = -1,
    Trapped = -2,
    ResourceLimitExceeded = -3,
    EntryArchived = -4,
    InsufficientRefundableFee = -5,
}

impl InvokeHostFunctionResultCode {
    pub const VARIANTS: [InvokeHostFunctionResultCode; 6] = [
        InvokeHostFunctionResultCode::Success,
        InvokeHostFunctionResultCode::Malformed,
        InvokeHostFunctionResultCode::Trapped,
        InvokeHostFunctionResultCode::ResourceLimitExceeded,
        InvokeHostFunctionResultCode::EntryArchived,
        InvokeHostFunctionResultCode::InsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "Malformed",
        "Trapped",
        "ResourceLimitExceeded",
        "EntryArchived",
        "InsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::Trapped => "Trapped",
            Self::ResourceLimitExceeded => "ResourceLimitExceeded",
            Self::EntryArchived => "EntryArchived",
            Self::InsufficientRefundableFee => "InsufficientRefundableFee",
        }
    }

    #[must_use]
    pub const fn variants() -> [InvokeHostFunctionResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for InvokeHostFunctionResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<InvokeHostFunctionResultCode> for InvokeHostFunctionResultCode {
    fn variants() -> slice::Iter<'static, InvokeHostFunctionResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for InvokeHostFunctionResultCode {}

impl fmt::Display for InvokeHostFunctionResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for InvokeHostFunctionResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => InvokeHostFunctionResultCode::Success,
            -1 => InvokeHostFunctionResultCode::Malformed,
            -2 => InvokeHostFunctionResultCode::Trapped,
            -3 => InvokeHostFunctionResultCode::ResourceLimitExceeded,
            -4 => InvokeHostFunctionResultCode::EntryArchived,
            -5 => InvokeHostFunctionResultCode::InsufficientRefundableFee,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<InvokeHostFunctionResultCode> for i32 {
    #[must_use]
    fn from(e: InvokeHostFunctionResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for InvokeHostFunctionResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for InvokeHostFunctionResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// InvokeHostFunctionResult is an XDR Union defines as:
///
/// ```text
/// union InvokeHostFunctionResult switch (InvokeHostFunctionResultCode code)
/// {
/// case INVOKE_HOST_FUNCTION_SUCCESS:
///     Hash success; // sha256(InvokeHostFunctionSuccessPreImage)
/// case INVOKE_HOST_FUNCTION_MALFORMED:
/// case INVOKE_HOST_FUNCTION_TRAPPED:
/// case INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED:
/// case INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED:
/// case INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE:
///     void;
/// };
/// ```
///
// union with discriminant InvokeHostFunctionResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum InvokeHostFunctionResult {
    Success(Hash),
    Malformed,
    Trapped,
    ResourceLimitExceeded,
    EntryArchived,
    InsufficientRefundableFee,
}

impl InvokeHostFunctionResult {
    pub const VARIANTS: [InvokeHostFunctionResultCode; 6] = [
        InvokeHostFunctionResultCode::Success,
        InvokeHostFunctionResultCode::Malformed,
        InvokeHostFunctionResultCode::Trapped,
        InvokeHostFunctionResultCode::ResourceLimitExceeded,
        InvokeHostFunctionResultCode::EntryArchived,
        InvokeHostFunctionResultCode::InsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 6] = [
        "Success",
        "Malformed",
        "Trapped",
        "ResourceLimitExceeded",
        "EntryArchived",
        "InsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success(_) => "Success",
            Self::Malformed => "Malformed",
            Self::Trapped => "Trapped",
            Self::ResourceLimitExceeded => "ResourceLimitExceeded",
            Self::EntryArchived => "EntryArchived",
            Self::InsufficientRefundableFee => "InsufficientRefundableFee",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> InvokeHostFunctionResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success(_) => InvokeHostFunctionResultCode::Success,
            Self::Malformed => InvokeHostFunctionResultCode::Malformed,
            Self::Trapped => InvokeHostFunctionResultCode::Trapped,
            Self::ResourceLimitExceeded => InvokeHostFunctionResultCode::ResourceLimitExceeded,
            Self::EntryArchived => InvokeHostFunctionResultCode::EntryArchived,
            Self::InsufficientRefundableFee => {
                InvokeHostFunctionResultCode::InsufficientRefundableFee
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [InvokeHostFunctionResultCode; 6] {
        Self::VARIANTS
    }
}

impl Name for InvokeHostFunctionResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<InvokeHostFunctionResultCode> for InvokeHostFunctionResult {
    #[must_use]
    fn discriminant(&self) -> InvokeHostFunctionResultCode {
        Self::discriminant(self)
    }
}

impl Variants<InvokeHostFunctionResultCode> for InvokeHostFunctionResult {
    fn variants() -> slice::Iter<'static, InvokeHostFunctionResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<InvokeHostFunctionResultCode> for InvokeHostFunctionResult {}

impl ReadXdr for InvokeHostFunctionResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: InvokeHostFunctionResultCode =
                <InvokeHostFunctionResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                InvokeHostFunctionResultCode::Success => Self::Success(Hash::read_xdr(r)?),
                InvokeHostFunctionResultCode::Malformed => Self::Malformed,
                InvokeHostFunctionResultCode::Trapped => Self::Trapped,
                InvokeHostFunctionResultCode::ResourceLimitExceeded => Self::ResourceLimitExceeded,
                InvokeHostFunctionResultCode::EntryArchived => Self::EntryArchived,
                InvokeHostFunctionResultCode::InsufficientRefundableFee => {
                    Self::InsufficientRefundableFee
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for InvokeHostFunctionResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success(v) => v.write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::Trapped => ().write_xdr(w)?,
                Self::ResourceLimitExceeded => ().write_xdr(w)?,
                Self::EntryArchived => ().write_xdr(w)?,
                Self::InsufficientRefundableFee => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// ExtendFootprintTtlResultCode is an XDR Enum defines as:
///
/// ```text
/// enum ExtendFootprintTTLResultCode
/// {
///     // codes considered as "success" for the operation
///     EXTEND_FOOTPRINT_TTL_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     EXTEND_FOOTPRINT_TTL_MALFORMED = -1,
///     EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED = -2,
///     EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE = -3
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum ExtendFootprintTtlResultCode {
    Success = 0,
    Malformed = -1,
    ResourceLimitExceeded = -2,
    InsufficientRefundableFee = -3,
}

impl ExtendFootprintTtlResultCode {
    pub const VARIANTS: [ExtendFootprintTtlResultCode; 4] = [
        ExtendFootprintTtlResultCode::Success,
        ExtendFootprintTtlResultCode::Malformed,
        ExtendFootprintTtlResultCode::ResourceLimitExceeded,
        ExtendFootprintTtlResultCode::InsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "Success",
        "Malformed",
        "ResourceLimitExceeded",
        "InsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::ResourceLimitExceeded => "ResourceLimitExceeded",
            Self::InsufficientRefundableFee => "InsufficientRefundableFee",
        }
    }

    #[must_use]
    pub const fn variants() -> [ExtendFootprintTtlResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for ExtendFootprintTtlResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<ExtendFootprintTtlResultCode> for ExtendFootprintTtlResultCode {
    fn variants() -> slice::Iter<'static, ExtendFootprintTtlResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for ExtendFootprintTtlResultCode {}

impl fmt::Display for ExtendFootprintTtlResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for ExtendFootprintTtlResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => ExtendFootprintTtlResultCode::Success,
            -1 => ExtendFootprintTtlResultCode::Malformed,
            -2 => ExtendFootprintTtlResultCode::ResourceLimitExceeded,
            -3 => ExtendFootprintTtlResultCode::InsufficientRefundableFee,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<ExtendFootprintTtlResultCode> for i32 {
    #[must_use]
    fn from(e: ExtendFootprintTtlResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for ExtendFootprintTtlResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for ExtendFootprintTtlResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// ExtendFootprintTtlResult is an XDR Union defines as:
///
/// ```text
/// union ExtendFootprintTTLResult switch (ExtendFootprintTTLResultCode code)
/// {
/// case EXTEND_FOOTPRINT_TTL_SUCCESS:
///     void;
/// case EXTEND_FOOTPRINT_TTL_MALFORMED:
/// case EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED:
/// case EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE:
///     void;
/// };
/// ```
///
// union with discriminant ExtendFootprintTtlResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ExtendFootprintTtlResult {
    Success,
    Malformed,
    ResourceLimitExceeded,
    InsufficientRefundableFee,
}

impl ExtendFootprintTtlResult {
    pub const VARIANTS: [ExtendFootprintTtlResultCode; 4] = [
        ExtendFootprintTtlResultCode::Success,
        ExtendFootprintTtlResultCode::Malformed,
        ExtendFootprintTtlResultCode::ResourceLimitExceeded,
        ExtendFootprintTtlResultCode::InsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "Success",
        "Malformed",
        "ResourceLimitExceeded",
        "InsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::ResourceLimitExceeded => "ResourceLimitExceeded",
            Self::InsufficientRefundableFee => "InsufficientRefundableFee",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> ExtendFootprintTtlResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => ExtendFootprintTtlResultCode::Success,
            Self::Malformed => ExtendFootprintTtlResultCode::Malformed,
            Self::ResourceLimitExceeded => ExtendFootprintTtlResultCode::ResourceLimitExceeded,
            Self::InsufficientRefundableFee => {
                ExtendFootprintTtlResultCode::InsufficientRefundableFee
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [ExtendFootprintTtlResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for ExtendFootprintTtlResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<ExtendFootprintTtlResultCode> for ExtendFootprintTtlResult {
    #[must_use]
    fn discriminant(&self) -> ExtendFootprintTtlResultCode {
        Self::discriminant(self)
    }
}

impl Variants<ExtendFootprintTtlResultCode> for ExtendFootprintTtlResult {
    fn variants() -> slice::Iter<'static, ExtendFootprintTtlResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<ExtendFootprintTtlResultCode> for ExtendFootprintTtlResult {}

impl ReadXdr for ExtendFootprintTtlResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: ExtendFootprintTtlResultCode =
                <ExtendFootprintTtlResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                ExtendFootprintTtlResultCode::Success => Self::Success,
                ExtendFootprintTtlResultCode::Malformed => Self::Malformed,
                ExtendFootprintTtlResultCode::ResourceLimitExceeded => Self::ResourceLimitExceeded,
                ExtendFootprintTtlResultCode::InsufficientRefundableFee => {
                    Self::InsufficientRefundableFee
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ExtendFootprintTtlResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::ResourceLimitExceeded => ().write_xdr(w)?,
                Self::InsufficientRefundableFee => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// RestoreFootprintResultCode is an XDR Enum defines as:
///
/// ```text
/// enum RestoreFootprintResultCode
/// {
///     // codes considered as "success" for the operation
///     RESTORE_FOOTPRINT_SUCCESS = 0,
///
///     // codes considered as "failure" for the operation
///     RESTORE_FOOTPRINT_MALFORMED = -1,
///     RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED = -2,
///     RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE = -3
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum RestoreFootprintResultCode {
    Success = 0,
    Malformed = -1,
    ResourceLimitExceeded = -2,
    InsufficientRefundableFee = -3,
}

impl RestoreFootprintResultCode {
    pub const VARIANTS: [RestoreFootprintResultCode; 4] = [
        RestoreFootprintResultCode::Success,
        RestoreFootprintResultCode::Malformed,
        RestoreFootprintResultCode::ResourceLimitExceeded,
        RestoreFootprintResultCode::InsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "Success",
        "Malformed",
        "ResourceLimitExceeded",
        "InsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::ResourceLimitExceeded => "ResourceLimitExceeded",
            Self::InsufficientRefundableFee => "InsufficientRefundableFee",
        }
    }

    #[must_use]
    pub const fn variants() -> [RestoreFootprintResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for RestoreFootprintResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<RestoreFootprintResultCode> for RestoreFootprintResultCode {
    fn variants() -> slice::Iter<'static, RestoreFootprintResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for RestoreFootprintResultCode {}

impl fmt::Display for RestoreFootprintResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for RestoreFootprintResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => RestoreFootprintResultCode::Success,
            -1 => RestoreFootprintResultCode::Malformed,
            -2 => RestoreFootprintResultCode::ResourceLimitExceeded,
            -3 => RestoreFootprintResultCode::InsufficientRefundableFee,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<RestoreFootprintResultCode> for i32 {
    #[must_use]
    fn from(e: RestoreFootprintResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for RestoreFootprintResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for RestoreFootprintResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// RestoreFootprintResult is an XDR Union defines as:
///
/// ```text
/// union RestoreFootprintResult switch (RestoreFootprintResultCode code)
/// {
/// case RESTORE_FOOTPRINT_SUCCESS:
///     void;
/// case RESTORE_FOOTPRINT_MALFORMED:
/// case RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED:
/// case RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE:
///     void;
/// };
/// ```
///
// union with discriminant RestoreFootprintResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum RestoreFootprintResult {
    Success,
    Malformed,
    ResourceLimitExceeded,
    InsufficientRefundableFee,
}

impl RestoreFootprintResult {
    pub const VARIANTS: [RestoreFootprintResultCode; 4] = [
        RestoreFootprintResultCode::Success,
        RestoreFootprintResultCode::Malformed,
        RestoreFootprintResultCode::ResourceLimitExceeded,
        RestoreFootprintResultCode::InsufficientRefundableFee,
    ];
    pub const VARIANTS_STR: [&'static str; 4] = [
        "Success",
        "Malformed",
        "ResourceLimitExceeded",
        "InsufficientRefundableFee",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Success => "Success",
            Self::Malformed => "Malformed",
            Self::ResourceLimitExceeded => "ResourceLimitExceeded",
            Self::InsufficientRefundableFee => "InsufficientRefundableFee",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> RestoreFootprintResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Success => RestoreFootprintResultCode::Success,
            Self::Malformed => RestoreFootprintResultCode::Malformed,
            Self::ResourceLimitExceeded => RestoreFootprintResultCode::ResourceLimitExceeded,
            Self::InsufficientRefundableFee => {
                RestoreFootprintResultCode::InsufficientRefundableFee
            }
        }
    }

    #[must_use]
    pub const fn variants() -> [RestoreFootprintResultCode; 4] {
        Self::VARIANTS
    }
}

impl Name for RestoreFootprintResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<RestoreFootprintResultCode> for RestoreFootprintResult {
    #[must_use]
    fn discriminant(&self) -> RestoreFootprintResultCode {
        Self::discriminant(self)
    }
}

impl Variants<RestoreFootprintResultCode> for RestoreFootprintResult {
    fn variants() -> slice::Iter<'static, RestoreFootprintResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<RestoreFootprintResultCode> for RestoreFootprintResult {}

impl ReadXdr for RestoreFootprintResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: RestoreFootprintResultCode =
                <RestoreFootprintResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                RestoreFootprintResultCode::Success => Self::Success,
                RestoreFootprintResultCode::Malformed => Self::Malformed,
                RestoreFootprintResultCode::ResourceLimitExceeded => Self::ResourceLimitExceeded,
                RestoreFootprintResultCode::InsufficientRefundableFee => {
                    Self::InsufficientRefundableFee
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for RestoreFootprintResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Success => ().write_xdr(w)?,
                Self::Malformed => ().write_xdr(w)?,
                Self::ResourceLimitExceeded => ().write_xdr(w)?,
                Self::InsufficientRefundableFee => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// OperationResultCode is an XDR Enum defines as:
///
/// ```text
/// enum OperationResultCode
/// {
///     opINNER = 0, // inner object result is valid
///
///     opBAD_AUTH = -1,            // too few valid signatures / wrong network
///     opNO_ACCOUNT = -2,          // source account was not found
///     opNOT_SUPPORTED = -3,       // operation not supported at this time
///     opTOO_MANY_SUBENTRIES = -4, // max number of subentries already reached
///     opEXCEEDED_WORK_LIMIT = -5, // operation did too much work
///     opTOO_MANY_SPONSORING = -6  // account is sponsoring too many entries
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum OperationResultCode {
    OpInner = 0,
    OpBadAuth = -1,
    OpNoAccount = -2,
    OpNotSupported = -3,
    OpTooManySubentries = -4,
    OpExceededWorkLimit = -5,
    OpTooManySponsoring = -6,
}

impl OperationResultCode {
    pub const VARIANTS: [OperationResultCode; 7] = [
        OperationResultCode::OpInner,
        OperationResultCode::OpBadAuth,
        OperationResultCode::OpNoAccount,
        OperationResultCode::OpNotSupported,
        OperationResultCode::OpTooManySubentries,
        OperationResultCode::OpExceededWorkLimit,
        OperationResultCode::OpTooManySponsoring,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "OpInner",
        "OpBadAuth",
        "OpNoAccount",
        "OpNotSupported",
        "OpTooManySubentries",
        "OpExceededWorkLimit",
        "OpTooManySponsoring",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::OpInner => "OpInner",
            Self::OpBadAuth => "OpBadAuth",
            Self::OpNoAccount => "OpNoAccount",
            Self::OpNotSupported => "OpNotSupported",
            Self::OpTooManySubentries => "OpTooManySubentries",
            Self::OpExceededWorkLimit => "OpExceededWorkLimit",
            Self::OpTooManySponsoring => "OpTooManySponsoring",
        }
    }

    #[must_use]
    pub const fn variants() -> [OperationResultCode; 7] {
        Self::VARIANTS
    }
}

impl Name for OperationResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<OperationResultCode> for OperationResultCode {
    fn variants() -> slice::Iter<'static, OperationResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for OperationResultCode {}

impl fmt::Display for OperationResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for OperationResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => OperationResultCode::OpInner,
            -1 => OperationResultCode::OpBadAuth,
            -2 => OperationResultCode::OpNoAccount,
            -3 => OperationResultCode::OpNotSupported,
            -4 => OperationResultCode::OpTooManySubentries,
            -5 => OperationResultCode::OpExceededWorkLimit,
            -6 => OperationResultCode::OpTooManySponsoring,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<OperationResultCode> for i32 {
    #[must_use]
    fn from(e: OperationResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for OperationResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for OperationResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// OperationResultTr is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (OperationType type)
///     {
///     case CREATE_ACCOUNT:
///         CreateAccountResult createAccountResult;
///     case PAYMENT:
///         PaymentResult paymentResult;
///     case PATH_PAYMENT_STRICT_RECEIVE:
///         PathPaymentStrictReceiveResult pathPaymentStrictReceiveResult;
///     case MANAGE_SELL_OFFER:
///         ManageSellOfferResult manageSellOfferResult;
///     case CREATE_PASSIVE_SELL_OFFER:
///         ManageSellOfferResult createPassiveSellOfferResult;
///     case SET_OPTIONS:
///         SetOptionsResult setOptionsResult;
///     case CHANGE_TRUST:
///         ChangeTrustResult changeTrustResult;
///     case ALLOW_TRUST:
///         AllowTrustResult allowTrustResult;
///     case ACCOUNT_MERGE:
///         AccountMergeResult accountMergeResult;
///     case INFLATION:
///         InflationResult inflationResult;
///     case MANAGE_DATA:
///         ManageDataResult manageDataResult;
///     case BUMP_SEQUENCE:
///         BumpSequenceResult bumpSeqResult;
///     case MANAGE_BUY_OFFER:
///         ManageBuyOfferResult manageBuyOfferResult;
///     case PATH_PAYMENT_STRICT_SEND:
///         PathPaymentStrictSendResult pathPaymentStrictSendResult;
///     case CREATE_CLAIMABLE_BALANCE:
///         CreateClaimableBalanceResult createClaimableBalanceResult;
///     case CLAIM_CLAIMABLE_BALANCE:
///         ClaimClaimableBalanceResult claimClaimableBalanceResult;
///     case BEGIN_SPONSORING_FUTURE_RESERVES:
///         BeginSponsoringFutureReservesResult beginSponsoringFutureReservesResult;
///     case END_SPONSORING_FUTURE_RESERVES:
///         EndSponsoringFutureReservesResult endSponsoringFutureReservesResult;
///     case REVOKE_SPONSORSHIP:
///         RevokeSponsorshipResult revokeSponsorshipResult;
///     case CLAWBACK:
///         ClawbackResult clawbackResult;
///     case CLAWBACK_CLAIMABLE_BALANCE:
///         ClawbackClaimableBalanceResult clawbackClaimableBalanceResult;
///     case SET_TRUST_LINE_FLAGS:
///         SetTrustLineFlagsResult setTrustLineFlagsResult;
///     case LIQUIDITY_POOL_DEPOSIT:
///         LiquidityPoolDepositResult liquidityPoolDepositResult;
///     case LIQUIDITY_POOL_WITHDRAW:
///         LiquidityPoolWithdrawResult liquidityPoolWithdrawResult;
///     case INVOKE_HOST_FUNCTION:
///         InvokeHostFunctionResult invokeHostFunctionResult;
///     case EXTEND_FOOTPRINT_TTL:
///         ExtendFootprintTTLResult extendFootprintTTLResult;
///     case RESTORE_FOOTPRINT:
///         RestoreFootprintResult restoreFootprintResult;
///     }
/// ```
///
// union with discriminant OperationType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum OperationResultTr {
    CreateAccount(CreateAccountResult),
    Payment(PaymentResult),
    PathPaymentStrictReceive(PathPaymentStrictReceiveResult),
    ManageSellOffer(ManageSellOfferResult),
    CreatePassiveSellOffer(ManageSellOfferResult),
    SetOptions(SetOptionsResult),
    ChangeTrust(ChangeTrustResult),
    AllowTrust(AllowTrustResult),
    AccountMerge(AccountMergeResult),
    Inflation(InflationResult),
    ManageData(ManageDataResult),
    BumpSequence(BumpSequenceResult),
    ManageBuyOffer(ManageBuyOfferResult),
    PathPaymentStrictSend(PathPaymentStrictSendResult),
    CreateClaimableBalance(CreateClaimableBalanceResult),
    ClaimClaimableBalance(ClaimClaimableBalanceResult),
    BeginSponsoringFutureReserves(BeginSponsoringFutureReservesResult),
    EndSponsoringFutureReserves(EndSponsoringFutureReservesResult),
    RevokeSponsorship(RevokeSponsorshipResult),
    Clawback(ClawbackResult),
    ClawbackClaimableBalance(ClawbackClaimableBalanceResult),
    SetTrustLineFlags(SetTrustLineFlagsResult),
    LiquidityPoolDeposit(LiquidityPoolDepositResult),
    LiquidityPoolWithdraw(LiquidityPoolWithdrawResult),
    InvokeHostFunction(InvokeHostFunctionResult),
    ExtendFootprintTtl(ExtendFootprintTtlResult),
    RestoreFootprint(RestoreFootprintResult),
}

impl OperationResultTr {
    pub const VARIANTS: [OperationType; 27] = [
        OperationType::CreateAccount,
        OperationType::Payment,
        OperationType::PathPaymentStrictReceive,
        OperationType::ManageSellOffer,
        OperationType::CreatePassiveSellOffer,
        OperationType::SetOptions,
        OperationType::ChangeTrust,
        OperationType::AllowTrust,
        OperationType::AccountMerge,
        OperationType::Inflation,
        OperationType::ManageData,
        OperationType::BumpSequence,
        OperationType::ManageBuyOffer,
        OperationType::PathPaymentStrictSend,
        OperationType::CreateClaimableBalance,
        OperationType::ClaimClaimableBalance,
        OperationType::BeginSponsoringFutureReserves,
        OperationType::EndSponsoringFutureReserves,
        OperationType::RevokeSponsorship,
        OperationType::Clawback,
        OperationType::ClawbackClaimableBalance,
        OperationType::SetTrustLineFlags,
        OperationType::LiquidityPoolDeposit,
        OperationType::LiquidityPoolWithdraw,
        OperationType::InvokeHostFunction,
        OperationType::ExtendFootprintTtl,
        OperationType::RestoreFootprint,
    ];
    pub const VARIANTS_STR: [&'static str; 27] = [
        "CreateAccount",
        "Payment",
        "PathPaymentStrictReceive",
        "ManageSellOffer",
        "CreatePassiveSellOffer",
        "SetOptions",
        "ChangeTrust",
        "AllowTrust",
        "AccountMerge",
        "Inflation",
        "ManageData",
        "BumpSequence",
        "ManageBuyOffer",
        "PathPaymentStrictSend",
        "CreateClaimableBalance",
        "ClaimClaimableBalance",
        "BeginSponsoringFutureReserves",
        "EndSponsoringFutureReserves",
        "RevokeSponsorship",
        "Clawback",
        "ClawbackClaimableBalance",
        "SetTrustLineFlags",
        "LiquidityPoolDeposit",
        "LiquidityPoolWithdraw",
        "InvokeHostFunction",
        "ExtendFootprintTtl",
        "RestoreFootprint",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::CreateAccount(_) => "CreateAccount",
            Self::Payment(_) => "Payment",
            Self::PathPaymentStrictReceive(_) => "PathPaymentStrictReceive",
            Self::ManageSellOffer(_) => "ManageSellOffer",
            Self::CreatePassiveSellOffer(_) => "CreatePassiveSellOffer",
            Self::SetOptions(_) => "SetOptions",
            Self::ChangeTrust(_) => "ChangeTrust",
            Self::AllowTrust(_) => "AllowTrust",
            Self::AccountMerge(_) => "AccountMerge",
            Self::Inflation(_) => "Inflation",
            Self::ManageData(_) => "ManageData",
            Self::BumpSequence(_) => "BumpSequence",
            Self::ManageBuyOffer(_) => "ManageBuyOffer",
            Self::PathPaymentStrictSend(_) => "PathPaymentStrictSend",
            Self::CreateClaimableBalance(_) => "CreateClaimableBalance",
            Self::ClaimClaimableBalance(_) => "ClaimClaimableBalance",
            Self::BeginSponsoringFutureReserves(_) => "BeginSponsoringFutureReserves",
            Self::EndSponsoringFutureReserves(_) => "EndSponsoringFutureReserves",
            Self::RevokeSponsorship(_) => "RevokeSponsorship",
            Self::Clawback(_) => "Clawback",
            Self::ClawbackClaimableBalance(_) => "ClawbackClaimableBalance",
            Self::SetTrustLineFlags(_) => "SetTrustLineFlags",
            Self::LiquidityPoolDeposit(_) => "LiquidityPoolDeposit",
            Self::LiquidityPoolWithdraw(_) => "LiquidityPoolWithdraw",
            Self::InvokeHostFunction(_) => "InvokeHostFunction",
            Self::ExtendFootprintTtl(_) => "ExtendFootprintTtl",
            Self::RestoreFootprint(_) => "RestoreFootprint",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> OperationType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::CreateAccount(_) => OperationType::CreateAccount,
            Self::Payment(_) => OperationType::Payment,
            Self::PathPaymentStrictReceive(_) => OperationType::PathPaymentStrictReceive,
            Self::ManageSellOffer(_) => OperationType::ManageSellOffer,
            Self::CreatePassiveSellOffer(_) => OperationType::CreatePassiveSellOffer,
            Self::SetOptions(_) => OperationType::SetOptions,
            Self::ChangeTrust(_) => OperationType::ChangeTrust,
            Self::AllowTrust(_) => OperationType::AllowTrust,
            Self::AccountMerge(_) => OperationType::AccountMerge,
            Self::Inflation(_) => OperationType::Inflation,
            Self::ManageData(_) => OperationType::ManageData,
            Self::BumpSequence(_) => OperationType::BumpSequence,
            Self::ManageBuyOffer(_) => OperationType::ManageBuyOffer,
            Self::PathPaymentStrictSend(_) => OperationType::PathPaymentStrictSend,
            Self::CreateClaimableBalance(_) => OperationType::CreateClaimableBalance,
            Self::ClaimClaimableBalance(_) => OperationType::ClaimClaimableBalance,
            Self::BeginSponsoringFutureReserves(_) => OperationType::BeginSponsoringFutureReserves,
            Self::EndSponsoringFutureReserves(_) => OperationType::EndSponsoringFutureReserves,
            Self::RevokeSponsorship(_) => OperationType::RevokeSponsorship,
            Self::Clawback(_) => OperationType::Clawback,
            Self::ClawbackClaimableBalance(_) => OperationType::ClawbackClaimableBalance,
            Self::SetTrustLineFlags(_) => OperationType::SetTrustLineFlags,
            Self::LiquidityPoolDeposit(_) => OperationType::LiquidityPoolDeposit,
            Self::LiquidityPoolWithdraw(_) => OperationType::LiquidityPoolWithdraw,
            Self::InvokeHostFunction(_) => OperationType::InvokeHostFunction,
            Self::ExtendFootprintTtl(_) => OperationType::ExtendFootprintTtl,
            Self::RestoreFootprint(_) => OperationType::RestoreFootprint,
        }
    }

    #[must_use]
    pub const fn variants() -> [OperationType; 27] {
        Self::VARIANTS
    }
}

impl Name for OperationResultTr {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<OperationType> for OperationResultTr {
    #[must_use]
    fn discriminant(&self) -> OperationType {
        Self::discriminant(self)
    }
}

impl Variants<OperationType> for OperationResultTr {
    fn variants() -> slice::Iter<'static, OperationType> {
        Self::VARIANTS.iter()
    }
}

impl Union<OperationType> for OperationResultTr {}

impl ReadXdr for OperationResultTr {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: OperationType = <OperationType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                OperationType::CreateAccount => {
                    Self::CreateAccount(CreateAccountResult::read_xdr(r)?)
                }
                OperationType::Payment => Self::Payment(PaymentResult::read_xdr(r)?),
                OperationType::PathPaymentStrictReceive => {
                    Self::PathPaymentStrictReceive(PathPaymentStrictReceiveResult::read_xdr(r)?)
                }
                OperationType::ManageSellOffer => {
                    Self::ManageSellOffer(ManageSellOfferResult::read_xdr(r)?)
                }
                OperationType::CreatePassiveSellOffer => {
                    Self::CreatePassiveSellOffer(ManageSellOfferResult::read_xdr(r)?)
                }
                OperationType::SetOptions => Self::SetOptions(SetOptionsResult::read_xdr(r)?),
                OperationType::ChangeTrust => Self::ChangeTrust(ChangeTrustResult::read_xdr(r)?),
                OperationType::AllowTrust => Self::AllowTrust(AllowTrustResult::read_xdr(r)?),
                OperationType::AccountMerge => Self::AccountMerge(AccountMergeResult::read_xdr(r)?),
                OperationType::Inflation => Self::Inflation(InflationResult::read_xdr(r)?),
                OperationType::ManageData => Self::ManageData(ManageDataResult::read_xdr(r)?),
                OperationType::BumpSequence => Self::BumpSequence(BumpSequenceResult::read_xdr(r)?),
                OperationType::ManageBuyOffer => {
                    Self::ManageBuyOffer(ManageBuyOfferResult::read_xdr(r)?)
                }
                OperationType::PathPaymentStrictSend => {
                    Self::PathPaymentStrictSend(PathPaymentStrictSendResult::read_xdr(r)?)
                }
                OperationType::CreateClaimableBalance => {
                    Self::CreateClaimableBalance(CreateClaimableBalanceResult::read_xdr(r)?)
                }
                OperationType::ClaimClaimableBalance => {
                    Self::ClaimClaimableBalance(ClaimClaimableBalanceResult::read_xdr(r)?)
                }
                OperationType::BeginSponsoringFutureReserves => {
                    Self::BeginSponsoringFutureReserves(
                        BeginSponsoringFutureReservesResult::read_xdr(r)?,
                    )
                }
                OperationType::EndSponsoringFutureReserves => Self::EndSponsoringFutureReserves(
                    EndSponsoringFutureReservesResult::read_xdr(r)?,
                ),
                OperationType::RevokeSponsorship => {
                    Self::RevokeSponsorship(RevokeSponsorshipResult::read_xdr(r)?)
                }
                OperationType::Clawback => Self::Clawback(ClawbackResult::read_xdr(r)?),
                OperationType::ClawbackClaimableBalance => {
                    Self::ClawbackClaimableBalance(ClawbackClaimableBalanceResult::read_xdr(r)?)
                }
                OperationType::SetTrustLineFlags => {
                    Self::SetTrustLineFlags(SetTrustLineFlagsResult::read_xdr(r)?)
                }
                OperationType::LiquidityPoolDeposit => {
                    Self::LiquidityPoolDeposit(LiquidityPoolDepositResult::read_xdr(r)?)
                }
                OperationType::LiquidityPoolWithdraw => {
                    Self::LiquidityPoolWithdraw(LiquidityPoolWithdrawResult::read_xdr(r)?)
                }
                OperationType::InvokeHostFunction => {
                    Self::InvokeHostFunction(InvokeHostFunctionResult::read_xdr(r)?)
                }
                OperationType::ExtendFootprintTtl => {
                    Self::ExtendFootprintTtl(ExtendFootprintTtlResult::read_xdr(r)?)
                }
                OperationType::RestoreFootprint => {
                    Self::RestoreFootprint(RestoreFootprintResult::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for OperationResultTr {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::CreateAccount(v) => v.write_xdr(w)?,
                Self::Payment(v) => v.write_xdr(w)?,
                Self::PathPaymentStrictReceive(v) => v.write_xdr(w)?,
                Self::ManageSellOffer(v) => v.write_xdr(w)?,
                Self::CreatePassiveSellOffer(v) => v.write_xdr(w)?,
                Self::SetOptions(v) => v.write_xdr(w)?,
                Self::ChangeTrust(v) => v.write_xdr(w)?,
                Self::AllowTrust(v) => v.write_xdr(w)?,
                Self::AccountMerge(v) => v.write_xdr(w)?,
                Self::Inflation(v) => v.write_xdr(w)?,
                Self::ManageData(v) => v.write_xdr(w)?,
                Self::BumpSequence(v) => v.write_xdr(w)?,
                Self::ManageBuyOffer(v) => v.write_xdr(w)?,
                Self::PathPaymentStrictSend(v) => v.write_xdr(w)?,
                Self::CreateClaimableBalance(v) => v.write_xdr(w)?,
                Self::ClaimClaimableBalance(v) => v.write_xdr(w)?,
                Self::BeginSponsoringFutureReserves(v) => v.write_xdr(w)?,
                Self::EndSponsoringFutureReserves(v) => v.write_xdr(w)?,
                Self::RevokeSponsorship(v) => v.write_xdr(w)?,
                Self::Clawback(v) => v.write_xdr(w)?,
                Self::ClawbackClaimableBalance(v) => v.write_xdr(w)?,
                Self::SetTrustLineFlags(v) => v.write_xdr(w)?,
                Self::LiquidityPoolDeposit(v) => v.write_xdr(w)?,
                Self::LiquidityPoolWithdraw(v) => v.write_xdr(w)?,
                Self::InvokeHostFunction(v) => v.write_xdr(w)?,
                Self::ExtendFootprintTtl(v) => v.write_xdr(w)?,
                Self::RestoreFootprint(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// OperationResult is an XDR Union defines as:
///
/// ```text
/// union OperationResult switch (OperationResultCode code)
/// {
/// case opINNER:
///     union switch (OperationType type)
///     {
///     case CREATE_ACCOUNT:
///         CreateAccountResult createAccountResult;
///     case PAYMENT:
///         PaymentResult paymentResult;
///     case PATH_PAYMENT_STRICT_RECEIVE:
///         PathPaymentStrictReceiveResult pathPaymentStrictReceiveResult;
///     case MANAGE_SELL_OFFER:
///         ManageSellOfferResult manageSellOfferResult;
///     case CREATE_PASSIVE_SELL_OFFER:
///         ManageSellOfferResult createPassiveSellOfferResult;
///     case SET_OPTIONS:
///         SetOptionsResult setOptionsResult;
///     case CHANGE_TRUST:
///         ChangeTrustResult changeTrustResult;
///     case ALLOW_TRUST:
///         AllowTrustResult allowTrustResult;
///     case ACCOUNT_MERGE:
///         AccountMergeResult accountMergeResult;
///     case INFLATION:
///         InflationResult inflationResult;
///     case MANAGE_DATA:
///         ManageDataResult manageDataResult;
///     case BUMP_SEQUENCE:
///         BumpSequenceResult bumpSeqResult;
///     case MANAGE_BUY_OFFER:
///         ManageBuyOfferResult manageBuyOfferResult;
///     case PATH_PAYMENT_STRICT_SEND:
///         PathPaymentStrictSendResult pathPaymentStrictSendResult;
///     case CREATE_CLAIMABLE_BALANCE:
///         CreateClaimableBalanceResult createClaimableBalanceResult;
///     case CLAIM_CLAIMABLE_BALANCE:
///         ClaimClaimableBalanceResult claimClaimableBalanceResult;
///     case BEGIN_SPONSORING_FUTURE_RESERVES:
///         BeginSponsoringFutureReservesResult beginSponsoringFutureReservesResult;
///     case END_SPONSORING_FUTURE_RESERVES:
///         EndSponsoringFutureReservesResult endSponsoringFutureReservesResult;
///     case REVOKE_SPONSORSHIP:
///         RevokeSponsorshipResult revokeSponsorshipResult;
///     case CLAWBACK:
///         ClawbackResult clawbackResult;
///     case CLAWBACK_CLAIMABLE_BALANCE:
///         ClawbackClaimableBalanceResult clawbackClaimableBalanceResult;
///     case SET_TRUST_LINE_FLAGS:
///         SetTrustLineFlagsResult setTrustLineFlagsResult;
///     case LIQUIDITY_POOL_DEPOSIT:
///         LiquidityPoolDepositResult liquidityPoolDepositResult;
///     case LIQUIDITY_POOL_WITHDRAW:
///         LiquidityPoolWithdrawResult liquidityPoolWithdrawResult;
///     case INVOKE_HOST_FUNCTION:
///         InvokeHostFunctionResult invokeHostFunctionResult;
///     case EXTEND_FOOTPRINT_TTL:
///         ExtendFootprintTTLResult extendFootprintTTLResult;
///     case RESTORE_FOOTPRINT:
///         RestoreFootprintResult restoreFootprintResult;
///     }
///     tr;
/// case opBAD_AUTH:
/// case opNO_ACCOUNT:
/// case opNOT_SUPPORTED:
/// case opTOO_MANY_SUBENTRIES:
/// case opEXCEEDED_WORK_LIMIT:
/// case opTOO_MANY_SPONSORING:
///     void;
/// };
/// ```
///
// union with discriminant OperationResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum OperationResult {
    OpInner(OperationResultTr),
    OpBadAuth,
    OpNoAccount,
    OpNotSupported,
    OpTooManySubentries,
    OpExceededWorkLimit,
    OpTooManySponsoring,
}

impl OperationResult {
    pub const VARIANTS: [OperationResultCode; 7] = [
        OperationResultCode::OpInner,
        OperationResultCode::OpBadAuth,
        OperationResultCode::OpNoAccount,
        OperationResultCode::OpNotSupported,
        OperationResultCode::OpTooManySubentries,
        OperationResultCode::OpExceededWorkLimit,
        OperationResultCode::OpTooManySponsoring,
    ];
    pub const VARIANTS_STR: [&'static str; 7] = [
        "OpInner",
        "OpBadAuth",
        "OpNoAccount",
        "OpNotSupported",
        "OpTooManySubentries",
        "OpExceededWorkLimit",
        "OpTooManySponsoring",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::OpInner(_) => "OpInner",
            Self::OpBadAuth => "OpBadAuth",
            Self::OpNoAccount => "OpNoAccount",
            Self::OpNotSupported => "OpNotSupported",
            Self::OpTooManySubentries => "OpTooManySubentries",
            Self::OpExceededWorkLimit => "OpExceededWorkLimit",
            Self::OpTooManySponsoring => "OpTooManySponsoring",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> OperationResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::OpInner(_) => OperationResultCode::OpInner,
            Self::OpBadAuth => OperationResultCode::OpBadAuth,
            Self::OpNoAccount => OperationResultCode::OpNoAccount,
            Self::OpNotSupported => OperationResultCode::OpNotSupported,
            Self::OpTooManySubentries => OperationResultCode::OpTooManySubentries,
            Self::OpExceededWorkLimit => OperationResultCode::OpExceededWorkLimit,
            Self::OpTooManySponsoring => OperationResultCode::OpTooManySponsoring,
        }
    }

    #[must_use]
    pub const fn variants() -> [OperationResultCode; 7] {
        Self::VARIANTS
    }
}

impl Name for OperationResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<OperationResultCode> for OperationResult {
    #[must_use]
    fn discriminant(&self) -> OperationResultCode {
        Self::discriminant(self)
    }
}

impl Variants<OperationResultCode> for OperationResult {
    fn variants() -> slice::Iter<'static, OperationResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<OperationResultCode> for OperationResult {}

impl ReadXdr for OperationResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: OperationResultCode = <OperationResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                OperationResultCode::OpInner => Self::OpInner(OperationResultTr::read_xdr(r)?),
                OperationResultCode::OpBadAuth => Self::OpBadAuth,
                OperationResultCode::OpNoAccount => Self::OpNoAccount,
                OperationResultCode::OpNotSupported => Self::OpNotSupported,
                OperationResultCode::OpTooManySubentries => Self::OpTooManySubentries,
                OperationResultCode::OpExceededWorkLimit => Self::OpExceededWorkLimit,
                OperationResultCode::OpTooManySponsoring => Self::OpTooManySponsoring,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for OperationResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::OpInner(v) => v.write_xdr(w)?,
                Self::OpBadAuth => ().write_xdr(w)?,
                Self::OpNoAccount => ().write_xdr(w)?,
                Self::OpNotSupported => ().write_xdr(w)?,
                Self::OpTooManySubentries => ().write_xdr(w)?,
                Self::OpExceededWorkLimit => ().write_xdr(w)?,
                Self::OpTooManySponsoring => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionResultCode is an XDR Enum defines as:
///
/// ```text
/// enum TransactionResultCode
/// {
///     txFEE_BUMP_INNER_SUCCESS = 1, // fee bump inner transaction succeeded
///     txSUCCESS = 0,                // all operations succeeded
///
///     txFAILED = -1, // one of the operations failed (none were applied)
///
///     txTOO_EARLY = -2,         // ledger closeTime before minTime
///     txTOO_LATE = -3,          // ledger closeTime after maxTime
///     txMISSING_OPERATION = -4, // no operation was specified
///     txBAD_SEQ = -5,           // sequence number does not match source account
///
///     txBAD_AUTH = -6,             // too few valid signatures / wrong network
///     txINSUFFICIENT_BALANCE = -7, // fee would bring account below reserve
///     txNO_ACCOUNT = -8,           // source account not found
///     txINSUFFICIENT_FEE = -9,     // fee is too small
///     txBAD_AUTH_EXTRA = -10,      // unused signatures attached to transaction
///     txINTERNAL_ERROR = -11,      // an unknown error occurred
///
///     txNOT_SUPPORTED = -12,          // transaction type not supported
///     txFEE_BUMP_INNER_FAILED = -13,  // fee bump inner transaction failed
///     txBAD_SPONSORSHIP = -14,        // sponsorship not confirmed
///     txBAD_MIN_SEQ_AGE_OR_GAP = -15, // minSeqAge or minSeqLedgerGap conditions not met
///     txMALFORMED = -16,              // precondition is invalid
///     txSOROBAN_INVALID = -17         // soroban-specific preconditions were not met
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum TransactionResultCode {
    TxFeeBumpInnerSuccess = 1,
    TxSuccess = 0,
    TxFailed = -1,
    TxTooEarly = -2,
    TxTooLate = -3,
    TxMissingOperation = -4,
    TxBadSeq = -5,
    TxBadAuth = -6,
    TxInsufficientBalance = -7,
    TxNoAccount = -8,
    TxInsufficientFee = -9,
    TxBadAuthExtra = -10,
    TxInternalError = -11,
    TxNotSupported = -12,
    TxFeeBumpInnerFailed = -13,
    TxBadSponsorship = -14,
    TxBadMinSeqAgeOrGap = -15,
    TxMalformed = -16,
    TxSorobanInvalid = -17,
}

impl TransactionResultCode {
    pub const VARIANTS: [TransactionResultCode; 19] = [
        TransactionResultCode::TxFeeBumpInnerSuccess,
        TransactionResultCode::TxSuccess,
        TransactionResultCode::TxFailed,
        TransactionResultCode::TxTooEarly,
        TransactionResultCode::TxTooLate,
        TransactionResultCode::TxMissingOperation,
        TransactionResultCode::TxBadSeq,
        TransactionResultCode::TxBadAuth,
        TransactionResultCode::TxInsufficientBalance,
        TransactionResultCode::TxNoAccount,
        TransactionResultCode::TxInsufficientFee,
        TransactionResultCode::TxBadAuthExtra,
        TransactionResultCode::TxInternalError,
        TransactionResultCode::TxNotSupported,
        TransactionResultCode::TxFeeBumpInnerFailed,
        TransactionResultCode::TxBadSponsorship,
        TransactionResultCode::TxBadMinSeqAgeOrGap,
        TransactionResultCode::TxMalformed,
        TransactionResultCode::TxSorobanInvalid,
    ];
    pub const VARIANTS_STR: [&'static str; 19] = [
        "TxFeeBumpInnerSuccess",
        "TxSuccess",
        "TxFailed",
        "TxTooEarly",
        "TxTooLate",
        "TxMissingOperation",
        "TxBadSeq",
        "TxBadAuth",
        "TxInsufficientBalance",
        "TxNoAccount",
        "TxInsufficientFee",
        "TxBadAuthExtra",
        "TxInternalError",
        "TxNotSupported",
        "TxFeeBumpInnerFailed",
        "TxBadSponsorship",
        "TxBadMinSeqAgeOrGap",
        "TxMalformed",
        "TxSorobanInvalid",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxFeeBumpInnerSuccess => "TxFeeBumpInnerSuccess",
            Self::TxSuccess => "TxSuccess",
            Self::TxFailed => "TxFailed",
            Self::TxTooEarly => "TxTooEarly",
            Self::TxTooLate => "TxTooLate",
            Self::TxMissingOperation => "TxMissingOperation",
            Self::TxBadSeq => "TxBadSeq",
            Self::TxBadAuth => "TxBadAuth",
            Self::TxInsufficientBalance => "TxInsufficientBalance",
            Self::TxNoAccount => "TxNoAccount",
            Self::TxInsufficientFee => "TxInsufficientFee",
            Self::TxBadAuthExtra => "TxBadAuthExtra",
            Self::TxInternalError => "TxInternalError",
            Self::TxNotSupported => "TxNotSupported",
            Self::TxFeeBumpInnerFailed => "TxFeeBumpInnerFailed",
            Self::TxBadSponsorship => "TxBadSponsorship",
            Self::TxBadMinSeqAgeOrGap => "TxBadMinSeqAgeOrGap",
            Self::TxMalformed => "TxMalformed",
            Self::TxSorobanInvalid => "TxSorobanInvalid",
        }
    }

    #[must_use]
    pub const fn variants() -> [TransactionResultCode; 19] {
        Self::VARIANTS
    }
}

impl Name for TransactionResultCode {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TransactionResultCode> for TransactionResultCode {
    fn variants() -> slice::Iter<'static, TransactionResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Enum for TransactionResultCode {}

impl fmt::Display for TransactionResultCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for TransactionResultCode {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            1 => TransactionResultCode::TxFeeBumpInnerSuccess,
            0 => TransactionResultCode::TxSuccess,
            -1 => TransactionResultCode::TxFailed,
            -2 => TransactionResultCode::TxTooEarly,
            -3 => TransactionResultCode::TxTooLate,
            -4 => TransactionResultCode::TxMissingOperation,
            -5 => TransactionResultCode::TxBadSeq,
            -6 => TransactionResultCode::TxBadAuth,
            -7 => TransactionResultCode::TxInsufficientBalance,
            -8 => TransactionResultCode::TxNoAccount,
            -9 => TransactionResultCode::TxInsufficientFee,
            -10 => TransactionResultCode::TxBadAuthExtra,
            -11 => TransactionResultCode::TxInternalError,
            -12 => TransactionResultCode::TxNotSupported,
            -13 => TransactionResultCode::TxFeeBumpInnerFailed,
            -14 => TransactionResultCode::TxBadSponsorship,
            -15 => TransactionResultCode::TxBadMinSeqAgeOrGap,
            -16 => TransactionResultCode::TxMalformed,
            -17 => TransactionResultCode::TxSorobanInvalid,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<TransactionResultCode> for i32 {
    #[must_use]
    fn from(e: TransactionResultCode) -> Self {
        e as Self
    }
}

impl ReadXdr for TransactionResultCode {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionResultCode {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// InnerTransactionResultResult is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (TransactionResultCode code)
///     {
///     // txFEE_BUMP_INNER_SUCCESS is not included
///     case txSUCCESS:
///     case txFAILED:
///         OperationResult results<>;
///     case txTOO_EARLY:
///     case txTOO_LATE:
///     case txMISSING_OPERATION:
///     case txBAD_SEQ:
///     case txBAD_AUTH:
///     case txINSUFFICIENT_BALANCE:
///     case txNO_ACCOUNT:
///     case txINSUFFICIENT_FEE:
///     case txBAD_AUTH_EXTRA:
///     case txINTERNAL_ERROR:
///     case txNOT_SUPPORTED:
///     // txFEE_BUMP_INNER_FAILED is not included
///     case txBAD_SPONSORSHIP:
///     case txBAD_MIN_SEQ_AGE_OR_GAP:
///     case txMALFORMED:
///     case txSOROBAN_INVALID:
///         void;
///     }
/// ```
///
// union with discriminant TransactionResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum InnerTransactionResultResult {
    TxSuccess(VecM<OperationResult>),
    TxFailed(VecM<OperationResult>),
    TxTooEarly,
    TxTooLate,
    TxMissingOperation,
    TxBadSeq,
    TxBadAuth,
    TxInsufficientBalance,
    TxNoAccount,
    TxInsufficientFee,
    TxBadAuthExtra,
    TxInternalError,
    TxNotSupported,
    TxBadSponsorship,
    TxBadMinSeqAgeOrGap,
    TxMalformed,
    TxSorobanInvalid,
}

impl InnerTransactionResultResult {
    pub const VARIANTS: [TransactionResultCode; 17] = [
        TransactionResultCode::TxSuccess,
        TransactionResultCode::TxFailed,
        TransactionResultCode::TxTooEarly,
        TransactionResultCode::TxTooLate,
        TransactionResultCode::TxMissingOperation,
        TransactionResultCode::TxBadSeq,
        TransactionResultCode::TxBadAuth,
        TransactionResultCode::TxInsufficientBalance,
        TransactionResultCode::TxNoAccount,
        TransactionResultCode::TxInsufficientFee,
        TransactionResultCode::TxBadAuthExtra,
        TransactionResultCode::TxInternalError,
        TransactionResultCode::TxNotSupported,
        TransactionResultCode::TxBadSponsorship,
        TransactionResultCode::TxBadMinSeqAgeOrGap,
        TransactionResultCode::TxMalformed,
        TransactionResultCode::TxSorobanInvalid,
    ];
    pub const VARIANTS_STR: [&'static str; 17] = [
        "TxSuccess",
        "TxFailed",
        "TxTooEarly",
        "TxTooLate",
        "TxMissingOperation",
        "TxBadSeq",
        "TxBadAuth",
        "TxInsufficientBalance",
        "TxNoAccount",
        "TxInsufficientFee",
        "TxBadAuthExtra",
        "TxInternalError",
        "TxNotSupported",
        "TxBadSponsorship",
        "TxBadMinSeqAgeOrGap",
        "TxMalformed",
        "TxSorobanInvalid",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxSuccess(_) => "TxSuccess",
            Self::TxFailed(_) => "TxFailed",
            Self::TxTooEarly => "TxTooEarly",
            Self::TxTooLate => "TxTooLate",
            Self::TxMissingOperation => "TxMissingOperation",
            Self::TxBadSeq => "TxBadSeq",
            Self::TxBadAuth => "TxBadAuth",
            Self::TxInsufficientBalance => "TxInsufficientBalance",
            Self::TxNoAccount => "TxNoAccount",
            Self::TxInsufficientFee => "TxInsufficientFee",
            Self::TxBadAuthExtra => "TxBadAuthExtra",
            Self::TxInternalError => "TxInternalError",
            Self::TxNotSupported => "TxNotSupported",
            Self::TxBadSponsorship => "TxBadSponsorship",
            Self::TxBadMinSeqAgeOrGap => "TxBadMinSeqAgeOrGap",
            Self::TxMalformed => "TxMalformed",
            Self::TxSorobanInvalid => "TxSorobanInvalid",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> TransactionResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::TxSuccess(_) => TransactionResultCode::TxSuccess,
            Self::TxFailed(_) => TransactionResultCode::TxFailed,
            Self::TxTooEarly => TransactionResultCode::TxTooEarly,
            Self::TxTooLate => TransactionResultCode::TxTooLate,
            Self::TxMissingOperation => TransactionResultCode::TxMissingOperation,
            Self::TxBadSeq => TransactionResultCode::TxBadSeq,
            Self::TxBadAuth => TransactionResultCode::TxBadAuth,
            Self::TxInsufficientBalance => TransactionResultCode::TxInsufficientBalance,
            Self::TxNoAccount => TransactionResultCode::TxNoAccount,
            Self::TxInsufficientFee => TransactionResultCode::TxInsufficientFee,
            Self::TxBadAuthExtra => TransactionResultCode::TxBadAuthExtra,
            Self::TxInternalError => TransactionResultCode::TxInternalError,
            Self::TxNotSupported => TransactionResultCode::TxNotSupported,
            Self::TxBadSponsorship => TransactionResultCode::TxBadSponsorship,
            Self::TxBadMinSeqAgeOrGap => TransactionResultCode::TxBadMinSeqAgeOrGap,
            Self::TxMalformed => TransactionResultCode::TxMalformed,
            Self::TxSorobanInvalid => TransactionResultCode::TxSorobanInvalid,
        }
    }

    #[must_use]
    pub const fn variants() -> [TransactionResultCode; 17] {
        Self::VARIANTS
    }
}

impl Name for InnerTransactionResultResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<TransactionResultCode> for InnerTransactionResultResult {
    #[must_use]
    fn discriminant(&self) -> TransactionResultCode {
        Self::discriminant(self)
    }
}

impl Variants<TransactionResultCode> for InnerTransactionResultResult {
    fn variants() -> slice::Iter<'static, TransactionResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<TransactionResultCode> for InnerTransactionResultResult {}

impl ReadXdr for InnerTransactionResultResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: TransactionResultCode = <TransactionResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                TransactionResultCode::TxSuccess => {
                    Self::TxSuccess(VecM::<OperationResult>::read_xdr(r)?)
                }
                TransactionResultCode::TxFailed => {
                    Self::TxFailed(VecM::<OperationResult>::read_xdr(r)?)
                }
                TransactionResultCode::TxTooEarly => Self::TxTooEarly,
                TransactionResultCode::TxTooLate => Self::TxTooLate,
                TransactionResultCode::TxMissingOperation => Self::TxMissingOperation,
                TransactionResultCode::TxBadSeq => Self::TxBadSeq,
                TransactionResultCode::TxBadAuth => Self::TxBadAuth,
                TransactionResultCode::TxInsufficientBalance => Self::TxInsufficientBalance,
                TransactionResultCode::TxNoAccount => Self::TxNoAccount,
                TransactionResultCode::TxInsufficientFee => Self::TxInsufficientFee,
                TransactionResultCode::TxBadAuthExtra => Self::TxBadAuthExtra,
                TransactionResultCode::TxInternalError => Self::TxInternalError,
                TransactionResultCode::TxNotSupported => Self::TxNotSupported,
                TransactionResultCode::TxBadSponsorship => Self::TxBadSponsorship,
                TransactionResultCode::TxBadMinSeqAgeOrGap => Self::TxBadMinSeqAgeOrGap,
                TransactionResultCode::TxMalformed => Self::TxMalformed,
                TransactionResultCode::TxSorobanInvalid => Self::TxSorobanInvalid,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for InnerTransactionResultResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::TxSuccess(v) => v.write_xdr(w)?,
                Self::TxFailed(v) => v.write_xdr(w)?,
                Self::TxTooEarly => ().write_xdr(w)?,
                Self::TxTooLate => ().write_xdr(w)?,
                Self::TxMissingOperation => ().write_xdr(w)?,
                Self::TxBadSeq => ().write_xdr(w)?,
                Self::TxBadAuth => ().write_xdr(w)?,
                Self::TxInsufficientBalance => ().write_xdr(w)?,
                Self::TxNoAccount => ().write_xdr(w)?,
                Self::TxInsufficientFee => ().write_xdr(w)?,
                Self::TxBadAuthExtra => ().write_xdr(w)?,
                Self::TxInternalError => ().write_xdr(w)?,
                Self::TxNotSupported => ().write_xdr(w)?,
                Self::TxBadSponsorship => ().write_xdr(w)?,
                Self::TxBadMinSeqAgeOrGap => ().write_xdr(w)?,
                Self::TxMalformed => ().write_xdr(w)?,
                Self::TxSorobanInvalid => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// InnerTransactionResultExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum InnerTransactionResultExt {
    V0,
}

impl InnerTransactionResultExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for InnerTransactionResultExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for InnerTransactionResultExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for InnerTransactionResultExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for InnerTransactionResultExt {}

impl ReadXdr for InnerTransactionResultExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for InnerTransactionResultExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// InnerTransactionResult is an XDR Struct defines as:
///
/// ```text
/// struct InnerTransactionResult
/// {
///     // Always 0. Here for binary compatibility.
///     int64 feeCharged;
///
///     union switch (TransactionResultCode code)
///     {
///     // txFEE_BUMP_INNER_SUCCESS is not included
///     case txSUCCESS:
///     case txFAILED:
///         OperationResult results<>;
///     case txTOO_EARLY:
///     case txTOO_LATE:
///     case txMISSING_OPERATION:
///     case txBAD_SEQ:
///     case txBAD_AUTH:
///     case txINSUFFICIENT_BALANCE:
///     case txNO_ACCOUNT:
///     case txINSUFFICIENT_FEE:
///     case txBAD_AUTH_EXTRA:
///     case txINTERNAL_ERROR:
///     case txNOT_SUPPORTED:
///     // txFEE_BUMP_INNER_FAILED is not included
///     case txBAD_SPONSORSHIP:
///     case txBAD_MIN_SEQ_AGE_OR_GAP:
///     case txMALFORMED:
///     case txSOROBAN_INVALID:
///         void;
///     }
///     result;
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct InnerTransactionResult {
    pub fee_charged: i64,
    pub result: InnerTransactionResultResult,
    pub ext: InnerTransactionResultExt,
}

impl ReadXdr for InnerTransactionResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                fee_charged: i64::read_xdr(r)?,
                result: InnerTransactionResultResult::read_xdr(r)?,
                ext: InnerTransactionResultExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InnerTransactionResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.fee_charged.write_xdr(w)?;
            self.result.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// InnerTransactionResultPair is an XDR Struct defines as:
///
/// ```text
/// struct InnerTransactionResultPair
/// {
///     Hash transactionHash;          // hash of the inner transaction
///     InnerTransactionResult result; // result for the inner transaction
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct InnerTransactionResultPair {
    pub transaction_hash: Hash,
    pub result: InnerTransactionResult,
}

impl ReadXdr for InnerTransactionResultPair {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                transaction_hash: Hash::read_xdr(r)?,
                result: InnerTransactionResult::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for InnerTransactionResultPair {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.transaction_hash.write_xdr(w)?;
            self.result.write_xdr(w)?;
            Ok(())
        })
    }
}

/// TransactionResultResult is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (TransactionResultCode code)
///     {
///     case txFEE_BUMP_INNER_SUCCESS:
///     case txFEE_BUMP_INNER_FAILED:
///         InnerTransactionResultPair innerResultPair;
///     case txSUCCESS:
///     case txFAILED:
///         OperationResult results<>;
///     case txTOO_EARLY:
///     case txTOO_LATE:
///     case txMISSING_OPERATION:
///     case txBAD_SEQ:
///     case txBAD_AUTH:
///     case txINSUFFICIENT_BALANCE:
///     case txNO_ACCOUNT:
///     case txINSUFFICIENT_FEE:
///     case txBAD_AUTH_EXTRA:
///     case txINTERNAL_ERROR:
///     case txNOT_SUPPORTED:
///     // case txFEE_BUMP_INNER_FAILED: handled above
///     case txBAD_SPONSORSHIP:
///     case txBAD_MIN_SEQ_AGE_OR_GAP:
///     case txMALFORMED:
///     case txSOROBAN_INVALID:
///         void;
///     }
/// ```
///
// union with discriminant TransactionResultCode
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TransactionResultResult {
    TxFeeBumpInnerSuccess(InnerTransactionResultPair),
    TxFeeBumpInnerFailed(InnerTransactionResultPair),
    TxSuccess(VecM<OperationResult>),
    TxFailed(VecM<OperationResult>),
    TxTooEarly,
    TxTooLate,
    TxMissingOperation,
    TxBadSeq,
    TxBadAuth,
    TxInsufficientBalance,
    TxNoAccount,
    TxInsufficientFee,
    TxBadAuthExtra,
    TxInternalError,
    TxNotSupported,
    TxBadSponsorship,
    TxBadMinSeqAgeOrGap,
    TxMalformed,
    TxSorobanInvalid,
}

impl TransactionResultResult {
    pub const VARIANTS: [TransactionResultCode; 19] = [
        TransactionResultCode::TxFeeBumpInnerSuccess,
        TransactionResultCode::TxFeeBumpInnerFailed,
        TransactionResultCode::TxSuccess,
        TransactionResultCode::TxFailed,
        TransactionResultCode::TxTooEarly,
        TransactionResultCode::TxTooLate,
        TransactionResultCode::TxMissingOperation,
        TransactionResultCode::TxBadSeq,
        TransactionResultCode::TxBadAuth,
        TransactionResultCode::TxInsufficientBalance,
        TransactionResultCode::TxNoAccount,
        TransactionResultCode::TxInsufficientFee,
        TransactionResultCode::TxBadAuthExtra,
        TransactionResultCode::TxInternalError,
        TransactionResultCode::TxNotSupported,
        TransactionResultCode::TxBadSponsorship,
        TransactionResultCode::TxBadMinSeqAgeOrGap,
        TransactionResultCode::TxMalformed,
        TransactionResultCode::TxSorobanInvalid,
    ];
    pub const VARIANTS_STR: [&'static str; 19] = [
        "TxFeeBumpInnerSuccess",
        "TxFeeBumpInnerFailed",
        "TxSuccess",
        "TxFailed",
        "TxTooEarly",
        "TxTooLate",
        "TxMissingOperation",
        "TxBadSeq",
        "TxBadAuth",
        "TxInsufficientBalance",
        "TxNoAccount",
        "TxInsufficientFee",
        "TxBadAuthExtra",
        "TxInternalError",
        "TxNotSupported",
        "TxBadSponsorship",
        "TxBadMinSeqAgeOrGap",
        "TxMalformed",
        "TxSorobanInvalid",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::TxFeeBumpInnerSuccess(_) => "TxFeeBumpInnerSuccess",
            Self::TxFeeBumpInnerFailed(_) => "TxFeeBumpInnerFailed",
            Self::TxSuccess(_) => "TxSuccess",
            Self::TxFailed(_) => "TxFailed",
            Self::TxTooEarly => "TxTooEarly",
            Self::TxTooLate => "TxTooLate",
            Self::TxMissingOperation => "TxMissingOperation",
            Self::TxBadSeq => "TxBadSeq",
            Self::TxBadAuth => "TxBadAuth",
            Self::TxInsufficientBalance => "TxInsufficientBalance",
            Self::TxNoAccount => "TxNoAccount",
            Self::TxInsufficientFee => "TxInsufficientFee",
            Self::TxBadAuthExtra => "TxBadAuthExtra",
            Self::TxInternalError => "TxInternalError",
            Self::TxNotSupported => "TxNotSupported",
            Self::TxBadSponsorship => "TxBadSponsorship",
            Self::TxBadMinSeqAgeOrGap => "TxBadMinSeqAgeOrGap",
            Self::TxMalformed => "TxMalformed",
            Self::TxSorobanInvalid => "TxSorobanInvalid",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> TransactionResultCode {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::TxFeeBumpInnerSuccess(_) => TransactionResultCode::TxFeeBumpInnerSuccess,
            Self::TxFeeBumpInnerFailed(_) => TransactionResultCode::TxFeeBumpInnerFailed,
            Self::TxSuccess(_) => TransactionResultCode::TxSuccess,
            Self::TxFailed(_) => TransactionResultCode::TxFailed,
            Self::TxTooEarly => TransactionResultCode::TxTooEarly,
            Self::TxTooLate => TransactionResultCode::TxTooLate,
            Self::TxMissingOperation => TransactionResultCode::TxMissingOperation,
            Self::TxBadSeq => TransactionResultCode::TxBadSeq,
            Self::TxBadAuth => TransactionResultCode::TxBadAuth,
            Self::TxInsufficientBalance => TransactionResultCode::TxInsufficientBalance,
            Self::TxNoAccount => TransactionResultCode::TxNoAccount,
            Self::TxInsufficientFee => TransactionResultCode::TxInsufficientFee,
            Self::TxBadAuthExtra => TransactionResultCode::TxBadAuthExtra,
            Self::TxInternalError => TransactionResultCode::TxInternalError,
            Self::TxNotSupported => TransactionResultCode::TxNotSupported,
            Self::TxBadSponsorship => TransactionResultCode::TxBadSponsorship,
            Self::TxBadMinSeqAgeOrGap => TransactionResultCode::TxBadMinSeqAgeOrGap,
            Self::TxMalformed => TransactionResultCode::TxMalformed,
            Self::TxSorobanInvalid => TransactionResultCode::TxSorobanInvalid,
        }
    }

    #[must_use]
    pub const fn variants() -> [TransactionResultCode; 19] {
        Self::VARIANTS
    }
}

impl Name for TransactionResultResult {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<TransactionResultCode> for TransactionResultResult {
    #[must_use]
    fn discriminant(&self) -> TransactionResultCode {
        Self::discriminant(self)
    }
}

impl Variants<TransactionResultCode> for TransactionResultResult {
    fn variants() -> slice::Iter<'static, TransactionResultCode> {
        Self::VARIANTS.iter()
    }
}

impl Union<TransactionResultCode> for TransactionResultResult {}

impl ReadXdr for TransactionResultResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: TransactionResultCode = <TransactionResultCode as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                TransactionResultCode::TxFeeBumpInnerSuccess => {
                    Self::TxFeeBumpInnerSuccess(InnerTransactionResultPair::read_xdr(r)?)
                }
                TransactionResultCode::TxFeeBumpInnerFailed => {
                    Self::TxFeeBumpInnerFailed(InnerTransactionResultPair::read_xdr(r)?)
                }
                TransactionResultCode::TxSuccess => {
                    Self::TxSuccess(VecM::<OperationResult>::read_xdr(r)?)
                }
                TransactionResultCode::TxFailed => {
                    Self::TxFailed(VecM::<OperationResult>::read_xdr(r)?)
                }
                TransactionResultCode::TxTooEarly => Self::TxTooEarly,
                TransactionResultCode::TxTooLate => Self::TxTooLate,
                TransactionResultCode::TxMissingOperation => Self::TxMissingOperation,
                TransactionResultCode::TxBadSeq => Self::TxBadSeq,
                TransactionResultCode::TxBadAuth => Self::TxBadAuth,
                TransactionResultCode::TxInsufficientBalance => Self::TxInsufficientBalance,
                TransactionResultCode::TxNoAccount => Self::TxNoAccount,
                TransactionResultCode::TxInsufficientFee => Self::TxInsufficientFee,
                TransactionResultCode::TxBadAuthExtra => Self::TxBadAuthExtra,
                TransactionResultCode::TxInternalError => Self::TxInternalError,
                TransactionResultCode::TxNotSupported => Self::TxNotSupported,
                TransactionResultCode::TxBadSponsorship => Self::TxBadSponsorship,
                TransactionResultCode::TxBadMinSeqAgeOrGap => Self::TxBadMinSeqAgeOrGap,
                TransactionResultCode::TxMalformed => Self::TxMalformed,
                TransactionResultCode::TxSorobanInvalid => Self::TxSorobanInvalid,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionResultResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::TxFeeBumpInnerSuccess(v) => v.write_xdr(w)?,
                Self::TxFeeBumpInnerFailed(v) => v.write_xdr(w)?,
                Self::TxSuccess(v) => v.write_xdr(w)?,
                Self::TxFailed(v) => v.write_xdr(w)?,
                Self::TxTooEarly => ().write_xdr(w)?,
                Self::TxTooLate => ().write_xdr(w)?,
                Self::TxMissingOperation => ().write_xdr(w)?,
                Self::TxBadSeq => ().write_xdr(w)?,
                Self::TxBadAuth => ().write_xdr(w)?,
                Self::TxInsufficientBalance => ().write_xdr(w)?,
                Self::TxNoAccount => ().write_xdr(w)?,
                Self::TxInsufficientFee => ().write_xdr(w)?,
                Self::TxBadAuthExtra => ().write_xdr(w)?,
                Self::TxInternalError => ().write_xdr(w)?,
                Self::TxNotSupported => ().write_xdr(w)?,
                Self::TxBadSponsorship => ().write_xdr(w)?,
                Self::TxBadMinSeqAgeOrGap => ().write_xdr(w)?,
                Self::TxMalformed => ().write_xdr(w)?,
                Self::TxSorobanInvalid => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionResultExt is an XDR NestedUnion defines as:
///
/// ```text
/// union switch (int v)
///     {
///     case 0:
///         void;
///     }
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum TransactionResultExt {
    V0,
}

impl TransactionResultExt {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for TransactionResultExt {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for TransactionResultExt {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for TransactionResultExt {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for TransactionResultExt {}

impl ReadXdr for TransactionResultExt {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for TransactionResultExt {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// TransactionResult is an XDR Struct defines as:
///
/// ```text
/// struct TransactionResult
/// {
///     int64 feeCharged; // actual fee charged for the transaction
///
///     union switch (TransactionResultCode code)
///     {
///     case txFEE_BUMP_INNER_SUCCESS:
///     case txFEE_BUMP_INNER_FAILED:
///         InnerTransactionResultPair innerResultPair;
///     case txSUCCESS:
///     case txFAILED:
///         OperationResult results<>;
///     case txTOO_EARLY:
///     case txTOO_LATE:
///     case txMISSING_OPERATION:
///     case txBAD_SEQ:
///     case txBAD_AUTH:
///     case txINSUFFICIENT_BALANCE:
///     case txNO_ACCOUNT:
///     case txINSUFFICIENT_FEE:
///     case txBAD_AUTH_EXTRA:
///     case txINTERNAL_ERROR:
///     case txNOT_SUPPORTED:
///     // case txFEE_BUMP_INNER_FAILED: handled above
///     case txBAD_SPONSORSHIP:
///     case txBAD_MIN_SEQ_AGE_OR_GAP:
///     case txMALFORMED:
///     case txSOROBAN_INVALID:
///         void;
///     }
///     result;
///
///     // reserved for future use
///     union switch (int v)
///     {
///     case 0:
///         void;
///     }
///     ext;
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct TransactionResult {
    pub fee_charged: i64,
    pub result: TransactionResultResult,
    pub ext: TransactionResultExt,
}

impl ReadXdr for TransactionResult {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                fee_charged: i64::read_xdr(r)?,
                result: TransactionResultResult::read_xdr(r)?,
                ext: TransactionResultExt::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for TransactionResult {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.fee_charged.write_xdr(w)?;
            self.result.write_xdr(w)?;
            self.ext.write_xdr(w)?;
            Ok(())
        })
    }
}

/// Hash is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque Hash[32];
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
pub struct Hash(pub [u8; 32]);

impl core::fmt::Debug for Hash {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "Hash(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}
impl core::fmt::Display for Hash {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl core::str::FromStr for Hash {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        hex::decode(s).map_err(|_| Error::InvalidHex)?.try_into()
    }
}
impl From<Hash> for [u8; 32] {
    #[must_use]
    fn from(x: Hash) -> Self {
        x.0
    }
}

impl From<[u8; 32]> for Hash {
    #[must_use]
    fn from(x: [u8; 32]) -> Self {
        Hash(x)
    }
}

impl AsRef<[u8; 32]> for Hash {
    #[must_use]
    fn as_ref(&self) -> &[u8; 32] {
        &self.0
    }
}

impl ReadXdr for Hash {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = <[u8; 32]>::read_xdr(r)?;
            let v = Hash(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Hash {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Hash {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for Hash {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for Hash {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for Hash {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self> {
        Ok(Hash(x.try_into()?))
    }
}

impl AsRef<[u8]> for Hash {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// Uint256 is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque uint256[32];
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
pub struct Uint256(pub [u8; 32]);

impl core::fmt::Debug for Uint256 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "Uint256(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}
impl core::fmt::Display for Uint256 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl core::str::FromStr for Uint256 {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        hex::decode(s).map_err(|_| Error::InvalidHex)?.try_into()
    }
}
impl From<Uint256> for [u8; 32] {
    #[must_use]
    fn from(x: Uint256) -> Self {
        x.0
    }
}

impl From<[u8; 32]> for Uint256 {
    #[must_use]
    fn from(x: [u8; 32]) -> Self {
        Uint256(x)
    }
}

impl AsRef<[u8; 32]> for Uint256 {
    #[must_use]
    fn as_ref(&self) -> &[u8; 32] {
        &self.0
    }
}

impl ReadXdr for Uint256 {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = <[u8; 32]>::read_xdr(r)?;
            let v = Uint256(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Uint256 {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Uint256 {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for Uint256 {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for Uint256 {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for Uint256 {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self> {
        Ok(Uint256(x.try_into()?))
    }
}

impl AsRef<[u8]> for Uint256 {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// Uint32 is an XDR Typedef defines as:
///
/// ```text
/// typedef unsigned int uint32;
/// ```
///
pub type Uint32 = u32;

/// Int32 is an XDR Typedef defines as:
///
/// ```text
/// typedef int int32;
/// ```
///
pub type Int32 = i32;

/// Uint64 is an XDR Typedef defines as:
///
/// ```text
/// typedef unsigned hyper uint64;
/// ```
///
pub type Uint64 = u64;

/// Int64 is an XDR Typedef defines as:
///
/// ```text
/// typedef hyper int64;
/// ```
///
pub type Int64 = i64;

/// TimePoint is an XDR Typedef defines as:
///
/// ```text
/// typedef uint64 TimePoint;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct TimePoint(pub u64);

impl From<TimePoint> for u64 {
    #[must_use]
    fn from(x: TimePoint) -> Self {
        x.0
    }
}

impl From<u64> for TimePoint {
    #[must_use]
    fn from(x: u64) -> Self {
        TimePoint(x)
    }
}

impl AsRef<u64> for TimePoint {
    #[must_use]
    fn as_ref(&self) -> &u64 {
        &self.0
    }
}

impl ReadXdr for TimePoint {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = u64::read_xdr(r)?;
            let v = TimePoint(i);
            Ok(v)
        })
    }
}

impl WriteXdr for TimePoint {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// Duration is an XDR Typedef defines as:
///
/// ```text
/// typedef uint64 Duration;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct Duration(pub u64);

impl From<Duration> for u64 {
    #[must_use]
    fn from(x: Duration) -> Self {
        x.0
    }
}

impl From<u64> for Duration {
    #[must_use]
    fn from(x: u64) -> Self {
        Duration(x)
    }
}

impl AsRef<u64> for Duration {
    #[must_use]
    fn as_ref(&self) -> &u64 {
        &self.0
    }
}

impl ReadXdr for Duration {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = u64::read_xdr(r)?;
            let v = Duration(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Duration {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// ExtensionPoint is an XDR Union defines as:
///
/// ```text
/// union ExtensionPoint switch (int v)
/// {
/// case 0:
///     void;
/// };
/// ```
///
// union with discriminant i32
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[allow(clippy::large_enum_variant)]
pub enum ExtensionPoint {
    V0,
}

impl ExtensionPoint {
    pub const VARIANTS: [i32; 1] = [0];
    pub const VARIANTS_STR: [&'static str; 1] = ["V0"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::V0 => "V0",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> i32 {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::V0 => 0,
        }
    }

    #[must_use]
    pub const fn variants() -> [i32; 1] {
        Self::VARIANTS
    }
}

impl Name for ExtensionPoint {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<i32> for ExtensionPoint {
    #[must_use]
    fn discriminant(&self) -> i32 {
        Self::discriminant(self)
    }
}

impl Variants<i32> for ExtensionPoint {
    fn variants() -> slice::Iter<'static, i32> {
        Self::VARIANTS.iter()
    }
}

impl Union<i32> for ExtensionPoint {}

impl ReadXdr for ExtensionPoint {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: i32 = <i32 as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                0 => Self::V0,
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for ExtensionPoint {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::V0 => ().write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// CryptoKeyType is an XDR Enum defines as:
///
/// ```text
/// enum CryptoKeyType
/// {
///     KEY_TYPE_ED25519 = 0,
///     KEY_TYPE_PRE_AUTH_TX = 1,
///     KEY_TYPE_HASH_X = 2,
///     KEY_TYPE_ED25519_SIGNED_PAYLOAD = 3,
///     // MUXED enum values for supported type are derived from the enum values
///     // above by ORing them with 0x100
///     KEY_TYPE_MUXED_ED25519 = 0x100
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum CryptoKeyType {
    Ed25519 = 0,
    PreAuthTx = 1,
    HashX = 2,
    Ed25519SignedPayload = 3,
    MuxedEd25519 = 256,
}

impl CryptoKeyType {
    pub const VARIANTS: [CryptoKeyType; 5] = [
        CryptoKeyType::Ed25519,
        CryptoKeyType::PreAuthTx,
        CryptoKeyType::HashX,
        CryptoKeyType::Ed25519SignedPayload,
        CryptoKeyType::MuxedEd25519,
    ];
    pub const VARIANTS_STR: [&'static str; 5] = [
        "Ed25519",
        "PreAuthTx",
        "HashX",
        "Ed25519SignedPayload",
        "MuxedEd25519",
    ];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Ed25519 => "Ed25519",
            Self::PreAuthTx => "PreAuthTx",
            Self::HashX => "HashX",
            Self::Ed25519SignedPayload => "Ed25519SignedPayload",
            Self::MuxedEd25519 => "MuxedEd25519",
        }
    }

    #[must_use]
    pub const fn variants() -> [CryptoKeyType; 5] {
        Self::VARIANTS
    }
}

impl Name for CryptoKeyType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<CryptoKeyType> for CryptoKeyType {
    fn variants() -> slice::Iter<'static, CryptoKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for CryptoKeyType {}

impl fmt::Display for CryptoKeyType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for CryptoKeyType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => CryptoKeyType::Ed25519,
            1 => CryptoKeyType::PreAuthTx,
            2 => CryptoKeyType::HashX,
            3 => CryptoKeyType::Ed25519SignedPayload,
            256 => CryptoKeyType::MuxedEd25519,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<CryptoKeyType> for i32 {
    #[must_use]
    fn from(e: CryptoKeyType) -> Self {
        e as Self
    }
}

impl ReadXdr for CryptoKeyType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for CryptoKeyType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// PublicKeyType is an XDR Enum defines as:
///
/// ```text
/// enum PublicKeyType
/// {
///     PUBLIC_KEY_TYPE_ED25519 = KEY_TYPE_ED25519
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum PublicKeyType {
    PublicKeyTypeEd25519 = 0,
}

impl PublicKeyType {
    pub const VARIANTS: [PublicKeyType; 1] = [PublicKeyType::PublicKeyTypeEd25519];
    pub const VARIANTS_STR: [&'static str; 1] = ["PublicKeyTypeEd25519"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PublicKeyTypeEd25519 => "PublicKeyTypeEd25519",
        }
    }

    #[must_use]
    pub const fn variants() -> [PublicKeyType; 1] {
        Self::VARIANTS
    }
}

impl Name for PublicKeyType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<PublicKeyType> for PublicKeyType {
    fn variants() -> slice::Iter<'static, PublicKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for PublicKeyType {}

impl fmt::Display for PublicKeyType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for PublicKeyType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => PublicKeyType::PublicKeyTypeEd25519,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<PublicKeyType> for i32 {
    #[must_use]
    fn from(e: PublicKeyType) -> Self {
        e as Self
    }
}

impl ReadXdr for PublicKeyType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for PublicKeyType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// SignerKeyType is an XDR Enum defines as:
///
/// ```text
/// enum SignerKeyType
/// {
///     SIGNER_KEY_TYPE_ED25519 = KEY_TYPE_ED25519,
///     SIGNER_KEY_TYPE_PRE_AUTH_TX = KEY_TYPE_PRE_AUTH_TX,
///     SIGNER_KEY_TYPE_HASH_X = KEY_TYPE_HASH_X,
///     SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD = KEY_TYPE_ED25519_SIGNED_PAYLOAD
/// };
/// ```
///
// enum
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[repr(i32)]
pub enum SignerKeyType {
    Ed25519 = 0,
    PreAuthTx = 1,
    HashX = 2,
    Ed25519SignedPayload = 3,
}

impl SignerKeyType {
    pub const VARIANTS: [SignerKeyType; 4] = [
        SignerKeyType::Ed25519,
        SignerKeyType::PreAuthTx,
        SignerKeyType::HashX,
        SignerKeyType::Ed25519SignedPayload,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Ed25519", "PreAuthTx", "HashX", "Ed25519SignedPayload"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Ed25519 => "Ed25519",
            Self::PreAuthTx => "PreAuthTx",
            Self::HashX => "HashX",
            Self::Ed25519SignedPayload => "Ed25519SignedPayload",
        }
    }

    #[must_use]
    pub const fn variants() -> [SignerKeyType; 4] {
        Self::VARIANTS
    }
}

impl Name for SignerKeyType {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<SignerKeyType> for SignerKeyType {
    fn variants() -> slice::Iter<'static, SignerKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Enum for SignerKeyType {}

impl fmt::Display for SignerKeyType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name())
    }
}

impl TryFrom<i32> for SignerKeyType {
    type Error = Error;

    fn try_from(i: i32) -> Result<Self> {
        let e = match i {
            0 => SignerKeyType::Ed25519,
            1 => SignerKeyType::PreAuthTx,
            2 => SignerKeyType::HashX,
            3 => SignerKeyType::Ed25519SignedPayload,
            #[allow(unreachable_patterns)]
            _ => return Err(Error::Invalid),
        };
        Ok(e)
    }
}

impl From<SignerKeyType> for i32 {
    #[must_use]
    fn from(e: SignerKeyType) -> Self {
        e as Self
    }
}

impl ReadXdr for SignerKeyType {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let e = i32::read_xdr(r)?;
            let v: Self = e.try_into()?;
            Ok(v)
        })
    }
}

impl WriteXdr for SignerKeyType {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            let i: i32 = (*self).into();
            i.write_xdr(w)
        })
    }
}

/// PublicKey is an XDR Union defines as:
///
/// ```text
/// union PublicKey switch (PublicKeyType type)
/// {
/// case PUBLIC_KEY_TYPE_ED25519:
///     uint256 ed25519;
/// };
/// ```
///
// union with discriminant PublicKeyType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[allow(clippy::large_enum_variant)]
pub enum PublicKey {
    PublicKeyTypeEd25519(Uint256),
}

impl PublicKey {
    pub const VARIANTS: [PublicKeyType; 1] = [PublicKeyType::PublicKeyTypeEd25519];
    pub const VARIANTS_STR: [&'static str; 1] = ["PublicKeyTypeEd25519"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::PublicKeyTypeEd25519(_) => "PublicKeyTypeEd25519",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> PublicKeyType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::PublicKeyTypeEd25519(_) => PublicKeyType::PublicKeyTypeEd25519,
        }
    }

    #[must_use]
    pub const fn variants() -> [PublicKeyType; 1] {
        Self::VARIANTS
    }
}

impl Name for PublicKey {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<PublicKeyType> for PublicKey {
    #[must_use]
    fn discriminant(&self) -> PublicKeyType {
        Self::discriminant(self)
    }
}

impl Variants<PublicKeyType> for PublicKey {
    fn variants() -> slice::Iter<'static, PublicKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Union<PublicKeyType> for PublicKey {}

impl ReadXdr for PublicKey {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: PublicKeyType = <PublicKeyType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                PublicKeyType::PublicKeyTypeEd25519 => {
                    Self::PublicKeyTypeEd25519(Uint256::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for PublicKey {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::PublicKeyTypeEd25519(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// SignerKeyEd25519SignedPayload is an XDR NestedStruct defines as:
///
/// ```text
/// struct
///     {
///         /* Public key that must sign the payload. */
///         uint256 ed25519;
///         /* Payload to be raw signed by ed25519. */
///         opaque payload<64>;
///     }
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
pub struct SignerKeyEd25519SignedPayload {
    pub ed25519: Uint256,
    pub payload: BytesM<64>,
}

impl ReadXdr for SignerKeyEd25519SignedPayload {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                ed25519: Uint256::read_xdr(r)?,
                payload: BytesM::<64>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for SignerKeyEd25519SignedPayload {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.ed25519.write_xdr(w)?;
            self.payload.write_xdr(w)?;
            Ok(())
        })
    }
}

/// SignerKey is an XDR Union defines as:
///
/// ```text
/// union SignerKey switch (SignerKeyType type)
/// {
/// case SIGNER_KEY_TYPE_ED25519:
///     uint256 ed25519;
/// case SIGNER_KEY_TYPE_PRE_AUTH_TX:
///     /* SHA-256 Hash of TransactionSignaturePayload structure */
///     uint256 preAuthTx;
/// case SIGNER_KEY_TYPE_HASH_X:
///     /* Hash of random 256 bit preimage X */
///     uint256 hashX;
/// case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
///     struct
///     {
///         /* Public key that must sign the payload. */
///         uint256 ed25519;
///         /* Payload to be raw signed by ed25519. */
///         opaque payload<64>;
///     } ed25519SignedPayload;
/// };
/// ```
///
// union with discriminant SignerKeyType
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[allow(clippy::large_enum_variant)]
pub enum SignerKey {
    Ed25519(Uint256),
    PreAuthTx(Uint256),
    HashX(Uint256),
    Ed25519SignedPayload(SignerKeyEd25519SignedPayload),
}

impl SignerKey {
    pub const VARIANTS: [SignerKeyType; 4] = [
        SignerKeyType::Ed25519,
        SignerKeyType::PreAuthTx,
        SignerKeyType::HashX,
        SignerKeyType::Ed25519SignedPayload,
    ];
    pub const VARIANTS_STR: [&'static str; 4] =
        ["Ed25519", "PreAuthTx", "HashX", "Ed25519SignedPayload"];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Ed25519(_) => "Ed25519",
            Self::PreAuthTx(_) => "PreAuthTx",
            Self::HashX(_) => "HashX",
            Self::Ed25519SignedPayload(_) => "Ed25519SignedPayload",
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> SignerKeyType {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Ed25519(_) => SignerKeyType::Ed25519,
            Self::PreAuthTx(_) => SignerKeyType::PreAuthTx,
            Self::HashX(_) => SignerKeyType::HashX,
            Self::Ed25519SignedPayload(_) => SignerKeyType::Ed25519SignedPayload,
        }
    }

    #[must_use]
    pub const fn variants() -> [SignerKeyType; 4] {
        Self::VARIANTS
    }
}

impl Name for SignerKey {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<SignerKeyType> for SignerKey {
    #[must_use]
    fn discriminant(&self) -> SignerKeyType {
        Self::discriminant(self)
    }
}

impl Variants<SignerKeyType> for SignerKey {
    fn variants() -> slice::Iter<'static, SignerKeyType> {
        Self::VARIANTS.iter()
    }
}

impl Union<SignerKeyType> for SignerKey {}

impl ReadXdr for SignerKey {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let dv: SignerKeyType = <SignerKeyType as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
                SignerKeyType::Ed25519 => Self::Ed25519(Uint256::read_xdr(r)?),
                SignerKeyType::PreAuthTx => Self::PreAuthTx(Uint256::read_xdr(r)?),
                SignerKeyType::HashX => Self::HashX(Uint256::read_xdr(r)?),
                SignerKeyType::Ed25519SignedPayload => {
                    Self::Ed25519SignedPayload(SignerKeyEd25519SignedPayload::read_xdr(r)?)
                }
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for SignerKey {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
                Self::Ed25519(v) => v.write_xdr(w)?,
                Self::PreAuthTx(v) => v.write_xdr(w)?,
                Self::HashX(v) => v.write_xdr(w)?,
                Self::Ed25519SignedPayload(v) => v.write_xdr(w)?,
            };
            Ok(())
        })
    }
}

/// Signature is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque Signature<64>;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[derive(Default)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[derive(Debug)]
pub struct Signature(pub BytesM<64>);

impl From<Signature> for BytesM<64> {
    #[must_use]
    fn from(x: Signature) -> Self {
        x.0
    }
}

impl From<BytesM<64>> for Signature {
    #[must_use]
    fn from(x: BytesM<64>) -> Self {
        Signature(x)
    }
}

impl AsRef<BytesM<64>> for Signature {
    #[must_use]
    fn as_ref(&self) -> &BytesM<64> {
        &self.0
    }
}

impl ReadXdr for Signature {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = BytesM::<64>::read_xdr(r)?;
            let v = Signature(i);
            Ok(v)
        })
    }
}

impl WriteXdr for Signature {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl Deref for Signature {
    type Target = BytesM<64>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<Signature> for Vec<u8> {
    #[must_use]
    fn from(x: Signature) -> Self {
        x.0 .0
    }
}

impl TryFrom<Vec<u8>> for Signature {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        Ok(Signature(x.try_into()?))
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for Signature {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        Ok(Signature(x.try_into()?))
    }
}

impl AsRef<Vec<u8>> for Signature {
    #[must_use]
    fn as_ref(&self) -> &Vec<u8> {
        &self.0 .0
    }
}

impl AsRef<[u8]> for Signature {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0 .0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        self.0 .0
    }
}

/// SignatureHint is an XDR Typedef defines as:
///
/// ```text
/// typedef opaque SignatureHint[4];
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
pub struct SignatureHint(pub [u8; 4]);

impl core::fmt::Debug for SignatureHint {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "SignatureHint(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}
impl core::fmt::Display for SignatureHint {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl core::str::FromStr for SignatureHint {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        hex::decode(s).map_err(|_| Error::InvalidHex)?.try_into()
    }
}
impl From<SignatureHint> for [u8; 4] {
    #[must_use]
    fn from(x: SignatureHint) -> Self {
        x.0
    }
}

impl From<[u8; 4]> for SignatureHint {
    #[must_use]
    fn from(x: [u8; 4]) -> Self {
        SignatureHint(x)
    }
}

impl AsRef<[u8; 4]> for SignatureHint {
    #[must_use]
    fn as_ref(&self) -> &[u8; 4] {
        &self.0
    }
}

impl ReadXdr for SignatureHint {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = <[u8; 4]>::read_xdr(r)?;
            let v = SignatureHint(i);
            Ok(v)
        })
    }
}

impl WriteXdr for SignatureHint {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

impl SignatureHint {
    #[must_use]
    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<Vec<u8>> for SignatureHint {
    type Error = Error;
    fn try_from(x: Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

#[cfg(feature = "alloc")]
impl TryFrom<&Vec<u8>> for SignatureHint {
    type Error = Error;
    fn try_from(x: &Vec<u8>) -> Result<Self> {
        x.as_slice().try_into()
    }
}

impl TryFrom<&[u8]> for SignatureHint {
    type Error = Error;
    fn try_from(x: &[u8]) -> Result<Self> {
        Ok(SignatureHint(x.try_into()?))
    }
}

impl AsRef<[u8]> for SignatureHint {
    #[must_use]
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// NodeId is an XDR Typedef defines as:
///
/// ```text
/// typedef PublicKey NodeID;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[derive(Debug)]
pub struct NodeId(pub PublicKey);

impl From<NodeId> for PublicKey {
    #[must_use]
    fn from(x: NodeId) -> Self {
        x.0
    }
}

impl From<PublicKey> for NodeId {
    #[must_use]
    fn from(x: PublicKey) -> Self {
        NodeId(x)
    }
}

impl AsRef<PublicKey> for NodeId {
    #[must_use]
    fn as_ref(&self) -> &PublicKey {
        &self.0
    }
}

impl ReadXdr for NodeId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = PublicKey::read_xdr(r)?;
            let v = NodeId(i);
            Ok(v)
        })
    }
}

impl WriteXdr for NodeId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// AccountId is an XDR Typedef defines as:
///
/// ```text
/// typedef PublicKey AccountID;
/// ```
///
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
#[derive(Debug)]
pub struct AccountId(pub PublicKey);

impl From<AccountId> for PublicKey {
    #[must_use]
    fn from(x: AccountId) -> Self {
        x.0
    }
}

impl From<PublicKey> for AccountId {
    #[must_use]
    fn from(x: PublicKey) -> Self {
        AccountId(x)
    }
}

impl AsRef<PublicKey> for AccountId {
    #[must_use]
    fn as_ref(&self) -> &PublicKey {
        &self.0
    }
}

impl ReadXdr for AccountId {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            let i = PublicKey::read_xdr(r)?;
            let v = AccountId(i);
            Ok(v)
        })
    }
}

impl WriteXdr for AccountId {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| self.0.write_xdr(w))
    }
}

/// Curve25519Secret is an XDR Struct defines as:
///
/// ```text
/// struct Curve25519Secret
/// {
///     opaque key[32];
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Curve25519Secret {
    pub key: [u8; 32],
}

impl ReadXdr for Curve25519Secret {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: <[u8; 32]>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Curve25519Secret {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;
            Ok(())
        })
    }
}

/// Curve25519Public is an XDR Struct defines as:
///
/// ```text
/// struct Curve25519Public
/// {
///     opaque key[32];
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct Curve25519Public {
    pub key: [u8; 32],
}

impl ReadXdr for Curve25519Public {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: <[u8; 32]>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for Curve25519Public {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;
            Ok(())
        })
    }
}

/// HmacSha256Key is an XDR Struct defines as:
///
/// ```text
/// struct HmacSha256Key
/// {
///     opaque key[32];
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct HmacSha256Key {
    pub key: [u8; 32],
}

impl ReadXdr for HmacSha256Key {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                key: <[u8; 32]>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HmacSha256Key {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.key.write_xdr(w)?;
            Ok(())
        })
    }
}

/// HmacSha256Mac is an XDR Struct defines as:
///
/// ```text
/// struct HmacSha256Mac
/// {
///     opaque mac[32];
/// };
/// ```
///
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub struct HmacSha256Mac {
    pub mac: [u8; 32],
}

impl ReadXdr for HmacSha256Mac {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self> {
        r.with_limited_depth(|r| {
            Ok(Self {
                mac: <[u8; 32]>::read_xdr(r)?,
            })
        })
    }
}

impl WriteXdr for HmacSha256Mac {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        w.with_limited_depth(|w| {
            self.mac.write_xdr(w)?;
            Ok(())
        })
    }
}

#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
pub enum TypeVariant {
    Value,
    ScpBallot,
    ScpStatementType,
    ScpNomination,
    ScpStatement,
    ScpStatementPledges,
    ScpStatementPrepare,
    ScpStatementConfirm,
    ScpStatementExternalize,
    ScpEnvelope,
    ScpQuorumSet,
    ConfigSettingContractExecutionLanesV0,
    ConfigSettingContractComputeV0,
    ConfigSettingContractLedgerCostV0,
    ConfigSettingContractHistoricalDataV0,
    ConfigSettingContractEventsV0,
    ConfigSettingContractBandwidthV0,
    ContractCostType,
    ContractCostParamEntry,
    StateArchivalSettings,
    EvictionIterator,
    ContractCostParams,
    ConfigSettingId,
    ConfigSettingEntry,
    ScEnvMetaKind,
    ScEnvMetaEntry,
    ScMetaV0,
    ScMetaKind,
    ScMetaEntry,
    ScSpecType,
    ScSpecTypeOption,
    ScSpecTypeResult,
    ScSpecTypeVec,
    ScSpecTypeMap,
    ScSpecTypeTuple,
    ScSpecTypeBytesN,
    ScSpecTypeUdt,
    ScSpecTypeDef,
    ScSpecUdtStructFieldV0,
    ScSpecUdtStructV0,
    ScSpecUdtUnionCaseVoidV0,
    ScSpecUdtUnionCaseTupleV0,
    ScSpecUdtUnionCaseV0Kind,
    ScSpecUdtUnionCaseV0,
    ScSpecUdtUnionV0,
    ScSpecUdtEnumCaseV0,
    ScSpecUdtEnumV0,
    ScSpecUdtErrorEnumCaseV0,
    ScSpecUdtErrorEnumV0,
    ScSpecFunctionInputV0,
    ScSpecFunctionV0,
    ScSpecEntryKind,
    ScSpecEntry,
    ScValType,
    ScErrorType,
    ScErrorCode,
    ScError,
    UInt128Parts,
    Int128Parts,
    UInt256Parts,
    Int256Parts,
    ContractExecutableType,
    ContractExecutable,
    ScAddressType,
    ScAddress,
    ScVec,
    ScMap,
    ScBytes,
    ScString,
    ScSymbol,
    ScNonceKey,
    ScContractInstance,
    ScVal,
    ScMapEntry,
    StoredTransactionSet,
    StoredDebugTransactionSet,
    PersistedScpStateV0,
    PersistedScpStateV1,
    PersistedScpState,
    Thresholds,
    String32,
    String64,
    SequenceNumber,
    DataValue,
    PoolId,
    AssetCode4,
    AssetCode12,
    AssetType,
    AssetCode,
    AlphaNum4,
    AlphaNum12,
    Asset,
    Price,
    Liabilities,
    ThresholdIndexes,
    LedgerEntryType,
    Signer,
    AccountFlags,
    SponsorshipDescriptor,
    AccountEntryExtensionV3,
    AccountEntryExtensionV2,
    AccountEntryExtensionV2Ext,
    AccountEntryExtensionV1,
    AccountEntryExtensionV1Ext,
    AccountEntry,
    AccountEntryExt,
    TrustLineFlags,
    LiquidityPoolType,
    TrustLineAsset,
    TrustLineEntryExtensionV2,
    TrustLineEntryExtensionV2Ext,
    TrustLineEntry,
    TrustLineEntryExt,
    TrustLineEntryV1,
    TrustLineEntryV1Ext,
    OfferEntryFlags,
    OfferEntry,
    OfferEntryExt,
    DataEntry,
    DataEntryExt,
    ClaimPredicateType,
    ClaimPredicate,
    ClaimantType,
    Claimant,
    ClaimantV0,
    ClaimableBalanceIdType,
    ClaimableBalanceId,
    ClaimableBalanceFlags,
    ClaimableBalanceEntryExtensionV1,
    ClaimableBalanceEntryExtensionV1Ext,
    ClaimableBalanceEntry,
    ClaimableBalanceEntryExt,
    LiquidityPoolConstantProductParameters,
    LiquidityPoolEntry,
    LiquidityPoolEntryBody,
    LiquidityPoolEntryConstantProduct,
    ContractDataDurability,
    ContractDataEntry,
    ContractCodeCostInputs,
    ContractCodeEntry,
    ContractCodeEntryExt,
    ContractCodeEntryV1,
    TtlEntry,
    LedgerEntryExtensionV1,
    LedgerEntryExtensionV1Ext,
    LedgerEntry,
    LedgerEntryData,
    LedgerEntryExt,
    LedgerKey,
    LedgerKeyAccount,
    LedgerKeyTrustLine,
    LedgerKeyOffer,
    LedgerKeyData,
    LedgerKeyClaimableBalance,
    LedgerKeyLiquidityPool,
    LedgerKeyContractData,
    LedgerKeyContractCode,
    LedgerKeyConfigSetting,
    LedgerKeyTtl,
    EnvelopeType,
    UpgradeType,
    StellarValueType,
    LedgerCloseValueSignature,
    StellarValue,
    StellarValueExt,
    LedgerHeaderFlags,
    LedgerHeaderExtensionV1,
    LedgerHeaderExtensionV1Ext,
    LedgerHeader,
    LedgerHeaderExt,
    LedgerUpgradeType,
    ConfigUpgradeSetKey,
    LedgerUpgrade,
    ConfigUpgradeSet,
    BucketEntryType,
    BucketMetadata,
    BucketMetadataExt,
    BucketEntry,
    TxSetComponentType,
    TxSetComponent,
    TxSetComponentTxsMaybeDiscountedFee,
    TransactionPhase,
    TransactionSet,
    TransactionSetV1,
    GeneralizedTransactionSet,
    TransactionResultPair,
    TransactionResultSet,
    TransactionHistoryEntry,
    TransactionHistoryEntryExt,
    TransactionHistoryResultEntry,
    TransactionHistoryResultEntryExt,
    LedgerHeaderHistoryEntry,
    LedgerHeaderHistoryEntryExt,
    LedgerScpMessages,
    ScpHistoryEntryV0,
    ScpHistoryEntry,
    LedgerEntryChangeType,
    LedgerEntryChange,
    LedgerEntryChanges,
    OperationMeta,
    TransactionMetaV1,
    TransactionMetaV2,
    ContractEventType,
    ContractEvent,
    ContractEventBody,
    ContractEventV0,
    DiagnosticEvent,
    SorobanTransactionMetaExtV1,
    SorobanTransactionMetaExt,
    SorobanTransactionMeta,
    TransactionMetaV3,
    InvokeHostFunctionSuccessPreImage,
    TransactionMeta,
    TransactionResultMeta,
    UpgradeEntryMeta,
    LedgerCloseMetaV0,
    LedgerCloseMetaExtV1,
    LedgerCloseMetaExt,
    LedgerCloseMetaV1,
    LedgerCloseMeta,
    ErrorCode,
    SError,
    SendMore,
    SendMoreExtended,
    AuthCert,
    Hello,
    Auth,
    IpAddrType,
    PeerAddress,
    PeerAddressIp,
    MessageType,
    DontHave,
    SurveyMessageCommandType,
    SurveyMessageResponseType,
    SurveyRequestMessage,
    SignedSurveyRequestMessage,
    EncryptedBody,
    SurveyResponseMessage,
    SignedSurveyResponseMessage,
    PeerStats,
    PeerStatList,
    TopologyResponseBodyV0,
    TopologyResponseBodyV1,
    SurveyResponseBody,
    TxAdvertVector,
    FloodAdvert,
    TxDemandVector,
    FloodDemand,
    StellarMessage,
    AuthenticatedMessage,
    AuthenticatedMessageV0,
    LiquidityPoolParameters,
    MuxedAccount,
    MuxedAccountMed25519,
    DecoratedSignature,
    OperationType,
    CreateAccountOp,
    PaymentOp,
    PathPaymentStrictReceiveOp,
    PathPaymentStrictSendOp,
    ManageSellOfferOp,
    ManageBuyOfferOp,
    CreatePassiveSellOfferOp,
    SetOptionsOp,
    ChangeTrustAsset,
    ChangeTrustOp,
    AllowTrustOp,
    ManageDataOp,
    BumpSequenceOp,
    CreateClaimableBalanceOp,
    ClaimClaimableBalanceOp,
    BeginSponsoringFutureReservesOp,
    RevokeSponsorshipType,
    RevokeSponsorshipOp,
    RevokeSponsorshipOpSigner,
    ClawbackOp,
    ClawbackClaimableBalanceOp,
    SetTrustLineFlagsOp,
    LiquidityPoolDepositOp,
    LiquidityPoolWithdrawOp,
    HostFunctionType,
    ContractIdPreimageType,
    ContractIdPreimage,
    ContractIdPreimageFromAddress,
    CreateContractArgs,
    InvokeContractArgs,
    HostFunction,
    SorobanAuthorizedFunctionType,
    SorobanAuthorizedFunction,
    SorobanAuthorizedInvocation,
    SorobanAddressCredentials,
    SorobanCredentialsType,
    SorobanCredentials,
    SorobanAuthorizationEntry,
    InvokeHostFunctionOp,
    ExtendFootprintTtlOp,
    RestoreFootprintOp,
    Operation,
    OperationBody,
    HashIdPreimage,
    HashIdPreimageOperationId,
    HashIdPreimageRevokeId,
    HashIdPreimageContractId,
    HashIdPreimageSorobanAuthorization,
    MemoType,
    Memo,
    TimeBounds,
    LedgerBounds,
    PreconditionsV2,
    PreconditionType,
    Preconditions,
    LedgerFootprint,
    SorobanResources,
    SorobanTransactionData,
    TransactionV0,
    TransactionV0Ext,
    TransactionV0Envelope,
    Transaction,
    TransactionExt,
    TransactionV1Envelope,
    FeeBumpTransaction,
    FeeBumpTransactionInnerTx,
    FeeBumpTransactionExt,
    FeeBumpTransactionEnvelope,
    TransactionEnvelope,
    TransactionSignaturePayload,
    TransactionSignaturePayloadTaggedTransaction,
    ClaimAtomType,
    ClaimOfferAtomV0,
    ClaimOfferAtom,
    ClaimLiquidityAtom,
    ClaimAtom,
    CreateAccountResultCode,
    CreateAccountResult,
    PaymentResultCode,
    PaymentResult,
    PathPaymentStrictReceiveResultCode,
    SimplePaymentResult,
    PathPaymentStrictReceiveResult,
    PathPaymentStrictReceiveResultSuccess,
    PathPaymentStrictSendResultCode,
    PathPaymentStrictSendResult,
    PathPaymentStrictSendResultSuccess,
    ManageSellOfferResultCode,
    ManageOfferEffect,
    ManageOfferSuccessResult,
    ManageOfferSuccessResultOffer,
    ManageSellOfferResult,
    ManageBuyOfferResultCode,
    ManageBuyOfferResult,
    SetOptionsResultCode,
    SetOptionsResult,
    ChangeTrustResultCode,
    ChangeTrustResult,
    AllowTrustResultCode,
    AllowTrustResult,
    AccountMergeResultCode,
    AccountMergeResult,
    InflationResultCode,
    InflationPayout,
    InflationResult,
    ManageDataResultCode,
    ManageDataResult,
    BumpSequenceResultCode,
    BumpSequenceResult,
    CreateClaimableBalanceResultCode,
    CreateClaimableBalanceResult,
    ClaimClaimableBalanceResultCode,
    ClaimClaimableBalanceResult,
    BeginSponsoringFutureReservesResultCode,
    BeginSponsoringFutureReservesResult,
    EndSponsoringFutureReservesResultCode,
    EndSponsoringFutureReservesResult,
    RevokeSponsorshipResultCode,
    RevokeSponsorshipResult,
    ClawbackResultCode,
    ClawbackResult,
    ClawbackClaimableBalanceResultCode,
    ClawbackClaimableBalanceResult,
    SetTrustLineFlagsResultCode,
    SetTrustLineFlagsResult,
    LiquidityPoolDepositResultCode,
    LiquidityPoolDepositResult,
    LiquidityPoolWithdrawResultCode,
    LiquidityPoolWithdrawResult,
    InvokeHostFunctionResultCode,
    InvokeHostFunctionResult,
    ExtendFootprintTtlResultCode,
    ExtendFootprintTtlResult,
    RestoreFootprintResultCode,
    RestoreFootprintResult,
    OperationResultCode,
    OperationResult,
    OperationResultTr,
    TransactionResultCode,
    InnerTransactionResult,
    InnerTransactionResultResult,
    InnerTransactionResultExt,
    InnerTransactionResultPair,
    TransactionResult,
    TransactionResultResult,
    TransactionResultExt,
    Hash,
    Uint256,
    Uint32,
    Int32,
    Uint64,
    Int64,
    TimePoint,
    Duration,
    ExtensionPoint,
    CryptoKeyType,
    PublicKeyType,
    SignerKeyType,
    PublicKey,
    SignerKey,
    SignerKeyEd25519SignedPayload,
    Signature,
    SignatureHint,
    NodeId,
    AccountId,
    Curve25519Secret,
    Curve25519Public,
    HmacSha256Key,
    HmacSha256Mac,
}

impl TypeVariant {
    pub const VARIANTS: [TypeVariant; 425] = [
        TypeVariant::Value,
        TypeVariant::ScpBallot,
        TypeVariant::ScpStatementType,
        TypeVariant::ScpNomination,
        TypeVariant::ScpStatement,
        TypeVariant::ScpStatementPledges,
        TypeVariant::ScpStatementPrepare,
        TypeVariant::ScpStatementConfirm,
        TypeVariant::ScpStatementExternalize,
        TypeVariant::ScpEnvelope,
        TypeVariant::ScpQuorumSet,
        TypeVariant::ConfigSettingContractExecutionLanesV0,
        TypeVariant::ConfigSettingContractComputeV0,
        TypeVariant::ConfigSettingContractLedgerCostV0,
        TypeVariant::ConfigSettingContractHistoricalDataV0,
        TypeVariant::ConfigSettingContractEventsV0,
        TypeVariant::ConfigSettingContractBandwidthV0,
        TypeVariant::ContractCostType,
        TypeVariant::ContractCostParamEntry,
        TypeVariant::StateArchivalSettings,
        TypeVariant::EvictionIterator,
        TypeVariant::ContractCostParams,
        TypeVariant::ConfigSettingId,
        TypeVariant::ConfigSettingEntry,
        TypeVariant::ScEnvMetaKind,
        TypeVariant::ScEnvMetaEntry,
        TypeVariant::ScMetaV0,
        TypeVariant::ScMetaKind,
        TypeVariant::ScMetaEntry,
        TypeVariant::ScSpecType,
        TypeVariant::ScSpecTypeOption,
        TypeVariant::ScSpecTypeResult,
        TypeVariant::ScSpecTypeVec,
        TypeVariant::ScSpecTypeMap,
        TypeVariant::ScSpecTypeTuple,
        TypeVariant::ScSpecTypeBytesN,
        TypeVariant::ScSpecTypeUdt,
        TypeVariant::ScSpecTypeDef,
        TypeVariant::ScSpecUdtStructFieldV0,
        TypeVariant::ScSpecUdtStructV0,
        TypeVariant::ScSpecUdtUnionCaseVoidV0,
        TypeVariant::ScSpecUdtUnionCaseTupleV0,
        TypeVariant::ScSpecUdtUnionCaseV0Kind,
        TypeVariant::ScSpecUdtUnionCaseV0,
        TypeVariant::ScSpecUdtUnionV0,
        TypeVariant::ScSpecUdtEnumCaseV0,
        TypeVariant::ScSpecUdtEnumV0,
        TypeVariant::ScSpecUdtErrorEnumCaseV0,
        TypeVariant::ScSpecUdtErrorEnumV0,
        TypeVariant::ScSpecFunctionInputV0,
        TypeVariant::ScSpecFunctionV0,
        TypeVariant::ScSpecEntryKind,
        TypeVariant::ScSpecEntry,
        TypeVariant::ScValType,
        TypeVariant::ScErrorType,
        TypeVariant::ScErrorCode,
        TypeVariant::ScError,
        TypeVariant::UInt128Parts,
        TypeVariant::Int128Parts,
        TypeVariant::UInt256Parts,
        TypeVariant::Int256Parts,
        TypeVariant::ContractExecutableType,
        TypeVariant::ContractExecutable,
        TypeVariant::ScAddressType,
        TypeVariant::ScAddress,
        TypeVariant::ScVec,
        TypeVariant::ScMap,
        TypeVariant::ScBytes,
        TypeVariant::ScString,
        TypeVariant::ScSymbol,
        TypeVariant::ScNonceKey,
        TypeVariant::ScContractInstance,
        TypeVariant::ScVal,
        TypeVariant::ScMapEntry,
        TypeVariant::StoredTransactionSet,
        TypeVariant::StoredDebugTransactionSet,
        TypeVariant::PersistedScpStateV0,
        TypeVariant::PersistedScpStateV1,
        TypeVariant::PersistedScpState,
        TypeVariant::Thresholds,
        TypeVariant::String32,
        TypeVariant::String64,
        TypeVariant::SequenceNumber,
        TypeVariant::DataValue,
        TypeVariant::PoolId,
        TypeVariant::AssetCode4,
        TypeVariant::AssetCode12,
        TypeVariant::AssetType,
        TypeVariant::AssetCode,
        TypeVariant::AlphaNum4,
        TypeVariant::AlphaNum12,
        TypeVariant::Asset,
        TypeVariant::Price,
        TypeVariant::Liabilities,
        TypeVariant::ThresholdIndexes,
        TypeVariant::LedgerEntryType,
        TypeVariant::Signer,
        TypeVariant::AccountFlags,
        TypeVariant::SponsorshipDescriptor,
        TypeVariant::AccountEntryExtensionV3,
        TypeVariant::AccountEntryExtensionV2,
        TypeVariant::AccountEntryExtensionV2Ext,
        TypeVariant::AccountEntryExtensionV1,
        TypeVariant::AccountEntryExtensionV1Ext,
        TypeVariant::AccountEntry,
        TypeVariant::AccountEntryExt,
        TypeVariant::TrustLineFlags,
        TypeVariant::LiquidityPoolType,
        TypeVariant::TrustLineAsset,
        TypeVariant::TrustLineEntryExtensionV2,
        TypeVariant::TrustLineEntryExtensionV2Ext,
        TypeVariant::TrustLineEntry,
        TypeVariant::TrustLineEntryExt,
        TypeVariant::TrustLineEntryV1,
        TypeVariant::TrustLineEntryV1Ext,
        TypeVariant::OfferEntryFlags,
        TypeVariant::OfferEntry,
        TypeVariant::OfferEntryExt,
        TypeVariant::DataEntry,
        TypeVariant::DataEntryExt,
        TypeVariant::ClaimPredicateType,
        TypeVariant::ClaimPredicate,
        TypeVariant::ClaimantType,
        TypeVariant::Claimant,
        TypeVariant::ClaimantV0,
        TypeVariant::ClaimableBalanceIdType,
        TypeVariant::ClaimableBalanceId,
        TypeVariant::ClaimableBalanceFlags,
        TypeVariant::ClaimableBalanceEntryExtensionV1,
        TypeVariant::ClaimableBalanceEntryExtensionV1Ext,
        TypeVariant::ClaimableBalanceEntry,
        TypeVariant::ClaimableBalanceEntryExt,
        TypeVariant::LiquidityPoolConstantProductParameters,
        TypeVariant::LiquidityPoolEntry,
        TypeVariant::LiquidityPoolEntryBody,
        TypeVariant::LiquidityPoolEntryConstantProduct,
        TypeVariant::ContractDataDurability,
        TypeVariant::ContractDataEntry,
        TypeVariant::ContractCodeCostInputs,
        TypeVariant::ContractCodeEntry,
        TypeVariant::ContractCodeEntryExt,
        TypeVariant::ContractCodeEntryV1,
        TypeVariant::TtlEntry,
        TypeVariant::LedgerEntryExtensionV1,
        TypeVariant::LedgerEntryExtensionV1Ext,
        TypeVariant::LedgerEntry,
        TypeVariant::LedgerEntryData,
        TypeVariant::LedgerEntryExt,
        TypeVariant::LedgerKey,
        TypeVariant::LedgerKeyAccount,
        TypeVariant::LedgerKeyTrustLine,
        TypeVariant::LedgerKeyOffer,
        TypeVariant::LedgerKeyData,
        TypeVariant::LedgerKeyClaimableBalance,
        TypeVariant::LedgerKeyLiquidityPool,
        TypeVariant::LedgerKeyContractData,
        TypeVariant::LedgerKeyContractCode,
        TypeVariant::LedgerKeyConfigSetting,
        TypeVariant::LedgerKeyTtl,
        TypeVariant::EnvelopeType,
        TypeVariant::UpgradeType,
        TypeVariant::StellarValueType,
        TypeVariant::LedgerCloseValueSignature,
        TypeVariant::StellarValue,
        TypeVariant::StellarValueExt,
        TypeVariant::LedgerHeaderFlags,
        TypeVariant::LedgerHeaderExtensionV1,
        TypeVariant::LedgerHeaderExtensionV1Ext,
        TypeVariant::LedgerHeader,
        TypeVariant::LedgerHeaderExt,
        TypeVariant::LedgerUpgradeType,
        TypeVariant::ConfigUpgradeSetKey,
        TypeVariant::LedgerUpgrade,
        TypeVariant::ConfigUpgradeSet,
        TypeVariant::BucketEntryType,
        TypeVariant::BucketMetadata,
        TypeVariant::BucketMetadataExt,
        TypeVariant::BucketEntry,
        TypeVariant::TxSetComponentType,
        TypeVariant::TxSetComponent,
        TypeVariant::TxSetComponentTxsMaybeDiscountedFee,
        TypeVariant::TransactionPhase,
        TypeVariant::TransactionSet,
        TypeVariant::TransactionSetV1,
        TypeVariant::GeneralizedTransactionSet,
        TypeVariant::TransactionResultPair,
        TypeVariant::TransactionResultSet,
        TypeVariant::TransactionHistoryEntry,
        TypeVariant::TransactionHistoryEntryExt,
        TypeVariant::TransactionHistoryResultEntry,
        TypeVariant::TransactionHistoryResultEntryExt,
        TypeVariant::LedgerHeaderHistoryEntry,
        TypeVariant::LedgerHeaderHistoryEntryExt,
        TypeVariant::LedgerScpMessages,
        TypeVariant::ScpHistoryEntryV0,
        TypeVariant::ScpHistoryEntry,
        TypeVariant::LedgerEntryChangeType,
        TypeVariant::LedgerEntryChange,
        TypeVariant::LedgerEntryChanges,
        TypeVariant::OperationMeta,
        TypeVariant::TransactionMetaV1,
        TypeVariant::TransactionMetaV2,
        TypeVariant::ContractEventType,
        TypeVariant::ContractEvent,
        TypeVariant::ContractEventBody,
        TypeVariant::ContractEventV0,
        TypeVariant::DiagnosticEvent,
        TypeVariant::SorobanTransactionMetaExtV1,
        TypeVariant::SorobanTransactionMetaExt,
        TypeVariant::SorobanTransactionMeta,
        TypeVariant::TransactionMetaV3,
        TypeVariant::InvokeHostFunctionSuccessPreImage,
        TypeVariant::TransactionMeta,
        TypeVariant::TransactionResultMeta,
        TypeVariant::UpgradeEntryMeta,
        TypeVariant::LedgerCloseMetaV0,
        TypeVariant::LedgerCloseMetaExtV1,
        TypeVariant::LedgerCloseMetaExt,
        TypeVariant::LedgerCloseMetaV1,
        TypeVariant::LedgerCloseMeta,
        TypeVariant::ErrorCode,
        TypeVariant::SError,
        TypeVariant::SendMore,
        TypeVariant::SendMoreExtended,
        TypeVariant::AuthCert,
        TypeVariant::Hello,
        TypeVariant::Auth,
        TypeVariant::IpAddrType,
        TypeVariant::PeerAddress,
        TypeVariant::PeerAddressIp,
        TypeVariant::MessageType,
        TypeVariant::DontHave,
        TypeVariant::SurveyMessageCommandType,
        TypeVariant::SurveyMessageResponseType,
        TypeVariant::SurveyRequestMessage,
        TypeVariant::SignedSurveyRequestMessage,
        TypeVariant::EncryptedBody,
        TypeVariant::SurveyResponseMessage,
        TypeVariant::SignedSurveyResponseMessage,
        TypeVariant::PeerStats,
        TypeVariant::PeerStatList,
        TypeVariant::TopologyResponseBodyV0,
        TypeVariant::TopologyResponseBodyV1,
        TypeVariant::SurveyResponseBody,
        TypeVariant::TxAdvertVector,
        TypeVariant::FloodAdvert,
        TypeVariant::TxDemandVector,
        TypeVariant::FloodDemand,
        TypeVariant::StellarMessage,
        TypeVariant::AuthenticatedMessage,
        TypeVariant::AuthenticatedMessageV0,
        TypeVariant::LiquidityPoolParameters,
        TypeVariant::MuxedAccount,
        TypeVariant::MuxedAccountMed25519,
        TypeVariant::DecoratedSignature,
        TypeVariant::OperationType,
        TypeVariant::CreateAccountOp,
        TypeVariant::PaymentOp,
        TypeVariant::PathPaymentStrictReceiveOp,
        TypeVariant::PathPaymentStrictSendOp,
        TypeVariant::ManageSellOfferOp,
        TypeVariant::ManageBuyOfferOp,
        TypeVariant::CreatePassiveSellOfferOp,
        TypeVariant::SetOptionsOp,
        TypeVariant::ChangeTrustAsset,
        TypeVariant::ChangeTrustOp,
        TypeVariant::AllowTrustOp,
        TypeVariant::ManageDataOp,
        TypeVariant::BumpSequenceOp,
        TypeVariant::CreateClaimableBalanceOp,
        TypeVariant::ClaimClaimableBalanceOp,
        TypeVariant::BeginSponsoringFutureReservesOp,
        TypeVariant::RevokeSponsorshipType,
        TypeVariant::RevokeSponsorshipOp,
        TypeVariant::RevokeSponsorshipOpSigner,
        TypeVariant::ClawbackOp,
        TypeVariant::ClawbackClaimableBalanceOp,
        TypeVariant::SetTrustLineFlagsOp,
        TypeVariant::LiquidityPoolDepositOp,
        TypeVariant::LiquidityPoolWithdrawOp,
        TypeVariant::HostFunctionType,
        TypeVariant::ContractIdPreimageType,
        TypeVariant::ContractIdPreimage,
        TypeVariant::ContractIdPreimageFromAddress,
        TypeVariant::CreateContractArgs,
        TypeVariant::InvokeContractArgs,
        TypeVariant::HostFunction,
        TypeVariant::SorobanAuthorizedFunctionType,
        TypeVariant::SorobanAuthorizedFunction,
        TypeVariant::SorobanAuthorizedInvocation,
        TypeVariant::SorobanAddressCredentials,
        TypeVariant::SorobanCredentialsType,
        TypeVariant::SorobanCredentials,
        TypeVariant::SorobanAuthorizationEntry,
        TypeVariant::InvokeHostFunctionOp,
        TypeVariant::ExtendFootprintTtlOp,
        TypeVariant::RestoreFootprintOp,
        TypeVariant::Operation,
        TypeVariant::OperationBody,
        TypeVariant::HashIdPreimage,
        TypeVariant::HashIdPreimageOperationId,
        TypeVariant::HashIdPreimageRevokeId,
        TypeVariant::HashIdPreimageContractId,
        TypeVariant::HashIdPreimageSorobanAuthorization,
        TypeVariant::MemoType,
        TypeVariant::Memo,
        TypeVariant::TimeBounds,
        TypeVariant::LedgerBounds,
        TypeVariant::PreconditionsV2,
        TypeVariant::PreconditionType,
        TypeVariant::Preconditions,
        TypeVariant::LedgerFootprint,
        TypeVariant::SorobanResources,
        TypeVariant::SorobanTransactionData,
        TypeVariant::TransactionV0,
        TypeVariant::TransactionV0Ext,
        TypeVariant::TransactionV0Envelope,
        TypeVariant::Transaction,
        TypeVariant::TransactionExt,
        TypeVariant::TransactionV1Envelope,
        TypeVariant::FeeBumpTransaction,
        TypeVariant::FeeBumpTransactionInnerTx,
        TypeVariant::FeeBumpTransactionExt,
        TypeVariant::FeeBumpTransactionEnvelope,
        TypeVariant::TransactionEnvelope,
        TypeVariant::TransactionSignaturePayload,
        TypeVariant::TransactionSignaturePayloadTaggedTransaction,
        TypeVariant::ClaimAtomType,
        TypeVariant::ClaimOfferAtomV0,
        TypeVariant::ClaimOfferAtom,
        TypeVariant::ClaimLiquidityAtom,
        TypeVariant::ClaimAtom,
        TypeVariant::CreateAccountResultCode,
        TypeVariant::CreateAccountResult,
        TypeVariant::PaymentResultCode,
        TypeVariant::PaymentResult,
        TypeVariant::PathPaymentStrictReceiveResultCode,
        TypeVariant::SimplePaymentResult,
        TypeVariant::PathPaymentStrictReceiveResult,
        TypeVariant::PathPaymentStrictReceiveResultSuccess,
        TypeVariant::PathPaymentStrictSendResultCode,
        TypeVariant::PathPaymentStrictSendResult,
        TypeVariant::PathPaymentStrictSendResultSuccess,
        TypeVariant::ManageSellOfferResultCode,
        TypeVariant::ManageOfferEffect,
        TypeVariant::ManageOfferSuccessResult,
        TypeVariant::ManageOfferSuccessResultOffer,
        TypeVariant::ManageSellOfferResult,
        TypeVariant::ManageBuyOfferResultCode,
        TypeVariant::ManageBuyOfferResult,
        TypeVariant::SetOptionsResultCode,
        TypeVariant::SetOptionsResult,
        TypeVariant::ChangeTrustResultCode,
        TypeVariant::ChangeTrustResult,
        TypeVariant::AllowTrustResultCode,
        TypeVariant::AllowTrustResult,
        TypeVariant::AccountMergeResultCode,
        TypeVariant::AccountMergeResult,
        TypeVariant::InflationResultCode,
        TypeVariant::InflationPayout,
        TypeVariant::InflationResult,
        TypeVariant::ManageDataResultCode,
        TypeVariant::ManageDataResult,
        TypeVariant::BumpSequenceResultCode,
        TypeVariant::BumpSequenceResult,
        TypeVariant::CreateClaimableBalanceResultCode,
        TypeVariant::CreateClaimableBalanceResult,
        TypeVariant::ClaimClaimableBalanceResultCode,
        TypeVariant::ClaimClaimableBalanceResult,
        TypeVariant::BeginSponsoringFutureReservesResultCode,
        TypeVariant::BeginSponsoringFutureReservesResult,
        TypeVariant::EndSponsoringFutureReservesResultCode,
        TypeVariant::EndSponsoringFutureReservesResult,
        TypeVariant::RevokeSponsorshipResultCode,
        TypeVariant::RevokeSponsorshipResult,
        TypeVariant::ClawbackResultCode,
        TypeVariant::ClawbackResult,
        TypeVariant::ClawbackClaimableBalanceResultCode,
        TypeVariant::ClawbackClaimableBalanceResult,
        TypeVariant::SetTrustLineFlagsResultCode,
        TypeVariant::SetTrustLineFlagsResult,
        TypeVariant::LiquidityPoolDepositResultCode,
        TypeVariant::LiquidityPoolDepositResult,
        TypeVariant::LiquidityPoolWithdrawResultCode,
        TypeVariant::LiquidityPoolWithdrawResult,
        TypeVariant::InvokeHostFunctionResultCode,
        TypeVariant::InvokeHostFunctionResult,
        TypeVariant::ExtendFootprintTtlResultCode,
        TypeVariant::ExtendFootprintTtlResult,
        TypeVariant::RestoreFootprintResultCode,
        TypeVariant::RestoreFootprintResult,
        TypeVariant::OperationResultCode,
        TypeVariant::OperationResult,
        TypeVariant::OperationResultTr,
        TypeVariant::TransactionResultCode,
        TypeVariant::InnerTransactionResult,
        TypeVariant::InnerTransactionResultResult,
        TypeVariant::InnerTransactionResultExt,
        TypeVariant::InnerTransactionResultPair,
        TypeVariant::TransactionResult,
        TypeVariant::TransactionResultResult,
        TypeVariant::TransactionResultExt,
        TypeVariant::Hash,
        TypeVariant::Uint256,
        TypeVariant::Uint32,
        TypeVariant::Int32,
        TypeVariant::Uint64,
        TypeVariant::Int64,
        TypeVariant::TimePoint,
        TypeVariant::Duration,
        TypeVariant::ExtensionPoint,
        TypeVariant::CryptoKeyType,
        TypeVariant::PublicKeyType,
        TypeVariant::SignerKeyType,
        TypeVariant::PublicKey,
        TypeVariant::SignerKey,
        TypeVariant::SignerKeyEd25519SignedPayload,
        TypeVariant::Signature,
        TypeVariant::SignatureHint,
        TypeVariant::NodeId,
        TypeVariant::AccountId,
        TypeVariant::Curve25519Secret,
        TypeVariant::Curve25519Public,
        TypeVariant::HmacSha256Key,
        TypeVariant::HmacSha256Mac,
    ];
    pub const VARIANTS_STR: [&'static str; 425] = [
        "Value",
        "ScpBallot",
        "ScpStatementType",
        "ScpNomination",
        "ScpStatement",
        "ScpStatementPledges",
        "ScpStatementPrepare",
        "ScpStatementConfirm",
        "ScpStatementExternalize",
        "ScpEnvelope",
        "ScpQuorumSet",
        "ConfigSettingContractExecutionLanesV0",
        "ConfigSettingContractComputeV0",
        "ConfigSettingContractLedgerCostV0",
        "ConfigSettingContractHistoricalDataV0",
        "ConfigSettingContractEventsV0",
        "ConfigSettingContractBandwidthV0",
        "ContractCostType",
        "ContractCostParamEntry",
        "StateArchivalSettings",
        "EvictionIterator",
        "ContractCostParams",
        "ConfigSettingId",
        "ConfigSettingEntry",
        "ScEnvMetaKind",
        "ScEnvMetaEntry",
        "ScMetaV0",
        "ScMetaKind",
        "ScMetaEntry",
        "ScSpecType",
        "ScSpecTypeOption",
        "ScSpecTypeResult",
        "ScSpecTypeVec",
        "ScSpecTypeMap",
        "ScSpecTypeTuple",
        "ScSpecTypeBytesN",
        "ScSpecTypeUdt",
        "ScSpecTypeDef",
        "ScSpecUdtStructFieldV0",
        "ScSpecUdtStructV0",
        "ScSpecUdtUnionCaseVoidV0",
        "ScSpecUdtUnionCaseTupleV0",
        "ScSpecUdtUnionCaseV0Kind",
        "ScSpecUdtUnionCaseV0",
        "ScSpecUdtUnionV0",
        "ScSpecUdtEnumCaseV0",
        "ScSpecUdtEnumV0",
        "ScSpecUdtErrorEnumCaseV0",
        "ScSpecUdtErrorEnumV0",
        "ScSpecFunctionInputV0",
        "ScSpecFunctionV0",
        "ScSpecEntryKind",
        "ScSpecEntry",
        "ScValType",
        "ScErrorType",
        "ScErrorCode",
        "ScError",
        "UInt128Parts",
        "Int128Parts",
        "UInt256Parts",
        "Int256Parts",
        "ContractExecutableType",
        "ContractExecutable",
        "ScAddressType",
        "ScAddress",
        "ScVec",
        "ScMap",
        "ScBytes",
        "ScString",
        "ScSymbol",
        "ScNonceKey",
        "ScContractInstance",
        "ScVal",
        "ScMapEntry",
        "StoredTransactionSet",
        "StoredDebugTransactionSet",
        "PersistedScpStateV0",
        "PersistedScpStateV1",
        "PersistedScpState",
        "Thresholds",
        "String32",
        "String64",
        "SequenceNumber",
        "DataValue",
        "PoolId",
        "AssetCode4",
        "AssetCode12",
        "AssetType",
        "AssetCode",
        "AlphaNum4",
        "AlphaNum12",
        "Asset",
        "Price",
        "Liabilities",
        "ThresholdIndexes",
        "LedgerEntryType",
        "Signer",
        "AccountFlags",
        "SponsorshipDescriptor",
        "AccountEntryExtensionV3",
        "AccountEntryExtensionV2",
        "AccountEntryExtensionV2Ext",
        "AccountEntryExtensionV1",
        "AccountEntryExtensionV1Ext",
        "AccountEntry",
        "AccountEntryExt",
        "TrustLineFlags",
        "LiquidityPoolType",
        "TrustLineAsset",
        "TrustLineEntryExtensionV2",
        "TrustLineEntryExtensionV2Ext",
        "TrustLineEntry",
        "TrustLineEntryExt",
        "TrustLineEntryV1",
        "TrustLineEntryV1Ext",
        "OfferEntryFlags",
        "OfferEntry",
        "OfferEntryExt",
        "DataEntry",
        "DataEntryExt",
        "ClaimPredicateType",
        "ClaimPredicate",
        "ClaimantType",
        "Claimant",
        "ClaimantV0",
        "ClaimableBalanceIdType",
        "ClaimableBalanceId",
        "ClaimableBalanceFlags",
        "ClaimableBalanceEntryExtensionV1",
        "ClaimableBalanceEntryExtensionV1Ext",
        "ClaimableBalanceEntry",
        "ClaimableBalanceEntryExt",
        "LiquidityPoolConstantProductParameters",
        "LiquidityPoolEntry",
        "LiquidityPoolEntryBody",
        "LiquidityPoolEntryConstantProduct",
        "ContractDataDurability",
        "ContractDataEntry",
        "ContractCodeCostInputs",
        "ContractCodeEntry",
        "ContractCodeEntryExt",
        "ContractCodeEntryV1",
        "TtlEntry",
        "LedgerEntryExtensionV1",
        "LedgerEntryExtensionV1Ext",
        "LedgerEntry",
        "LedgerEntryData",
        "LedgerEntryExt",
        "LedgerKey",
        "LedgerKeyAccount",
        "LedgerKeyTrustLine",
        "LedgerKeyOffer",
        "LedgerKeyData",
        "LedgerKeyClaimableBalance",
        "LedgerKeyLiquidityPool",
        "LedgerKeyContractData",
        "LedgerKeyContractCode",
        "LedgerKeyConfigSetting",
        "LedgerKeyTtl",
        "EnvelopeType",
        "UpgradeType",
        "StellarValueType",
        "LedgerCloseValueSignature",
        "StellarValue",
        "StellarValueExt",
        "LedgerHeaderFlags",
        "LedgerHeaderExtensionV1",
        "LedgerHeaderExtensionV1Ext",
        "LedgerHeader",
        "LedgerHeaderExt",
        "LedgerUpgradeType",
        "ConfigUpgradeSetKey",
        "LedgerUpgrade",
        "ConfigUpgradeSet",
        "BucketEntryType",
        "BucketMetadata",
        "BucketMetadataExt",
        "BucketEntry",
        "TxSetComponentType",
        "TxSetComponent",
        "TxSetComponentTxsMaybeDiscountedFee",
        "TransactionPhase",
        "TransactionSet",
        "TransactionSetV1",
        "GeneralizedTransactionSet",
        "TransactionResultPair",
        "TransactionResultSet",
        "TransactionHistoryEntry",
        "TransactionHistoryEntryExt",
        "TransactionHistoryResultEntry",
        "TransactionHistoryResultEntryExt",
        "LedgerHeaderHistoryEntry",
        "LedgerHeaderHistoryEntryExt",
        "LedgerScpMessages",
        "ScpHistoryEntryV0",
        "ScpHistoryEntry",
        "LedgerEntryChangeType",
        "LedgerEntryChange",
        "LedgerEntryChanges",
        "OperationMeta",
        "TransactionMetaV1",
        "TransactionMetaV2",
        "ContractEventType",
        "ContractEvent",
        "ContractEventBody",
        "ContractEventV0",
        "DiagnosticEvent",
        "SorobanTransactionMetaExtV1",
        "SorobanTransactionMetaExt",
        "SorobanTransactionMeta",
        "TransactionMetaV3",
        "InvokeHostFunctionSuccessPreImage",
        "TransactionMeta",
        "TransactionResultMeta",
        "UpgradeEntryMeta",
        "LedgerCloseMetaV0",
        "LedgerCloseMetaExtV1",
        "LedgerCloseMetaExt",
        "LedgerCloseMetaV1",
        "LedgerCloseMeta",
        "ErrorCode",
        "SError",
        "SendMore",
        "SendMoreExtended",
        "AuthCert",
        "Hello",
        "Auth",
        "IpAddrType",
        "PeerAddress",
        "PeerAddressIp",
        "MessageType",
        "DontHave",
        "SurveyMessageCommandType",
        "SurveyMessageResponseType",
        "SurveyRequestMessage",
        "SignedSurveyRequestMessage",
        "EncryptedBody",
        "SurveyResponseMessage",
        "SignedSurveyResponseMessage",
        "PeerStats",
        "PeerStatList",
        "TopologyResponseBodyV0",
        "TopologyResponseBodyV1",
        "SurveyResponseBody",
        "TxAdvertVector",
        "FloodAdvert",
        "TxDemandVector",
        "FloodDemand",
        "StellarMessage",
        "AuthenticatedMessage",
        "AuthenticatedMessageV0",
        "LiquidityPoolParameters",
        "MuxedAccount",
        "MuxedAccountMed25519",
        "DecoratedSignature",
        "OperationType",
        "CreateAccountOp",
        "PaymentOp",
        "PathPaymentStrictReceiveOp",
        "PathPaymentStrictSendOp",
        "ManageSellOfferOp",
        "ManageBuyOfferOp",
        "CreatePassiveSellOfferOp",
        "SetOptionsOp",
        "ChangeTrustAsset",
        "ChangeTrustOp",
        "AllowTrustOp",
        "ManageDataOp",
        "BumpSequenceOp",
        "CreateClaimableBalanceOp",
        "ClaimClaimableBalanceOp",
        "BeginSponsoringFutureReservesOp",
        "RevokeSponsorshipType",
        "RevokeSponsorshipOp",
        "RevokeSponsorshipOpSigner",
        "ClawbackOp",
        "ClawbackClaimableBalanceOp",
        "SetTrustLineFlagsOp",
        "LiquidityPoolDepositOp",
        "LiquidityPoolWithdrawOp",
        "HostFunctionType",
        "ContractIdPreimageType",
        "ContractIdPreimage",
        "ContractIdPreimageFromAddress",
        "CreateContractArgs",
        "InvokeContractArgs",
        "HostFunction",
        "SorobanAuthorizedFunctionType",
        "SorobanAuthorizedFunction",
        "SorobanAuthorizedInvocation",
        "SorobanAddressCredentials",
        "SorobanCredentialsType",
        "SorobanCredentials",
        "SorobanAuthorizationEntry",
        "InvokeHostFunctionOp",
        "ExtendFootprintTtlOp",
        "RestoreFootprintOp",
        "Operation",
        "OperationBody",
        "HashIdPreimage",
        "HashIdPreimageOperationId",
        "HashIdPreimageRevokeId",
        "HashIdPreimageContractId",
        "HashIdPreimageSorobanAuthorization",
        "MemoType",
        "Memo",
        "TimeBounds",
        "LedgerBounds",
        "PreconditionsV2",
        "PreconditionType",
        "Preconditions",
        "LedgerFootprint",
        "SorobanResources",
        "SorobanTransactionData",
        "TransactionV0",
        "TransactionV0Ext",
        "TransactionV0Envelope",
        "Transaction",
        "TransactionExt",
        "TransactionV1Envelope",
        "FeeBumpTransaction",
        "FeeBumpTransactionInnerTx",
        "FeeBumpTransactionExt",
        "FeeBumpTransactionEnvelope",
        "TransactionEnvelope",
        "TransactionSignaturePayload",
        "TransactionSignaturePayloadTaggedTransaction",
        "ClaimAtomType",
        "ClaimOfferAtomV0",
        "ClaimOfferAtom",
        "ClaimLiquidityAtom",
        "ClaimAtom",
        "CreateAccountResultCode",
        "CreateAccountResult",
        "PaymentResultCode",
        "PaymentResult",
        "PathPaymentStrictReceiveResultCode",
        "SimplePaymentResult",
        "PathPaymentStrictReceiveResult",
        "PathPaymentStrictReceiveResultSuccess",
        "PathPaymentStrictSendResultCode",
        "PathPaymentStrictSendResult",
        "PathPaymentStrictSendResultSuccess",
        "ManageSellOfferResultCode",
        "ManageOfferEffect",
        "ManageOfferSuccessResult",
        "ManageOfferSuccessResultOffer",
        "ManageSellOfferResult",
        "ManageBuyOfferResultCode",
        "ManageBuyOfferResult",
        "SetOptionsResultCode",
        "SetOptionsResult",
        "ChangeTrustResultCode",
        "ChangeTrustResult",
        "AllowTrustResultCode",
        "AllowTrustResult",
        "AccountMergeResultCode",
        "AccountMergeResult",
        "InflationResultCode",
        "InflationPayout",
        "InflationResult",
        "ManageDataResultCode",
        "ManageDataResult",
        "BumpSequenceResultCode",
        "BumpSequenceResult",
        "CreateClaimableBalanceResultCode",
        "CreateClaimableBalanceResult",
        "ClaimClaimableBalanceResultCode",
        "ClaimClaimableBalanceResult",
        "BeginSponsoringFutureReservesResultCode",
        "BeginSponsoringFutureReservesResult",
        "EndSponsoringFutureReservesResultCode",
        "EndSponsoringFutureReservesResult",
        "RevokeSponsorshipResultCode",
        "RevokeSponsorshipResult",
        "ClawbackResultCode",
        "ClawbackResult",
        "ClawbackClaimableBalanceResultCode",
        "ClawbackClaimableBalanceResult",
        "SetTrustLineFlagsResultCode",
        "SetTrustLineFlagsResult",
        "LiquidityPoolDepositResultCode",
        "LiquidityPoolDepositResult",
        "LiquidityPoolWithdrawResultCode",
        "LiquidityPoolWithdrawResult",
        "InvokeHostFunctionResultCode",
        "InvokeHostFunctionResult",
        "ExtendFootprintTtlResultCode",
        "ExtendFootprintTtlResult",
        "RestoreFootprintResultCode",
        "RestoreFootprintResult",
        "OperationResultCode",
        "OperationResult",
        "OperationResultTr",
        "TransactionResultCode",
        "InnerTransactionResult",
        "InnerTransactionResultResult",
        "InnerTransactionResultExt",
        "InnerTransactionResultPair",
        "TransactionResult",
        "TransactionResultResult",
        "TransactionResultExt",
        "Hash",
        "Uint256",
        "Uint32",
        "Int32",
        "Uint64",
        "Int64",
        "TimePoint",
        "Duration",
        "ExtensionPoint",
        "CryptoKeyType",
        "PublicKeyType",
        "SignerKeyType",
        "PublicKey",
        "SignerKey",
        "SignerKeyEd25519SignedPayload",
        "Signature",
        "SignatureHint",
        "NodeId",
        "AccountId",
        "Curve25519Secret",
        "Curve25519Public",
        "HmacSha256Key",
        "HmacSha256Mac",
    ];

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Value => "Value",
            Self::ScpBallot => "ScpBallot",
            Self::ScpStatementType => "ScpStatementType",
            Self::ScpNomination => "ScpNomination",
            Self::ScpStatement => "ScpStatement",
            Self::ScpStatementPledges => "ScpStatementPledges",
            Self::ScpStatementPrepare => "ScpStatementPrepare",
            Self::ScpStatementConfirm => "ScpStatementConfirm",
            Self::ScpStatementExternalize => "ScpStatementExternalize",
            Self::ScpEnvelope => "ScpEnvelope",
            Self::ScpQuorumSet => "ScpQuorumSet",
            Self::ConfigSettingContractExecutionLanesV0 => "ConfigSettingContractExecutionLanesV0",
            Self::ConfigSettingContractComputeV0 => "ConfigSettingContractComputeV0",
            Self::ConfigSettingContractLedgerCostV0 => "ConfigSettingContractLedgerCostV0",
            Self::ConfigSettingContractHistoricalDataV0 => "ConfigSettingContractHistoricalDataV0",
            Self::ConfigSettingContractEventsV0 => "ConfigSettingContractEventsV0",
            Self::ConfigSettingContractBandwidthV0 => "ConfigSettingContractBandwidthV0",
            Self::ContractCostType => "ContractCostType",
            Self::ContractCostParamEntry => "ContractCostParamEntry",
            Self::StateArchivalSettings => "StateArchivalSettings",
            Self::EvictionIterator => "EvictionIterator",
            Self::ContractCostParams => "ContractCostParams",
            Self::ConfigSettingId => "ConfigSettingId",
            Self::ConfigSettingEntry => "ConfigSettingEntry",
            Self::ScEnvMetaKind => "ScEnvMetaKind",
            Self::ScEnvMetaEntry => "ScEnvMetaEntry",
            Self::ScMetaV0 => "ScMetaV0",
            Self::ScMetaKind => "ScMetaKind",
            Self::ScMetaEntry => "ScMetaEntry",
            Self::ScSpecType => "ScSpecType",
            Self::ScSpecTypeOption => "ScSpecTypeOption",
            Self::ScSpecTypeResult => "ScSpecTypeResult",
            Self::ScSpecTypeVec => "ScSpecTypeVec",
            Self::ScSpecTypeMap => "ScSpecTypeMap",
            Self::ScSpecTypeTuple => "ScSpecTypeTuple",
            Self::ScSpecTypeBytesN => "ScSpecTypeBytesN",
            Self::ScSpecTypeUdt => "ScSpecTypeUdt",
            Self::ScSpecTypeDef => "ScSpecTypeDef",
            Self::ScSpecUdtStructFieldV0 => "ScSpecUdtStructFieldV0",
            Self::ScSpecUdtStructV0 => "ScSpecUdtStructV0",
            Self::ScSpecUdtUnionCaseVoidV0 => "ScSpecUdtUnionCaseVoidV0",
            Self::ScSpecUdtUnionCaseTupleV0 => "ScSpecUdtUnionCaseTupleV0",
            Self::ScSpecUdtUnionCaseV0Kind => "ScSpecUdtUnionCaseV0Kind",
            Self::ScSpecUdtUnionCaseV0 => "ScSpecUdtUnionCaseV0",
            Self::ScSpecUdtUnionV0 => "ScSpecUdtUnionV0",
            Self::ScSpecUdtEnumCaseV0 => "ScSpecUdtEnumCaseV0",
            Self::ScSpecUdtEnumV0 => "ScSpecUdtEnumV0",
            Self::ScSpecUdtErrorEnumCaseV0 => "ScSpecUdtErrorEnumCaseV0",
            Self::ScSpecUdtErrorEnumV0 => "ScSpecUdtErrorEnumV0",
            Self::ScSpecFunctionInputV0 => "ScSpecFunctionInputV0",
            Self::ScSpecFunctionV0 => "ScSpecFunctionV0",
            Self::ScSpecEntryKind => "ScSpecEntryKind",
            Self::ScSpecEntry => "ScSpecEntry",
            Self::ScValType => "ScValType",
            Self::ScErrorType => "ScErrorType",
            Self::ScErrorCode => "ScErrorCode",
            Self::ScError => "ScError",
            Self::UInt128Parts => "UInt128Parts",
            Self::Int128Parts => "Int128Parts",
            Self::UInt256Parts => "UInt256Parts",
            Self::Int256Parts => "Int256Parts",
            Self::ContractExecutableType => "ContractExecutableType",
            Self::ContractExecutable => "ContractExecutable",
            Self::ScAddressType => "ScAddressType",
            Self::ScAddress => "ScAddress",
            Self::ScVec => "ScVec",
            Self::ScMap => "ScMap",
            Self::ScBytes => "ScBytes",
            Self::ScString => "ScString",
            Self::ScSymbol => "ScSymbol",
            Self::ScNonceKey => "ScNonceKey",
            Self::ScContractInstance => "ScContractInstance",
            Self::ScVal => "ScVal",
            Self::ScMapEntry => "ScMapEntry",
            Self::StoredTransactionSet => "StoredTransactionSet",
            Self::StoredDebugTransactionSet => "StoredDebugTransactionSet",
            Self::PersistedScpStateV0 => "PersistedScpStateV0",
            Self::PersistedScpStateV1 => "PersistedScpStateV1",
            Self::PersistedScpState => "PersistedScpState",
            Self::Thresholds => "Thresholds",
            Self::String32 => "String32",
            Self::String64 => "String64",
            Self::SequenceNumber => "SequenceNumber",
            Self::DataValue => "DataValue",
            Self::PoolId => "PoolId",
            Self::AssetCode4 => "AssetCode4",
            Self::AssetCode12 => "AssetCode12",
            Self::AssetType => "AssetType",
            Self::AssetCode => "AssetCode",
            Self::AlphaNum4 => "AlphaNum4",
            Self::AlphaNum12 => "AlphaNum12",
            Self::Asset => "Asset",
            Self::Price => "Price",
            Self::Liabilities => "Liabilities",
            Self::ThresholdIndexes => "ThresholdIndexes",
            Self::LedgerEntryType => "LedgerEntryType",
            Self::Signer => "Signer",
            Self::AccountFlags => "AccountFlags",
            Self::SponsorshipDescriptor => "SponsorshipDescriptor",
            Self::AccountEntryExtensionV3 => "AccountEntryExtensionV3",
            Self::AccountEntryExtensionV2 => "AccountEntryExtensionV2",
            Self::AccountEntryExtensionV2Ext => "AccountEntryExtensionV2Ext",
            Self::AccountEntryExtensionV1 => "AccountEntryExtensionV1",
            Self::AccountEntryExtensionV1Ext => "AccountEntryExtensionV1Ext",
            Self::AccountEntry => "AccountEntry",
            Self::AccountEntryExt => "AccountEntryExt",
            Self::TrustLineFlags => "TrustLineFlags",
            Self::LiquidityPoolType => "LiquidityPoolType",
            Self::TrustLineAsset => "TrustLineAsset",
            Self::TrustLineEntryExtensionV2 => "TrustLineEntryExtensionV2",
            Self::TrustLineEntryExtensionV2Ext => "TrustLineEntryExtensionV2Ext",
            Self::TrustLineEntry => "TrustLineEntry",
            Self::TrustLineEntryExt => "TrustLineEntryExt",
            Self::TrustLineEntryV1 => "TrustLineEntryV1",
            Self::TrustLineEntryV1Ext => "TrustLineEntryV1Ext",
            Self::OfferEntryFlags => "OfferEntryFlags",
            Self::OfferEntry => "OfferEntry",
            Self::OfferEntryExt => "OfferEntryExt",
            Self::DataEntry => "DataEntry",
            Self::DataEntryExt => "DataEntryExt",
            Self::ClaimPredicateType => "ClaimPredicateType",
            Self::ClaimPredicate => "ClaimPredicate",
            Self::ClaimantType => "ClaimantType",
            Self::Claimant => "Claimant",
            Self::ClaimantV0 => "ClaimantV0",
            Self::ClaimableBalanceIdType => "ClaimableBalanceIdType",
            Self::ClaimableBalanceId => "ClaimableBalanceId",
            Self::ClaimableBalanceFlags => "ClaimableBalanceFlags",
            Self::ClaimableBalanceEntryExtensionV1 => "ClaimableBalanceEntryExtensionV1",
            Self::ClaimableBalanceEntryExtensionV1Ext => "ClaimableBalanceEntryExtensionV1Ext",
            Self::ClaimableBalanceEntry => "ClaimableBalanceEntry",
            Self::ClaimableBalanceEntryExt => "ClaimableBalanceEntryExt",
            Self::LiquidityPoolConstantProductParameters => {
                "LiquidityPoolConstantProductParameters"
            }
            Self::LiquidityPoolEntry => "LiquidityPoolEntry",
            Self::LiquidityPoolEntryBody => "LiquidityPoolEntryBody",
            Self::LiquidityPoolEntryConstantProduct => "LiquidityPoolEntryConstantProduct",
            Self::ContractDataDurability => "ContractDataDurability",
            Self::ContractDataEntry => "ContractDataEntry",
            Self::ContractCodeCostInputs => "ContractCodeCostInputs",
            Self::ContractCodeEntry => "ContractCodeEntry",
            Self::ContractCodeEntryExt => "ContractCodeEntryExt",
            Self::ContractCodeEntryV1 => "ContractCodeEntryV1",
            Self::TtlEntry => "TtlEntry",
            Self::LedgerEntryExtensionV1 => "LedgerEntryExtensionV1",
            Self::LedgerEntryExtensionV1Ext => "LedgerEntryExtensionV1Ext",
            Self::LedgerEntry => "LedgerEntry",
            Self::LedgerEntryData => "LedgerEntryData",
            Self::LedgerEntryExt => "LedgerEntryExt",
            Self::LedgerKey => "LedgerKey",
            Self::LedgerKeyAccount => "LedgerKeyAccount",
            Self::LedgerKeyTrustLine => "LedgerKeyTrustLine",
            Self::LedgerKeyOffer => "LedgerKeyOffer",
            Self::LedgerKeyData => "LedgerKeyData",
            Self::LedgerKeyClaimableBalance => "LedgerKeyClaimableBalance",
            Self::LedgerKeyLiquidityPool => "LedgerKeyLiquidityPool",
            Self::LedgerKeyContractData => "LedgerKeyContractData",
            Self::LedgerKeyContractCode => "LedgerKeyContractCode",
            Self::LedgerKeyConfigSetting => "LedgerKeyConfigSetting",
            Self::LedgerKeyTtl => "LedgerKeyTtl",
            Self::EnvelopeType => "EnvelopeType",
            Self::UpgradeType => "UpgradeType",
            Self::StellarValueType => "StellarValueType",
            Self::LedgerCloseValueSignature => "LedgerCloseValueSignature",
            Self::StellarValue => "StellarValue",
            Self::StellarValueExt => "StellarValueExt",
            Self::LedgerHeaderFlags => "LedgerHeaderFlags",
            Self::LedgerHeaderExtensionV1 => "LedgerHeaderExtensionV1",
            Self::LedgerHeaderExtensionV1Ext => "LedgerHeaderExtensionV1Ext",
            Self::LedgerHeader => "LedgerHeader",
            Self::LedgerHeaderExt => "LedgerHeaderExt",
            Self::LedgerUpgradeType => "LedgerUpgradeType",
            Self::ConfigUpgradeSetKey => "ConfigUpgradeSetKey",
            Self::LedgerUpgrade => "LedgerUpgrade",
            Self::ConfigUpgradeSet => "ConfigUpgradeSet",
            Self::BucketEntryType => "BucketEntryType",
            Self::BucketMetadata => "BucketMetadata",
            Self::BucketMetadataExt => "BucketMetadataExt",
            Self::BucketEntry => "BucketEntry",
            Self::TxSetComponentType => "TxSetComponentType",
            Self::TxSetComponent => "TxSetComponent",
            Self::TxSetComponentTxsMaybeDiscountedFee => "TxSetComponentTxsMaybeDiscountedFee",
            Self::TransactionPhase => "TransactionPhase",
            Self::TransactionSet => "TransactionSet",
            Self::TransactionSetV1 => "TransactionSetV1",
            Self::GeneralizedTransactionSet => "GeneralizedTransactionSet",
            Self::TransactionResultPair => "TransactionResultPair",
            Self::TransactionResultSet => "TransactionResultSet",
            Self::TransactionHistoryEntry => "TransactionHistoryEntry",
            Self::TransactionHistoryEntryExt => "TransactionHistoryEntryExt",
            Self::TransactionHistoryResultEntry => "TransactionHistoryResultEntry",
            Self::TransactionHistoryResultEntryExt => "TransactionHistoryResultEntryExt",
            Self::LedgerHeaderHistoryEntry => "LedgerHeaderHistoryEntry",
            Self::LedgerHeaderHistoryEntryExt => "LedgerHeaderHistoryEntryExt",
            Self::LedgerScpMessages => "LedgerScpMessages",
            Self::ScpHistoryEntryV0 => "ScpHistoryEntryV0",
            Self::ScpHistoryEntry => "ScpHistoryEntry",
            Self::LedgerEntryChangeType => "LedgerEntryChangeType",
            Self::LedgerEntryChange => "LedgerEntryChange",
            Self::LedgerEntryChanges => "LedgerEntryChanges",
            Self::OperationMeta => "OperationMeta",
            Self::TransactionMetaV1 => "TransactionMetaV1",
            Self::TransactionMetaV2 => "TransactionMetaV2",
            Self::ContractEventType => "ContractEventType",
            Self::ContractEvent => "ContractEvent",
            Self::ContractEventBody => "ContractEventBody",
            Self::ContractEventV0 => "ContractEventV0",
            Self::DiagnosticEvent => "DiagnosticEvent",
            Self::SorobanTransactionMetaExtV1 => "SorobanTransactionMetaExtV1",
            Self::SorobanTransactionMetaExt => "SorobanTransactionMetaExt",
            Self::SorobanTransactionMeta => "SorobanTransactionMeta",
            Self::TransactionMetaV3 => "TransactionMetaV3",
            Self::InvokeHostFunctionSuccessPreImage => "InvokeHostFunctionSuccessPreImage",
            Self::TransactionMeta => "TransactionMeta",
            Self::TransactionResultMeta => "TransactionResultMeta",
            Self::UpgradeEntryMeta => "UpgradeEntryMeta",
            Self::LedgerCloseMetaV0 => "LedgerCloseMetaV0",
            Self::LedgerCloseMetaExtV1 => "LedgerCloseMetaExtV1",
            Self::LedgerCloseMetaExt => "LedgerCloseMetaExt",
            Self::LedgerCloseMetaV1 => "LedgerCloseMetaV1",
            Self::LedgerCloseMeta => "LedgerCloseMeta",
            Self::ErrorCode => "ErrorCode",
            Self::SError => "SError",
            Self::SendMore => "SendMore",
            Self::SendMoreExtended => "SendMoreExtended",
            Self::AuthCert => "AuthCert",
            Self::Hello => "Hello",
            Self::Auth => "Auth",
            Self::IpAddrType => "IpAddrType",
            Self::PeerAddress => "PeerAddress",
            Self::PeerAddressIp => "PeerAddressIp",
            Self::MessageType => "MessageType",
            Self::DontHave => "DontHave",
            Self::SurveyMessageCommandType => "SurveyMessageCommandType",
            Self::SurveyMessageResponseType => "SurveyMessageResponseType",
            Self::SurveyRequestMessage => "SurveyRequestMessage",
            Self::SignedSurveyRequestMessage => "SignedSurveyRequestMessage",
            Self::EncryptedBody => "EncryptedBody",
            Self::SurveyResponseMessage => "SurveyResponseMessage",
            Self::SignedSurveyResponseMessage => "SignedSurveyResponseMessage",
            Self::PeerStats => "PeerStats",
            Self::PeerStatList => "PeerStatList",
            Self::TopologyResponseBodyV0 => "TopologyResponseBodyV0",
            Self::TopologyResponseBodyV1 => "TopologyResponseBodyV1",
            Self::SurveyResponseBody => "SurveyResponseBody",
            Self::TxAdvertVector => "TxAdvertVector",
            Self::FloodAdvert => "FloodAdvert",
            Self::TxDemandVector => "TxDemandVector",
            Self::FloodDemand => "FloodDemand",
            Self::StellarMessage => "StellarMessage",
            Self::AuthenticatedMessage => "AuthenticatedMessage",
            Self::AuthenticatedMessageV0 => "AuthenticatedMessageV0",
            Self::LiquidityPoolParameters => "LiquidityPoolParameters",
            Self::MuxedAccount => "MuxedAccount",
            Self::MuxedAccountMed25519 => "MuxedAccountMed25519",
            Self::DecoratedSignature => "DecoratedSignature",
            Self::OperationType => "OperationType",
            Self::CreateAccountOp => "CreateAccountOp",
            Self::PaymentOp => "PaymentOp",
            Self::PathPaymentStrictReceiveOp => "PathPaymentStrictReceiveOp",
            Self::PathPaymentStrictSendOp => "PathPaymentStrictSendOp",
            Self::ManageSellOfferOp => "ManageSellOfferOp",
            Self::ManageBuyOfferOp => "ManageBuyOfferOp",
            Self::CreatePassiveSellOfferOp => "CreatePassiveSellOfferOp",
            Self::SetOptionsOp => "SetOptionsOp",
            Self::ChangeTrustAsset => "ChangeTrustAsset",
            Self::ChangeTrustOp => "ChangeTrustOp",
            Self::AllowTrustOp => "AllowTrustOp",
            Self::ManageDataOp => "ManageDataOp",
            Self::BumpSequenceOp => "BumpSequenceOp",
            Self::CreateClaimableBalanceOp => "CreateClaimableBalanceOp",
            Self::ClaimClaimableBalanceOp => "ClaimClaimableBalanceOp",
            Self::BeginSponsoringFutureReservesOp => "BeginSponsoringFutureReservesOp",
            Self::RevokeSponsorshipType => "RevokeSponsorshipType",
            Self::RevokeSponsorshipOp => "RevokeSponsorshipOp",
            Self::RevokeSponsorshipOpSigner => "RevokeSponsorshipOpSigner",
            Self::ClawbackOp => "ClawbackOp",
            Self::ClawbackClaimableBalanceOp => "ClawbackClaimableBalanceOp",
            Self::SetTrustLineFlagsOp => "SetTrustLineFlagsOp",
            Self::LiquidityPoolDepositOp => "LiquidityPoolDepositOp",
            Self::LiquidityPoolWithdrawOp => "LiquidityPoolWithdrawOp",
            Self::HostFunctionType => "HostFunctionType",
            Self::ContractIdPreimageType => "ContractIdPreimageType",
            Self::ContractIdPreimage => "ContractIdPreimage",
            Self::ContractIdPreimageFromAddress => "ContractIdPreimageFromAddress",
            Self::CreateContractArgs => "CreateContractArgs",
            Self::InvokeContractArgs => "InvokeContractArgs",
            Self::HostFunction => "HostFunction",
            Self::SorobanAuthorizedFunctionType => "SorobanAuthorizedFunctionType",
            Self::SorobanAuthorizedFunction => "SorobanAuthorizedFunction",
            Self::SorobanAuthorizedInvocation => "SorobanAuthorizedInvocation",
            Self::SorobanAddressCredentials => "SorobanAddressCredentials",
            Self::SorobanCredentialsType => "SorobanCredentialsType",
            Self::SorobanCredentials => "SorobanCredentials",
            Self::SorobanAuthorizationEntry => "SorobanAuthorizationEntry",
            Self::InvokeHostFunctionOp => "InvokeHostFunctionOp",
            Self::ExtendFootprintTtlOp => "ExtendFootprintTtlOp",
            Self::RestoreFootprintOp => "RestoreFootprintOp",
            Self::Operation => "Operation",
            Self::OperationBody => "OperationBody",
            Self::HashIdPreimage => "HashIdPreimage",
            Self::HashIdPreimageOperationId => "HashIdPreimageOperationId",
            Self::HashIdPreimageRevokeId => "HashIdPreimageRevokeId",
            Self::HashIdPreimageContractId => "HashIdPreimageContractId",
            Self::HashIdPreimageSorobanAuthorization => "HashIdPreimageSorobanAuthorization",
            Self::MemoType => "MemoType",
            Self::Memo => "Memo",
            Self::TimeBounds => "TimeBounds",
            Self::LedgerBounds => "LedgerBounds",
            Self::PreconditionsV2 => "PreconditionsV2",
            Self::PreconditionType => "PreconditionType",
            Self::Preconditions => "Preconditions",
            Self::LedgerFootprint => "LedgerFootprint",
            Self::SorobanResources => "SorobanResources",
            Self::SorobanTransactionData => "SorobanTransactionData",
            Self::TransactionV0 => "TransactionV0",
            Self::TransactionV0Ext => "TransactionV0Ext",
            Self::TransactionV0Envelope => "TransactionV0Envelope",
            Self::Transaction => "Transaction",
            Self::TransactionExt => "TransactionExt",
            Self::TransactionV1Envelope => "TransactionV1Envelope",
            Self::FeeBumpTransaction => "FeeBumpTransaction",
            Self::FeeBumpTransactionInnerTx => "FeeBumpTransactionInnerTx",
            Self::FeeBumpTransactionExt => "FeeBumpTransactionExt",
            Self::FeeBumpTransactionEnvelope => "FeeBumpTransactionEnvelope",
            Self::TransactionEnvelope => "TransactionEnvelope",
            Self::TransactionSignaturePayload => "TransactionSignaturePayload",
            Self::TransactionSignaturePayloadTaggedTransaction => {
                "TransactionSignaturePayloadTaggedTransaction"
            }
            Self::ClaimAtomType => "ClaimAtomType",
            Self::ClaimOfferAtomV0 => "ClaimOfferAtomV0",
            Self::ClaimOfferAtom => "ClaimOfferAtom",
            Self::ClaimLiquidityAtom => "ClaimLiquidityAtom",
            Self::ClaimAtom => "ClaimAtom",
            Self::CreateAccountResultCode => "CreateAccountResultCode",
            Self::CreateAccountResult => "CreateAccountResult",
            Self::PaymentResultCode => "PaymentResultCode",
            Self::PaymentResult => "PaymentResult",
            Self::PathPaymentStrictReceiveResultCode => "PathPaymentStrictReceiveResultCode",
            Self::SimplePaymentResult => "SimplePaymentResult",
            Self::PathPaymentStrictReceiveResult => "PathPaymentStrictReceiveResult",
            Self::PathPaymentStrictReceiveResultSuccess => "PathPaymentStrictReceiveResultSuccess",
            Self::PathPaymentStrictSendResultCode => "PathPaymentStrictSendResultCode",
            Self::PathPaymentStrictSendResult => "PathPaymentStrictSendResult",
            Self::PathPaymentStrictSendResultSuccess => "PathPaymentStrictSendResultSuccess",
            Self::ManageSellOfferResultCode => "ManageSellOfferResultCode",
            Self::ManageOfferEffect => "ManageOfferEffect",
            Self::ManageOfferSuccessResult => "ManageOfferSuccessResult",
            Self::ManageOfferSuccessResultOffer => "ManageOfferSuccessResultOffer",
            Self::ManageSellOfferResult => "ManageSellOfferResult",
            Self::ManageBuyOfferResultCode => "ManageBuyOfferResultCode",
            Self::ManageBuyOfferResult => "ManageBuyOfferResult",
            Self::SetOptionsResultCode => "SetOptionsResultCode",
            Self::SetOptionsResult => "SetOptionsResult",
            Self::ChangeTrustResultCode => "ChangeTrustResultCode",
            Self::ChangeTrustResult => "ChangeTrustResult",
            Self::AllowTrustResultCode => "AllowTrustResultCode",
            Self::AllowTrustResult => "AllowTrustResult",
            Self::AccountMergeResultCode => "AccountMergeResultCode",
            Self::AccountMergeResult => "AccountMergeResult",
            Self::InflationResultCode => "InflationResultCode",
            Self::InflationPayout => "InflationPayout",
            Self::InflationResult => "InflationResult",
            Self::ManageDataResultCode => "ManageDataResultCode",
            Self::ManageDataResult => "ManageDataResult",
            Self::BumpSequenceResultCode => "BumpSequenceResultCode",
            Self::BumpSequenceResult => "BumpSequenceResult",
            Self::CreateClaimableBalanceResultCode => "CreateClaimableBalanceResultCode",
            Self::CreateClaimableBalanceResult => "CreateClaimableBalanceResult",
            Self::ClaimClaimableBalanceResultCode => "ClaimClaimableBalanceResultCode",
            Self::ClaimClaimableBalanceResult => "ClaimClaimableBalanceResult",
            Self::BeginSponsoringFutureReservesResultCode => {
                "BeginSponsoringFutureReservesResultCode"
            }
            Self::BeginSponsoringFutureReservesResult => "BeginSponsoringFutureReservesResult",
            Self::EndSponsoringFutureReservesResultCode => "EndSponsoringFutureReservesResultCode",
            Self::EndSponsoringFutureReservesResult => "EndSponsoringFutureReservesResult",
            Self::RevokeSponsorshipResultCode => "RevokeSponsorshipResultCode",
            Self::RevokeSponsorshipResult => "RevokeSponsorshipResult",
            Self::ClawbackResultCode => "ClawbackResultCode",
            Self::ClawbackResult => "ClawbackResult",
            Self::ClawbackClaimableBalanceResultCode => "ClawbackClaimableBalanceResultCode",
            Self::ClawbackClaimableBalanceResult => "ClawbackClaimableBalanceResult",
            Self::SetTrustLineFlagsResultCode => "SetTrustLineFlagsResultCode",
            Self::SetTrustLineFlagsResult => "SetTrustLineFlagsResult",
            Self::LiquidityPoolDepositResultCode => "LiquidityPoolDepositResultCode",
            Self::LiquidityPoolDepositResult => "LiquidityPoolDepositResult",
            Self::LiquidityPoolWithdrawResultCode => "LiquidityPoolWithdrawResultCode",
            Self::LiquidityPoolWithdrawResult => "LiquidityPoolWithdrawResult",
            Self::InvokeHostFunctionResultCode => "InvokeHostFunctionResultCode",
            Self::InvokeHostFunctionResult => "InvokeHostFunctionResult",
            Self::ExtendFootprintTtlResultCode => "ExtendFootprintTtlResultCode",
            Self::ExtendFootprintTtlResult => "ExtendFootprintTtlResult",
            Self::RestoreFootprintResultCode => "RestoreFootprintResultCode",
            Self::RestoreFootprintResult => "RestoreFootprintResult",
            Self::OperationResultCode => "OperationResultCode",
            Self::OperationResult => "OperationResult",
            Self::OperationResultTr => "OperationResultTr",
            Self::TransactionResultCode => "TransactionResultCode",
            Self::InnerTransactionResult => "InnerTransactionResult",
            Self::InnerTransactionResultResult => "InnerTransactionResultResult",
            Self::InnerTransactionResultExt => "InnerTransactionResultExt",
            Self::InnerTransactionResultPair => "InnerTransactionResultPair",
            Self::TransactionResult => "TransactionResult",
            Self::TransactionResultResult => "TransactionResultResult",
            Self::TransactionResultExt => "TransactionResultExt",
            Self::Hash => "Hash",
            Self::Uint256 => "Uint256",
            Self::Uint32 => "Uint32",
            Self::Int32 => "Int32",
            Self::Uint64 => "Uint64",
            Self::Int64 => "Int64",
            Self::TimePoint => "TimePoint",
            Self::Duration => "Duration",
            Self::ExtensionPoint => "ExtensionPoint",
            Self::CryptoKeyType => "CryptoKeyType",
            Self::PublicKeyType => "PublicKeyType",
            Self::SignerKeyType => "SignerKeyType",
            Self::PublicKey => "PublicKey",
            Self::SignerKey => "SignerKey",
            Self::SignerKeyEd25519SignedPayload => "SignerKeyEd25519SignedPayload",
            Self::Signature => "Signature",
            Self::SignatureHint => "SignatureHint",
            Self::NodeId => "NodeId",
            Self::AccountId => "AccountId",
            Self::Curve25519Secret => "Curve25519Secret",
            Self::Curve25519Public => "Curve25519Public",
            Self::HmacSha256Key => "HmacSha256Key",
            Self::HmacSha256Mac => "HmacSha256Mac",
        }
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn variants() -> [TypeVariant; 425] {
        Self::VARIANTS
    }
}

impl Name for TypeVariant {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TypeVariant> for TypeVariant {
    fn variants() -> slice::Iter<'static, TypeVariant> {
        Self::VARIANTS.iter()
    }
}

impl core::str::FromStr for TypeVariant {
    type Err = Error;
    #[allow(clippy::too_many_lines)]
    fn from_str(s: &str) -> Result<Self> {
        match s {
            "Value" => Ok(Self::Value),
            "ScpBallot" => Ok(Self::ScpBallot),
            "ScpStatementType" => Ok(Self::ScpStatementType),
            "ScpNomination" => Ok(Self::ScpNomination),
            "ScpStatement" => Ok(Self::ScpStatement),
            "ScpStatementPledges" => Ok(Self::ScpStatementPledges),
            "ScpStatementPrepare" => Ok(Self::ScpStatementPrepare),
            "ScpStatementConfirm" => Ok(Self::ScpStatementConfirm),
            "ScpStatementExternalize" => Ok(Self::ScpStatementExternalize),
            "ScpEnvelope" => Ok(Self::ScpEnvelope),
            "ScpQuorumSet" => Ok(Self::ScpQuorumSet),
            "ConfigSettingContractExecutionLanesV0" => {
                Ok(Self::ConfigSettingContractExecutionLanesV0)
            }
            "ConfigSettingContractComputeV0" => Ok(Self::ConfigSettingContractComputeV0),
            "ConfigSettingContractLedgerCostV0" => Ok(Self::ConfigSettingContractLedgerCostV0),
            "ConfigSettingContractHistoricalDataV0" => {
                Ok(Self::ConfigSettingContractHistoricalDataV0)
            }
            "ConfigSettingContractEventsV0" => Ok(Self::ConfigSettingContractEventsV0),
            "ConfigSettingContractBandwidthV0" => Ok(Self::ConfigSettingContractBandwidthV0),
            "ContractCostType" => Ok(Self::ContractCostType),
            "ContractCostParamEntry" => Ok(Self::ContractCostParamEntry),
            "StateArchivalSettings" => Ok(Self::StateArchivalSettings),
            "EvictionIterator" => Ok(Self::EvictionIterator),
            "ContractCostParams" => Ok(Self::ContractCostParams),
            "ConfigSettingId" => Ok(Self::ConfigSettingId),
            "ConfigSettingEntry" => Ok(Self::ConfigSettingEntry),
            "ScEnvMetaKind" => Ok(Self::ScEnvMetaKind),
            "ScEnvMetaEntry" => Ok(Self::ScEnvMetaEntry),
            "ScMetaV0" => Ok(Self::ScMetaV0),
            "ScMetaKind" => Ok(Self::ScMetaKind),
            "ScMetaEntry" => Ok(Self::ScMetaEntry),
            "ScSpecType" => Ok(Self::ScSpecType),
            "ScSpecTypeOption" => Ok(Self::ScSpecTypeOption),
            "ScSpecTypeResult" => Ok(Self::ScSpecTypeResult),
            "ScSpecTypeVec" => Ok(Self::ScSpecTypeVec),
            "ScSpecTypeMap" => Ok(Self::ScSpecTypeMap),
            "ScSpecTypeTuple" => Ok(Self::ScSpecTypeTuple),
            "ScSpecTypeBytesN" => Ok(Self::ScSpecTypeBytesN),
            "ScSpecTypeUdt" => Ok(Self::ScSpecTypeUdt),
            "ScSpecTypeDef" => Ok(Self::ScSpecTypeDef),
            "ScSpecUdtStructFieldV0" => Ok(Self::ScSpecUdtStructFieldV0),
            "ScSpecUdtStructV0" => Ok(Self::ScSpecUdtStructV0),
            "ScSpecUdtUnionCaseVoidV0" => Ok(Self::ScSpecUdtUnionCaseVoidV0),
            "ScSpecUdtUnionCaseTupleV0" => Ok(Self::ScSpecUdtUnionCaseTupleV0),
            "ScSpecUdtUnionCaseV0Kind" => Ok(Self::ScSpecUdtUnionCaseV0Kind),
            "ScSpecUdtUnionCaseV0" => Ok(Self::ScSpecUdtUnionCaseV0),
            "ScSpecUdtUnionV0" => Ok(Self::ScSpecUdtUnionV0),
            "ScSpecUdtEnumCaseV0" => Ok(Self::ScSpecUdtEnumCaseV0),
            "ScSpecUdtEnumV0" => Ok(Self::ScSpecUdtEnumV0),
            "ScSpecUdtErrorEnumCaseV0" => Ok(Self::ScSpecUdtErrorEnumCaseV0),
            "ScSpecUdtErrorEnumV0" => Ok(Self::ScSpecUdtErrorEnumV0),
            "ScSpecFunctionInputV0" => Ok(Self::ScSpecFunctionInputV0),
            "ScSpecFunctionV0" => Ok(Self::ScSpecFunctionV0),
            "ScSpecEntryKind" => Ok(Self::ScSpecEntryKind),
            "ScSpecEntry" => Ok(Self::ScSpecEntry),
            "ScValType" => Ok(Self::ScValType),
            "ScErrorType" => Ok(Self::ScErrorType),
            "ScErrorCode" => Ok(Self::ScErrorCode),
            "ScError" => Ok(Self::ScError),
            "UInt128Parts" => Ok(Self::UInt128Parts),
            "Int128Parts" => Ok(Self::Int128Parts),
            "UInt256Parts" => Ok(Self::UInt256Parts),
            "Int256Parts" => Ok(Self::Int256Parts),
            "ContractExecutableType" => Ok(Self::ContractExecutableType),
            "ContractExecutable" => Ok(Self::ContractExecutable),
            "ScAddressType" => Ok(Self::ScAddressType),
            "ScAddress" => Ok(Self::ScAddress),
            "ScVec" => Ok(Self::ScVec),
            "ScMap" => Ok(Self::ScMap),
            "ScBytes" => Ok(Self::ScBytes),
            "ScString" => Ok(Self::ScString),
            "ScSymbol" => Ok(Self::ScSymbol),
            "ScNonceKey" => Ok(Self::ScNonceKey),
            "ScContractInstance" => Ok(Self::ScContractInstance),
            "ScVal" => Ok(Self::ScVal),
            "ScMapEntry" => Ok(Self::ScMapEntry),
            "StoredTransactionSet" => Ok(Self::StoredTransactionSet),
            "StoredDebugTransactionSet" => Ok(Self::StoredDebugTransactionSet),
            "PersistedScpStateV0" => Ok(Self::PersistedScpStateV0),
            "PersistedScpStateV1" => Ok(Self::PersistedScpStateV1),
            "PersistedScpState" => Ok(Self::PersistedScpState),
            "Thresholds" => Ok(Self::Thresholds),
            "String32" => Ok(Self::String32),
            "String64" => Ok(Self::String64),
            "SequenceNumber" => Ok(Self::SequenceNumber),
            "DataValue" => Ok(Self::DataValue),
            "PoolId" => Ok(Self::PoolId),
            "AssetCode4" => Ok(Self::AssetCode4),
            "AssetCode12" => Ok(Self::AssetCode12),
            "AssetType" => Ok(Self::AssetType),
            "AssetCode" => Ok(Self::AssetCode),
            "AlphaNum4" => Ok(Self::AlphaNum4),
            "AlphaNum12" => Ok(Self::AlphaNum12),
            "Asset" => Ok(Self::Asset),
            "Price" => Ok(Self::Price),
            "Liabilities" => Ok(Self::Liabilities),
            "ThresholdIndexes" => Ok(Self::ThresholdIndexes),
            "LedgerEntryType" => Ok(Self::LedgerEntryType),
            "Signer" => Ok(Self::Signer),
            "AccountFlags" => Ok(Self::AccountFlags),
            "SponsorshipDescriptor" => Ok(Self::SponsorshipDescriptor),
            "AccountEntryExtensionV3" => Ok(Self::AccountEntryExtensionV3),
            "AccountEntryExtensionV2" => Ok(Self::AccountEntryExtensionV2),
            "AccountEntryExtensionV2Ext" => Ok(Self::AccountEntryExtensionV2Ext),
            "AccountEntryExtensionV1" => Ok(Self::AccountEntryExtensionV1),
            "AccountEntryExtensionV1Ext" => Ok(Self::AccountEntryExtensionV1Ext),
            "AccountEntry" => Ok(Self::AccountEntry),
            "AccountEntryExt" => Ok(Self::AccountEntryExt),
            "TrustLineFlags" => Ok(Self::TrustLineFlags),
            "LiquidityPoolType" => Ok(Self::LiquidityPoolType),
            "TrustLineAsset" => Ok(Self::TrustLineAsset),
            "TrustLineEntryExtensionV2" => Ok(Self::TrustLineEntryExtensionV2),
            "TrustLineEntryExtensionV2Ext" => Ok(Self::TrustLineEntryExtensionV2Ext),
            "TrustLineEntry" => Ok(Self::TrustLineEntry),
            "TrustLineEntryExt" => Ok(Self::TrustLineEntryExt),
            "TrustLineEntryV1" => Ok(Self::TrustLineEntryV1),
            "TrustLineEntryV1Ext" => Ok(Self::TrustLineEntryV1Ext),
            "OfferEntryFlags" => Ok(Self::OfferEntryFlags),
            "OfferEntry" => Ok(Self::OfferEntry),
            "OfferEntryExt" => Ok(Self::OfferEntryExt),
            "DataEntry" => Ok(Self::DataEntry),
            "DataEntryExt" => Ok(Self::DataEntryExt),
            "ClaimPredicateType" => Ok(Self::ClaimPredicateType),
            "ClaimPredicate" => Ok(Self::ClaimPredicate),
            "ClaimantType" => Ok(Self::ClaimantType),
            "Claimant" => Ok(Self::Claimant),
            "ClaimantV0" => Ok(Self::ClaimantV0),
            "ClaimableBalanceIdType" => Ok(Self::ClaimableBalanceIdType),
            "ClaimableBalanceId" => Ok(Self::ClaimableBalanceId),
            "ClaimableBalanceFlags" => Ok(Self::ClaimableBalanceFlags),
            "ClaimableBalanceEntryExtensionV1" => Ok(Self::ClaimableBalanceEntryExtensionV1),
            "ClaimableBalanceEntryExtensionV1Ext" => Ok(Self::ClaimableBalanceEntryExtensionV1Ext),
            "ClaimableBalanceEntry" => Ok(Self::ClaimableBalanceEntry),
            "ClaimableBalanceEntryExt" => Ok(Self::ClaimableBalanceEntryExt),
            "LiquidityPoolConstantProductParameters" => {
                Ok(Self::LiquidityPoolConstantProductParameters)
            }
            "LiquidityPoolEntry" => Ok(Self::LiquidityPoolEntry),
            "LiquidityPoolEntryBody" => Ok(Self::LiquidityPoolEntryBody),
            "LiquidityPoolEntryConstantProduct" => Ok(Self::LiquidityPoolEntryConstantProduct),
            "ContractDataDurability" => Ok(Self::ContractDataDurability),
            "ContractDataEntry" => Ok(Self::ContractDataEntry),
            "ContractCodeCostInputs" => Ok(Self::ContractCodeCostInputs),
            "ContractCodeEntry" => Ok(Self::ContractCodeEntry),
            "ContractCodeEntryExt" => Ok(Self::ContractCodeEntryExt),
            "ContractCodeEntryV1" => Ok(Self::ContractCodeEntryV1),
            "TtlEntry" => Ok(Self::TtlEntry),
            "LedgerEntryExtensionV1" => Ok(Self::LedgerEntryExtensionV1),
            "LedgerEntryExtensionV1Ext" => Ok(Self::LedgerEntryExtensionV1Ext),
            "LedgerEntry" => Ok(Self::LedgerEntry),
            "LedgerEntryData" => Ok(Self::LedgerEntryData),
            "LedgerEntryExt" => Ok(Self::LedgerEntryExt),
            "LedgerKey" => Ok(Self::LedgerKey),
            "LedgerKeyAccount" => Ok(Self::LedgerKeyAccount),
            "LedgerKeyTrustLine" => Ok(Self::LedgerKeyTrustLine),
            "LedgerKeyOffer" => Ok(Self::LedgerKeyOffer),
            "LedgerKeyData" => Ok(Self::LedgerKeyData),
            "LedgerKeyClaimableBalance" => Ok(Self::LedgerKeyClaimableBalance),
            "LedgerKeyLiquidityPool" => Ok(Self::LedgerKeyLiquidityPool),
            "LedgerKeyContractData" => Ok(Self::LedgerKeyContractData),
            "LedgerKeyContractCode" => Ok(Self::LedgerKeyContractCode),
            "LedgerKeyConfigSetting" => Ok(Self::LedgerKeyConfigSetting),
            "LedgerKeyTtl" => Ok(Self::LedgerKeyTtl),
            "EnvelopeType" => Ok(Self::EnvelopeType),
            "UpgradeType" => Ok(Self::UpgradeType),
            "StellarValueType" => Ok(Self::StellarValueType),
            "LedgerCloseValueSignature" => Ok(Self::LedgerCloseValueSignature),
            "StellarValue" => Ok(Self::StellarValue),
            "StellarValueExt" => Ok(Self::StellarValueExt),
            "LedgerHeaderFlags" => Ok(Self::LedgerHeaderFlags),
            "LedgerHeaderExtensionV1" => Ok(Self::LedgerHeaderExtensionV1),
            "LedgerHeaderExtensionV1Ext" => Ok(Self::LedgerHeaderExtensionV1Ext),
            "LedgerHeader" => Ok(Self::LedgerHeader),
            "LedgerHeaderExt" => Ok(Self::LedgerHeaderExt),
            "LedgerUpgradeType" => Ok(Self::LedgerUpgradeType),
            "ConfigUpgradeSetKey" => Ok(Self::ConfigUpgradeSetKey),
            "LedgerUpgrade" => Ok(Self::LedgerUpgrade),
            "ConfigUpgradeSet" => Ok(Self::ConfigUpgradeSet),
            "BucketEntryType" => Ok(Self::BucketEntryType),
            "BucketMetadata" => Ok(Self::BucketMetadata),
            "BucketMetadataExt" => Ok(Self::BucketMetadataExt),
            "BucketEntry" => Ok(Self::BucketEntry),
            "TxSetComponentType" => Ok(Self::TxSetComponentType),
            "TxSetComponent" => Ok(Self::TxSetComponent),
            "TxSetComponentTxsMaybeDiscountedFee" => Ok(Self::TxSetComponentTxsMaybeDiscountedFee),
            "TransactionPhase" => Ok(Self::TransactionPhase),
            "TransactionSet" => Ok(Self::TransactionSet),
            "TransactionSetV1" => Ok(Self::TransactionSetV1),
            "GeneralizedTransactionSet" => Ok(Self::GeneralizedTransactionSet),
            "TransactionResultPair" => Ok(Self::TransactionResultPair),
            "TransactionResultSet" => Ok(Self::TransactionResultSet),
            "TransactionHistoryEntry" => Ok(Self::TransactionHistoryEntry),
            "TransactionHistoryEntryExt" => Ok(Self::TransactionHistoryEntryExt),
            "TransactionHistoryResultEntry" => Ok(Self::TransactionHistoryResultEntry),
            "TransactionHistoryResultEntryExt" => Ok(Self::TransactionHistoryResultEntryExt),
            "LedgerHeaderHistoryEntry" => Ok(Self::LedgerHeaderHistoryEntry),
            "LedgerHeaderHistoryEntryExt" => Ok(Self::LedgerHeaderHistoryEntryExt),
            "LedgerScpMessages" => Ok(Self::LedgerScpMessages),
            "ScpHistoryEntryV0" => Ok(Self::ScpHistoryEntryV0),
            "ScpHistoryEntry" => Ok(Self::ScpHistoryEntry),
            "LedgerEntryChangeType" => Ok(Self::LedgerEntryChangeType),
            "LedgerEntryChange" => Ok(Self::LedgerEntryChange),
            "LedgerEntryChanges" => Ok(Self::LedgerEntryChanges),
            "OperationMeta" => Ok(Self::OperationMeta),
            "TransactionMetaV1" => Ok(Self::TransactionMetaV1),
            "TransactionMetaV2" => Ok(Self::TransactionMetaV2),
            "ContractEventType" => Ok(Self::ContractEventType),
            "ContractEvent" => Ok(Self::ContractEvent),
            "ContractEventBody" => Ok(Self::ContractEventBody),
            "ContractEventV0" => Ok(Self::ContractEventV0),
            "DiagnosticEvent" => Ok(Self::DiagnosticEvent),
            "SorobanTransactionMetaExtV1" => Ok(Self::SorobanTransactionMetaExtV1),
            "SorobanTransactionMetaExt" => Ok(Self::SorobanTransactionMetaExt),
            "SorobanTransactionMeta" => Ok(Self::SorobanTransactionMeta),
            "TransactionMetaV3" => Ok(Self::TransactionMetaV3),
            "InvokeHostFunctionSuccessPreImage" => Ok(Self::InvokeHostFunctionSuccessPreImage),
            "TransactionMeta" => Ok(Self::TransactionMeta),
            "TransactionResultMeta" => Ok(Self::TransactionResultMeta),
            "UpgradeEntryMeta" => Ok(Self::UpgradeEntryMeta),
            "LedgerCloseMetaV0" => Ok(Self::LedgerCloseMetaV0),
            "LedgerCloseMetaExtV1" => Ok(Self::LedgerCloseMetaExtV1),
            "LedgerCloseMetaExt" => Ok(Self::LedgerCloseMetaExt),
            "LedgerCloseMetaV1" => Ok(Self::LedgerCloseMetaV1),
            "LedgerCloseMeta" => Ok(Self::LedgerCloseMeta),
            "ErrorCode" => Ok(Self::ErrorCode),
            "SError" => Ok(Self::SError),
            "SendMore" => Ok(Self::SendMore),
            "SendMoreExtended" => Ok(Self::SendMoreExtended),
            "AuthCert" => Ok(Self::AuthCert),
            "Hello" => Ok(Self::Hello),
            "Auth" => Ok(Self::Auth),
            "IpAddrType" => Ok(Self::IpAddrType),
            "PeerAddress" => Ok(Self::PeerAddress),
            "PeerAddressIp" => Ok(Self::PeerAddressIp),
            "MessageType" => Ok(Self::MessageType),
            "DontHave" => Ok(Self::DontHave),
            "SurveyMessageCommandType" => Ok(Self::SurveyMessageCommandType),
            "SurveyMessageResponseType" => Ok(Self::SurveyMessageResponseType),
            "SurveyRequestMessage" => Ok(Self::SurveyRequestMessage),
            "SignedSurveyRequestMessage" => Ok(Self::SignedSurveyRequestMessage),
            "EncryptedBody" => Ok(Self::EncryptedBody),
            "SurveyResponseMessage" => Ok(Self::SurveyResponseMessage),
            "SignedSurveyResponseMessage" => Ok(Self::SignedSurveyResponseMessage),
            "PeerStats" => Ok(Self::PeerStats),
            "PeerStatList" => Ok(Self::PeerStatList),
            "TopologyResponseBodyV0" => Ok(Self::TopologyResponseBodyV0),
            "TopologyResponseBodyV1" => Ok(Self::TopologyResponseBodyV1),
            "SurveyResponseBody" => Ok(Self::SurveyResponseBody),
            "TxAdvertVector" => Ok(Self::TxAdvertVector),
            "FloodAdvert" => Ok(Self::FloodAdvert),
            "TxDemandVector" => Ok(Self::TxDemandVector),
            "FloodDemand" => Ok(Self::FloodDemand),
            "StellarMessage" => Ok(Self::StellarMessage),
            "AuthenticatedMessage" => Ok(Self::AuthenticatedMessage),
            "AuthenticatedMessageV0" => Ok(Self::AuthenticatedMessageV0),
            "LiquidityPoolParameters" => Ok(Self::LiquidityPoolParameters),
            "MuxedAccount" => Ok(Self::MuxedAccount),
            "MuxedAccountMed25519" => Ok(Self::MuxedAccountMed25519),
            "DecoratedSignature" => Ok(Self::DecoratedSignature),
            "OperationType" => Ok(Self::OperationType),
            "CreateAccountOp" => Ok(Self::CreateAccountOp),
            "PaymentOp" => Ok(Self::PaymentOp),
            "PathPaymentStrictReceiveOp" => Ok(Self::PathPaymentStrictReceiveOp),
            "PathPaymentStrictSendOp" => Ok(Self::PathPaymentStrictSendOp),
            "ManageSellOfferOp" => Ok(Self::ManageSellOfferOp),
            "ManageBuyOfferOp" => Ok(Self::ManageBuyOfferOp),
            "CreatePassiveSellOfferOp" => Ok(Self::CreatePassiveSellOfferOp),
            "SetOptionsOp" => Ok(Self::SetOptionsOp),
            "ChangeTrustAsset" => Ok(Self::ChangeTrustAsset),
            "ChangeTrustOp" => Ok(Self::ChangeTrustOp),
            "AllowTrustOp" => Ok(Self::AllowTrustOp),
            "ManageDataOp" => Ok(Self::ManageDataOp),
            "BumpSequenceOp" => Ok(Self::BumpSequenceOp),
            "CreateClaimableBalanceOp" => Ok(Self::CreateClaimableBalanceOp),
            "ClaimClaimableBalanceOp" => Ok(Self::ClaimClaimableBalanceOp),
            "BeginSponsoringFutureReservesOp" => Ok(Self::BeginSponsoringFutureReservesOp),
            "RevokeSponsorshipType" => Ok(Self::RevokeSponsorshipType),
            "RevokeSponsorshipOp" => Ok(Self::RevokeSponsorshipOp),
            "RevokeSponsorshipOpSigner" => Ok(Self::RevokeSponsorshipOpSigner),
            "ClawbackOp" => Ok(Self::ClawbackOp),
            "ClawbackClaimableBalanceOp" => Ok(Self::ClawbackClaimableBalanceOp),
            "SetTrustLineFlagsOp" => Ok(Self::SetTrustLineFlagsOp),
            "LiquidityPoolDepositOp" => Ok(Self::LiquidityPoolDepositOp),
            "LiquidityPoolWithdrawOp" => Ok(Self::LiquidityPoolWithdrawOp),
            "HostFunctionType" => Ok(Self::HostFunctionType),
            "ContractIdPreimageType" => Ok(Self::ContractIdPreimageType),
            "ContractIdPreimage" => Ok(Self::ContractIdPreimage),
            "ContractIdPreimageFromAddress" => Ok(Self::ContractIdPreimageFromAddress),
            "CreateContractArgs" => Ok(Self::CreateContractArgs),
            "InvokeContractArgs" => Ok(Self::InvokeContractArgs),
            "HostFunction" => Ok(Self::HostFunction),
            "SorobanAuthorizedFunctionType" => Ok(Self::SorobanAuthorizedFunctionType),
            "SorobanAuthorizedFunction" => Ok(Self::SorobanAuthorizedFunction),
            "SorobanAuthorizedInvocation" => Ok(Self::SorobanAuthorizedInvocation),
            "SorobanAddressCredentials" => Ok(Self::SorobanAddressCredentials),
            "SorobanCredentialsType" => Ok(Self::SorobanCredentialsType),
            "SorobanCredentials" => Ok(Self::SorobanCredentials),
            "SorobanAuthorizationEntry" => Ok(Self::SorobanAuthorizationEntry),
            "InvokeHostFunctionOp" => Ok(Self::InvokeHostFunctionOp),
            "ExtendFootprintTtlOp" => Ok(Self::ExtendFootprintTtlOp),
            "RestoreFootprintOp" => Ok(Self::RestoreFootprintOp),
            "Operation" => Ok(Self::Operation),
            "OperationBody" => Ok(Self::OperationBody),
            "HashIdPreimage" => Ok(Self::HashIdPreimage),
            "HashIdPreimageOperationId" => Ok(Self::HashIdPreimageOperationId),
            "HashIdPreimageRevokeId" => Ok(Self::HashIdPreimageRevokeId),
            "HashIdPreimageContractId" => Ok(Self::HashIdPreimageContractId),
            "HashIdPreimageSorobanAuthorization" => Ok(Self::HashIdPreimageSorobanAuthorization),
            "MemoType" => Ok(Self::MemoType),
            "Memo" => Ok(Self::Memo),
            "TimeBounds" => Ok(Self::TimeBounds),
            "LedgerBounds" => Ok(Self::LedgerBounds),
            "PreconditionsV2" => Ok(Self::PreconditionsV2),
            "PreconditionType" => Ok(Self::PreconditionType),
            "Preconditions" => Ok(Self::Preconditions),
            "LedgerFootprint" => Ok(Self::LedgerFootprint),
            "SorobanResources" => Ok(Self::SorobanResources),
            "SorobanTransactionData" => Ok(Self::SorobanTransactionData),
            "TransactionV0" => Ok(Self::TransactionV0),
            "TransactionV0Ext" => Ok(Self::TransactionV0Ext),
            "TransactionV0Envelope" => Ok(Self::TransactionV0Envelope),
            "Transaction" => Ok(Self::Transaction),
            "TransactionExt" => Ok(Self::TransactionExt),
            "TransactionV1Envelope" => Ok(Self::TransactionV1Envelope),
            "FeeBumpTransaction" => Ok(Self::FeeBumpTransaction),
            "FeeBumpTransactionInnerTx" => Ok(Self::FeeBumpTransactionInnerTx),
            "FeeBumpTransactionExt" => Ok(Self::FeeBumpTransactionExt),
            "FeeBumpTransactionEnvelope" => Ok(Self::FeeBumpTransactionEnvelope),
            "TransactionEnvelope" => Ok(Self::TransactionEnvelope),
            "TransactionSignaturePayload" => Ok(Self::TransactionSignaturePayload),
            "TransactionSignaturePayloadTaggedTransaction" => {
                Ok(Self::TransactionSignaturePayloadTaggedTransaction)
            }
            "ClaimAtomType" => Ok(Self::ClaimAtomType),
            "ClaimOfferAtomV0" => Ok(Self::ClaimOfferAtomV0),
            "ClaimOfferAtom" => Ok(Self::ClaimOfferAtom),
            "ClaimLiquidityAtom" => Ok(Self::ClaimLiquidityAtom),
            "ClaimAtom" => Ok(Self::ClaimAtom),
            "CreateAccountResultCode" => Ok(Self::CreateAccountResultCode),
            "CreateAccountResult" => Ok(Self::CreateAccountResult),
            "PaymentResultCode" => Ok(Self::PaymentResultCode),
            "PaymentResult" => Ok(Self::PaymentResult),
            "PathPaymentStrictReceiveResultCode" => Ok(Self::PathPaymentStrictReceiveResultCode),
            "SimplePaymentResult" => Ok(Self::SimplePaymentResult),
            "PathPaymentStrictReceiveResult" => Ok(Self::PathPaymentStrictReceiveResult),
            "PathPaymentStrictReceiveResultSuccess" => {
                Ok(Self::PathPaymentStrictReceiveResultSuccess)
            }
            "PathPaymentStrictSendResultCode" => Ok(Self::PathPaymentStrictSendResultCode),
            "PathPaymentStrictSendResult" => Ok(Self::PathPaymentStrictSendResult),
            "PathPaymentStrictSendResultSuccess" => Ok(Self::PathPaymentStrictSendResultSuccess),
            "ManageSellOfferResultCode" => Ok(Self::ManageSellOfferResultCode),
            "ManageOfferEffect" => Ok(Self::ManageOfferEffect),
            "ManageOfferSuccessResult" => Ok(Self::ManageOfferSuccessResult),
            "ManageOfferSuccessResultOffer" => Ok(Self::ManageOfferSuccessResultOffer),
            "ManageSellOfferResult" => Ok(Self::ManageSellOfferResult),
            "ManageBuyOfferResultCode" => Ok(Self::ManageBuyOfferResultCode),
            "ManageBuyOfferResult" => Ok(Self::ManageBuyOfferResult),
            "SetOptionsResultCode" => Ok(Self::SetOptionsResultCode),
            "SetOptionsResult" => Ok(Self::SetOptionsResult),
            "ChangeTrustResultCode" => Ok(Self::ChangeTrustResultCode),
            "ChangeTrustResult" => Ok(Self::ChangeTrustResult),
            "AllowTrustResultCode" => Ok(Self::AllowTrustResultCode),
            "AllowTrustResult" => Ok(Self::AllowTrustResult),
            "AccountMergeResultCode" => Ok(Self::AccountMergeResultCode),
            "AccountMergeResult" => Ok(Self::AccountMergeResult),
            "InflationResultCode" => Ok(Self::InflationResultCode),
            "InflationPayout" => Ok(Self::InflationPayout),
            "InflationResult" => Ok(Self::InflationResult),
            "ManageDataResultCode" => Ok(Self::ManageDataResultCode),
            "ManageDataResult" => Ok(Self::ManageDataResult),
            "BumpSequenceResultCode" => Ok(Self::BumpSequenceResultCode),
            "BumpSequenceResult" => Ok(Self::BumpSequenceResult),
            "CreateClaimableBalanceResultCode" => Ok(Self::CreateClaimableBalanceResultCode),
            "CreateClaimableBalanceResult" => Ok(Self::CreateClaimableBalanceResult),
            "ClaimClaimableBalanceResultCode" => Ok(Self::ClaimClaimableBalanceResultCode),
            "ClaimClaimableBalanceResult" => Ok(Self::ClaimClaimableBalanceResult),
            "BeginSponsoringFutureReservesResultCode" => {
                Ok(Self::BeginSponsoringFutureReservesResultCode)
            }
            "BeginSponsoringFutureReservesResult" => Ok(Self::BeginSponsoringFutureReservesResult),
            "EndSponsoringFutureReservesResultCode" => {
                Ok(Self::EndSponsoringFutureReservesResultCode)
            }
            "EndSponsoringFutureReservesResult" => Ok(Self::EndSponsoringFutureReservesResult),
            "RevokeSponsorshipResultCode" => Ok(Self::RevokeSponsorshipResultCode),
            "RevokeSponsorshipResult" => Ok(Self::RevokeSponsorshipResult),
            "ClawbackResultCode" => Ok(Self::ClawbackResultCode),
            "ClawbackResult" => Ok(Self::ClawbackResult),
            "ClawbackClaimableBalanceResultCode" => Ok(Self::ClawbackClaimableBalanceResultCode),
            "ClawbackClaimableBalanceResult" => Ok(Self::ClawbackClaimableBalanceResult),
            "SetTrustLineFlagsResultCode" => Ok(Self::SetTrustLineFlagsResultCode),
            "SetTrustLineFlagsResult" => Ok(Self::SetTrustLineFlagsResult),
            "LiquidityPoolDepositResultCode" => Ok(Self::LiquidityPoolDepositResultCode),
            "LiquidityPoolDepositResult" => Ok(Self::LiquidityPoolDepositResult),
            "LiquidityPoolWithdrawResultCode" => Ok(Self::LiquidityPoolWithdrawResultCode),
            "LiquidityPoolWithdrawResult" => Ok(Self::LiquidityPoolWithdrawResult),
            "InvokeHostFunctionResultCode" => Ok(Self::InvokeHostFunctionResultCode),
            "InvokeHostFunctionResult" => Ok(Self::InvokeHostFunctionResult),
            "ExtendFootprintTtlResultCode" => Ok(Self::ExtendFootprintTtlResultCode),
            "ExtendFootprintTtlResult" => Ok(Self::ExtendFootprintTtlResult),
            "RestoreFootprintResultCode" => Ok(Self::RestoreFootprintResultCode),
            "RestoreFootprintResult" => Ok(Self::RestoreFootprintResult),
            "OperationResultCode" => Ok(Self::OperationResultCode),
            "OperationResult" => Ok(Self::OperationResult),
            "OperationResultTr" => Ok(Self::OperationResultTr),
            "TransactionResultCode" => Ok(Self::TransactionResultCode),
            "InnerTransactionResult" => Ok(Self::InnerTransactionResult),
            "InnerTransactionResultResult" => Ok(Self::InnerTransactionResultResult),
            "InnerTransactionResultExt" => Ok(Self::InnerTransactionResultExt),
            "InnerTransactionResultPair" => Ok(Self::InnerTransactionResultPair),
            "TransactionResult" => Ok(Self::TransactionResult),
            "TransactionResultResult" => Ok(Self::TransactionResultResult),
            "TransactionResultExt" => Ok(Self::TransactionResultExt),
            "Hash" => Ok(Self::Hash),
            "Uint256" => Ok(Self::Uint256),
            "Uint32" => Ok(Self::Uint32),
            "Int32" => Ok(Self::Int32),
            "Uint64" => Ok(Self::Uint64),
            "Int64" => Ok(Self::Int64),
            "TimePoint" => Ok(Self::TimePoint),
            "Duration" => Ok(Self::Duration),
            "ExtensionPoint" => Ok(Self::ExtensionPoint),
            "CryptoKeyType" => Ok(Self::CryptoKeyType),
            "PublicKeyType" => Ok(Self::PublicKeyType),
            "SignerKeyType" => Ok(Self::SignerKeyType),
            "PublicKey" => Ok(Self::PublicKey),
            "SignerKey" => Ok(Self::SignerKey),
            "SignerKeyEd25519SignedPayload" => Ok(Self::SignerKeyEd25519SignedPayload),
            "Signature" => Ok(Self::Signature),
            "SignatureHint" => Ok(Self::SignatureHint),
            "NodeId" => Ok(Self::NodeId),
            "AccountId" => Ok(Self::AccountId),
            "Curve25519Secret" => Ok(Self::Curve25519Secret),
            "Curve25519Public" => Ok(Self::Curve25519Public),
            "HmacSha256Key" => Ok(Self::HmacSha256Key),
            "HmacSha256Mac" => Ok(Self::HmacSha256Mac),
            _ => Err(Error::Invalid),
        }
    }
}

#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case"),
    serde(untagged)
)]
pub enum Type {
    Value(Box<Value>),
    ScpBallot(Box<ScpBallot>),
    ScpStatementType(Box<ScpStatementType>),
    ScpNomination(Box<ScpNomination>),
    ScpStatement(Box<ScpStatement>),
    ScpStatementPledges(Box<ScpStatementPledges>),
    ScpStatementPrepare(Box<ScpStatementPrepare>),
    ScpStatementConfirm(Box<ScpStatementConfirm>),
    ScpStatementExternalize(Box<ScpStatementExternalize>),
    ScpEnvelope(Box<ScpEnvelope>),
    ScpQuorumSet(Box<ScpQuorumSet>),
    ConfigSettingContractExecutionLanesV0(Box<ConfigSettingContractExecutionLanesV0>),
    ConfigSettingContractComputeV0(Box<ConfigSettingContractComputeV0>),
    ConfigSettingContractLedgerCostV0(Box<ConfigSettingContractLedgerCostV0>),
    ConfigSettingContractHistoricalDataV0(Box<ConfigSettingContractHistoricalDataV0>),
    ConfigSettingContractEventsV0(Box<ConfigSettingContractEventsV0>),
    ConfigSettingContractBandwidthV0(Box<ConfigSettingContractBandwidthV0>),
    ContractCostType(Box<ContractCostType>),
    ContractCostParamEntry(Box<ContractCostParamEntry>),
    StateArchivalSettings(Box<StateArchivalSettings>),
    EvictionIterator(Box<EvictionIterator>),
    ContractCostParams(Box<ContractCostParams>),
    ConfigSettingId(Box<ConfigSettingId>),
    ConfigSettingEntry(Box<ConfigSettingEntry>),
    ScEnvMetaKind(Box<ScEnvMetaKind>),
    ScEnvMetaEntry(Box<ScEnvMetaEntry>),
    ScMetaV0(Box<ScMetaV0>),
    ScMetaKind(Box<ScMetaKind>),
    ScMetaEntry(Box<ScMetaEntry>),
    ScSpecType(Box<ScSpecType>),
    ScSpecTypeOption(Box<ScSpecTypeOption>),
    ScSpecTypeResult(Box<ScSpecTypeResult>),
    ScSpecTypeVec(Box<ScSpecTypeVec>),
    ScSpecTypeMap(Box<ScSpecTypeMap>),
    ScSpecTypeTuple(Box<ScSpecTypeTuple>),
    ScSpecTypeBytesN(Box<ScSpecTypeBytesN>),
    ScSpecTypeUdt(Box<ScSpecTypeUdt>),
    ScSpecTypeDef(Box<ScSpecTypeDef>),
    ScSpecUdtStructFieldV0(Box<ScSpecUdtStructFieldV0>),
    ScSpecUdtStructV0(Box<ScSpecUdtStructV0>),
    ScSpecUdtUnionCaseVoidV0(Box<ScSpecUdtUnionCaseVoidV0>),
    ScSpecUdtUnionCaseTupleV0(Box<ScSpecUdtUnionCaseTupleV0>),
    ScSpecUdtUnionCaseV0Kind(Box<ScSpecUdtUnionCaseV0Kind>),
    ScSpecUdtUnionCaseV0(Box<ScSpecUdtUnionCaseV0>),
    ScSpecUdtUnionV0(Box<ScSpecUdtUnionV0>),
    ScSpecUdtEnumCaseV0(Box<ScSpecUdtEnumCaseV0>),
    ScSpecUdtEnumV0(Box<ScSpecUdtEnumV0>),
    ScSpecUdtErrorEnumCaseV0(Box<ScSpecUdtErrorEnumCaseV0>),
    ScSpecUdtErrorEnumV0(Box<ScSpecUdtErrorEnumV0>),
    ScSpecFunctionInputV0(Box<ScSpecFunctionInputV0>),
    ScSpecFunctionV0(Box<ScSpecFunctionV0>),
    ScSpecEntryKind(Box<ScSpecEntryKind>),
    ScSpecEntry(Box<ScSpecEntry>),
    ScValType(Box<ScValType>),
    ScErrorType(Box<ScErrorType>),
    ScErrorCode(Box<ScErrorCode>),
    ScError(Box<ScError>),
    UInt128Parts(Box<UInt128Parts>),
    Int128Parts(Box<Int128Parts>),
    UInt256Parts(Box<UInt256Parts>),
    Int256Parts(Box<Int256Parts>),
    ContractExecutableType(Box<ContractExecutableType>),
    ContractExecutable(Box<ContractExecutable>),
    ScAddressType(Box<ScAddressType>),
    ScAddress(Box<ScAddress>),
    ScVec(Box<ScVec>),
    ScMap(Box<ScMap>),
    ScBytes(Box<ScBytes>),
    ScString(Box<ScString>),
    ScSymbol(Box<ScSymbol>),
    ScNonceKey(Box<ScNonceKey>),
    ScContractInstance(Box<ScContractInstance>),
    ScVal(Box<ScVal>),
    ScMapEntry(Box<ScMapEntry>),
    StoredTransactionSet(Box<StoredTransactionSet>),
    StoredDebugTransactionSet(Box<StoredDebugTransactionSet>),
    PersistedScpStateV0(Box<PersistedScpStateV0>),
    PersistedScpStateV1(Box<PersistedScpStateV1>),
    PersistedScpState(Box<PersistedScpState>),
    Thresholds(Box<Thresholds>),
    String32(Box<String32>),
    String64(Box<String64>),
    SequenceNumber(Box<SequenceNumber>),
    DataValue(Box<DataValue>),
    PoolId(Box<PoolId>),
    AssetCode4(Box<AssetCode4>),
    AssetCode12(Box<AssetCode12>),
    AssetType(Box<AssetType>),
    AssetCode(Box<AssetCode>),
    AlphaNum4(Box<AlphaNum4>),
    AlphaNum12(Box<AlphaNum12>),
    Asset(Box<Asset>),
    Price(Box<Price>),
    Liabilities(Box<Liabilities>),
    ThresholdIndexes(Box<ThresholdIndexes>),
    LedgerEntryType(Box<LedgerEntryType>),
    Signer(Box<Signer>),
    AccountFlags(Box<AccountFlags>),
    SponsorshipDescriptor(Box<SponsorshipDescriptor>),
    AccountEntryExtensionV3(Box<AccountEntryExtensionV3>),
    AccountEntryExtensionV2(Box<AccountEntryExtensionV2>),
    AccountEntryExtensionV2Ext(Box<AccountEntryExtensionV2Ext>),
    AccountEntryExtensionV1(Box<AccountEntryExtensionV1>),
    AccountEntryExtensionV1Ext(Box<AccountEntryExtensionV1Ext>),
    AccountEntry(Box<AccountEntry>),
    AccountEntryExt(Box<AccountEntryExt>),
    TrustLineFlags(Box<TrustLineFlags>),
    LiquidityPoolType(Box<LiquidityPoolType>),
    TrustLineAsset(Box<TrustLineAsset>),
    TrustLineEntryExtensionV2(Box<TrustLineEntryExtensionV2>),
    TrustLineEntryExtensionV2Ext(Box<TrustLineEntryExtensionV2Ext>),
    TrustLineEntry(Box<TrustLineEntry>),
    TrustLineEntryExt(Box<TrustLineEntryExt>),
    TrustLineEntryV1(Box<TrustLineEntryV1>),
    TrustLineEntryV1Ext(Box<TrustLineEntryV1Ext>),
    OfferEntryFlags(Box<OfferEntryFlags>),
    OfferEntry(Box<OfferEntry>),
    OfferEntryExt(Box<OfferEntryExt>),
    DataEntry(Box<DataEntry>),
    DataEntryExt(Box<DataEntryExt>),
    ClaimPredicateType(Box<ClaimPredicateType>),
    ClaimPredicate(Box<ClaimPredicate>),
    ClaimantType(Box<ClaimantType>),
    Claimant(Box<Claimant>),
    ClaimantV0(Box<ClaimantV0>),
    ClaimableBalanceIdType(Box<ClaimableBalanceIdType>),
    ClaimableBalanceId(Box<ClaimableBalanceId>),
    ClaimableBalanceFlags(Box<ClaimableBalanceFlags>),
    ClaimableBalanceEntryExtensionV1(Box<ClaimableBalanceEntryExtensionV1>),
    ClaimableBalanceEntryExtensionV1Ext(Box<ClaimableBalanceEntryExtensionV1Ext>),
    ClaimableBalanceEntry(Box<ClaimableBalanceEntry>),
    ClaimableBalanceEntryExt(Box<ClaimableBalanceEntryExt>),
    LiquidityPoolConstantProductParameters(Box<LiquidityPoolConstantProductParameters>),
    LiquidityPoolEntry(Box<LiquidityPoolEntry>),
    LiquidityPoolEntryBody(Box<LiquidityPoolEntryBody>),
    LiquidityPoolEntryConstantProduct(Box<LiquidityPoolEntryConstantProduct>),
    ContractDataDurability(Box<ContractDataDurability>),
    ContractDataEntry(Box<ContractDataEntry>),
    ContractCodeCostInputs(Box<ContractCodeCostInputs>),
    ContractCodeEntry(Box<ContractCodeEntry>),
    ContractCodeEntryExt(Box<ContractCodeEntryExt>),
    ContractCodeEntryV1(Box<ContractCodeEntryV1>),
    TtlEntry(Box<TtlEntry>),
    LedgerEntryExtensionV1(Box<LedgerEntryExtensionV1>),
    LedgerEntryExtensionV1Ext(Box<LedgerEntryExtensionV1Ext>),
    LedgerEntry(Box<LedgerEntry>),
    LedgerEntryData(Box<LedgerEntryData>),
    LedgerEntryExt(Box<LedgerEntryExt>),
    LedgerKey(Box<LedgerKey>),
    LedgerKeyAccount(Box<LedgerKeyAccount>),
    LedgerKeyTrustLine(Box<LedgerKeyTrustLine>),
    LedgerKeyOffer(Box<LedgerKeyOffer>),
    LedgerKeyData(Box<LedgerKeyData>),
    LedgerKeyClaimableBalance(Box<LedgerKeyClaimableBalance>),
    LedgerKeyLiquidityPool(Box<LedgerKeyLiquidityPool>),
    LedgerKeyContractData(Box<LedgerKeyContractData>),
    LedgerKeyContractCode(Box<LedgerKeyContractCode>),
    LedgerKeyConfigSetting(Box<LedgerKeyConfigSetting>),
    LedgerKeyTtl(Box<LedgerKeyTtl>),
    EnvelopeType(Box<EnvelopeType>),
    UpgradeType(Box<UpgradeType>),
    StellarValueType(Box<StellarValueType>),
    LedgerCloseValueSignature(Box<LedgerCloseValueSignature>),
    StellarValue(Box<StellarValue>),
    StellarValueExt(Box<StellarValueExt>),
    LedgerHeaderFlags(Box<LedgerHeaderFlags>),
    LedgerHeaderExtensionV1(Box<LedgerHeaderExtensionV1>),
    LedgerHeaderExtensionV1Ext(Box<LedgerHeaderExtensionV1Ext>),
    LedgerHeader(Box<LedgerHeader>),
    LedgerHeaderExt(Box<LedgerHeaderExt>),
    LedgerUpgradeType(Box<LedgerUpgradeType>),
    ConfigUpgradeSetKey(Box<ConfigUpgradeSetKey>),
    LedgerUpgrade(Box<LedgerUpgrade>),
    ConfigUpgradeSet(Box<ConfigUpgradeSet>),
    BucketEntryType(Box<BucketEntryType>),
    BucketMetadata(Box<BucketMetadata>),
    BucketMetadataExt(Box<BucketMetadataExt>),
    BucketEntry(Box<BucketEntry>),
    TxSetComponentType(Box<TxSetComponentType>),
    TxSetComponent(Box<TxSetComponent>),
    TxSetComponentTxsMaybeDiscountedFee(Box<TxSetComponentTxsMaybeDiscountedFee>),
    TransactionPhase(Box<TransactionPhase>),
    TransactionSet(Box<TransactionSet>),
    TransactionSetV1(Box<TransactionSetV1>),
    GeneralizedTransactionSet(Box<GeneralizedTransactionSet>),
    TransactionResultPair(Box<TransactionResultPair>),
    TransactionResultSet(Box<TransactionResultSet>),
    TransactionHistoryEntry(Box<TransactionHistoryEntry>),
    TransactionHistoryEntryExt(Box<TransactionHistoryEntryExt>),
    TransactionHistoryResultEntry(Box<TransactionHistoryResultEntry>),
    TransactionHistoryResultEntryExt(Box<TransactionHistoryResultEntryExt>),
    LedgerHeaderHistoryEntry(Box<LedgerHeaderHistoryEntry>),
    LedgerHeaderHistoryEntryExt(Box<LedgerHeaderHistoryEntryExt>),
    LedgerScpMessages(Box<LedgerScpMessages>),
    ScpHistoryEntryV0(Box<ScpHistoryEntryV0>),
    ScpHistoryEntry(Box<ScpHistoryEntry>),
    LedgerEntryChangeType(Box<LedgerEntryChangeType>),
    LedgerEntryChange(Box<LedgerEntryChange>),
    LedgerEntryChanges(Box<LedgerEntryChanges>),
    OperationMeta(Box<OperationMeta>),
    TransactionMetaV1(Box<TransactionMetaV1>),
    TransactionMetaV2(Box<TransactionMetaV2>),
    ContractEventType(Box<ContractEventType>),
    ContractEvent(Box<ContractEvent>),
    ContractEventBody(Box<ContractEventBody>),
    ContractEventV0(Box<ContractEventV0>),
    DiagnosticEvent(Box<DiagnosticEvent>),
    SorobanTransactionMetaExtV1(Box<SorobanTransactionMetaExtV1>),
    SorobanTransactionMetaExt(Box<SorobanTransactionMetaExt>),
    SorobanTransactionMeta(Box<SorobanTransactionMeta>),
    TransactionMetaV3(Box<TransactionMetaV3>),
    InvokeHostFunctionSuccessPreImage(Box<InvokeHostFunctionSuccessPreImage>),
    TransactionMeta(Box<TransactionMeta>),
    TransactionResultMeta(Box<TransactionResultMeta>),
    UpgradeEntryMeta(Box<UpgradeEntryMeta>),
    LedgerCloseMetaV0(Box<LedgerCloseMetaV0>),
    LedgerCloseMetaExtV1(Box<LedgerCloseMetaExtV1>),
    LedgerCloseMetaExt(Box<LedgerCloseMetaExt>),
    LedgerCloseMetaV1(Box<LedgerCloseMetaV1>),
    LedgerCloseMeta(Box<LedgerCloseMeta>),
    ErrorCode(Box<ErrorCode>),
    SError(Box<SError>),
    SendMore(Box<SendMore>),
    SendMoreExtended(Box<SendMoreExtended>),
    AuthCert(Box<AuthCert>),
    Hello(Box<Hello>),
    Auth(Box<Auth>),
    IpAddrType(Box<IpAddrType>),
    PeerAddress(Box<PeerAddress>),
    PeerAddressIp(Box<PeerAddressIp>),
    MessageType(Box<MessageType>),
    DontHave(Box<DontHave>),
    SurveyMessageCommandType(Box<SurveyMessageCommandType>),
    SurveyMessageResponseType(Box<SurveyMessageResponseType>),
    SurveyRequestMessage(Box<SurveyRequestMessage>),
    SignedSurveyRequestMessage(Box<SignedSurveyRequestMessage>),
    EncryptedBody(Box<EncryptedBody>),
    SurveyResponseMessage(Box<SurveyResponseMessage>),
    SignedSurveyResponseMessage(Box<SignedSurveyResponseMessage>),
    PeerStats(Box<PeerStats>),
    PeerStatList(Box<PeerStatList>),
    TopologyResponseBodyV0(Box<TopologyResponseBodyV0>),
    TopologyResponseBodyV1(Box<TopologyResponseBodyV1>),
    SurveyResponseBody(Box<SurveyResponseBody>),
    TxAdvertVector(Box<TxAdvertVector>),
    FloodAdvert(Box<FloodAdvert>),
    TxDemandVector(Box<TxDemandVector>),
    FloodDemand(Box<FloodDemand>),
    StellarMessage(Box<StellarMessage>),
    AuthenticatedMessage(Box<AuthenticatedMessage>),
    AuthenticatedMessageV0(Box<AuthenticatedMessageV0>),
    LiquidityPoolParameters(Box<LiquidityPoolParameters>),
    MuxedAccount(Box<MuxedAccount>),
    MuxedAccountMed25519(Box<MuxedAccountMed25519>),
    DecoratedSignature(Box<DecoratedSignature>),
    OperationType(Box<OperationType>),
    CreateAccountOp(Box<CreateAccountOp>),
    PaymentOp(Box<PaymentOp>),
    PathPaymentStrictReceiveOp(Box<PathPaymentStrictReceiveOp>),
    PathPaymentStrictSendOp(Box<PathPaymentStrictSendOp>),
    ManageSellOfferOp(Box<ManageSellOfferOp>),
    ManageBuyOfferOp(Box<ManageBuyOfferOp>),
    CreatePassiveSellOfferOp(Box<CreatePassiveSellOfferOp>),
    SetOptionsOp(Box<SetOptionsOp>),
    ChangeTrustAsset(Box<ChangeTrustAsset>),
    ChangeTrustOp(Box<ChangeTrustOp>),
    AllowTrustOp(Box<AllowTrustOp>),
    ManageDataOp(Box<ManageDataOp>),
    BumpSequenceOp(Box<BumpSequenceOp>),
    CreateClaimableBalanceOp(Box<CreateClaimableBalanceOp>),
    ClaimClaimableBalanceOp(Box<ClaimClaimableBalanceOp>),
    BeginSponsoringFutureReservesOp(Box<BeginSponsoringFutureReservesOp>),
    RevokeSponsorshipType(Box<RevokeSponsorshipType>),
    RevokeSponsorshipOp(Box<RevokeSponsorshipOp>),
    RevokeSponsorshipOpSigner(Box<RevokeSponsorshipOpSigner>),
    ClawbackOp(Box<ClawbackOp>),
    ClawbackClaimableBalanceOp(Box<ClawbackClaimableBalanceOp>),
    SetTrustLineFlagsOp(Box<SetTrustLineFlagsOp>),
    LiquidityPoolDepositOp(Box<LiquidityPoolDepositOp>),
    LiquidityPoolWithdrawOp(Box<LiquidityPoolWithdrawOp>),
    HostFunctionType(Box<HostFunctionType>),
    ContractIdPreimageType(Box<ContractIdPreimageType>),
    ContractIdPreimage(Box<ContractIdPreimage>),
    ContractIdPreimageFromAddress(Box<ContractIdPreimageFromAddress>),
    CreateContractArgs(Box<CreateContractArgs>),
    InvokeContractArgs(Box<InvokeContractArgs>),
    HostFunction(Box<HostFunction>),
    SorobanAuthorizedFunctionType(Box<SorobanAuthorizedFunctionType>),
    SorobanAuthorizedFunction(Box<SorobanAuthorizedFunction>),
    SorobanAuthorizedInvocation(Box<SorobanAuthorizedInvocation>),
    SorobanAddressCredentials(Box<SorobanAddressCredentials>),
    SorobanCredentialsType(Box<SorobanCredentialsType>),
    SorobanCredentials(Box<SorobanCredentials>),
    SorobanAuthorizationEntry(Box<SorobanAuthorizationEntry>),
    InvokeHostFunctionOp(Box<InvokeHostFunctionOp>),
    ExtendFootprintTtlOp(Box<ExtendFootprintTtlOp>),
    RestoreFootprintOp(Box<RestoreFootprintOp>),
    Operation(Box<Operation>),
    OperationBody(Box<OperationBody>),
    HashIdPreimage(Box<HashIdPreimage>),
    HashIdPreimageOperationId(Box<HashIdPreimageOperationId>),
    HashIdPreimageRevokeId(Box<HashIdPreimageRevokeId>),
    HashIdPreimageContractId(Box<HashIdPreimageContractId>),
    HashIdPreimageSorobanAuthorization(Box<HashIdPreimageSorobanAuthorization>),
    MemoType(Box<MemoType>),
    Memo(Box<Memo>),
    TimeBounds(Box<TimeBounds>),
    LedgerBounds(Box<LedgerBounds>),
    PreconditionsV2(Box<PreconditionsV2>),
    PreconditionType(Box<PreconditionType>),
    Preconditions(Box<Preconditions>),
    LedgerFootprint(Box<LedgerFootprint>),
    SorobanResources(Box<SorobanResources>),
    SorobanTransactionData(Box<SorobanTransactionData>),
    TransactionV0(Box<TransactionV0>),
    TransactionV0Ext(Box<TransactionV0Ext>),
    TransactionV0Envelope(Box<TransactionV0Envelope>),
    Transaction(Box<Transaction>),
    TransactionExt(Box<TransactionExt>),
    TransactionV1Envelope(Box<TransactionV1Envelope>),
    FeeBumpTransaction(Box<FeeBumpTransaction>),
    FeeBumpTransactionInnerTx(Box<FeeBumpTransactionInnerTx>),
    FeeBumpTransactionExt(Box<FeeBumpTransactionExt>),
    FeeBumpTransactionEnvelope(Box<FeeBumpTransactionEnvelope>),
    TransactionEnvelope(Box<TransactionEnvelope>),
    TransactionSignaturePayload(Box<TransactionSignaturePayload>),
    TransactionSignaturePayloadTaggedTransaction(Box<TransactionSignaturePayloadTaggedTransaction>),
    ClaimAtomType(Box<ClaimAtomType>),
    ClaimOfferAtomV0(Box<ClaimOfferAtomV0>),
    ClaimOfferAtom(Box<ClaimOfferAtom>),
    ClaimLiquidityAtom(Box<ClaimLiquidityAtom>),
    ClaimAtom(Box<ClaimAtom>),
    CreateAccountResultCode(Box<CreateAccountResultCode>),
    CreateAccountResult(Box<CreateAccountResult>),
    PaymentResultCode(Box<PaymentResultCode>),
    PaymentResult(Box<PaymentResult>),
    PathPaymentStrictReceiveResultCode(Box<PathPaymentStrictReceiveResultCode>),
    SimplePaymentResult(Box<SimplePaymentResult>),
    PathPaymentStrictReceiveResult(Box<PathPaymentStrictReceiveResult>),
    PathPaymentStrictReceiveResultSuccess(Box<PathPaymentStrictReceiveResultSuccess>),
    PathPaymentStrictSendResultCode(Box<PathPaymentStrictSendResultCode>),
    PathPaymentStrictSendResult(Box<PathPaymentStrictSendResult>),
    PathPaymentStrictSendResultSuccess(Box<PathPaymentStrictSendResultSuccess>),
    ManageSellOfferResultCode(Box<ManageSellOfferResultCode>),
    ManageOfferEffect(Box<ManageOfferEffect>),
    ManageOfferSuccessResult(Box<ManageOfferSuccessResult>),
    ManageOfferSuccessResultOffer(Box<ManageOfferSuccessResultOffer>),
    ManageSellOfferResult(Box<ManageSellOfferResult>),
    ManageBuyOfferResultCode(Box<ManageBuyOfferResultCode>),
    ManageBuyOfferResult(Box<ManageBuyOfferResult>),
    SetOptionsResultCode(Box<SetOptionsResultCode>),
    SetOptionsResult(Box<SetOptionsResult>),
    ChangeTrustResultCode(Box<ChangeTrustResultCode>),
    ChangeTrustResult(Box<ChangeTrustResult>),
    AllowTrustResultCode(Box<AllowTrustResultCode>),
    AllowTrustResult(Box<AllowTrustResult>),
    AccountMergeResultCode(Box<AccountMergeResultCode>),
    AccountMergeResult(Box<AccountMergeResult>),
    InflationResultCode(Box<InflationResultCode>),
    InflationPayout(Box<InflationPayout>),
    InflationResult(Box<InflationResult>),
    ManageDataResultCode(Box<ManageDataResultCode>),
    ManageDataResult(Box<ManageDataResult>),
    BumpSequenceResultCode(Box<BumpSequenceResultCode>),
    BumpSequenceResult(Box<BumpSequenceResult>),
    CreateClaimableBalanceResultCode(Box<CreateClaimableBalanceResultCode>),
    CreateClaimableBalanceResult(Box<CreateClaimableBalanceResult>),
    ClaimClaimableBalanceResultCode(Box<ClaimClaimableBalanceResultCode>),
    ClaimClaimableBalanceResult(Box<ClaimClaimableBalanceResult>),
    BeginSponsoringFutureReservesResultCode(Box<BeginSponsoringFutureReservesResultCode>),
    BeginSponsoringFutureReservesResult(Box<BeginSponsoringFutureReservesResult>),
    EndSponsoringFutureReservesResultCode(Box<EndSponsoringFutureReservesResultCode>),
    EndSponsoringFutureReservesResult(Box<EndSponsoringFutureReservesResult>),
    RevokeSponsorshipResultCode(Box<RevokeSponsorshipResultCode>),
    RevokeSponsorshipResult(Box<RevokeSponsorshipResult>),
    ClawbackResultCode(Box<ClawbackResultCode>),
    ClawbackResult(Box<ClawbackResult>),
    ClawbackClaimableBalanceResultCode(Box<ClawbackClaimableBalanceResultCode>),
    ClawbackClaimableBalanceResult(Box<ClawbackClaimableBalanceResult>),
    SetTrustLineFlagsResultCode(Box<SetTrustLineFlagsResultCode>),
    SetTrustLineFlagsResult(Box<SetTrustLineFlagsResult>),
    LiquidityPoolDepositResultCode(Box<LiquidityPoolDepositResultCode>),
    LiquidityPoolDepositResult(Box<LiquidityPoolDepositResult>),
    LiquidityPoolWithdrawResultCode(Box<LiquidityPoolWithdrawResultCode>),
    LiquidityPoolWithdrawResult(Box<LiquidityPoolWithdrawResult>),
    InvokeHostFunctionResultCode(Box<InvokeHostFunctionResultCode>),
    InvokeHostFunctionResult(Box<InvokeHostFunctionResult>),
    ExtendFootprintTtlResultCode(Box<ExtendFootprintTtlResultCode>),
    ExtendFootprintTtlResult(Box<ExtendFootprintTtlResult>),
    RestoreFootprintResultCode(Box<RestoreFootprintResultCode>),
    RestoreFootprintResult(Box<RestoreFootprintResult>),
    OperationResultCode(Box<OperationResultCode>),
    OperationResult(Box<OperationResult>),
    OperationResultTr(Box<OperationResultTr>),
    TransactionResultCode(Box<TransactionResultCode>),
    InnerTransactionResult(Box<InnerTransactionResult>),
    InnerTransactionResultResult(Box<InnerTransactionResultResult>),
    InnerTransactionResultExt(Box<InnerTransactionResultExt>),
    InnerTransactionResultPair(Box<InnerTransactionResultPair>),
    TransactionResult(Box<TransactionResult>),
    TransactionResultResult(Box<TransactionResultResult>),
    TransactionResultExt(Box<TransactionResultExt>),
    Hash(Box<Hash>),
    Uint256(Box<Uint256>),
    Uint32(Box<Uint32>),
    Int32(Box<Int32>),
    Uint64(Box<Uint64>),
    Int64(Box<Int64>),
    TimePoint(Box<TimePoint>),
    Duration(Box<Duration>),
    ExtensionPoint(Box<ExtensionPoint>),
    CryptoKeyType(Box<CryptoKeyType>),
    PublicKeyType(Box<PublicKeyType>),
    SignerKeyType(Box<SignerKeyType>),
    PublicKey(Box<PublicKey>),
    SignerKey(Box<SignerKey>),
    SignerKeyEd25519SignedPayload(Box<SignerKeyEd25519SignedPayload>),
    Signature(Box<Signature>),
    SignatureHint(Box<SignatureHint>),
    NodeId(Box<NodeId>),
    AccountId(Box<AccountId>),
    Curve25519Secret(Box<Curve25519Secret>),
    Curve25519Public(Box<Curve25519Public>),
    HmacSha256Key(Box<HmacSha256Key>),
    HmacSha256Mac(Box<HmacSha256Mac>),
}

impl Type {
    pub const VARIANTS: [TypeVariant; 425] = [
        TypeVariant::Value,
        TypeVariant::ScpBallot,
        TypeVariant::ScpStatementType,
        TypeVariant::ScpNomination,
        TypeVariant::ScpStatement,
        TypeVariant::ScpStatementPledges,
        TypeVariant::ScpStatementPrepare,
        TypeVariant::ScpStatementConfirm,
        TypeVariant::ScpStatementExternalize,
        TypeVariant::ScpEnvelope,
        TypeVariant::ScpQuorumSet,
        TypeVariant::ConfigSettingContractExecutionLanesV0,
        TypeVariant::ConfigSettingContractComputeV0,
        TypeVariant::ConfigSettingContractLedgerCostV0,
        TypeVariant::ConfigSettingContractHistoricalDataV0,
        TypeVariant::ConfigSettingContractEventsV0,
        TypeVariant::ConfigSettingContractBandwidthV0,
        TypeVariant::ContractCostType,
        TypeVariant::ContractCostParamEntry,
        TypeVariant::StateArchivalSettings,
        TypeVariant::EvictionIterator,
        TypeVariant::ContractCostParams,
        TypeVariant::ConfigSettingId,
        TypeVariant::ConfigSettingEntry,
        TypeVariant::ScEnvMetaKind,
        TypeVariant::ScEnvMetaEntry,
        TypeVariant::ScMetaV0,
        TypeVariant::ScMetaKind,
        TypeVariant::ScMetaEntry,
        TypeVariant::ScSpecType,
        TypeVariant::ScSpecTypeOption,
        TypeVariant::ScSpecTypeResult,
        TypeVariant::ScSpecTypeVec,
        TypeVariant::ScSpecTypeMap,
        TypeVariant::ScSpecTypeTuple,
        TypeVariant::ScSpecTypeBytesN,
        TypeVariant::ScSpecTypeUdt,
        TypeVariant::ScSpecTypeDef,
        TypeVariant::ScSpecUdtStructFieldV0,
        TypeVariant::ScSpecUdtStructV0,
        TypeVariant::ScSpecUdtUnionCaseVoidV0,
        TypeVariant::ScSpecUdtUnionCaseTupleV0,
        TypeVariant::ScSpecUdtUnionCaseV0Kind,
        TypeVariant::ScSpecUdtUnionCaseV0,
        TypeVariant::ScSpecUdtUnionV0,
        TypeVariant::ScSpecUdtEnumCaseV0,
        TypeVariant::ScSpecUdtEnumV0,
        TypeVariant::ScSpecUdtErrorEnumCaseV0,
        TypeVariant::ScSpecUdtErrorEnumV0,
        TypeVariant::ScSpecFunctionInputV0,
        TypeVariant::ScSpecFunctionV0,
        TypeVariant::ScSpecEntryKind,
        TypeVariant::ScSpecEntry,
        TypeVariant::ScValType,
        TypeVariant::ScErrorType,
        TypeVariant::ScErrorCode,
        TypeVariant::ScError,
        TypeVariant::UInt128Parts,
        TypeVariant::Int128Parts,
        TypeVariant::UInt256Parts,
        TypeVariant::Int256Parts,
        TypeVariant::ContractExecutableType,
        TypeVariant::ContractExecutable,
        TypeVariant::ScAddressType,
        TypeVariant::ScAddress,
        TypeVariant::ScVec,
        TypeVariant::ScMap,
        TypeVariant::ScBytes,
        TypeVariant::ScString,
        TypeVariant::ScSymbol,
        TypeVariant::ScNonceKey,
        TypeVariant::ScContractInstance,
        TypeVariant::ScVal,
        TypeVariant::ScMapEntry,
        TypeVariant::StoredTransactionSet,
        TypeVariant::StoredDebugTransactionSet,
        TypeVariant::PersistedScpStateV0,
        TypeVariant::PersistedScpStateV1,
        TypeVariant::PersistedScpState,
        TypeVariant::Thresholds,
        TypeVariant::String32,
        TypeVariant::String64,
        TypeVariant::SequenceNumber,
        TypeVariant::DataValue,
        TypeVariant::PoolId,
        TypeVariant::AssetCode4,
        TypeVariant::AssetCode12,
        TypeVariant::AssetType,
        TypeVariant::AssetCode,
        TypeVariant::AlphaNum4,
        TypeVariant::AlphaNum12,
        TypeVariant::Asset,
        TypeVariant::Price,
        TypeVariant::Liabilities,
        TypeVariant::ThresholdIndexes,
        TypeVariant::LedgerEntryType,
        TypeVariant::Signer,
        TypeVariant::AccountFlags,
        TypeVariant::SponsorshipDescriptor,
        TypeVariant::AccountEntryExtensionV3,
        TypeVariant::AccountEntryExtensionV2,
        TypeVariant::AccountEntryExtensionV2Ext,
        TypeVariant::AccountEntryExtensionV1,
        TypeVariant::AccountEntryExtensionV1Ext,
        TypeVariant::AccountEntry,
        TypeVariant::AccountEntryExt,
        TypeVariant::TrustLineFlags,
        TypeVariant::LiquidityPoolType,
        TypeVariant::TrustLineAsset,
        TypeVariant::TrustLineEntryExtensionV2,
        TypeVariant::TrustLineEntryExtensionV2Ext,
        TypeVariant::TrustLineEntry,
        TypeVariant::TrustLineEntryExt,
        TypeVariant::TrustLineEntryV1,
        TypeVariant::TrustLineEntryV1Ext,
        TypeVariant::OfferEntryFlags,
        TypeVariant::OfferEntry,
        TypeVariant::OfferEntryExt,
        TypeVariant::DataEntry,
        TypeVariant::DataEntryExt,
        TypeVariant::ClaimPredicateType,
        TypeVariant::ClaimPredicate,
        TypeVariant::ClaimantType,
        TypeVariant::Claimant,
        TypeVariant::ClaimantV0,
        TypeVariant::ClaimableBalanceIdType,
        TypeVariant::ClaimableBalanceId,
        TypeVariant::ClaimableBalanceFlags,
        TypeVariant::ClaimableBalanceEntryExtensionV1,
        TypeVariant::ClaimableBalanceEntryExtensionV1Ext,
        TypeVariant::ClaimableBalanceEntry,
        TypeVariant::ClaimableBalanceEntryExt,
        TypeVariant::LiquidityPoolConstantProductParameters,
        TypeVariant::LiquidityPoolEntry,
        TypeVariant::LiquidityPoolEntryBody,
        TypeVariant::LiquidityPoolEntryConstantProduct,
        TypeVariant::ContractDataDurability,
        TypeVariant::ContractDataEntry,
        TypeVariant::ContractCodeCostInputs,
        TypeVariant::ContractCodeEntry,
        TypeVariant::ContractCodeEntryExt,
        TypeVariant::ContractCodeEntryV1,
        TypeVariant::TtlEntry,
        TypeVariant::LedgerEntryExtensionV1,
        TypeVariant::LedgerEntryExtensionV1Ext,
        TypeVariant::LedgerEntry,
        TypeVariant::LedgerEntryData,
        TypeVariant::LedgerEntryExt,
        TypeVariant::LedgerKey,
        TypeVariant::LedgerKeyAccount,
        TypeVariant::LedgerKeyTrustLine,
        TypeVariant::LedgerKeyOffer,
        TypeVariant::LedgerKeyData,
        TypeVariant::LedgerKeyClaimableBalance,
        TypeVariant::LedgerKeyLiquidityPool,
        TypeVariant::LedgerKeyContractData,
        TypeVariant::LedgerKeyContractCode,
        TypeVariant::LedgerKeyConfigSetting,
        TypeVariant::LedgerKeyTtl,
        TypeVariant::EnvelopeType,
        TypeVariant::UpgradeType,
        TypeVariant::StellarValueType,
        TypeVariant::LedgerCloseValueSignature,
        TypeVariant::StellarValue,
        TypeVariant::StellarValueExt,
        TypeVariant::LedgerHeaderFlags,
        TypeVariant::LedgerHeaderExtensionV1,
        TypeVariant::LedgerHeaderExtensionV1Ext,
        TypeVariant::LedgerHeader,
        TypeVariant::LedgerHeaderExt,
        TypeVariant::LedgerUpgradeType,
        TypeVariant::ConfigUpgradeSetKey,
        TypeVariant::LedgerUpgrade,
        TypeVariant::ConfigUpgradeSet,
        TypeVariant::BucketEntryType,
        TypeVariant::BucketMetadata,
        TypeVariant::BucketMetadataExt,
        TypeVariant::BucketEntry,
        TypeVariant::TxSetComponentType,
        TypeVariant::TxSetComponent,
        TypeVariant::TxSetComponentTxsMaybeDiscountedFee,
        TypeVariant::TransactionPhase,
        TypeVariant::TransactionSet,
        TypeVariant::TransactionSetV1,
        TypeVariant::GeneralizedTransactionSet,
        TypeVariant::TransactionResultPair,
        TypeVariant::TransactionResultSet,
        TypeVariant::TransactionHistoryEntry,
        TypeVariant::TransactionHistoryEntryExt,
        TypeVariant::TransactionHistoryResultEntry,
        TypeVariant::TransactionHistoryResultEntryExt,
        TypeVariant::LedgerHeaderHistoryEntry,
        TypeVariant::LedgerHeaderHistoryEntryExt,
        TypeVariant::LedgerScpMessages,
        TypeVariant::ScpHistoryEntryV0,
        TypeVariant::ScpHistoryEntry,
        TypeVariant::LedgerEntryChangeType,
        TypeVariant::LedgerEntryChange,
        TypeVariant::LedgerEntryChanges,
        TypeVariant::OperationMeta,
        TypeVariant::TransactionMetaV1,
        TypeVariant::TransactionMetaV2,
        TypeVariant::ContractEventType,
        TypeVariant::ContractEvent,
        TypeVariant::ContractEventBody,
        TypeVariant::ContractEventV0,
        TypeVariant::DiagnosticEvent,
        TypeVariant::SorobanTransactionMetaExtV1,
        TypeVariant::SorobanTransactionMetaExt,
        TypeVariant::SorobanTransactionMeta,
        TypeVariant::TransactionMetaV3,
        TypeVariant::InvokeHostFunctionSuccessPreImage,
        TypeVariant::TransactionMeta,
        TypeVariant::TransactionResultMeta,
        TypeVariant::UpgradeEntryMeta,
        TypeVariant::LedgerCloseMetaV0,
        TypeVariant::LedgerCloseMetaExtV1,
        TypeVariant::LedgerCloseMetaExt,
        TypeVariant::LedgerCloseMetaV1,
        TypeVariant::LedgerCloseMeta,
        TypeVariant::ErrorCode,
        TypeVariant::SError,
        TypeVariant::SendMore,
        TypeVariant::SendMoreExtended,
        TypeVariant::AuthCert,
        TypeVariant::Hello,
        TypeVariant::Auth,
        TypeVariant::IpAddrType,
        TypeVariant::PeerAddress,
        TypeVariant::PeerAddressIp,
        TypeVariant::MessageType,
        TypeVariant::DontHave,
        TypeVariant::SurveyMessageCommandType,
        TypeVariant::SurveyMessageResponseType,
        TypeVariant::SurveyRequestMessage,
        TypeVariant::SignedSurveyRequestMessage,
        TypeVariant::EncryptedBody,
        TypeVariant::SurveyResponseMessage,
        TypeVariant::SignedSurveyResponseMessage,
        TypeVariant::PeerStats,
        TypeVariant::PeerStatList,
        TypeVariant::TopologyResponseBodyV0,
        TypeVariant::TopologyResponseBodyV1,
        TypeVariant::SurveyResponseBody,
        TypeVariant::TxAdvertVector,
        TypeVariant::FloodAdvert,
        TypeVariant::TxDemandVector,
        TypeVariant::FloodDemand,
        TypeVariant::StellarMessage,
        TypeVariant::AuthenticatedMessage,
        TypeVariant::AuthenticatedMessageV0,
        TypeVariant::LiquidityPoolParameters,
        TypeVariant::MuxedAccount,
        TypeVariant::MuxedAccountMed25519,
        TypeVariant::DecoratedSignature,
        TypeVariant::OperationType,
        TypeVariant::CreateAccountOp,
        TypeVariant::PaymentOp,
        TypeVariant::PathPaymentStrictReceiveOp,
        TypeVariant::PathPaymentStrictSendOp,
        TypeVariant::ManageSellOfferOp,
        TypeVariant::ManageBuyOfferOp,
        TypeVariant::CreatePassiveSellOfferOp,
        TypeVariant::SetOptionsOp,
        TypeVariant::ChangeTrustAsset,
        TypeVariant::ChangeTrustOp,
        TypeVariant::AllowTrustOp,
        TypeVariant::ManageDataOp,
        TypeVariant::BumpSequenceOp,
        TypeVariant::CreateClaimableBalanceOp,
        TypeVariant::ClaimClaimableBalanceOp,
        TypeVariant::BeginSponsoringFutureReservesOp,
        TypeVariant::RevokeSponsorshipType,
        TypeVariant::RevokeSponsorshipOp,
        TypeVariant::RevokeSponsorshipOpSigner,
        TypeVariant::ClawbackOp,
        TypeVariant::ClawbackClaimableBalanceOp,
        TypeVariant::SetTrustLineFlagsOp,
        TypeVariant::LiquidityPoolDepositOp,
        TypeVariant::LiquidityPoolWithdrawOp,
        TypeVariant::HostFunctionType,
        TypeVariant::ContractIdPreimageType,
        TypeVariant::ContractIdPreimage,
        TypeVariant::ContractIdPreimageFromAddress,
        TypeVariant::CreateContractArgs,
        TypeVariant::InvokeContractArgs,
        TypeVariant::HostFunction,
        TypeVariant::SorobanAuthorizedFunctionType,
        TypeVariant::SorobanAuthorizedFunction,
        TypeVariant::SorobanAuthorizedInvocation,
        TypeVariant::SorobanAddressCredentials,
        TypeVariant::SorobanCredentialsType,
        TypeVariant::SorobanCredentials,
        TypeVariant::SorobanAuthorizationEntry,
        TypeVariant::InvokeHostFunctionOp,
        TypeVariant::ExtendFootprintTtlOp,
        TypeVariant::RestoreFootprintOp,
        TypeVariant::Operation,
        TypeVariant::OperationBody,
        TypeVariant::HashIdPreimage,
        TypeVariant::HashIdPreimageOperationId,
        TypeVariant::HashIdPreimageRevokeId,
        TypeVariant::HashIdPreimageContractId,
        TypeVariant::HashIdPreimageSorobanAuthorization,
        TypeVariant::MemoType,
        TypeVariant::Memo,
        TypeVariant::TimeBounds,
        TypeVariant::LedgerBounds,
        TypeVariant::PreconditionsV2,
        TypeVariant::PreconditionType,
        TypeVariant::Preconditions,
        TypeVariant::LedgerFootprint,
        TypeVariant::SorobanResources,
        TypeVariant::SorobanTransactionData,
        TypeVariant::TransactionV0,
        TypeVariant::TransactionV0Ext,
        TypeVariant::TransactionV0Envelope,
        TypeVariant::Transaction,
        TypeVariant::TransactionExt,
        TypeVariant::TransactionV1Envelope,
        TypeVariant::FeeBumpTransaction,
        TypeVariant::FeeBumpTransactionInnerTx,
        TypeVariant::FeeBumpTransactionExt,
        TypeVariant::FeeBumpTransactionEnvelope,
        TypeVariant::TransactionEnvelope,
        TypeVariant::TransactionSignaturePayload,
        TypeVariant::TransactionSignaturePayloadTaggedTransaction,
        TypeVariant::ClaimAtomType,
        TypeVariant::ClaimOfferAtomV0,
        TypeVariant::ClaimOfferAtom,
        TypeVariant::ClaimLiquidityAtom,
        TypeVariant::ClaimAtom,
        TypeVariant::CreateAccountResultCode,
        TypeVariant::CreateAccountResult,
        TypeVariant::PaymentResultCode,
        TypeVariant::PaymentResult,
        TypeVariant::PathPaymentStrictReceiveResultCode,
        TypeVariant::SimplePaymentResult,
        TypeVariant::PathPaymentStrictReceiveResult,
        TypeVariant::PathPaymentStrictReceiveResultSuccess,
        TypeVariant::PathPaymentStrictSendResultCode,
        TypeVariant::PathPaymentStrictSendResult,
        TypeVariant::PathPaymentStrictSendResultSuccess,
        TypeVariant::ManageSellOfferResultCode,
        TypeVariant::ManageOfferEffect,
        TypeVariant::ManageOfferSuccessResult,
        TypeVariant::ManageOfferSuccessResultOffer,
        TypeVariant::ManageSellOfferResult,
        TypeVariant::ManageBuyOfferResultCode,
        TypeVariant::ManageBuyOfferResult,
        TypeVariant::SetOptionsResultCode,
        TypeVariant::SetOptionsResult,
        TypeVariant::ChangeTrustResultCode,
        TypeVariant::ChangeTrustResult,
        TypeVariant::AllowTrustResultCode,
        TypeVariant::AllowTrustResult,
        TypeVariant::AccountMergeResultCode,
        TypeVariant::AccountMergeResult,
        TypeVariant::InflationResultCode,
        TypeVariant::InflationPayout,
        TypeVariant::InflationResult,
        TypeVariant::ManageDataResultCode,
        TypeVariant::ManageDataResult,
        TypeVariant::BumpSequenceResultCode,
        TypeVariant::BumpSequenceResult,
        TypeVariant::CreateClaimableBalanceResultCode,
        TypeVariant::CreateClaimableBalanceResult,
        TypeVariant::ClaimClaimableBalanceResultCode,
        TypeVariant::ClaimClaimableBalanceResult,
        TypeVariant::BeginSponsoringFutureReservesResultCode,
        TypeVariant::BeginSponsoringFutureReservesResult,
        TypeVariant::EndSponsoringFutureReservesResultCode,
        TypeVariant::EndSponsoringFutureReservesResult,
        TypeVariant::RevokeSponsorshipResultCode,
        TypeVariant::RevokeSponsorshipResult,
        TypeVariant::ClawbackResultCode,
        TypeVariant::ClawbackResult,
        TypeVariant::ClawbackClaimableBalanceResultCode,
        TypeVariant::ClawbackClaimableBalanceResult,
        TypeVariant::SetTrustLineFlagsResultCode,
        TypeVariant::SetTrustLineFlagsResult,
        TypeVariant::LiquidityPoolDepositResultCode,
        TypeVariant::LiquidityPoolDepositResult,
        TypeVariant::LiquidityPoolWithdrawResultCode,
        TypeVariant::LiquidityPoolWithdrawResult,
        TypeVariant::InvokeHostFunctionResultCode,
        TypeVariant::InvokeHostFunctionResult,
        TypeVariant::ExtendFootprintTtlResultCode,
        TypeVariant::ExtendFootprintTtlResult,
        TypeVariant::RestoreFootprintResultCode,
        TypeVariant::RestoreFootprintResult,
        TypeVariant::OperationResultCode,
        TypeVariant::OperationResult,
        TypeVariant::OperationResultTr,
        TypeVariant::TransactionResultCode,
        TypeVariant::InnerTransactionResult,
        TypeVariant::InnerTransactionResultResult,
        TypeVariant::InnerTransactionResultExt,
        TypeVariant::InnerTransactionResultPair,
        TypeVariant::TransactionResult,
        TypeVariant::TransactionResultResult,
        TypeVariant::TransactionResultExt,
        TypeVariant::Hash,
        TypeVariant::Uint256,
        TypeVariant::Uint32,
        TypeVariant::Int32,
        TypeVariant::Uint64,
        TypeVariant::Int64,
        TypeVariant::TimePoint,
        TypeVariant::Duration,
        TypeVariant::ExtensionPoint,
        TypeVariant::CryptoKeyType,
        TypeVariant::PublicKeyType,
        TypeVariant::SignerKeyType,
        TypeVariant::PublicKey,
        TypeVariant::SignerKey,
        TypeVariant::SignerKeyEd25519SignedPayload,
        TypeVariant::Signature,
        TypeVariant::SignatureHint,
        TypeVariant::NodeId,
        TypeVariant::AccountId,
        TypeVariant::Curve25519Secret,
        TypeVariant::Curve25519Public,
        TypeVariant::HmacSha256Key,
        TypeVariant::HmacSha256Mac,
    ];
    pub const VARIANTS_STR: [&'static str; 425] = [
        "Value",
        "ScpBallot",
        "ScpStatementType",
        "ScpNomination",
        "ScpStatement",
        "ScpStatementPledges",
        "ScpStatementPrepare",
        "ScpStatementConfirm",
        "ScpStatementExternalize",
        "ScpEnvelope",
        "ScpQuorumSet",
        "ConfigSettingContractExecutionLanesV0",
        "ConfigSettingContractComputeV0",
        "ConfigSettingContractLedgerCostV0",
        "ConfigSettingContractHistoricalDataV0",
        "ConfigSettingContractEventsV0",
        "ConfigSettingContractBandwidthV0",
        "ContractCostType",
        "ContractCostParamEntry",
        "StateArchivalSettings",
        "EvictionIterator",
        "ContractCostParams",
        "ConfigSettingId",
        "ConfigSettingEntry",
        "ScEnvMetaKind",
        "ScEnvMetaEntry",
        "ScMetaV0",
        "ScMetaKind",
        "ScMetaEntry",
        "ScSpecType",
        "ScSpecTypeOption",
        "ScSpecTypeResult",
        "ScSpecTypeVec",
        "ScSpecTypeMap",
        "ScSpecTypeTuple",
        "ScSpecTypeBytesN",
        "ScSpecTypeUdt",
        "ScSpecTypeDef",
        "ScSpecUdtStructFieldV0",
        "ScSpecUdtStructV0",
        "ScSpecUdtUnionCaseVoidV0",
        "ScSpecUdtUnionCaseTupleV0",
        "ScSpecUdtUnionCaseV0Kind",
        "ScSpecUdtUnionCaseV0",
        "ScSpecUdtUnionV0",
        "ScSpecUdtEnumCaseV0",
        "ScSpecUdtEnumV0",
        "ScSpecUdtErrorEnumCaseV0",
        "ScSpecUdtErrorEnumV0",
        "ScSpecFunctionInputV0",
        "ScSpecFunctionV0",
        "ScSpecEntryKind",
        "ScSpecEntry",
        "ScValType",
        "ScErrorType",
        "ScErrorCode",
        "ScError",
        "UInt128Parts",
        "Int128Parts",
        "UInt256Parts",
        "Int256Parts",
        "ContractExecutableType",
        "ContractExecutable",
        "ScAddressType",
        "ScAddress",
        "ScVec",
        "ScMap",
        "ScBytes",
        "ScString",
        "ScSymbol",
        "ScNonceKey",
        "ScContractInstance",
        "ScVal",
        "ScMapEntry",
        "StoredTransactionSet",
        "StoredDebugTransactionSet",
        "PersistedScpStateV0",
        "PersistedScpStateV1",
        "PersistedScpState",
        "Thresholds",
        "String32",
        "String64",
        "SequenceNumber",
        "DataValue",
        "PoolId",
        "AssetCode4",
        "AssetCode12",
        "AssetType",
        "AssetCode",
        "AlphaNum4",
        "AlphaNum12",
        "Asset",
        "Price",
        "Liabilities",
        "ThresholdIndexes",
        "LedgerEntryType",
        "Signer",
        "AccountFlags",
        "SponsorshipDescriptor",
        "AccountEntryExtensionV3",
        "AccountEntryExtensionV2",
        "AccountEntryExtensionV2Ext",
        "AccountEntryExtensionV1",
        "AccountEntryExtensionV1Ext",
        "AccountEntry",
        "AccountEntryExt",
        "TrustLineFlags",
        "LiquidityPoolType",
        "TrustLineAsset",
        "TrustLineEntryExtensionV2",
        "TrustLineEntryExtensionV2Ext",
        "TrustLineEntry",
        "TrustLineEntryExt",
        "TrustLineEntryV1",
        "TrustLineEntryV1Ext",
        "OfferEntryFlags",
        "OfferEntry",
        "OfferEntryExt",
        "DataEntry",
        "DataEntryExt",
        "ClaimPredicateType",
        "ClaimPredicate",
        "ClaimantType",
        "Claimant",
        "ClaimantV0",
        "ClaimableBalanceIdType",
        "ClaimableBalanceId",
        "ClaimableBalanceFlags",
        "ClaimableBalanceEntryExtensionV1",
        "ClaimableBalanceEntryExtensionV1Ext",
        "ClaimableBalanceEntry",
        "ClaimableBalanceEntryExt",
        "LiquidityPoolConstantProductParameters",
        "LiquidityPoolEntry",
        "LiquidityPoolEntryBody",
        "LiquidityPoolEntryConstantProduct",
        "ContractDataDurability",
        "ContractDataEntry",
        "ContractCodeCostInputs",
        "ContractCodeEntry",
        "ContractCodeEntryExt",
        "ContractCodeEntryV1",
        "TtlEntry",
        "LedgerEntryExtensionV1",
        "LedgerEntryExtensionV1Ext",
        "LedgerEntry",
        "LedgerEntryData",
        "LedgerEntryExt",
        "LedgerKey",
        "LedgerKeyAccount",
        "LedgerKeyTrustLine",
        "LedgerKeyOffer",
        "LedgerKeyData",
        "LedgerKeyClaimableBalance",
        "LedgerKeyLiquidityPool",
        "LedgerKeyContractData",
        "LedgerKeyContractCode",
        "LedgerKeyConfigSetting",
        "LedgerKeyTtl",
        "EnvelopeType",
        "UpgradeType",
        "StellarValueType",
        "LedgerCloseValueSignature",
        "StellarValue",
        "StellarValueExt",
        "LedgerHeaderFlags",
        "LedgerHeaderExtensionV1",
        "LedgerHeaderExtensionV1Ext",
        "LedgerHeader",
        "LedgerHeaderExt",
        "LedgerUpgradeType",
        "ConfigUpgradeSetKey",
        "LedgerUpgrade",
        "ConfigUpgradeSet",
        "BucketEntryType",
        "BucketMetadata",
        "BucketMetadataExt",
        "BucketEntry",
        "TxSetComponentType",
        "TxSetComponent",
        "TxSetComponentTxsMaybeDiscountedFee",
        "TransactionPhase",
        "TransactionSet",
        "TransactionSetV1",
        "GeneralizedTransactionSet",
        "TransactionResultPair",
        "TransactionResultSet",
        "TransactionHistoryEntry",
        "TransactionHistoryEntryExt",
        "TransactionHistoryResultEntry",
        "TransactionHistoryResultEntryExt",
        "LedgerHeaderHistoryEntry",
        "LedgerHeaderHistoryEntryExt",
        "LedgerScpMessages",
        "ScpHistoryEntryV0",
        "ScpHistoryEntry",
        "LedgerEntryChangeType",
        "LedgerEntryChange",
        "LedgerEntryChanges",
        "OperationMeta",
        "TransactionMetaV1",
        "TransactionMetaV2",
        "ContractEventType",
        "ContractEvent",
        "ContractEventBody",
        "ContractEventV0",
        "DiagnosticEvent",
        "SorobanTransactionMetaExtV1",
        "SorobanTransactionMetaExt",
        "SorobanTransactionMeta",
        "TransactionMetaV3",
        "InvokeHostFunctionSuccessPreImage",
        "TransactionMeta",
        "TransactionResultMeta",
        "UpgradeEntryMeta",
        "LedgerCloseMetaV0",
        "LedgerCloseMetaExtV1",
        "LedgerCloseMetaExt",
        "LedgerCloseMetaV1",
        "LedgerCloseMeta",
        "ErrorCode",
        "SError",
        "SendMore",
        "SendMoreExtended",
        "AuthCert",
        "Hello",
        "Auth",
        "IpAddrType",
        "PeerAddress",
        "PeerAddressIp",
        "MessageType",
        "DontHave",
        "SurveyMessageCommandType",
        "SurveyMessageResponseType",
        "SurveyRequestMessage",
        "SignedSurveyRequestMessage",
        "EncryptedBody",
        "SurveyResponseMessage",
        "SignedSurveyResponseMessage",
        "PeerStats",
        "PeerStatList",
        "TopologyResponseBodyV0",
        "TopologyResponseBodyV1",
        "SurveyResponseBody",
        "TxAdvertVector",
        "FloodAdvert",
        "TxDemandVector",
        "FloodDemand",
        "StellarMessage",
        "AuthenticatedMessage",
        "AuthenticatedMessageV0",
        "LiquidityPoolParameters",
        "MuxedAccount",
        "MuxedAccountMed25519",
        "DecoratedSignature",
        "OperationType",
        "CreateAccountOp",
        "PaymentOp",
        "PathPaymentStrictReceiveOp",
        "PathPaymentStrictSendOp",
        "ManageSellOfferOp",
        "ManageBuyOfferOp",
        "CreatePassiveSellOfferOp",
        "SetOptionsOp",
        "ChangeTrustAsset",
        "ChangeTrustOp",
        "AllowTrustOp",
        "ManageDataOp",
        "BumpSequenceOp",
        "CreateClaimableBalanceOp",
        "ClaimClaimableBalanceOp",
        "BeginSponsoringFutureReservesOp",
        "RevokeSponsorshipType",
        "RevokeSponsorshipOp",
        "RevokeSponsorshipOpSigner",
        "ClawbackOp",
        "ClawbackClaimableBalanceOp",
        "SetTrustLineFlagsOp",
        "LiquidityPoolDepositOp",
        "LiquidityPoolWithdrawOp",
        "HostFunctionType",
        "ContractIdPreimageType",
        "ContractIdPreimage",
        "ContractIdPreimageFromAddress",
        "CreateContractArgs",
        "InvokeContractArgs",
        "HostFunction",
        "SorobanAuthorizedFunctionType",
        "SorobanAuthorizedFunction",
        "SorobanAuthorizedInvocation",
        "SorobanAddressCredentials",
        "SorobanCredentialsType",
        "SorobanCredentials",
        "SorobanAuthorizationEntry",
        "InvokeHostFunctionOp",
        "ExtendFootprintTtlOp",
        "RestoreFootprintOp",
        "Operation",
        "OperationBody",
        "HashIdPreimage",
        "HashIdPreimageOperationId",
        "HashIdPreimageRevokeId",
        "HashIdPreimageContractId",
        "HashIdPreimageSorobanAuthorization",
        "MemoType",
        "Memo",
        "TimeBounds",
        "LedgerBounds",
        "PreconditionsV2",
        "PreconditionType",
        "Preconditions",
        "LedgerFootprint",
        "SorobanResources",
        "SorobanTransactionData",
        "TransactionV0",
        "TransactionV0Ext",
        "TransactionV0Envelope",
        "Transaction",
        "TransactionExt",
        "TransactionV1Envelope",
        "FeeBumpTransaction",
        "FeeBumpTransactionInnerTx",
        "FeeBumpTransactionExt",
        "FeeBumpTransactionEnvelope",
        "TransactionEnvelope",
        "TransactionSignaturePayload",
        "TransactionSignaturePayloadTaggedTransaction",
        "ClaimAtomType",
        "ClaimOfferAtomV0",
        "ClaimOfferAtom",
        "ClaimLiquidityAtom",
        "ClaimAtom",
        "CreateAccountResultCode",
        "CreateAccountResult",
        "PaymentResultCode",
        "PaymentResult",
        "PathPaymentStrictReceiveResultCode",
        "SimplePaymentResult",
        "PathPaymentStrictReceiveResult",
        "PathPaymentStrictReceiveResultSuccess",
        "PathPaymentStrictSendResultCode",
        "PathPaymentStrictSendResult",
        "PathPaymentStrictSendResultSuccess",
        "ManageSellOfferResultCode",
        "ManageOfferEffect",
        "ManageOfferSuccessResult",
        "ManageOfferSuccessResultOffer",
        "ManageSellOfferResult",
        "ManageBuyOfferResultCode",
        "ManageBuyOfferResult",
        "SetOptionsResultCode",
        "SetOptionsResult",
        "ChangeTrustResultCode",
        "ChangeTrustResult",
        "AllowTrustResultCode",
        "AllowTrustResult",
        "AccountMergeResultCode",
        "AccountMergeResult",
        "InflationResultCode",
        "InflationPayout",
        "InflationResult",
        "ManageDataResultCode",
        "ManageDataResult",
        "BumpSequenceResultCode",
        "BumpSequenceResult",
        "CreateClaimableBalanceResultCode",
        "CreateClaimableBalanceResult",
        "ClaimClaimableBalanceResultCode",
        "ClaimClaimableBalanceResult",
        "BeginSponsoringFutureReservesResultCode",
        "BeginSponsoringFutureReservesResult",
        "EndSponsoringFutureReservesResultCode",
        "EndSponsoringFutureReservesResult",
        "RevokeSponsorshipResultCode",
        "RevokeSponsorshipResult",
        "ClawbackResultCode",
        "ClawbackResult",
        "ClawbackClaimableBalanceResultCode",
        "ClawbackClaimableBalanceResult",
        "SetTrustLineFlagsResultCode",
        "SetTrustLineFlagsResult",
        "LiquidityPoolDepositResultCode",
        "LiquidityPoolDepositResult",
        "LiquidityPoolWithdrawResultCode",
        "LiquidityPoolWithdrawResult",
        "InvokeHostFunctionResultCode",
        "InvokeHostFunctionResult",
        "ExtendFootprintTtlResultCode",
        "ExtendFootprintTtlResult",
        "RestoreFootprintResultCode",
        "RestoreFootprintResult",
        "OperationResultCode",
        "OperationResult",
        "OperationResultTr",
        "TransactionResultCode",
        "InnerTransactionResult",
        "InnerTransactionResultResult",
        "InnerTransactionResultExt",
        "InnerTransactionResultPair",
        "TransactionResult",
        "TransactionResultResult",
        "TransactionResultExt",
        "Hash",
        "Uint256",
        "Uint32",
        "Int32",
        "Uint64",
        "Int64",
        "TimePoint",
        "Duration",
        "ExtensionPoint",
        "CryptoKeyType",
        "PublicKeyType",
        "SignerKeyType",
        "PublicKey",
        "SignerKey",
        "SignerKeyEd25519SignedPayload",
        "Signature",
        "SignatureHint",
        "NodeId",
        "AccountId",
        "Curve25519Secret",
        "Curve25519Public",
        "HmacSha256Key",
        "HmacSha256Mac",
    ];

    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Result<Self> {
        match v {
            TypeVariant::Value => {
                r.with_limited_depth(|r| Ok(Self::Value(Box::new(Value::read_xdr(r)?))))
            }
            TypeVariant::ScpBallot => {
                r.with_limited_depth(|r| Ok(Self::ScpBallot(Box::new(ScpBallot::read_xdr(r)?))))
            }
            TypeVariant::ScpStatementType => r.with_limited_depth(|r| {
                Ok(Self::ScpStatementType(Box::new(
                    ScpStatementType::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScpNomination => r.with_limited_depth(|r| {
                Ok(Self::ScpNomination(Box::new(ScpNomination::read_xdr(r)?)))
            }),
            TypeVariant::ScpStatement => r.with_limited_depth(|r| {
                Ok(Self::ScpStatement(Box::new(ScpStatement::read_xdr(r)?)))
            }),
            TypeVariant::ScpStatementPledges => r.with_limited_depth(|r| {
                Ok(Self::ScpStatementPledges(Box::new(
                    ScpStatementPledges::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScpStatementPrepare => r.with_limited_depth(|r| {
                Ok(Self::ScpStatementPrepare(Box::new(
                    ScpStatementPrepare::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScpStatementConfirm => r.with_limited_depth(|r| {
                Ok(Self::ScpStatementConfirm(Box::new(
                    ScpStatementConfirm::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScpStatementExternalize => r.with_limited_depth(|r| {
                Ok(Self::ScpStatementExternalize(Box::new(
                    ScpStatementExternalize::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScpEnvelope => {
                r.with_limited_depth(|r| Ok(Self::ScpEnvelope(Box::new(ScpEnvelope::read_xdr(r)?))))
            }
            TypeVariant::ScpQuorumSet => r.with_limited_depth(|r| {
                Ok(Self::ScpQuorumSet(Box::new(ScpQuorumSet::read_xdr(r)?)))
            }),
            TypeVariant::ConfigSettingContractExecutionLanesV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractExecutionLanesV0(Box::new(
                    ConfigSettingContractExecutionLanesV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ConfigSettingContractComputeV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractComputeV0(Box::new(
                    ConfigSettingContractComputeV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ConfigSettingContractLedgerCostV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractLedgerCostV0(Box::new(
                    ConfigSettingContractLedgerCostV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ConfigSettingContractHistoricalDataV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractHistoricalDataV0(Box::new(
                    ConfigSettingContractHistoricalDataV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ConfigSettingContractEventsV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractEventsV0(Box::new(
                    ConfigSettingContractEventsV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ConfigSettingContractBandwidthV0 => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingContractBandwidthV0(Box::new(
                    ConfigSettingContractBandwidthV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractCostType => r.with_limited_depth(|r| {
                Ok(Self::ContractCostType(Box::new(
                    ContractCostType::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractCostParamEntry => r.with_limited_depth(|r| {
                Ok(Self::ContractCostParamEntry(Box::new(
                    ContractCostParamEntry::read_xdr(r)?,
                )))
            }),
            TypeVariant::StateArchivalSettings => r.with_limited_depth(|r| {
                Ok(Self::StateArchivalSettings(Box::new(
                    StateArchivalSettings::read_xdr(r)?,
                )))
            }),
            TypeVariant::EvictionIterator => r.with_limited_depth(|r| {
                Ok(Self::EvictionIterator(Box::new(
                    EvictionIterator::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractCostParams => r.with_limited_depth(|r| {
                Ok(Self::ContractCostParams(Box::new(
                    ContractCostParams::read_xdr(r)?,
                )))
            }),
            TypeVariant::ConfigSettingId => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingId(Box::new(ConfigSettingId::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::ConfigSettingEntry => r.with_limited_depth(|r| {
                Ok(Self::ConfigSettingEntry(Box::new(
                    ConfigSettingEntry::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScEnvMetaKind => r.with_limited_depth(|r| {
                Ok(Self::ScEnvMetaKind(Box::new(ScEnvMetaKind::read_xdr(r)?)))
            }),
            TypeVariant::ScEnvMetaEntry => r.with_limited_depth(|r| {
                Ok(Self::ScEnvMetaEntry(Box::new(ScEnvMetaEntry::read_xdr(r)?)))
            }),
            TypeVariant::ScMetaV0 => {
                r.with_limited_depth(|r| Ok(Self::ScMetaV0(Box::new(ScMetaV0::read_xdr(r)?))))
            }
            TypeVariant::ScMetaKind => {
                r.with_limited_depth(|r| Ok(Self::ScMetaKind(Box::new(ScMetaKind::read_xdr(r)?))))
            }
            TypeVariant::ScMetaEntry => {
                r.with_limited_depth(|r| Ok(Self::ScMetaEntry(Box::new(ScMetaEntry::read_xdr(r)?))))
            }
            TypeVariant::ScSpecType => {
                r.with_limited_depth(|r| Ok(Self::ScSpecType(Box::new(ScSpecType::read_xdr(r)?))))
            }
            TypeVariant::ScSpecTypeOption => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeOption(Box::new(
                    ScSpecTypeOption::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecTypeResult => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeResult(Box::new(
                    ScSpecTypeResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecTypeVec => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeVec(Box::new(ScSpecTypeVec::read_xdr(r)?)))
            }),
            TypeVariant::ScSpecTypeMap => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeMap(Box::new(ScSpecTypeMap::read_xdr(r)?)))
            }),
            TypeVariant::ScSpecTypeTuple => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeTuple(Box::new(ScSpecTypeTuple::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::ScSpecTypeBytesN => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeBytesN(Box::new(
                    ScSpecTypeBytesN::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecTypeUdt => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeUdt(Box::new(ScSpecTypeUdt::read_xdr(r)?)))
            }),
            TypeVariant::ScSpecTypeDef => r.with_limited_depth(|r| {
                Ok(Self::ScSpecTypeDef(Box::new(ScSpecTypeDef::read_xdr(r)?)))
            }),
            TypeVariant::ScSpecUdtStructFieldV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtStructFieldV0(Box::new(
                    ScSpecUdtStructFieldV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecUdtStructV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtStructV0(Box::new(
                    ScSpecUdtStructV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecUdtUnionCaseVoidV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtUnionCaseVoidV0(Box::new(
                    ScSpecUdtUnionCaseVoidV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecUdtUnionCaseTupleV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtUnionCaseTupleV0(Box::new(
                    ScSpecUdtUnionCaseTupleV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecUdtUnionCaseV0Kind => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtUnionCaseV0Kind(Box::new(
                    ScSpecUdtUnionCaseV0Kind::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecUdtUnionCaseV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtUnionCaseV0(Box::new(
                    ScSpecUdtUnionCaseV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecUdtUnionV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtUnionV0(Box::new(
                    ScSpecUdtUnionV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecUdtEnumCaseV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtEnumCaseV0(Box::new(
                    ScSpecUdtEnumCaseV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecUdtEnumV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtEnumV0(Box::new(ScSpecUdtEnumV0::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::ScSpecUdtErrorEnumCaseV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtErrorEnumCaseV0(Box::new(
                    ScSpecUdtErrorEnumCaseV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecUdtErrorEnumV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecUdtErrorEnumV0(Box::new(
                    ScSpecUdtErrorEnumV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecFunctionInputV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecFunctionInputV0(Box::new(
                    ScSpecFunctionInputV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecFunctionV0 => r.with_limited_depth(|r| {
                Ok(Self::ScSpecFunctionV0(Box::new(
                    ScSpecFunctionV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScSpecEntryKind => r.with_limited_depth(|r| {
                Ok(Self::ScSpecEntryKind(Box::new(ScSpecEntryKind::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::ScSpecEntry => {
                r.with_limited_depth(|r| Ok(Self::ScSpecEntry(Box::new(ScSpecEntry::read_xdr(r)?))))
            }
            TypeVariant::ScValType => {
                r.with_limited_depth(|r| Ok(Self::ScValType(Box::new(ScValType::read_xdr(r)?))))
            }
            TypeVariant::ScErrorType => {
                r.with_limited_depth(|r| Ok(Self::ScErrorType(Box::new(ScErrorType::read_xdr(r)?))))
            }
            TypeVariant::ScErrorCode => {
                r.with_limited_depth(|r| Ok(Self::ScErrorCode(Box::new(ScErrorCode::read_xdr(r)?))))
            }
            TypeVariant::ScError => {
                r.with_limited_depth(|r| Ok(Self::ScError(Box::new(ScError::read_xdr(r)?))))
            }
            TypeVariant::UInt128Parts => r.with_limited_depth(|r| {
                Ok(Self::UInt128Parts(Box::new(UInt128Parts::read_xdr(r)?)))
            }),
            TypeVariant::Int128Parts => {
                r.with_limited_depth(|r| Ok(Self::Int128Parts(Box::new(Int128Parts::read_xdr(r)?))))
            }
            TypeVariant::UInt256Parts => r.with_limited_depth(|r| {
                Ok(Self::UInt256Parts(Box::new(UInt256Parts::read_xdr(r)?)))
            }),
            TypeVariant::Int256Parts => {
                r.with_limited_depth(|r| Ok(Self::Int256Parts(Box::new(Int256Parts::read_xdr(r)?))))
            }
            TypeVariant::ContractExecutableType => r.with_limited_depth(|r| {
                Ok(Self::ContractExecutableType(Box::new(
                    ContractExecutableType::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractExecutable => r.with_limited_depth(|r| {
                Ok(Self::ContractExecutable(Box::new(
                    ContractExecutable::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScAddressType => r.with_limited_depth(|r| {
                Ok(Self::ScAddressType(Box::new(ScAddressType::read_xdr(r)?)))
            }),
            TypeVariant::ScAddress => {
                r.with_limited_depth(|r| Ok(Self::ScAddress(Box::new(ScAddress::read_xdr(r)?))))
            }
            TypeVariant::ScVec => {
                r.with_limited_depth(|r| Ok(Self::ScVec(Box::new(ScVec::read_xdr(r)?))))
            }
            TypeVariant::ScMap => {
                r.with_limited_depth(|r| Ok(Self::ScMap(Box::new(ScMap::read_xdr(r)?))))
            }
            TypeVariant::ScBytes => {
                r.with_limited_depth(|r| Ok(Self::ScBytes(Box::new(ScBytes::read_xdr(r)?))))
            }
            TypeVariant::ScString => {
                r.with_limited_depth(|r| Ok(Self::ScString(Box::new(ScString::read_xdr(r)?))))
            }
            TypeVariant::ScSymbol => {
                r.with_limited_depth(|r| Ok(Self::ScSymbol(Box::new(ScSymbol::read_xdr(r)?))))
            }
            TypeVariant::ScNonceKey => {
                r.with_limited_depth(|r| Ok(Self::ScNonceKey(Box::new(ScNonceKey::read_xdr(r)?))))
            }
            TypeVariant::ScContractInstance => r.with_limited_depth(|r| {
                Ok(Self::ScContractInstance(Box::new(
                    ScContractInstance::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScVal => {
                r.with_limited_depth(|r| Ok(Self::ScVal(Box::new(ScVal::read_xdr(r)?))))
            }
            TypeVariant::ScMapEntry => {
                r.with_limited_depth(|r| Ok(Self::ScMapEntry(Box::new(ScMapEntry::read_xdr(r)?))))
            }
            TypeVariant::StoredTransactionSet => r.with_limited_depth(|r| {
                Ok(Self::StoredTransactionSet(Box::new(
                    StoredTransactionSet::read_xdr(r)?,
                )))
            }),
            TypeVariant::StoredDebugTransactionSet => r.with_limited_depth(|r| {
                Ok(Self::StoredDebugTransactionSet(Box::new(
                    StoredDebugTransactionSet::read_xdr(r)?,
                )))
            }),
            TypeVariant::PersistedScpStateV0 => r.with_limited_depth(|r| {
                Ok(Self::PersistedScpStateV0(Box::new(
                    PersistedScpStateV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::PersistedScpStateV1 => r.with_limited_depth(|r| {
                Ok(Self::PersistedScpStateV1(Box::new(
                    PersistedScpStateV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::PersistedScpState => r.with_limited_depth(|r| {
                Ok(Self::PersistedScpState(Box::new(
                    PersistedScpState::read_xdr(r)?,
                )))
            }),
            TypeVariant::Thresholds => {
                r.with_limited_depth(|r| Ok(Self::Thresholds(Box::new(Thresholds::read_xdr(r)?))))
            }
            TypeVariant::String32 => {
                r.with_limited_depth(|r| Ok(Self::String32(Box::new(String32::read_xdr(r)?))))
            }
            TypeVariant::String64 => {
                r.with_limited_depth(|r| Ok(Self::String64(Box::new(String64::read_xdr(r)?))))
            }
            TypeVariant::SequenceNumber => r.with_limited_depth(|r| {
                Ok(Self::SequenceNumber(Box::new(SequenceNumber::read_xdr(r)?)))
            }),
            TypeVariant::DataValue => {
                r.with_limited_depth(|r| Ok(Self::DataValue(Box::new(DataValue::read_xdr(r)?))))
            }
            TypeVariant::PoolId => {
                r.with_limited_depth(|r| Ok(Self::PoolId(Box::new(PoolId::read_xdr(r)?))))
            }
            TypeVariant::AssetCode4 => {
                r.with_limited_depth(|r| Ok(Self::AssetCode4(Box::new(AssetCode4::read_xdr(r)?))))
            }
            TypeVariant::AssetCode12 => {
                r.with_limited_depth(|r| Ok(Self::AssetCode12(Box::new(AssetCode12::read_xdr(r)?))))
            }
            TypeVariant::AssetType => {
                r.with_limited_depth(|r| Ok(Self::AssetType(Box::new(AssetType::read_xdr(r)?))))
            }
            TypeVariant::AssetCode => {
                r.with_limited_depth(|r| Ok(Self::AssetCode(Box::new(AssetCode::read_xdr(r)?))))
            }
            TypeVariant::AlphaNum4 => {
                r.with_limited_depth(|r| Ok(Self::AlphaNum4(Box::new(AlphaNum4::read_xdr(r)?))))
            }
            TypeVariant::AlphaNum12 => {
                r.with_limited_depth(|r| Ok(Self::AlphaNum12(Box::new(AlphaNum12::read_xdr(r)?))))
            }
            TypeVariant::Asset => {
                r.with_limited_depth(|r| Ok(Self::Asset(Box::new(Asset::read_xdr(r)?))))
            }
            TypeVariant::Price => {
                r.with_limited_depth(|r| Ok(Self::Price(Box::new(Price::read_xdr(r)?))))
            }
            TypeVariant::Liabilities => {
                r.with_limited_depth(|r| Ok(Self::Liabilities(Box::new(Liabilities::read_xdr(r)?))))
            }
            TypeVariant::ThresholdIndexes => r.with_limited_depth(|r| {
                Ok(Self::ThresholdIndexes(Box::new(
                    ThresholdIndexes::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerEntryType => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryType(Box::new(LedgerEntryType::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::Signer => {
                r.with_limited_depth(|r| Ok(Self::Signer(Box::new(Signer::read_xdr(r)?))))
            }
            TypeVariant::AccountFlags => r.with_limited_depth(|r| {
                Ok(Self::AccountFlags(Box::new(AccountFlags::read_xdr(r)?)))
            }),
            TypeVariant::SponsorshipDescriptor => r.with_limited_depth(|r| {
                Ok(Self::SponsorshipDescriptor(Box::new(
                    SponsorshipDescriptor::read_xdr(r)?,
                )))
            }),
            TypeVariant::AccountEntryExtensionV3 => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExtensionV3(Box::new(
                    AccountEntryExtensionV3::read_xdr(r)?,
                )))
            }),
            TypeVariant::AccountEntryExtensionV2 => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExtensionV2(Box::new(
                    AccountEntryExtensionV2::read_xdr(r)?,
                )))
            }),
            TypeVariant::AccountEntryExtensionV2Ext => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExtensionV2Ext(Box::new(
                    AccountEntryExtensionV2Ext::read_xdr(r)?,
                )))
            }),
            TypeVariant::AccountEntryExtensionV1 => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExtensionV1(Box::new(
                    AccountEntryExtensionV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::AccountEntryExtensionV1Ext => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExtensionV1Ext(Box::new(
                    AccountEntryExtensionV1Ext::read_xdr(r)?,
                )))
            }),
            TypeVariant::AccountEntry => r.with_limited_depth(|r| {
                Ok(Self::AccountEntry(Box::new(AccountEntry::read_xdr(r)?)))
            }),
            TypeVariant::AccountEntryExt => r.with_limited_depth(|r| {
                Ok(Self::AccountEntryExt(Box::new(AccountEntryExt::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::TrustLineFlags => r.with_limited_depth(|r| {
                Ok(Self::TrustLineFlags(Box::new(TrustLineFlags::read_xdr(r)?)))
            }),
            TypeVariant::LiquidityPoolType => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolType(Box::new(
                    LiquidityPoolType::read_xdr(r)?,
                )))
            }),
            TypeVariant::TrustLineAsset => r.with_limited_depth(|r| {
                Ok(Self::TrustLineAsset(Box::new(TrustLineAsset::read_xdr(r)?)))
            }),
            TypeVariant::TrustLineEntryExtensionV2 => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntryExtensionV2(Box::new(
                    TrustLineEntryExtensionV2::read_xdr(r)?,
                )))
            }),
            TypeVariant::TrustLineEntryExtensionV2Ext => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntryExtensionV2Ext(Box::new(
                    TrustLineEntryExtensionV2Ext::read_xdr(r)?,
                )))
            }),
            TypeVariant::TrustLineEntry => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntry(Box::new(TrustLineEntry::read_xdr(r)?)))
            }),
            TypeVariant::TrustLineEntryExt => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntryExt(Box::new(
                    TrustLineEntryExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::TrustLineEntryV1 => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntryV1(Box::new(
                    TrustLineEntryV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::TrustLineEntryV1Ext => r.with_limited_depth(|r| {
                Ok(Self::TrustLineEntryV1Ext(Box::new(
                    TrustLineEntryV1Ext::read_xdr(r)?,
                )))
            }),
            TypeVariant::OfferEntryFlags => r.with_limited_depth(|r| {
                Ok(Self::OfferEntryFlags(Box::new(OfferEntryFlags::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::OfferEntry => {
                r.with_limited_depth(|r| Ok(Self::OfferEntry(Box::new(OfferEntry::read_xdr(r)?))))
            }
            TypeVariant::OfferEntryExt => r.with_limited_depth(|r| {
                Ok(Self::OfferEntryExt(Box::new(OfferEntryExt::read_xdr(r)?)))
            }),
            TypeVariant::DataEntry => {
                r.with_limited_depth(|r| Ok(Self::DataEntry(Box::new(DataEntry::read_xdr(r)?))))
            }
            TypeVariant::DataEntryExt => r.with_limited_depth(|r| {
                Ok(Self::DataEntryExt(Box::new(DataEntryExt::read_xdr(r)?)))
            }),
            TypeVariant::ClaimPredicateType => r.with_limited_depth(|r| {
                Ok(Self::ClaimPredicateType(Box::new(
                    ClaimPredicateType::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimPredicate => r.with_limited_depth(|r| {
                Ok(Self::ClaimPredicate(Box::new(ClaimPredicate::read_xdr(r)?)))
            }),
            TypeVariant::ClaimantType => r.with_limited_depth(|r| {
                Ok(Self::ClaimantType(Box::new(ClaimantType::read_xdr(r)?)))
            }),
            TypeVariant::Claimant => {
                r.with_limited_depth(|r| Ok(Self::Claimant(Box::new(Claimant::read_xdr(r)?))))
            }
            TypeVariant::ClaimantV0 => {
                r.with_limited_depth(|r| Ok(Self::ClaimantV0(Box::new(ClaimantV0::read_xdr(r)?))))
            }
            TypeVariant::ClaimableBalanceIdType => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceIdType(Box::new(
                    ClaimableBalanceIdType::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimableBalanceId => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceId(Box::new(
                    ClaimableBalanceId::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimableBalanceFlags => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceFlags(Box::new(
                    ClaimableBalanceFlags::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimableBalanceEntryExtensionV1 => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceEntryExtensionV1(Box::new(
                    ClaimableBalanceEntryExtensionV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(
                    ClaimableBalanceEntryExtensionV1Ext::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimableBalanceEntry => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceEntry(Box::new(
                    ClaimableBalanceEntry::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimableBalanceEntryExt => r.with_limited_depth(|r| {
                Ok(Self::ClaimableBalanceEntryExt(Box::new(
                    ClaimableBalanceEntryExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::LiquidityPoolConstantProductParameters => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolConstantProductParameters(Box::new(
                    LiquidityPoolConstantProductParameters::read_xdr(r)?,
                )))
            }),
            TypeVariant::LiquidityPoolEntry => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolEntry(Box::new(
                    LiquidityPoolEntry::read_xdr(r)?,
                )))
            }),
            TypeVariant::LiquidityPoolEntryBody => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolEntryBody(Box::new(
                    LiquidityPoolEntryBody::read_xdr(r)?,
                )))
            }),
            TypeVariant::LiquidityPoolEntryConstantProduct => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolEntryConstantProduct(Box::new(
                    LiquidityPoolEntryConstantProduct::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractDataDurability => r.with_limited_depth(|r| {
                Ok(Self::ContractDataDurability(Box::new(
                    ContractDataDurability::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractDataEntry => r.with_limited_depth(|r| {
                Ok(Self::ContractDataEntry(Box::new(
                    ContractDataEntry::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractCodeCostInputs => r.with_limited_depth(|r| {
                Ok(Self::ContractCodeCostInputs(Box::new(
                    ContractCodeCostInputs::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractCodeEntry => r.with_limited_depth(|r| {
                Ok(Self::ContractCodeEntry(Box::new(
                    ContractCodeEntry::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractCodeEntryExt => r.with_limited_depth(|r| {
                Ok(Self::ContractCodeEntryExt(Box::new(
                    ContractCodeEntryExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractCodeEntryV1 => r.with_limited_depth(|r| {
                Ok(Self::ContractCodeEntryV1(Box::new(
                    ContractCodeEntryV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::TtlEntry => {
                r.with_limited_depth(|r| Ok(Self::TtlEntry(Box::new(TtlEntry::read_xdr(r)?))))
            }
            TypeVariant::LedgerEntryExtensionV1 => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryExtensionV1(Box::new(
                    LedgerEntryExtensionV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerEntryExtensionV1Ext => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryExtensionV1Ext(Box::new(
                    LedgerEntryExtensionV1Ext::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerEntry => {
                r.with_limited_depth(|r| Ok(Self::LedgerEntry(Box::new(LedgerEntry::read_xdr(r)?))))
            }
            TypeVariant::LedgerEntryData => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryData(Box::new(LedgerEntryData::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::LedgerEntryExt => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryExt(Box::new(LedgerEntryExt::read_xdr(r)?)))
            }),
            TypeVariant::LedgerKey => {
                r.with_limited_depth(|r| Ok(Self::LedgerKey(Box::new(LedgerKey::read_xdr(r)?))))
            }
            TypeVariant::LedgerKeyAccount => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyAccount(Box::new(
                    LedgerKeyAccount::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerKeyTrustLine => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyTrustLine(Box::new(
                    LedgerKeyTrustLine::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerKeyOffer => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyOffer(Box::new(LedgerKeyOffer::read_xdr(r)?)))
            }),
            TypeVariant::LedgerKeyData => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyData(Box::new(LedgerKeyData::read_xdr(r)?)))
            }),
            TypeVariant::LedgerKeyClaimableBalance => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyClaimableBalance(Box::new(
                    LedgerKeyClaimableBalance::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerKeyLiquidityPool => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyLiquidityPool(Box::new(
                    LedgerKeyLiquidityPool::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerKeyContractData => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyContractData(Box::new(
                    LedgerKeyContractData::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerKeyContractCode => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyContractCode(Box::new(
                    LedgerKeyContractCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerKeyConfigSetting => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyConfigSetting(Box::new(
                    LedgerKeyConfigSetting::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerKeyTtl => r.with_limited_depth(|r| {
                Ok(Self::LedgerKeyTtl(Box::new(LedgerKeyTtl::read_xdr(r)?)))
            }),
            TypeVariant::EnvelopeType => r.with_limited_depth(|r| {
                Ok(Self::EnvelopeType(Box::new(EnvelopeType::read_xdr(r)?)))
            }),
            TypeVariant::UpgradeType => {
                r.with_limited_depth(|r| Ok(Self::UpgradeType(Box::new(UpgradeType::read_xdr(r)?))))
            }
            TypeVariant::StellarValueType => r.with_limited_depth(|r| {
                Ok(Self::StellarValueType(Box::new(
                    StellarValueType::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerCloseValueSignature => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseValueSignature(Box::new(
                    LedgerCloseValueSignature::read_xdr(r)?,
                )))
            }),
            TypeVariant::StellarValue => r.with_limited_depth(|r| {
                Ok(Self::StellarValue(Box::new(StellarValue::read_xdr(r)?)))
            }),
            TypeVariant::StellarValueExt => r.with_limited_depth(|r| {
                Ok(Self::StellarValueExt(Box::new(StellarValueExt::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::LedgerHeaderFlags => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderFlags(Box::new(
                    LedgerHeaderFlags::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerHeaderExtensionV1 => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderExtensionV1(Box::new(
                    LedgerHeaderExtensionV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerHeaderExtensionV1Ext => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderExtensionV1Ext(Box::new(
                    LedgerHeaderExtensionV1Ext::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerHeader => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeader(Box::new(LedgerHeader::read_xdr(r)?)))
            }),
            TypeVariant::LedgerHeaderExt => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderExt(Box::new(LedgerHeaderExt::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::LedgerUpgradeType => r.with_limited_depth(|r| {
                Ok(Self::LedgerUpgradeType(Box::new(
                    LedgerUpgradeType::read_xdr(r)?,
                )))
            }),
            TypeVariant::ConfigUpgradeSetKey => r.with_limited_depth(|r| {
                Ok(Self::ConfigUpgradeSetKey(Box::new(
                    ConfigUpgradeSetKey::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerUpgrade => r.with_limited_depth(|r| {
                Ok(Self::LedgerUpgrade(Box::new(LedgerUpgrade::read_xdr(r)?)))
            }),
            TypeVariant::ConfigUpgradeSet => r.with_limited_depth(|r| {
                Ok(Self::ConfigUpgradeSet(Box::new(
                    ConfigUpgradeSet::read_xdr(r)?,
                )))
            }),
            TypeVariant::BucketEntryType => r.with_limited_depth(|r| {
                Ok(Self::BucketEntryType(Box::new(BucketEntryType::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::BucketMetadata => r.with_limited_depth(|r| {
                Ok(Self::BucketMetadata(Box::new(BucketMetadata::read_xdr(r)?)))
            }),
            TypeVariant::BucketMetadataExt => r.with_limited_depth(|r| {
                Ok(Self::BucketMetadataExt(Box::new(
                    BucketMetadataExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::BucketEntry => {
                r.with_limited_depth(|r| Ok(Self::BucketEntry(Box::new(BucketEntry::read_xdr(r)?))))
            }
            TypeVariant::TxSetComponentType => r.with_limited_depth(|r| {
                Ok(Self::TxSetComponentType(Box::new(
                    TxSetComponentType::read_xdr(r)?,
                )))
            }),
            TypeVariant::TxSetComponent => r.with_limited_depth(|r| {
                Ok(Self::TxSetComponent(Box::new(TxSetComponent::read_xdr(r)?)))
            }),
            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => r.with_limited_depth(|r| {
                Ok(Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(
                    TxSetComponentTxsMaybeDiscountedFee::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionPhase => r.with_limited_depth(|r| {
                Ok(Self::TransactionPhase(Box::new(
                    TransactionPhase::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionSet => r.with_limited_depth(|r| {
                Ok(Self::TransactionSet(Box::new(TransactionSet::read_xdr(r)?)))
            }),
            TypeVariant::TransactionSetV1 => r.with_limited_depth(|r| {
                Ok(Self::TransactionSetV1(Box::new(
                    TransactionSetV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::GeneralizedTransactionSet => r.with_limited_depth(|r| {
                Ok(Self::GeneralizedTransactionSet(Box::new(
                    GeneralizedTransactionSet::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionResultPair => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultPair(Box::new(
                    TransactionResultPair::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionResultSet => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultSet(Box::new(
                    TransactionResultSet::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionHistoryEntry => r.with_limited_depth(|r| {
                Ok(Self::TransactionHistoryEntry(Box::new(
                    TransactionHistoryEntry::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionHistoryEntryExt => r.with_limited_depth(|r| {
                Ok(Self::TransactionHistoryEntryExt(Box::new(
                    TransactionHistoryEntryExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionHistoryResultEntry => r.with_limited_depth(|r| {
                Ok(Self::TransactionHistoryResultEntry(Box::new(
                    TransactionHistoryResultEntry::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionHistoryResultEntryExt => r.with_limited_depth(|r| {
                Ok(Self::TransactionHistoryResultEntryExt(Box::new(
                    TransactionHistoryResultEntryExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerHeaderHistoryEntry => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderHistoryEntry(Box::new(
                    LedgerHeaderHistoryEntry::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerHeaderHistoryEntryExt => r.with_limited_depth(|r| {
                Ok(Self::LedgerHeaderHistoryEntryExt(Box::new(
                    LedgerHeaderHistoryEntryExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerScpMessages => r.with_limited_depth(|r| {
                Ok(Self::LedgerScpMessages(Box::new(
                    LedgerScpMessages::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScpHistoryEntryV0 => r.with_limited_depth(|r| {
                Ok(Self::ScpHistoryEntryV0(Box::new(
                    ScpHistoryEntryV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ScpHistoryEntry => r.with_limited_depth(|r| {
                Ok(Self::ScpHistoryEntry(Box::new(ScpHistoryEntry::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::LedgerEntryChangeType => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryChangeType(Box::new(
                    LedgerEntryChangeType::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerEntryChange => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryChange(Box::new(
                    LedgerEntryChange::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerEntryChanges => r.with_limited_depth(|r| {
                Ok(Self::LedgerEntryChanges(Box::new(
                    LedgerEntryChanges::read_xdr(r)?,
                )))
            }),
            TypeVariant::OperationMeta => r.with_limited_depth(|r| {
                Ok(Self::OperationMeta(Box::new(OperationMeta::read_xdr(r)?)))
            }),
            TypeVariant::TransactionMetaV1 => r.with_limited_depth(|r| {
                Ok(Self::TransactionMetaV1(Box::new(
                    TransactionMetaV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionMetaV2 => r.with_limited_depth(|r| {
                Ok(Self::TransactionMetaV2(Box::new(
                    TransactionMetaV2::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractEventType => r.with_limited_depth(|r| {
                Ok(Self::ContractEventType(Box::new(
                    ContractEventType::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractEvent => r.with_limited_depth(|r| {
                Ok(Self::ContractEvent(Box::new(ContractEvent::read_xdr(r)?)))
            }),
            TypeVariant::ContractEventBody => r.with_limited_depth(|r| {
                Ok(Self::ContractEventBody(Box::new(
                    ContractEventBody::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractEventV0 => r.with_limited_depth(|r| {
                Ok(Self::ContractEventV0(Box::new(ContractEventV0::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::DiagnosticEvent => r.with_limited_depth(|r| {
                Ok(Self::DiagnosticEvent(Box::new(DiagnosticEvent::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::SorobanTransactionMetaExtV1 => r.with_limited_depth(|r| {
                Ok(Self::SorobanTransactionMetaExtV1(Box::new(
                    SorobanTransactionMetaExtV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::SorobanTransactionMetaExt => r.with_limited_depth(|r| {
                Ok(Self::SorobanTransactionMetaExt(Box::new(
                    SorobanTransactionMetaExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::SorobanTransactionMeta => r.with_limited_depth(|r| {
                Ok(Self::SorobanTransactionMeta(Box::new(
                    SorobanTransactionMeta::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionMetaV3 => r.with_limited_depth(|r| {
                Ok(Self::TransactionMetaV3(Box::new(
                    TransactionMetaV3::read_xdr(r)?,
                )))
            }),
            TypeVariant::InvokeHostFunctionSuccessPreImage => r.with_limited_depth(|r| {
                Ok(Self::InvokeHostFunctionSuccessPreImage(Box::new(
                    InvokeHostFunctionSuccessPreImage::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionMeta => r.with_limited_depth(|r| {
                Ok(Self::TransactionMeta(Box::new(TransactionMeta::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::TransactionResultMeta => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultMeta(Box::new(
                    TransactionResultMeta::read_xdr(r)?,
                )))
            }),
            TypeVariant::UpgradeEntryMeta => r.with_limited_depth(|r| {
                Ok(Self::UpgradeEntryMeta(Box::new(
                    UpgradeEntryMeta::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerCloseMetaV0 => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMetaV0(Box::new(
                    LedgerCloseMetaV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerCloseMetaExtV1 => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMetaExtV1(Box::new(
                    LedgerCloseMetaExtV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerCloseMetaExt => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMetaExt(Box::new(
                    LedgerCloseMetaExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerCloseMetaV1 => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMetaV1(Box::new(
                    LedgerCloseMetaV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::LedgerCloseMeta => r.with_limited_depth(|r| {
                Ok(Self::LedgerCloseMeta(Box::new(LedgerCloseMeta::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::ErrorCode => {
                r.with_limited_depth(|r| Ok(Self::ErrorCode(Box::new(ErrorCode::read_xdr(r)?))))
            }
            TypeVariant::SError => {
                r.with_limited_depth(|r| Ok(Self::SError(Box::new(SError::read_xdr(r)?))))
            }
            TypeVariant::SendMore => {
                r.with_limited_depth(|r| Ok(Self::SendMore(Box::new(SendMore::read_xdr(r)?))))
            }
            TypeVariant::SendMoreExtended => r.with_limited_depth(|r| {
                Ok(Self::SendMoreExtended(Box::new(
                    SendMoreExtended::read_xdr(r)?,
                )))
            }),
            TypeVariant::AuthCert => {
                r.with_limited_depth(|r| Ok(Self::AuthCert(Box::new(AuthCert::read_xdr(r)?))))
            }
            TypeVariant::Hello => {
                r.with_limited_depth(|r| Ok(Self::Hello(Box::new(Hello::read_xdr(r)?))))
            }
            TypeVariant::Auth => {
                r.with_limited_depth(|r| Ok(Self::Auth(Box::new(Auth::read_xdr(r)?))))
            }
            TypeVariant::IpAddrType => {
                r.with_limited_depth(|r| Ok(Self::IpAddrType(Box::new(IpAddrType::read_xdr(r)?))))
            }
            TypeVariant::PeerAddress => {
                r.with_limited_depth(|r| Ok(Self::PeerAddress(Box::new(PeerAddress::read_xdr(r)?))))
            }
            TypeVariant::PeerAddressIp => r.with_limited_depth(|r| {
                Ok(Self::PeerAddressIp(Box::new(PeerAddressIp::read_xdr(r)?)))
            }),
            TypeVariant::MessageType => {
                r.with_limited_depth(|r| Ok(Self::MessageType(Box::new(MessageType::read_xdr(r)?))))
            }
            TypeVariant::DontHave => {
                r.with_limited_depth(|r| Ok(Self::DontHave(Box::new(DontHave::read_xdr(r)?))))
            }
            TypeVariant::SurveyMessageCommandType => r.with_limited_depth(|r| {
                Ok(Self::SurveyMessageCommandType(Box::new(
                    SurveyMessageCommandType::read_xdr(r)?,
                )))
            }),
            TypeVariant::SurveyMessageResponseType => r.with_limited_depth(|r| {
                Ok(Self::SurveyMessageResponseType(Box::new(
                    SurveyMessageResponseType::read_xdr(r)?,
                )))
            }),
            TypeVariant::SurveyRequestMessage => r.with_limited_depth(|r| {
                Ok(Self::SurveyRequestMessage(Box::new(
                    SurveyRequestMessage::read_xdr(r)?,
                )))
            }),
            TypeVariant::SignedSurveyRequestMessage => r.with_limited_depth(|r| {
                Ok(Self::SignedSurveyRequestMessage(Box::new(
                    SignedSurveyRequestMessage::read_xdr(r)?,
                )))
            }),
            TypeVariant::EncryptedBody => r.with_limited_depth(|r| {
                Ok(Self::EncryptedBody(Box::new(EncryptedBody::read_xdr(r)?)))
            }),
            TypeVariant::SurveyResponseMessage => r.with_limited_depth(|r| {
                Ok(Self::SurveyResponseMessage(Box::new(
                    SurveyResponseMessage::read_xdr(r)?,
                )))
            }),
            TypeVariant::SignedSurveyResponseMessage => r.with_limited_depth(|r| {
                Ok(Self::SignedSurveyResponseMessage(Box::new(
                    SignedSurveyResponseMessage::read_xdr(r)?,
                )))
            }),
            TypeVariant::PeerStats => {
                r.with_limited_depth(|r| Ok(Self::PeerStats(Box::new(PeerStats::read_xdr(r)?))))
            }
            TypeVariant::PeerStatList => r.with_limited_depth(|r| {
                Ok(Self::PeerStatList(Box::new(PeerStatList::read_xdr(r)?)))
            }),
            TypeVariant::TopologyResponseBodyV0 => r.with_limited_depth(|r| {
                Ok(Self::TopologyResponseBodyV0(Box::new(
                    TopologyResponseBodyV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::TopologyResponseBodyV1 => r.with_limited_depth(|r| {
                Ok(Self::TopologyResponseBodyV1(Box::new(
                    TopologyResponseBodyV1::read_xdr(r)?,
                )))
            }),
            TypeVariant::SurveyResponseBody => r.with_limited_depth(|r| {
                Ok(Self::SurveyResponseBody(Box::new(
                    SurveyResponseBody::read_xdr(r)?,
                )))
            }),
            TypeVariant::TxAdvertVector => r.with_limited_depth(|r| {
                Ok(Self::TxAdvertVector(Box::new(TxAdvertVector::read_xdr(r)?)))
            }),
            TypeVariant::FloodAdvert => {
                r.with_limited_depth(|r| Ok(Self::FloodAdvert(Box::new(FloodAdvert::read_xdr(r)?))))
            }
            TypeVariant::TxDemandVector => r.with_limited_depth(|r| {
                Ok(Self::TxDemandVector(Box::new(TxDemandVector::read_xdr(r)?)))
            }),
            TypeVariant::FloodDemand => {
                r.with_limited_depth(|r| Ok(Self::FloodDemand(Box::new(FloodDemand::read_xdr(r)?))))
            }
            TypeVariant::StellarMessage => r.with_limited_depth(|r| {
                Ok(Self::StellarMessage(Box::new(StellarMessage::read_xdr(r)?)))
            }),
            TypeVariant::AuthenticatedMessage => r.with_limited_depth(|r| {
                Ok(Self::AuthenticatedMessage(Box::new(
                    AuthenticatedMessage::read_xdr(r)?,
                )))
            }),
            TypeVariant::AuthenticatedMessageV0 => r.with_limited_depth(|r| {
                Ok(Self::AuthenticatedMessageV0(Box::new(
                    AuthenticatedMessageV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::LiquidityPoolParameters => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolParameters(Box::new(
                    LiquidityPoolParameters::read_xdr(r)?,
                )))
            }),
            TypeVariant::MuxedAccount => r.with_limited_depth(|r| {
                Ok(Self::MuxedAccount(Box::new(MuxedAccount::read_xdr(r)?)))
            }),
            TypeVariant::MuxedAccountMed25519 => r.with_limited_depth(|r| {
                Ok(Self::MuxedAccountMed25519(Box::new(
                    MuxedAccountMed25519::read_xdr(r)?,
                )))
            }),
            TypeVariant::DecoratedSignature => r.with_limited_depth(|r| {
                Ok(Self::DecoratedSignature(Box::new(
                    DecoratedSignature::read_xdr(r)?,
                )))
            }),
            TypeVariant::OperationType => r.with_limited_depth(|r| {
                Ok(Self::OperationType(Box::new(OperationType::read_xdr(r)?)))
            }),
            TypeVariant::CreateAccountOp => r.with_limited_depth(|r| {
                Ok(Self::CreateAccountOp(Box::new(CreateAccountOp::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::PaymentOp => {
                r.with_limited_depth(|r| Ok(Self::PaymentOp(Box::new(PaymentOp::read_xdr(r)?))))
            }
            TypeVariant::PathPaymentStrictReceiveOp => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictReceiveOp(Box::new(
                    PathPaymentStrictReceiveOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::PathPaymentStrictSendOp => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictSendOp(Box::new(
                    PathPaymentStrictSendOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::ManageSellOfferOp => r.with_limited_depth(|r| {
                Ok(Self::ManageSellOfferOp(Box::new(
                    ManageSellOfferOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::ManageBuyOfferOp => r.with_limited_depth(|r| {
                Ok(Self::ManageBuyOfferOp(Box::new(
                    ManageBuyOfferOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::CreatePassiveSellOfferOp => r.with_limited_depth(|r| {
                Ok(Self::CreatePassiveSellOfferOp(Box::new(
                    CreatePassiveSellOfferOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::SetOptionsOp => r.with_limited_depth(|r| {
                Ok(Self::SetOptionsOp(Box::new(SetOptionsOp::read_xdr(r)?)))
            }),
            TypeVariant::ChangeTrustAsset => r.with_limited_depth(|r| {
                Ok(Self::ChangeTrustAsset(Box::new(
                    ChangeTrustAsset::read_xdr(r)?,
                )))
            }),
            TypeVariant::ChangeTrustOp => r.with_limited_depth(|r| {
                Ok(Self::ChangeTrustOp(Box::new(ChangeTrustOp::read_xdr(r)?)))
            }),
            TypeVariant::AllowTrustOp => r.with_limited_depth(|r| {
                Ok(Self::AllowTrustOp(Box::new(AllowTrustOp::read_xdr(r)?)))
            }),
            TypeVariant::ManageDataOp => r.with_limited_depth(|r| {
                Ok(Self::ManageDataOp(Box::new(ManageDataOp::read_xdr(r)?)))
            }),
            TypeVariant::BumpSequenceOp => r.with_limited_depth(|r| {
                Ok(Self::BumpSequenceOp(Box::new(BumpSequenceOp::read_xdr(r)?)))
            }),
            TypeVariant::CreateClaimableBalanceOp => r.with_limited_depth(|r| {
                Ok(Self::CreateClaimableBalanceOp(Box::new(
                    CreateClaimableBalanceOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimClaimableBalanceOp => r.with_limited_depth(|r| {
                Ok(Self::ClaimClaimableBalanceOp(Box::new(
                    ClaimClaimableBalanceOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::BeginSponsoringFutureReservesOp => r.with_limited_depth(|r| {
                Ok(Self::BeginSponsoringFutureReservesOp(Box::new(
                    BeginSponsoringFutureReservesOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::RevokeSponsorshipType => r.with_limited_depth(|r| {
                Ok(Self::RevokeSponsorshipType(Box::new(
                    RevokeSponsorshipType::read_xdr(r)?,
                )))
            }),
            TypeVariant::RevokeSponsorshipOp => r.with_limited_depth(|r| {
                Ok(Self::RevokeSponsorshipOp(Box::new(
                    RevokeSponsorshipOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::RevokeSponsorshipOpSigner => r.with_limited_depth(|r| {
                Ok(Self::RevokeSponsorshipOpSigner(Box::new(
                    RevokeSponsorshipOpSigner::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClawbackOp => {
                r.with_limited_depth(|r| Ok(Self::ClawbackOp(Box::new(ClawbackOp::read_xdr(r)?))))
            }
            TypeVariant::ClawbackClaimableBalanceOp => r.with_limited_depth(|r| {
                Ok(Self::ClawbackClaimableBalanceOp(Box::new(
                    ClawbackClaimableBalanceOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::SetTrustLineFlagsOp => r.with_limited_depth(|r| {
                Ok(Self::SetTrustLineFlagsOp(Box::new(
                    SetTrustLineFlagsOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::LiquidityPoolDepositOp => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolDepositOp(Box::new(
                    LiquidityPoolDepositOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::LiquidityPoolWithdrawOp => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolWithdrawOp(Box::new(
                    LiquidityPoolWithdrawOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::HostFunctionType => r.with_limited_depth(|r| {
                Ok(Self::HostFunctionType(Box::new(
                    HostFunctionType::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractIdPreimageType => r.with_limited_depth(|r| {
                Ok(Self::ContractIdPreimageType(Box::new(
                    ContractIdPreimageType::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractIdPreimage => r.with_limited_depth(|r| {
                Ok(Self::ContractIdPreimage(Box::new(
                    ContractIdPreimage::read_xdr(r)?,
                )))
            }),
            TypeVariant::ContractIdPreimageFromAddress => r.with_limited_depth(|r| {
                Ok(Self::ContractIdPreimageFromAddress(Box::new(
                    ContractIdPreimageFromAddress::read_xdr(r)?,
                )))
            }),
            TypeVariant::CreateContractArgs => r.with_limited_depth(|r| {
                Ok(Self::CreateContractArgs(Box::new(
                    CreateContractArgs::read_xdr(r)?,
                )))
            }),
            TypeVariant::InvokeContractArgs => r.with_limited_depth(|r| {
                Ok(Self::InvokeContractArgs(Box::new(
                    InvokeContractArgs::read_xdr(r)?,
                )))
            }),
            TypeVariant::HostFunction => r.with_limited_depth(|r| {
                Ok(Self::HostFunction(Box::new(HostFunction::read_xdr(r)?)))
            }),
            TypeVariant::SorobanAuthorizedFunctionType => r.with_limited_depth(|r| {
                Ok(Self::SorobanAuthorizedFunctionType(Box::new(
                    SorobanAuthorizedFunctionType::read_xdr(r)?,
                )))
            }),
            TypeVariant::SorobanAuthorizedFunction => r.with_limited_depth(|r| {
                Ok(Self::SorobanAuthorizedFunction(Box::new(
                    SorobanAuthorizedFunction::read_xdr(r)?,
                )))
            }),
            TypeVariant::SorobanAuthorizedInvocation => r.with_limited_depth(|r| {
                Ok(Self::SorobanAuthorizedInvocation(Box::new(
                    SorobanAuthorizedInvocation::read_xdr(r)?,
                )))
            }),
            TypeVariant::SorobanAddressCredentials => r.with_limited_depth(|r| {
                Ok(Self::SorobanAddressCredentials(Box::new(
                    SorobanAddressCredentials::read_xdr(r)?,
                )))
            }),
            TypeVariant::SorobanCredentialsType => r.with_limited_depth(|r| {
                Ok(Self::SorobanCredentialsType(Box::new(
                    SorobanCredentialsType::read_xdr(r)?,
                )))
            }),
            TypeVariant::SorobanCredentials => r.with_limited_depth(|r| {
                Ok(Self::SorobanCredentials(Box::new(
                    SorobanCredentials::read_xdr(r)?,
                )))
            }),
            TypeVariant::SorobanAuthorizationEntry => r.with_limited_depth(|r| {
                Ok(Self::SorobanAuthorizationEntry(Box::new(
                    SorobanAuthorizationEntry::read_xdr(r)?,
                )))
            }),
            TypeVariant::InvokeHostFunctionOp => r.with_limited_depth(|r| {
                Ok(Self::InvokeHostFunctionOp(Box::new(
                    InvokeHostFunctionOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::ExtendFootprintTtlOp => r.with_limited_depth(|r| {
                Ok(Self::ExtendFootprintTtlOp(Box::new(
                    ExtendFootprintTtlOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::RestoreFootprintOp => r.with_limited_depth(|r| {
                Ok(Self::RestoreFootprintOp(Box::new(
                    RestoreFootprintOp::read_xdr(r)?,
                )))
            }),
            TypeVariant::Operation => {
                r.with_limited_depth(|r| Ok(Self::Operation(Box::new(Operation::read_xdr(r)?))))
            }
            TypeVariant::OperationBody => r.with_limited_depth(|r| {
                Ok(Self::OperationBody(Box::new(OperationBody::read_xdr(r)?)))
            }),
            TypeVariant::HashIdPreimage => r.with_limited_depth(|r| {
                Ok(Self::HashIdPreimage(Box::new(HashIdPreimage::read_xdr(r)?)))
            }),
            TypeVariant::HashIdPreimageOperationId => r.with_limited_depth(|r| {
                Ok(Self::HashIdPreimageOperationId(Box::new(
                    HashIdPreimageOperationId::read_xdr(r)?,
                )))
            }),
            TypeVariant::HashIdPreimageRevokeId => r.with_limited_depth(|r| {
                Ok(Self::HashIdPreimageRevokeId(Box::new(
                    HashIdPreimageRevokeId::read_xdr(r)?,
                )))
            }),
            TypeVariant::HashIdPreimageContractId => r.with_limited_depth(|r| {
                Ok(Self::HashIdPreimageContractId(Box::new(
                    HashIdPreimageContractId::read_xdr(r)?,
                )))
            }),
            TypeVariant::HashIdPreimageSorobanAuthorization => r.with_limited_depth(|r| {
                Ok(Self::HashIdPreimageSorobanAuthorization(Box::new(
                    HashIdPreimageSorobanAuthorization::read_xdr(r)?,
                )))
            }),
            TypeVariant::MemoType => {
                r.with_limited_depth(|r| Ok(Self::MemoType(Box::new(MemoType::read_xdr(r)?))))
            }
            TypeVariant::Memo => {
                r.with_limited_depth(|r| Ok(Self::Memo(Box::new(Memo::read_xdr(r)?))))
            }
            TypeVariant::TimeBounds => {
                r.with_limited_depth(|r| Ok(Self::TimeBounds(Box::new(TimeBounds::read_xdr(r)?))))
            }
            TypeVariant::LedgerBounds => r.with_limited_depth(|r| {
                Ok(Self::LedgerBounds(Box::new(LedgerBounds::read_xdr(r)?)))
            }),
            TypeVariant::PreconditionsV2 => r.with_limited_depth(|r| {
                Ok(Self::PreconditionsV2(Box::new(PreconditionsV2::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::PreconditionType => r.with_limited_depth(|r| {
                Ok(Self::PreconditionType(Box::new(
                    PreconditionType::read_xdr(r)?,
                )))
            }),
            TypeVariant::Preconditions => r.with_limited_depth(|r| {
                Ok(Self::Preconditions(Box::new(Preconditions::read_xdr(r)?)))
            }),
            TypeVariant::LedgerFootprint => r.with_limited_depth(|r| {
                Ok(Self::LedgerFootprint(Box::new(LedgerFootprint::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::SorobanResources => r.with_limited_depth(|r| {
                Ok(Self::SorobanResources(Box::new(
                    SorobanResources::read_xdr(r)?,
                )))
            }),
            TypeVariant::SorobanTransactionData => r.with_limited_depth(|r| {
                Ok(Self::SorobanTransactionData(Box::new(
                    SorobanTransactionData::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionV0 => r.with_limited_depth(|r| {
                Ok(Self::TransactionV0(Box::new(TransactionV0::read_xdr(r)?)))
            }),
            TypeVariant::TransactionV0Ext => r.with_limited_depth(|r| {
                Ok(Self::TransactionV0Ext(Box::new(
                    TransactionV0Ext::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionV0Envelope => r.with_limited_depth(|r| {
                Ok(Self::TransactionV0Envelope(Box::new(
                    TransactionV0Envelope::read_xdr(r)?,
                )))
            }),
            TypeVariant::Transaction => {
                r.with_limited_depth(|r| Ok(Self::Transaction(Box::new(Transaction::read_xdr(r)?))))
            }
            TypeVariant::TransactionExt => r.with_limited_depth(|r| {
                Ok(Self::TransactionExt(Box::new(TransactionExt::read_xdr(r)?)))
            }),
            TypeVariant::TransactionV1Envelope => r.with_limited_depth(|r| {
                Ok(Self::TransactionV1Envelope(Box::new(
                    TransactionV1Envelope::read_xdr(r)?,
                )))
            }),
            TypeVariant::FeeBumpTransaction => r.with_limited_depth(|r| {
                Ok(Self::FeeBumpTransaction(Box::new(
                    FeeBumpTransaction::read_xdr(r)?,
                )))
            }),
            TypeVariant::FeeBumpTransactionInnerTx => r.with_limited_depth(|r| {
                Ok(Self::FeeBumpTransactionInnerTx(Box::new(
                    FeeBumpTransactionInnerTx::read_xdr(r)?,
                )))
            }),
            TypeVariant::FeeBumpTransactionExt => r.with_limited_depth(|r| {
                Ok(Self::FeeBumpTransactionExt(Box::new(
                    FeeBumpTransactionExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::FeeBumpTransactionEnvelope => r.with_limited_depth(|r| {
                Ok(Self::FeeBumpTransactionEnvelope(Box::new(
                    FeeBumpTransactionEnvelope::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionEnvelope => r.with_limited_depth(|r| {
                Ok(Self::TransactionEnvelope(Box::new(
                    TransactionEnvelope::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionSignaturePayload => r.with_limited_depth(|r| {
                Ok(Self::TransactionSignaturePayload(Box::new(
                    TransactionSignaturePayload::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionSignaturePayloadTaggedTransaction => {
                r.with_limited_depth(|r| {
                    Ok(Self::TransactionSignaturePayloadTaggedTransaction(
                        Box::new(TransactionSignaturePayloadTaggedTransaction::read_xdr(r)?),
                    ))
                })
            }
            TypeVariant::ClaimAtomType => r.with_limited_depth(|r| {
                Ok(Self::ClaimAtomType(Box::new(ClaimAtomType::read_xdr(r)?)))
            }),
            TypeVariant::ClaimOfferAtomV0 => r.with_limited_depth(|r| {
                Ok(Self::ClaimOfferAtomV0(Box::new(
                    ClaimOfferAtomV0::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimOfferAtom => r.with_limited_depth(|r| {
                Ok(Self::ClaimOfferAtom(Box::new(ClaimOfferAtom::read_xdr(r)?)))
            }),
            TypeVariant::ClaimLiquidityAtom => r.with_limited_depth(|r| {
                Ok(Self::ClaimLiquidityAtom(Box::new(
                    ClaimLiquidityAtom::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimAtom => {
                r.with_limited_depth(|r| Ok(Self::ClaimAtom(Box::new(ClaimAtom::read_xdr(r)?))))
            }
            TypeVariant::CreateAccountResultCode => r.with_limited_depth(|r| {
                Ok(Self::CreateAccountResultCode(Box::new(
                    CreateAccountResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::CreateAccountResult => r.with_limited_depth(|r| {
                Ok(Self::CreateAccountResult(Box::new(
                    CreateAccountResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::PaymentResultCode => r.with_limited_depth(|r| {
                Ok(Self::PaymentResultCode(Box::new(
                    PaymentResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::PaymentResult => r.with_limited_depth(|r| {
                Ok(Self::PaymentResult(Box::new(PaymentResult::read_xdr(r)?)))
            }),
            TypeVariant::PathPaymentStrictReceiveResultCode => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictReceiveResultCode(Box::new(
                    PathPaymentStrictReceiveResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::SimplePaymentResult => r.with_limited_depth(|r| {
                Ok(Self::SimplePaymentResult(Box::new(
                    SimplePaymentResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::PathPaymentStrictReceiveResult => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictReceiveResult(Box::new(
                    PathPaymentStrictReceiveResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::PathPaymentStrictReceiveResultSuccess => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictReceiveResultSuccess(Box::new(
                    PathPaymentStrictReceiveResultSuccess::read_xdr(r)?,
                )))
            }),
            TypeVariant::PathPaymentStrictSendResultCode => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictSendResultCode(Box::new(
                    PathPaymentStrictSendResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::PathPaymentStrictSendResult => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictSendResult(Box::new(
                    PathPaymentStrictSendResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::PathPaymentStrictSendResultSuccess => r.with_limited_depth(|r| {
                Ok(Self::PathPaymentStrictSendResultSuccess(Box::new(
                    PathPaymentStrictSendResultSuccess::read_xdr(r)?,
                )))
            }),
            TypeVariant::ManageSellOfferResultCode => r.with_limited_depth(|r| {
                Ok(Self::ManageSellOfferResultCode(Box::new(
                    ManageSellOfferResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::ManageOfferEffect => r.with_limited_depth(|r| {
                Ok(Self::ManageOfferEffect(Box::new(
                    ManageOfferEffect::read_xdr(r)?,
                )))
            }),
            TypeVariant::ManageOfferSuccessResult => r.with_limited_depth(|r| {
                Ok(Self::ManageOfferSuccessResult(Box::new(
                    ManageOfferSuccessResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::ManageOfferSuccessResultOffer => r.with_limited_depth(|r| {
                Ok(Self::ManageOfferSuccessResultOffer(Box::new(
                    ManageOfferSuccessResultOffer::read_xdr(r)?,
                )))
            }),
            TypeVariant::ManageSellOfferResult => r.with_limited_depth(|r| {
                Ok(Self::ManageSellOfferResult(Box::new(
                    ManageSellOfferResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::ManageBuyOfferResultCode => r.with_limited_depth(|r| {
                Ok(Self::ManageBuyOfferResultCode(Box::new(
                    ManageBuyOfferResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::ManageBuyOfferResult => r.with_limited_depth(|r| {
                Ok(Self::ManageBuyOfferResult(Box::new(
                    ManageBuyOfferResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::SetOptionsResultCode => r.with_limited_depth(|r| {
                Ok(Self::SetOptionsResultCode(Box::new(
                    SetOptionsResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::SetOptionsResult => r.with_limited_depth(|r| {
                Ok(Self::SetOptionsResult(Box::new(
                    SetOptionsResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::ChangeTrustResultCode => r.with_limited_depth(|r| {
                Ok(Self::ChangeTrustResultCode(Box::new(
                    ChangeTrustResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::ChangeTrustResult => r.with_limited_depth(|r| {
                Ok(Self::ChangeTrustResult(Box::new(
                    ChangeTrustResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::AllowTrustResultCode => r.with_limited_depth(|r| {
                Ok(Self::AllowTrustResultCode(Box::new(
                    AllowTrustResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::AllowTrustResult => r.with_limited_depth(|r| {
                Ok(Self::AllowTrustResult(Box::new(
                    AllowTrustResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::AccountMergeResultCode => r.with_limited_depth(|r| {
                Ok(Self::AccountMergeResultCode(Box::new(
                    AccountMergeResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::AccountMergeResult => r.with_limited_depth(|r| {
                Ok(Self::AccountMergeResult(Box::new(
                    AccountMergeResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::InflationResultCode => r.with_limited_depth(|r| {
                Ok(Self::InflationResultCode(Box::new(
                    InflationResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::InflationPayout => r.with_limited_depth(|r| {
                Ok(Self::InflationPayout(Box::new(InflationPayout::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::InflationResult => r.with_limited_depth(|r| {
                Ok(Self::InflationResult(Box::new(InflationResult::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::ManageDataResultCode => r.with_limited_depth(|r| {
                Ok(Self::ManageDataResultCode(Box::new(
                    ManageDataResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::ManageDataResult => r.with_limited_depth(|r| {
                Ok(Self::ManageDataResult(Box::new(
                    ManageDataResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::BumpSequenceResultCode => r.with_limited_depth(|r| {
                Ok(Self::BumpSequenceResultCode(Box::new(
                    BumpSequenceResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::BumpSequenceResult => r.with_limited_depth(|r| {
                Ok(Self::BumpSequenceResult(Box::new(
                    BumpSequenceResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::CreateClaimableBalanceResultCode => r.with_limited_depth(|r| {
                Ok(Self::CreateClaimableBalanceResultCode(Box::new(
                    CreateClaimableBalanceResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::CreateClaimableBalanceResult => r.with_limited_depth(|r| {
                Ok(Self::CreateClaimableBalanceResult(Box::new(
                    CreateClaimableBalanceResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimClaimableBalanceResultCode => r.with_limited_depth(|r| {
                Ok(Self::ClaimClaimableBalanceResultCode(Box::new(
                    ClaimClaimableBalanceResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClaimClaimableBalanceResult => r.with_limited_depth(|r| {
                Ok(Self::ClaimClaimableBalanceResult(Box::new(
                    ClaimClaimableBalanceResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::BeginSponsoringFutureReservesResultCode => r.with_limited_depth(|r| {
                Ok(Self::BeginSponsoringFutureReservesResultCode(Box::new(
                    BeginSponsoringFutureReservesResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::BeginSponsoringFutureReservesResult => r.with_limited_depth(|r| {
                Ok(Self::BeginSponsoringFutureReservesResult(Box::new(
                    BeginSponsoringFutureReservesResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::EndSponsoringFutureReservesResultCode => r.with_limited_depth(|r| {
                Ok(Self::EndSponsoringFutureReservesResultCode(Box::new(
                    EndSponsoringFutureReservesResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::EndSponsoringFutureReservesResult => r.with_limited_depth(|r| {
                Ok(Self::EndSponsoringFutureReservesResult(Box::new(
                    EndSponsoringFutureReservesResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::RevokeSponsorshipResultCode => r.with_limited_depth(|r| {
                Ok(Self::RevokeSponsorshipResultCode(Box::new(
                    RevokeSponsorshipResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::RevokeSponsorshipResult => r.with_limited_depth(|r| {
                Ok(Self::RevokeSponsorshipResult(Box::new(
                    RevokeSponsorshipResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClawbackResultCode => r.with_limited_depth(|r| {
                Ok(Self::ClawbackResultCode(Box::new(
                    ClawbackResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClawbackResult => r.with_limited_depth(|r| {
                Ok(Self::ClawbackResult(Box::new(ClawbackResult::read_xdr(r)?)))
            }),
            TypeVariant::ClawbackClaimableBalanceResultCode => r.with_limited_depth(|r| {
                Ok(Self::ClawbackClaimableBalanceResultCode(Box::new(
                    ClawbackClaimableBalanceResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::ClawbackClaimableBalanceResult => r.with_limited_depth(|r| {
                Ok(Self::ClawbackClaimableBalanceResult(Box::new(
                    ClawbackClaimableBalanceResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::SetTrustLineFlagsResultCode => r.with_limited_depth(|r| {
                Ok(Self::SetTrustLineFlagsResultCode(Box::new(
                    SetTrustLineFlagsResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::SetTrustLineFlagsResult => r.with_limited_depth(|r| {
                Ok(Self::SetTrustLineFlagsResult(Box::new(
                    SetTrustLineFlagsResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::LiquidityPoolDepositResultCode => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolDepositResultCode(Box::new(
                    LiquidityPoolDepositResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::LiquidityPoolDepositResult => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolDepositResult(Box::new(
                    LiquidityPoolDepositResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::LiquidityPoolWithdrawResultCode => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolWithdrawResultCode(Box::new(
                    LiquidityPoolWithdrawResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::LiquidityPoolWithdrawResult => r.with_limited_depth(|r| {
                Ok(Self::LiquidityPoolWithdrawResult(Box::new(
                    LiquidityPoolWithdrawResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::InvokeHostFunctionResultCode => r.with_limited_depth(|r| {
                Ok(Self::InvokeHostFunctionResultCode(Box::new(
                    InvokeHostFunctionResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::InvokeHostFunctionResult => r.with_limited_depth(|r| {
                Ok(Self::InvokeHostFunctionResult(Box::new(
                    InvokeHostFunctionResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::ExtendFootprintTtlResultCode => r.with_limited_depth(|r| {
                Ok(Self::ExtendFootprintTtlResultCode(Box::new(
                    ExtendFootprintTtlResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::ExtendFootprintTtlResult => r.with_limited_depth(|r| {
                Ok(Self::ExtendFootprintTtlResult(Box::new(
                    ExtendFootprintTtlResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::RestoreFootprintResultCode => r.with_limited_depth(|r| {
                Ok(Self::RestoreFootprintResultCode(Box::new(
                    RestoreFootprintResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::RestoreFootprintResult => r.with_limited_depth(|r| {
                Ok(Self::RestoreFootprintResult(Box::new(
                    RestoreFootprintResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::OperationResultCode => r.with_limited_depth(|r| {
                Ok(Self::OperationResultCode(Box::new(
                    OperationResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::OperationResult => r.with_limited_depth(|r| {
                Ok(Self::OperationResult(Box::new(OperationResult::read_xdr(
                    r,
                )?)))
            }),
            TypeVariant::OperationResultTr => r.with_limited_depth(|r| {
                Ok(Self::OperationResultTr(Box::new(
                    OperationResultTr::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionResultCode => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultCode(Box::new(
                    TransactionResultCode::read_xdr(r)?,
                )))
            }),
            TypeVariant::InnerTransactionResult => r.with_limited_depth(|r| {
                Ok(Self::InnerTransactionResult(Box::new(
                    InnerTransactionResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::InnerTransactionResultResult => r.with_limited_depth(|r| {
                Ok(Self::InnerTransactionResultResult(Box::new(
                    InnerTransactionResultResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::InnerTransactionResultExt => r.with_limited_depth(|r| {
                Ok(Self::InnerTransactionResultExt(Box::new(
                    InnerTransactionResultExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::InnerTransactionResultPair => r.with_limited_depth(|r| {
                Ok(Self::InnerTransactionResultPair(Box::new(
                    InnerTransactionResultPair::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionResult => r.with_limited_depth(|r| {
                Ok(Self::TransactionResult(Box::new(
                    TransactionResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionResultResult => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultResult(Box::new(
                    TransactionResultResult::read_xdr(r)?,
                )))
            }),
            TypeVariant::TransactionResultExt => r.with_limited_depth(|r| {
                Ok(Self::TransactionResultExt(Box::new(
                    TransactionResultExt::read_xdr(r)?,
                )))
            }),
            TypeVariant::Hash => {
                r.with_limited_depth(|r| Ok(Self::Hash(Box::new(Hash::read_xdr(r)?))))
            }
            TypeVariant::Uint256 => {
                r.with_limited_depth(|r| Ok(Self::Uint256(Box::new(Uint256::read_xdr(r)?))))
            }
            TypeVariant::Uint32 => {
                r.with_limited_depth(|r| Ok(Self::Uint32(Box::new(Uint32::read_xdr(r)?))))
            }
            TypeVariant::Int32 => {
                r.with_limited_depth(|r| Ok(Self::Int32(Box::new(Int32::read_xdr(r)?))))
            }
            TypeVariant::Uint64 => {
                r.with_limited_depth(|r| Ok(Self::Uint64(Box::new(Uint64::read_xdr(r)?))))
            }
            TypeVariant::Int64 => {
                r.with_limited_depth(|r| Ok(Self::Int64(Box::new(Int64::read_xdr(r)?))))
            }
            TypeVariant::TimePoint => {
                r.with_limited_depth(|r| Ok(Self::TimePoint(Box::new(TimePoint::read_xdr(r)?))))
            }
            TypeVariant::Duration => {
                r.with_limited_depth(|r| Ok(Self::Duration(Box::new(Duration::read_xdr(r)?))))
            }
            TypeVariant::ExtensionPoint => r.with_limited_depth(|r| {
                Ok(Self::ExtensionPoint(Box::new(ExtensionPoint::read_xdr(r)?)))
            }),
            TypeVariant::CryptoKeyType => r.with_limited_depth(|r| {
                Ok(Self::CryptoKeyType(Box::new(CryptoKeyType::read_xdr(r)?)))
            }),
            TypeVariant::PublicKeyType => r.with_limited_depth(|r| {
                Ok(Self::PublicKeyType(Box::new(PublicKeyType::read_xdr(r)?)))
            }),
            TypeVariant::SignerKeyType => r.with_limited_depth(|r| {
                Ok(Self::SignerKeyType(Box::new(SignerKeyType::read_xdr(r)?)))
            }),
            TypeVariant::PublicKey => {
                r.with_limited_depth(|r| Ok(Self::PublicKey(Box::new(PublicKey::read_xdr(r)?))))
            }
            TypeVariant::SignerKey => {
                r.with_limited_depth(|r| Ok(Self::SignerKey(Box::new(SignerKey::read_xdr(r)?))))
            }
            TypeVariant::SignerKeyEd25519SignedPayload => r.with_limited_depth(|r| {
                Ok(Self::SignerKeyEd25519SignedPayload(Box::new(
                    SignerKeyEd25519SignedPayload::read_xdr(r)?,
                )))
            }),
            TypeVariant::Signature => {
                r.with_limited_depth(|r| Ok(Self::Signature(Box::new(Signature::read_xdr(r)?))))
            }
            TypeVariant::SignatureHint => r.with_limited_depth(|r| {
                Ok(Self::SignatureHint(Box::new(SignatureHint::read_xdr(r)?)))
            }),
            TypeVariant::NodeId => {
                r.with_limited_depth(|r| Ok(Self::NodeId(Box::new(NodeId::read_xdr(r)?))))
            }
            TypeVariant::AccountId => {
                r.with_limited_depth(|r| Ok(Self::AccountId(Box::new(AccountId::read_xdr(r)?))))
            }
            TypeVariant::Curve25519Secret => r.with_limited_depth(|r| {
                Ok(Self::Curve25519Secret(Box::new(
                    Curve25519Secret::read_xdr(r)?,
                )))
            }),
            TypeVariant::Curve25519Public => r.with_limited_depth(|r| {
                Ok(Self::Curve25519Public(Box::new(
                    Curve25519Public::read_xdr(r)?,
                )))
            }),
            TypeVariant::HmacSha256Key => r.with_limited_depth(|r| {
                Ok(Self::HmacSha256Key(Box::new(HmacSha256Key::read_xdr(r)?)))
            }),
            TypeVariant::HmacSha256Mac => r.with_limited_depth(|r| {
                Ok(Self::HmacSha256Mac(Box::new(HmacSha256Mac::read_xdr(r)?)))
            }),
        }
    }

    #[cfg(feature = "base64")]
    pub fn read_xdr_base64<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Result<Self> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(&mut r.inner, base64::STANDARD),
            r.limits.clone(),
        );
        let t = Self::read_xdr(v, &mut dec)?;
        Ok(t)
    }

    #[cfg(feature = "std")]
    pub fn read_xdr_to_end<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Result<Self> {
        let s = Self::read_xdr(v, r)?;
        // Check that any further reads, such as this read of one byte, read no
        // data, indicating EOF. If a byte is read the data is invalid.
        if r.read(&mut [0u8; 1])? == 0 {
            Ok(s)
        } else {
            Err(Error::Invalid)
        }
    }

    #[cfg(feature = "base64")]
    pub fn read_xdr_base64_to_end<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Result<Self> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(&mut r.inner, base64::STANDARD),
            r.limits.clone(),
        );
        let t = Self::read_xdr_to_end(v, &mut dec)?;
        Ok(t)
    }

    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr_iter<R: Read>(
        v: TypeVariant,
        r: &mut Limited<R>,
    ) -> Box<dyn Iterator<Item = Result<Self>> + '_> {
        match v {
            TypeVariant::Value => Box::new(
                ReadXdrIter::<_, Value>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Value(Box::new(t)))),
            ),
            TypeVariant::ScpBallot => Box::new(
                ReadXdrIter::<_, ScpBallot>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpBallot(Box::new(t)))),
            ),
            TypeVariant::ScpStatementType => Box::new(
                ReadXdrIter::<_, ScpStatementType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementType(Box::new(t)))),
            ),
            TypeVariant::ScpNomination => Box::new(
                ReadXdrIter::<_, ScpNomination>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpNomination(Box::new(t)))),
            ),
            TypeVariant::ScpStatement => Box::new(
                ReadXdrIter::<_, ScpStatement>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatement(Box::new(t)))),
            ),
            TypeVariant::ScpStatementPledges => Box::new(
                ReadXdrIter::<_, ScpStatementPledges>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPledges(Box::new(t)))),
            ),
            TypeVariant::ScpStatementPrepare => Box::new(
                ReadXdrIter::<_, ScpStatementPrepare>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPrepare(Box::new(t)))),
            ),
            TypeVariant::ScpStatementConfirm => Box::new(
                ReadXdrIter::<_, ScpStatementConfirm>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementConfirm(Box::new(t)))),
            ),
            TypeVariant::ScpStatementExternalize => Box::new(
                ReadXdrIter::<_, ScpStatementExternalize>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementExternalize(Box::new(t)))),
            ),
            TypeVariant::ScpEnvelope => Box::new(
                ReadXdrIter::<_, ScpEnvelope>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpEnvelope(Box::new(t)))),
            ),
            TypeVariant::ScpQuorumSet => Box::new(
                ReadXdrIter::<_, ScpQuorumSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpQuorumSet(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractExecutionLanesV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractExecutionLanesV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractExecutionLanesV0(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractComputeV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractComputeV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractComputeV0(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractLedgerCostV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractLedgerCostV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractLedgerCostV0(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractHistoricalDataV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractHistoricalDataV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractHistoricalDataV0(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractEventsV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractEventsV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractEventsV0(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractBandwidthV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractBandwidthV0>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractBandwidthV0(Box::new(t)))),
            ),
            TypeVariant::ContractCostType => Box::new(
                ReadXdrIter::<_, ContractCostType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostType(Box::new(t)))),
            ),
            TypeVariant::ContractCostParamEntry => Box::new(
                ReadXdrIter::<_, ContractCostParamEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostParamEntry(Box::new(t)))),
            ),
            TypeVariant::StateArchivalSettings => Box::new(
                ReadXdrIter::<_, StateArchivalSettings>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StateArchivalSettings(Box::new(t)))),
            ),
            TypeVariant::EvictionIterator => Box::new(
                ReadXdrIter::<_, EvictionIterator>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EvictionIterator(Box::new(t)))),
            ),
            TypeVariant::ContractCostParams => Box::new(
                ReadXdrIter::<_, ContractCostParams>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostParams(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingId => Box::new(
                ReadXdrIter::<_, ConfigSettingId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingId(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingEntry => Box::new(
                ReadXdrIter::<_, ConfigSettingEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingEntry(Box::new(t)))),
            ),
            TypeVariant::ScEnvMetaKind => Box::new(
                ReadXdrIter::<_, ScEnvMetaKind>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaKind(Box::new(t)))),
            ),
            TypeVariant::ScEnvMetaEntry => Box::new(
                ReadXdrIter::<_, ScEnvMetaEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaEntry(Box::new(t)))),
            ),
            TypeVariant::ScMetaV0 => Box::new(
                ReadXdrIter::<_, ScMetaV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaV0(Box::new(t)))),
            ),
            TypeVariant::ScMetaKind => Box::new(
                ReadXdrIter::<_, ScMetaKind>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaKind(Box::new(t)))),
            ),
            TypeVariant::ScMetaEntry => Box::new(
                ReadXdrIter::<_, ScMetaEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaEntry(Box::new(t)))),
            ),
            TypeVariant::ScSpecType => Box::new(
                ReadXdrIter::<_, ScSpecType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecType(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeOption => Box::new(
                ReadXdrIter::<_, ScSpecTypeOption>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeOption(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeResult => Box::new(
                ReadXdrIter::<_, ScSpecTypeResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeResult(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeVec => Box::new(
                ReadXdrIter::<_, ScSpecTypeVec>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeVec(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeMap => Box::new(
                ReadXdrIter::<_, ScSpecTypeMap>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeMap(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeTuple => Box::new(
                ReadXdrIter::<_, ScSpecTypeTuple>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeTuple(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeBytesN => Box::new(
                ReadXdrIter::<_, ScSpecTypeBytesN>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeBytesN(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeUdt => Box::new(
                ReadXdrIter::<_, ScSpecTypeUdt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeUdt(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeDef => Box::new(
                ReadXdrIter::<_, ScSpecTypeDef>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeDef(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtStructFieldV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtStructFieldV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtStructFieldV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtStructV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtStructV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtStructV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseVoidV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseVoidV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseVoidV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseTupleV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseTupleV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseTupleV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseV0Kind => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseV0Kind>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0Kind(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtUnionV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtEnumCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtEnumCaseV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumCaseV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtEnumV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtEnumV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtErrorEnumCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtErrorEnumCaseV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumCaseV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtErrorEnumV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtErrorEnumV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecFunctionInputV0 => Box::new(
                ReadXdrIter::<_, ScSpecFunctionInputV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionInputV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecFunctionV0 => Box::new(
                ReadXdrIter::<_, ScSpecFunctionV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecEntryKind => Box::new(
                ReadXdrIter::<_, ScSpecEntryKind>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntryKind(Box::new(t)))),
            ),
            TypeVariant::ScSpecEntry => Box::new(
                ReadXdrIter::<_, ScSpecEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntry(Box::new(t)))),
            ),
            TypeVariant::ScValType => Box::new(
                ReadXdrIter::<_, ScValType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScValType(Box::new(t)))),
            ),
            TypeVariant::ScErrorType => Box::new(
                ReadXdrIter::<_, ScErrorType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorType(Box::new(t)))),
            ),
            TypeVariant::ScErrorCode => Box::new(
                ReadXdrIter::<_, ScErrorCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorCode(Box::new(t)))),
            ),
            TypeVariant::ScError => Box::new(
                ReadXdrIter::<_, ScError>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScError(Box::new(t)))),
            ),
            TypeVariant::UInt128Parts => Box::new(
                ReadXdrIter::<_, UInt128Parts>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt128Parts(Box::new(t)))),
            ),
            TypeVariant::Int128Parts => Box::new(
                ReadXdrIter::<_, Int128Parts>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int128Parts(Box::new(t)))),
            ),
            TypeVariant::UInt256Parts => Box::new(
                ReadXdrIter::<_, UInt256Parts>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt256Parts(Box::new(t)))),
            ),
            TypeVariant::Int256Parts => Box::new(
                ReadXdrIter::<_, Int256Parts>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int256Parts(Box::new(t)))),
            ),
            TypeVariant::ContractExecutableType => Box::new(
                ReadXdrIter::<_, ContractExecutableType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractExecutableType(Box::new(t)))),
            ),
            TypeVariant::ContractExecutable => Box::new(
                ReadXdrIter::<_, ContractExecutable>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractExecutable(Box::new(t)))),
            ),
            TypeVariant::ScAddressType => Box::new(
                ReadXdrIter::<_, ScAddressType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddressType(Box::new(t)))),
            ),
            TypeVariant::ScAddress => Box::new(
                ReadXdrIter::<_, ScAddress>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddress(Box::new(t)))),
            ),
            TypeVariant::ScVec => Box::new(
                ReadXdrIter::<_, ScVec>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVec(Box::new(t)))),
            ),
            TypeVariant::ScMap => Box::new(
                ReadXdrIter::<_, ScMap>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMap(Box::new(t)))),
            ),
            TypeVariant::ScBytes => Box::new(
                ReadXdrIter::<_, ScBytes>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScBytes(Box::new(t)))),
            ),
            TypeVariant::ScString => Box::new(
                ReadXdrIter::<_, ScString>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScString(Box::new(t)))),
            ),
            TypeVariant::ScSymbol => Box::new(
                ReadXdrIter::<_, ScSymbol>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSymbol(Box::new(t)))),
            ),
            TypeVariant::ScNonceKey => Box::new(
                ReadXdrIter::<_, ScNonceKey>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScNonceKey(Box::new(t)))),
            ),
            TypeVariant::ScContractInstance => Box::new(
                ReadXdrIter::<_, ScContractInstance>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScContractInstance(Box::new(t)))),
            ),
            TypeVariant::ScVal => Box::new(
                ReadXdrIter::<_, ScVal>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVal(Box::new(t)))),
            ),
            TypeVariant::ScMapEntry => Box::new(
                ReadXdrIter::<_, ScMapEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMapEntry(Box::new(t)))),
            ),
            TypeVariant::StoredTransactionSet => Box::new(
                ReadXdrIter::<_, StoredTransactionSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StoredTransactionSet(Box::new(t)))),
            ),
            TypeVariant::StoredDebugTransactionSet => Box::new(
                ReadXdrIter::<_, StoredDebugTransactionSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StoredDebugTransactionSet(Box::new(t)))),
            ),
            TypeVariant::PersistedScpStateV0 => Box::new(
                ReadXdrIter::<_, PersistedScpStateV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV0(Box::new(t)))),
            ),
            TypeVariant::PersistedScpStateV1 => Box::new(
                ReadXdrIter::<_, PersistedScpStateV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV1(Box::new(t)))),
            ),
            TypeVariant::PersistedScpState => Box::new(
                ReadXdrIter::<_, PersistedScpState>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpState(Box::new(t)))),
            ),
            TypeVariant::Thresholds => Box::new(
                ReadXdrIter::<_, Thresholds>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Thresholds(Box::new(t)))),
            ),
            TypeVariant::String32 => Box::new(
                ReadXdrIter::<_, String32>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::String32(Box::new(t)))),
            ),
            TypeVariant::String64 => Box::new(
                ReadXdrIter::<_, String64>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::String64(Box::new(t)))),
            ),
            TypeVariant::SequenceNumber => Box::new(
                ReadXdrIter::<_, SequenceNumber>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SequenceNumber(Box::new(t)))),
            ),
            TypeVariant::DataValue => Box::new(
                ReadXdrIter::<_, DataValue>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataValue(Box::new(t)))),
            ),
            TypeVariant::PoolId => Box::new(
                ReadXdrIter::<_, PoolId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PoolId(Box::new(t)))),
            ),
            TypeVariant::AssetCode4 => Box::new(
                ReadXdrIter::<_, AssetCode4>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode4(Box::new(t)))),
            ),
            TypeVariant::AssetCode12 => Box::new(
                ReadXdrIter::<_, AssetCode12>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode12(Box::new(t)))),
            ),
            TypeVariant::AssetType => Box::new(
                ReadXdrIter::<_, AssetType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetType(Box::new(t)))),
            ),
            TypeVariant::AssetCode => Box::new(
                ReadXdrIter::<_, AssetCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode(Box::new(t)))),
            ),
            TypeVariant::AlphaNum4 => Box::new(
                ReadXdrIter::<_, AlphaNum4>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum4(Box::new(t)))),
            ),
            TypeVariant::AlphaNum12 => Box::new(
                ReadXdrIter::<_, AlphaNum12>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum12(Box::new(t)))),
            ),
            TypeVariant::Asset => Box::new(
                ReadXdrIter::<_, Asset>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Asset(Box::new(t)))),
            ),
            TypeVariant::Price => Box::new(
                ReadXdrIter::<_, Price>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Price(Box::new(t)))),
            ),
            TypeVariant::Liabilities => Box::new(
                ReadXdrIter::<_, Liabilities>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Liabilities(Box::new(t)))),
            ),
            TypeVariant::ThresholdIndexes => Box::new(
                ReadXdrIter::<_, ThresholdIndexes>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ThresholdIndexes(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryType => Box::new(
                ReadXdrIter::<_, LedgerEntryType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryType(Box::new(t)))),
            ),
            TypeVariant::Signer => Box::new(
                ReadXdrIter::<_, Signer>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signer(Box::new(t)))),
            ),
            TypeVariant::AccountFlags => Box::new(
                ReadXdrIter::<_, AccountFlags>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountFlags(Box::new(t)))),
            ),
            TypeVariant::SponsorshipDescriptor => Box::new(
                ReadXdrIter::<_, SponsorshipDescriptor>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SponsorshipDescriptor(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExtensionV3 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV3>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV3(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV2(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV2Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV2Ext(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV1(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV1Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV1Ext(Box::new(t)))),
            ),
            TypeVariant::AccountEntry => Box::new(
                ReadXdrIter::<_, AccountEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntry(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExt => Box::new(
                ReadXdrIter::<_, AccountEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExt(Box::new(t)))),
            ),
            TypeVariant::TrustLineFlags => Box::new(
                ReadXdrIter::<_, TrustLineFlags>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineFlags(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolType => Box::new(
                ReadXdrIter::<_, LiquidityPoolType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolType(Box::new(t)))),
            ),
            TypeVariant::TrustLineAsset => Box::new(
                ReadXdrIter::<_, TrustLineAsset>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineAsset(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, TrustLineEntryExtensionV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, TrustLineEntryExtensionV2Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2Ext(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntry => Box::new(
                ReadXdrIter::<_, TrustLineEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntry(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntryExt => Box::new(
                ReadXdrIter::<_, TrustLineEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExt(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntryV1 => Box::new(
                ReadXdrIter::<_, TrustLineEntryV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntryV1Ext => Box::new(
                ReadXdrIter::<_, TrustLineEntryV1Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1Ext(Box::new(t)))),
            ),
            TypeVariant::OfferEntryFlags => Box::new(
                ReadXdrIter::<_, OfferEntryFlags>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryFlags(Box::new(t)))),
            ),
            TypeVariant::OfferEntry => Box::new(
                ReadXdrIter::<_, OfferEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntry(Box::new(t)))),
            ),
            TypeVariant::OfferEntryExt => Box::new(
                ReadXdrIter::<_, OfferEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryExt(Box::new(t)))),
            ),
            TypeVariant::DataEntry => Box::new(
                ReadXdrIter::<_, DataEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntry(Box::new(t)))),
            ),
            TypeVariant::DataEntryExt => Box::new(
                ReadXdrIter::<_, DataEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntryExt(Box::new(t)))),
            ),
            TypeVariant::ClaimPredicateType => Box::new(
                ReadXdrIter::<_, ClaimPredicateType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicateType(Box::new(t)))),
            ),
            TypeVariant::ClaimPredicate => Box::new(
                ReadXdrIter::<_, ClaimPredicate>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicate(Box::new(t)))),
            ),
            TypeVariant::ClaimantType => Box::new(
                ReadXdrIter::<_, ClaimantType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantType(Box::new(t)))),
            ),
            TypeVariant::Claimant => Box::new(
                ReadXdrIter::<_, Claimant>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Claimant(Box::new(t)))),
            ),
            TypeVariant::ClaimantV0 => Box::new(
                ReadXdrIter::<_, ClaimantV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantV0(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceIdType => Box::new(
                ReadXdrIter::<_, ClaimableBalanceIdType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceIdType(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceId => Box::new(
                ReadXdrIter::<_, ClaimableBalanceId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceId(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceFlags => Box::new(
                ReadXdrIter::<_, ClaimableBalanceFlags>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceFlags(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExtensionV1>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExtensionV1Ext>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceEntry => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntry(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceEntryExt => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntryExt(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolConstantProductParameters => Box::new(
                ReadXdrIter::<_, LiquidityPoolConstantProductParameters>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolConstantProductParameters(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolEntry => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntry(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolEntryBody => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntryBody>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntryBody(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolEntryConstantProduct => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntryConstantProduct>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolEntryConstantProduct(Box::new(t)))),
            ),
            TypeVariant::ContractDataDurability => Box::new(
                ReadXdrIter::<_, ContractDataDurability>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractDataDurability(Box::new(t)))),
            ),
            TypeVariant::ContractDataEntry => Box::new(
                ReadXdrIter::<_, ContractDataEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractDataEntry(Box::new(t)))),
            ),
            TypeVariant::ContractCodeCostInputs => Box::new(
                ReadXdrIter::<_, ContractCodeCostInputs>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeCostInputs(Box::new(t)))),
            ),
            TypeVariant::ContractCodeEntry => Box::new(
                ReadXdrIter::<_, ContractCodeEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntry(Box::new(t)))),
            ),
            TypeVariant::ContractCodeEntryExt => Box::new(
                ReadXdrIter::<_, ContractCodeEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryExt(Box::new(t)))),
            ),
            TypeVariant::ContractCodeEntryV1 => Box::new(
                ReadXdrIter::<_, ContractCodeEntryV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryV1(Box::new(t)))),
            ),
            TypeVariant::TtlEntry => Box::new(
                ReadXdrIter::<_, TtlEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TtlEntry(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, LedgerEntryExtensionV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExtensionV1(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, LedgerEntryExtensionV1Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExtensionV1Ext(Box::new(t)))),
            ),
            TypeVariant::LedgerEntry => Box::new(
                ReadXdrIter::<_, LedgerEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntry(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryData => Box::new(
                ReadXdrIter::<_, LedgerEntryData>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryData(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryExt => Box::new(
                ReadXdrIter::<_, LedgerEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExt(Box::new(t)))),
            ),
            TypeVariant::LedgerKey => Box::new(
                ReadXdrIter::<_, LedgerKey>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKey(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyAccount => Box::new(
                ReadXdrIter::<_, LedgerKeyAccount>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyAccount(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyTrustLine => Box::new(
                ReadXdrIter::<_, LedgerKeyTrustLine>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTrustLine(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyOffer => Box::new(
                ReadXdrIter::<_, LedgerKeyOffer>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyOffer(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyData => Box::new(
                ReadXdrIter::<_, LedgerKeyData>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyData(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyClaimableBalance => Box::new(
                ReadXdrIter::<_, LedgerKeyClaimableBalance>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyClaimableBalance(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyLiquidityPool => Box::new(
                ReadXdrIter::<_, LedgerKeyLiquidityPool>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyLiquidityPool(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyContractData => Box::new(
                ReadXdrIter::<_, LedgerKeyContractData>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractData(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyContractCode => Box::new(
                ReadXdrIter::<_, LedgerKeyContractCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractCode(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyConfigSetting => Box::new(
                ReadXdrIter::<_, LedgerKeyConfigSetting>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyConfigSetting(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyTtl => Box::new(
                ReadXdrIter::<_, LedgerKeyTtl>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTtl(Box::new(t)))),
            ),
            TypeVariant::EnvelopeType => Box::new(
                ReadXdrIter::<_, EnvelopeType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EnvelopeType(Box::new(t)))),
            ),
            TypeVariant::UpgradeType => Box::new(
                ReadXdrIter::<_, UpgradeType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeType(Box::new(t)))),
            ),
            TypeVariant::StellarValueType => Box::new(
                ReadXdrIter::<_, StellarValueType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueType(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseValueSignature => Box::new(
                ReadXdrIter::<_, LedgerCloseValueSignature>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseValueSignature(Box::new(t)))),
            ),
            TypeVariant::StellarValue => Box::new(
                ReadXdrIter::<_, StellarValue>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValue(Box::new(t)))),
            ),
            TypeVariant::StellarValueExt => Box::new(
                ReadXdrIter::<_, StellarValueExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueExt(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderFlags => Box::new(
                ReadXdrIter::<_, LedgerHeaderFlags>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderFlags(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderExtensionV1 => Box::new(
                ReadXdrIter::<_, LedgerHeaderExtensionV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderExtensionV1Ext => Box::new(
                ReadXdrIter::<_, LedgerHeaderExtensionV1Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1Ext(Box::new(t)))),
            ),
            TypeVariant::LedgerHeader => Box::new(
                ReadXdrIter::<_, LedgerHeader>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeader(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderExt => Box::new(
                ReadXdrIter::<_, LedgerHeaderExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExt(Box::new(t)))),
            ),
            TypeVariant::LedgerUpgradeType => Box::new(
                ReadXdrIter::<_, LedgerUpgradeType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgradeType(Box::new(t)))),
            ),
            TypeVariant::ConfigUpgradeSetKey => Box::new(
                ReadXdrIter::<_, ConfigUpgradeSetKey>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSetKey(Box::new(t)))),
            ),
            TypeVariant::LedgerUpgrade => Box::new(
                ReadXdrIter::<_, LedgerUpgrade>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgrade(Box::new(t)))),
            ),
            TypeVariant::ConfigUpgradeSet => Box::new(
                ReadXdrIter::<_, ConfigUpgradeSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSet(Box::new(t)))),
            ),
            TypeVariant::BucketEntryType => Box::new(
                ReadXdrIter::<_, BucketEntryType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntryType(Box::new(t)))),
            ),
            TypeVariant::BucketMetadata => Box::new(
                ReadXdrIter::<_, BucketMetadata>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadata(Box::new(t)))),
            ),
            TypeVariant::BucketMetadataExt => Box::new(
                ReadXdrIter::<_, BucketMetadataExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadataExt(Box::new(t)))),
            ),
            TypeVariant::BucketEntry => Box::new(
                ReadXdrIter::<_, BucketEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntry(Box::new(t)))),
            ),
            TypeVariant::TxSetComponentType => Box::new(
                ReadXdrIter::<_, TxSetComponentType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponentType(Box::new(t)))),
            ),
            TypeVariant::TxSetComponent => Box::new(
                ReadXdrIter::<_, TxSetComponent>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponent(Box::new(t)))),
            ),
            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => Box::new(
                ReadXdrIter::<_, TxSetComponentTxsMaybeDiscountedFee>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(t)))),
            ),
            TypeVariant::TransactionPhase => Box::new(
                ReadXdrIter::<_, TransactionPhase>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionPhase(Box::new(t)))),
            ),
            TypeVariant::TransactionSet => Box::new(
                ReadXdrIter::<_, TransactionSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSet(Box::new(t)))),
            ),
            TypeVariant::TransactionSetV1 => Box::new(
                ReadXdrIter::<_, TransactionSetV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSetV1(Box::new(t)))),
            ),
            TypeVariant::GeneralizedTransactionSet => Box::new(
                ReadXdrIter::<_, GeneralizedTransactionSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::GeneralizedTransactionSet(Box::new(t)))),
            ),
            TypeVariant::TransactionResultPair => Box::new(
                ReadXdrIter::<_, TransactionResultPair>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultPair(Box::new(t)))),
            ),
            TypeVariant::TransactionResultSet => Box::new(
                ReadXdrIter::<_, TransactionResultSet>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultSet(Box::new(t)))),
            ),
            TypeVariant::TransactionHistoryEntry => Box::new(
                ReadXdrIter::<_, TransactionHistoryEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryEntry(Box::new(t)))),
            ),
            TypeVariant::TransactionHistoryEntryExt => Box::new(
                ReadXdrIter::<_, TransactionHistoryEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryEntryExt(Box::new(t)))),
            ),
            TypeVariant::TransactionHistoryResultEntry => Box::new(
                ReadXdrIter::<_, TransactionHistoryResultEntry>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryResultEntry(Box::new(t)))),
            ),
            TypeVariant::TransactionHistoryResultEntryExt => Box::new(
                ReadXdrIter::<_, TransactionHistoryResultEntryExt>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryResultEntryExt(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderHistoryEntry => Box::new(
                ReadXdrIter::<_, LedgerHeaderHistoryEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntry(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderHistoryEntryExt => Box::new(
                ReadXdrIter::<_, LedgerHeaderHistoryEntryExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntryExt(Box::new(t)))),
            ),
            TypeVariant::LedgerScpMessages => Box::new(
                ReadXdrIter::<_, LedgerScpMessages>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerScpMessages(Box::new(t)))),
            ),
            TypeVariant::ScpHistoryEntryV0 => Box::new(
                ReadXdrIter::<_, ScpHistoryEntryV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntryV0(Box::new(t)))),
            ),
            TypeVariant::ScpHistoryEntry => Box::new(
                ReadXdrIter::<_, ScpHistoryEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntry(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryChangeType => Box::new(
                ReadXdrIter::<_, LedgerEntryChangeType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChangeType(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryChange => Box::new(
                ReadXdrIter::<_, LedgerEntryChange>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChange(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryChanges => Box::new(
                ReadXdrIter::<_, LedgerEntryChanges>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChanges(Box::new(t)))),
            ),
            TypeVariant::OperationMeta => Box::new(
                ReadXdrIter::<_, OperationMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationMeta(Box::new(t)))),
            ),
            TypeVariant::TransactionMetaV1 => Box::new(
                ReadXdrIter::<_, TransactionMetaV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV1(Box::new(t)))),
            ),
            TypeVariant::TransactionMetaV2 => Box::new(
                ReadXdrIter::<_, TransactionMetaV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV2(Box::new(t)))),
            ),
            TypeVariant::ContractEventType => Box::new(
                ReadXdrIter::<_, ContractEventType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventType(Box::new(t)))),
            ),
            TypeVariant::ContractEvent => Box::new(
                ReadXdrIter::<_, ContractEvent>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEvent(Box::new(t)))),
            ),
            TypeVariant::ContractEventBody => Box::new(
                ReadXdrIter::<_, ContractEventBody>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventBody(Box::new(t)))),
            ),
            TypeVariant::ContractEventV0 => Box::new(
                ReadXdrIter::<_, ContractEventV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventV0(Box::new(t)))),
            ),
            TypeVariant::DiagnosticEvent => Box::new(
                ReadXdrIter::<_, DiagnosticEvent>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DiagnosticEvent(Box::new(t)))),
            ),
            TypeVariant::SorobanTransactionMetaExtV1 => Box::new(
                ReadXdrIter::<_, SorobanTransactionMetaExtV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMetaExtV1(Box::new(t)))),
            ),
            TypeVariant::SorobanTransactionMetaExt => Box::new(
                ReadXdrIter::<_, SorobanTransactionMetaExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMetaExt(Box::new(t)))),
            ),
            TypeVariant::SorobanTransactionMeta => Box::new(
                ReadXdrIter::<_, SorobanTransactionMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMeta(Box::new(t)))),
            ),
            TypeVariant::TransactionMetaV3 => Box::new(
                ReadXdrIter::<_, TransactionMetaV3>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV3(Box::new(t)))),
            ),
            TypeVariant::InvokeHostFunctionSuccessPreImage => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionSuccessPreImage>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InvokeHostFunctionSuccessPreImage(Box::new(t)))),
            ),
            TypeVariant::TransactionMeta => Box::new(
                ReadXdrIter::<_, TransactionMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMeta(Box::new(t)))),
            ),
            TypeVariant::TransactionResultMeta => Box::new(
                ReadXdrIter::<_, TransactionResultMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultMeta(Box::new(t)))),
            ),
            TypeVariant::UpgradeEntryMeta => Box::new(
                ReadXdrIter::<_, UpgradeEntryMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeEntryMeta(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseMetaV0 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV0(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseMetaExtV1 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaExtV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExtV1(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseMetaExt => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExt(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseMetaV1 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV1(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseMeta => Box::new(
                ReadXdrIter::<_, LedgerCloseMeta>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMeta(Box::new(t)))),
            ),
            TypeVariant::ErrorCode => Box::new(
                ReadXdrIter::<_, ErrorCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ErrorCode(Box::new(t)))),
            ),
            TypeVariant::SError => Box::new(
                ReadXdrIter::<_, SError>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SError(Box::new(t)))),
            ),
            TypeVariant::SendMore => Box::new(
                ReadXdrIter::<_, SendMore>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMore(Box::new(t)))),
            ),
            TypeVariant::SendMoreExtended => Box::new(
                ReadXdrIter::<_, SendMoreExtended>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMoreExtended(Box::new(t)))),
            ),
            TypeVariant::AuthCert => Box::new(
                ReadXdrIter::<_, AuthCert>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthCert(Box::new(t)))),
            ),
            TypeVariant::Hello => Box::new(
                ReadXdrIter::<_, Hello>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hello(Box::new(t)))),
            ),
            TypeVariant::Auth => Box::new(
                ReadXdrIter::<_, Auth>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Auth(Box::new(t)))),
            ),
            TypeVariant::IpAddrType => Box::new(
                ReadXdrIter::<_, IpAddrType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::IpAddrType(Box::new(t)))),
            ),
            TypeVariant::PeerAddress => Box::new(
                ReadXdrIter::<_, PeerAddress>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddress(Box::new(t)))),
            ),
            TypeVariant::PeerAddressIp => Box::new(
                ReadXdrIter::<_, PeerAddressIp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddressIp(Box::new(t)))),
            ),
            TypeVariant::MessageType => Box::new(
                ReadXdrIter::<_, MessageType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MessageType(Box::new(t)))),
            ),
            TypeVariant::DontHave => Box::new(
                ReadXdrIter::<_, DontHave>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DontHave(Box::new(t)))),
            ),
            TypeVariant::SurveyMessageCommandType => Box::new(
                ReadXdrIter::<_, SurveyMessageCommandType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyMessageCommandType(Box::new(t)))),
            ),
            TypeVariant::SurveyMessageResponseType => Box::new(
                ReadXdrIter::<_, SurveyMessageResponseType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyMessageResponseType(Box::new(t)))),
            ),
            TypeVariant::SurveyRequestMessage => Box::new(
                ReadXdrIter::<_, SurveyRequestMessage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyRequestMessage(Box::new(t)))),
            ),
            TypeVariant::SignedSurveyRequestMessage => Box::new(
                ReadXdrIter::<_, SignedSurveyRequestMessage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignedSurveyRequestMessage(Box::new(t)))),
            ),
            TypeVariant::EncryptedBody => Box::new(
                ReadXdrIter::<_, EncryptedBody>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EncryptedBody(Box::new(t)))),
            ),
            TypeVariant::SurveyResponseMessage => Box::new(
                ReadXdrIter::<_, SurveyResponseMessage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseMessage(Box::new(t)))),
            ),
            TypeVariant::SignedSurveyResponseMessage => Box::new(
                ReadXdrIter::<_, SignedSurveyResponseMessage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignedSurveyResponseMessage(Box::new(t)))),
            ),
            TypeVariant::PeerStats => Box::new(
                ReadXdrIter::<_, PeerStats>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerStats(Box::new(t)))),
            ),
            TypeVariant::PeerStatList => Box::new(
                ReadXdrIter::<_, PeerStatList>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerStatList(Box::new(t)))),
            ),
            TypeVariant::TopologyResponseBodyV0 => Box::new(
                ReadXdrIter::<_, TopologyResponseBodyV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TopologyResponseBodyV0(Box::new(t)))),
            ),
            TypeVariant::TopologyResponseBodyV1 => Box::new(
                ReadXdrIter::<_, TopologyResponseBodyV1>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TopologyResponseBodyV1(Box::new(t)))),
            ),
            TypeVariant::SurveyResponseBody => Box::new(
                ReadXdrIter::<_, SurveyResponseBody>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseBody(Box::new(t)))),
            ),
            TypeVariant::TxAdvertVector => Box::new(
                ReadXdrIter::<_, TxAdvertVector>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxAdvertVector(Box::new(t)))),
            ),
            TypeVariant::FloodAdvert => Box::new(
                ReadXdrIter::<_, FloodAdvert>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodAdvert(Box::new(t)))),
            ),
            TypeVariant::TxDemandVector => Box::new(
                ReadXdrIter::<_, TxDemandVector>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxDemandVector(Box::new(t)))),
            ),
            TypeVariant::FloodDemand => Box::new(
                ReadXdrIter::<_, FloodDemand>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodDemand(Box::new(t)))),
            ),
            TypeVariant::StellarMessage => Box::new(
                ReadXdrIter::<_, StellarMessage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarMessage(Box::new(t)))),
            ),
            TypeVariant::AuthenticatedMessage => Box::new(
                ReadXdrIter::<_, AuthenticatedMessage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthenticatedMessage(Box::new(t)))),
            ),
            TypeVariant::AuthenticatedMessageV0 => Box::new(
                ReadXdrIter::<_, AuthenticatedMessageV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthenticatedMessageV0(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolParameters => Box::new(
                ReadXdrIter::<_, LiquidityPoolParameters>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolParameters(Box::new(t)))),
            ),
            TypeVariant::MuxedAccount => Box::new(
                ReadXdrIter::<_, MuxedAccount>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccount(Box::new(t)))),
            ),
            TypeVariant::MuxedAccountMed25519 => Box::new(
                ReadXdrIter::<_, MuxedAccountMed25519>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccountMed25519(Box::new(t)))),
            ),
            TypeVariant::DecoratedSignature => Box::new(
                ReadXdrIter::<_, DecoratedSignature>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DecoratedSignature(Box::new(t)))),
            ),
            TypeVariant::OperationType => Box::new(
                ReadXdrIter::<_, OperationType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationType(Box::new(t)))),
            ),
            TypeVariant::CreateAccountOp => Box::new(
                ReadXdrIter::<_, CreateAccountOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountOp(Box::new(t)))),
            ),
            TypeVariant::PaymentOp => Box::new(
                ReadXdrIter::<_, PaymentOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentOp(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictReceiveOp => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictReceiveOp(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictSendOp => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendOp(Box::new(t)))),
            ),
            TypeVariant::ManageSellOfferOp => Box::new(
                ReadXdrIter::<_, ManageSellOfferOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferOp(Box::new(t)))),
            ),
            TypeVariant::ManageBuyOfferOp => Box::new(
                ReadXdrIter::<_, ManageBuyOfferOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferOp(Box::new(t)))),
            ),
            TypeVariant::CreatePassiveSellOfferOp => Box::new(
                ReadXdrIter::<_, CreatePassiveSellOfferOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreatePassiveSellOfferOp(Box::new(t)))),
            ),
            TypeVariant::SetOptionsOp => Box::new(
                ReadXdrIter::<_, SetOptionsOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsOp(Box::new(t)))),
            ),
            TypeVariant::ChangeTrustAsset => Box::new(
                ReadXdrIter::<_, ChangeTrustAsset>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustAsset(Box::new(t)))),
            ),
            TypeVariant::ChangeTrustOp => Box::new(
                ReadXdrIter::<_, ChangeTrustOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustOp(Box::new(t)))),
            ),
            TypeVariant::AllowTrustOp => Box::new(
                ReadXdrIter::<_, AllowTrustOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustOp(Box::new(t)))),
            ),
            TypeVariant::ManageDataOp => Box::new(
                ReadXdrIter::<_, ManageDataOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataOp(Box::new(t)))),
            ),
            TypeVariant::BumpSequenceOp => Box::new(
                ReadXdrIter::<_, BumpSequenceOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceOp(Box::new(t)))),
            ),
            TypeVariant::CreateClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateClaimableBalanceOp(Box::new(t)))),
            ),
            TypeVariant::ClaimClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimClaimableBalanceOp(Box::new(t)))),
            ),
            TypeVariant::BeginSponsoringFutureReservesOp => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesOp>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesOp(Box::new(t)))),
            ),
            TypeVariant::RevokeSponsorshipType => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipType(Box::new(t)))),
            ),
            TypeVariant::RevokeSponsorshipOp => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipOp(Box::new(t)))),
            ),
            TypeVariant::RevokeSponsorshipOpSigner => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipOpSigner>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipOpSigner(Box::new(t)))),
            ),
            TypeVariant::ClawbackOp => Box::new(
                ReadXdrIter::<_, ClawbackOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackOp(Box::new(t)))),
            ),
            TypeVariant::ClawbackClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackClaimableBalanceOp(Box::new(t)))),
            ),
            TypeVariant::SetTrustLineFlagsOp => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsOp(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolDepositOp => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolDepositOp(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolWithdrawOp => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolWithdrawOp(Box::new(t)))),
            ),
            TypeVariant::HostFunctionType => Box::new(
                ReadXdrIter::<_, HostFunctionType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunctionType(Box::new(t)))),
            ),
            TypeVariant::ContractIdPreimageType => Box::new(
                ReadXdrIter::<_, ContractIdPreimageType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimageType(Box::new(t)))),
            ),
            TypeVariant::ContractIdPreimage => Box::new(
                ReadXdrIter::<_, ContractIdPreimage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimage(Box::new(t)))),
            ),
            TypeVariant::ContractIdPreimageFromAddress => Box::new(
                ReadXdrIter::<_, ContractIdPreimageFromAddress>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractIdPreimageFromAddress(Box::new(t)))),
            ),
            TypeVariant::CreateContractArgs => Box::new(
                ReadXdrIter::<_, CreateContractArgs>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateContractArgs(Box::new(t)))),
            ),
            TypeVariant::InvokeContractArgs => Box::new(
                ReadXdrIter::<_, InvokeContractArgs>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeContractArgs(Box::new(t)))),
            ),
            TypeVariant::HostFunction => Box::new(
                ReadXdrIter::<_, HostFunction>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunction(Box::new(t)))),
            ),
            TypeVariant::SorobanAuthorizedFunctionType => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedFunctionType>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAuthorizedFunctionType(Box::new(t)))),
            ),
            TypeVariant::SorobanAuthorizedFunction => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedFunction>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizedFunction(Box::new(t)))),
            ),
            TypeVariant::SorobanAuthorizedInvocation => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedInvocation>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizedInvocation(Box::new(t)))),
            ),
            TypeVariant::SorobanAddressCredentials => Box::new(
                ReadXdrIter::<_, SorobanAddressCredentials>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAddressCredentials(Box::new(t)))),
            ),
            TypeVariant::SorobanCredentialsType => Box::new(
                ReadXdrIter::<_, SorobanCredentialsType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanCredentialsType(Box::new(t)))),
            ),
            TypeVariant::SorobanCredentials => Box::new(
                ReadXdrIter::<_, SorobanCredentials>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanCredentials(Box::new(t)))),
            ),
            TypeVariant::SorobanAuthorizationEntry => Box::new(
                ReadXdrIter::<_, SorobanAuthorizationEntry>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizationEntry(Box::new(t)))),
            ),
            TypeVariant::InvokeHostFunctionOp => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionOp(Box::new(t)))),
            ),
            TypeVariant::ExtendFootprintTtlOp => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlOp(Box::new(t)))),
            ),
            TypeVariant::RestoreFootprintOp => Box::new(
                ReadXdrIter::<_, RestoreFootprintOp>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintOp(Box::new(t)))),
            ),
            TypeVariant::Operation => Box::new(
                ReadXdrIter::<_, Operation>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Operation(Box::new(t)))),
            ),
            TypeVariant::OperationBody => Box::new(
                ReadXdrIter::<_, OperationBody>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationBody(Box::new(t)))),
            ),
            TypeVariant::HashIdPreimage => Box::new(
                ReadXdrIter::<_, HashIdPreimage>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimage(Box::new(t)))),
            ),
            TypeVariant::HashIdPreimageOperationId => Box::new(
                ReadXdrIter::<_, HashIdPreimageOperationId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageOperationId(Box::new(t)))),
            ),
            TypeVariant::HashIdPreimageRevokeId => Box::new(
                ReadXdrIter::<_, HashIdPreimageRevokeId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageRevokeId(Box::new(t)))),
            ),
            TypeVariant::HashIdPreimageContractId => Box::new(
                ReadXdrIter::<_, HashIdPreimageContractId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageContractId(Box::new(t)))),
            ),
            TypeVariant::HashIdPreimageSorobanAuthorization => Box::new(
                ReadXdrIter::<_, HashIdPreimageSorobanAuthorization>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::HashIdPreimageSorobanAuthorization(Box::new(t)))),
            ),
            TypeVariant::MemoType => Box::new(
                ReadXdrIter::<_, MemoType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MemoType(Box::new(t)))),
            ),
            TypeVariant::Memo => Box::new(
                ReadXdrIter::<_, Memo>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Memo(Box::new(t)))),
            ),
            TypeVariant::TimeBounds => Box::new(
                ReadXdrIter::<_, TimeBounds>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeBounds(Box::new(t)))),
            ),
            TypeVariant::LedgerBounds => Box::new(
                ReadXdrIter::<_, LedgerBounds>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerBounds(Box::new(t)))),
            ),
            TypeVariant::PreconditionsV2 => Box::new(
                ReadXdrIter::<_, PreconditionsV2>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionsV2(Box::new(t)))),
            ),
            TypeVariant::PreconditionType => Box::new(
                ReadXdrIter::<_, PreconditionType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionType(Box::new(t)))),
            ),
            TypeVariant::Preconditions => Box::new(
                ReadXdrIter::<_, Preconditions>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Preconditions(Box::new(t)))),
            ),
            TypeVariant::LedgerFootprint => Box::new(
                ReadXdrIter::<_, LedgerFootprint>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerFootprint(Box::new(t)))),
            ),
            TypeVariant::SorobanResources => Box::new(
                ReadXdrIter::<_, SorobanResources>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanResources(Box::new(t)))),
            ),
            TypeVariant::SorobanTransactionData => Box::new(
                ReadXdrIter::<_, SorobanTransactionData>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionData(Box::new(t)))),
            ),
            TypeVariant::TransactionV0 => Box::new(
                ReadXdrIter::<_, TransactionV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0(Box::new(t)))),
            ),
            TypeVariant::TransactionV0Ext => Box::new(
                ReadXdrIter::<_, TransactionV0Ext>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Ext(Box::new(t)))),
            ),
            TypeVariant::TransactionV0Envelope => Box::new(
                ReadXdrIter::<_, TransactionV0Envelope>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Envelope(Box::new(t)))),
            ),
            TypeVariant::Transaction => Box::new(
                ReadXdrIter::<_, Transaction>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Transaction(Box::new(t)))),
            ),
            TypeVariant::TransactionExt => Box::new(
                ReadXdrIter::<_, TransactionExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionExt(Box::new(t)))),
            ),
            TypeVariant::TransactionV1Envelope => Box::new(
                ReadXdrIter::<_, TransactionV1Envelope>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV1Envelope(Box::new(t)))),
            ),
            TypeVariant::FeeBumpTransaction => Box::new(
                ReadXdrIter::<_, FeeBumpTransaction>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransaction(Box::new(t)))),
            ),
            TypeVariant::FeeBumpTransactionInnerTx => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionInnerTx>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionInnerTx(Box::new(t)))),
            ),
            TypeVariant::FeeBumpTransactionExt => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionExt(Box::new(t)))),
            ),
            TypeVariant::FeeBumpTransactionEnvelope => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionEnvelope>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionEnvelope(Box::new(t)))),
            ),
            TypeVariant::TransactionEnvelope => Box::new(
                ReadXdrIter::<_, TransactionEnvelope>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEnvelope(Box::new(t)))),
            ),
            TypeVariant::TransactionSignaturePayload => Box::new(
                ReadXdrIter::<_, TransactionSignaturePayload>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSignaturePayload(Box::new(t)))),
            ),
            TypeVariant::TransactionSignaturePayloadTaggedTransaction => Box::new(
                ReadXdrIter::<_, TransactionSignaturePayloadTaggedTransaction>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| {
                    r.map(|t| Self::TransactionSignaturePayloadTaggedTransaction(Box::new(t)))
                }),
            ),
            TypeVariant::ClaimAtomType => Box::new(
                ReadXdrIter::<_, ClaimAtomType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtomType(Box::new(t)))),
            ),
            TypeVariant::ClaimOfferAtomV0 => Box::new(
                ReadXdrIter::<_, ClaimOfferAtomV0>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtomV0(Box::new(t)))),
            ),
            TypeVariant::ClaimOfferAtom => Box::new(
                ReadXdrIter::<_, ClaimOfferAtom>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtom(Box::new(t)))),
            ),
            TypeVariant::ClaimLiquidityAtom => Box::new(
                ReadXdrIter::<_, ClaimLiquidityAtom>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimLiquidityAtom(Box::new(t)))),
            ),
            TypeVariant::ClaimAtom => Box::new(
                ReadXdrIter::<_, ClaimAtom>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtom(Box::new(t)))),
            ),
            TypeVariant::CreateAccountResultCode => Box::new(
                ReadXdrIter::<_, CreateAccountResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountResultCode(Box::new(t)))),
            ),
            TypeVariant::CreateAccountResult => Box::new(
                ReadXdrIter::<_, CreateAccountResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountResult(Box::new(t)))),
            ),
            TypeVariant::PaymentResultCode => Box::new(
                ReadXdrIter::<_, PaymentResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResultCode(Box::new(t)))),
            ),
            TypeVariant::PaymentResult => Box::new(
                ReadXdrIter::<_, PaymentResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResult(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictReceiveResultCode => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultCode(Box::new(t)))),
            ),
            TypeVariant::SimplePaymentResult => Box::new(
                ReadXdrIter::<_, SimplePaymentResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SimplePaymentResult(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictReceiveResult => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResult>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResult(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictReceiveResultSuccess => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResultSuccess>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultSuccess(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictSendResultCode => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendResultCode(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictSendResult => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendResult(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictSendResultSuccess => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResultSuccess>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendResultSuccess(Box::new(t)))),
            ),
            TypeVariant::ManageSellOfferResultCode => Box::new(
                ReadXdrIter::<_, ManageSellOfferResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferResultCode(Box::new(t)))),
            ),
            TypeVariant::ManageOfferEffect => Box::new(
                ReadXdrIter::<_, ManageOfferEffect>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferEffect(Box::new(t)))),
            ),
            TypeVariant::ManageOfferSuccessResult => Box::new(
                ReadXdrIter::<_, ManageOfferSuccessResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferSuccessResult(Box::new(t)))),
            ),
            TypeVariant::ManageOfferSuccessResultOffer => Box::new(
                ReadXdrIter::<_, ManageOfferSuccessResultOffer>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ManageOfferSuccessResultOffer(Box::new(t)))),
            ),
            TypeVariant::ManageSellOfferResult => Box::new(
                ReadXdrIter::<_, ManageSellOfferResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferResult(Box::new(t)))),
            ),
            TypeVariant::ManageBuyOfferResultCode => Box::new(
                ReadXdrIter::<_, ManageBuyOfferResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferResultCode(Box::new(t)))),
            ),
            TypeVariant::ManageBuyOfferResult => Box::new(
                ReadXdrIter::<_, ManageBuyOfferResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferResult(Box::new(t)))),
            ),
            TypeVariant::SetOptionsResultCode => Box::new(
                ReadXdrIter::<_, SetOptionsResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResultCode(Box::new(t)))),
            ),
            TypeVariant::SetOptionsResult => Box::new(
                ReadXdrIter::<_, SetOptionsResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResult(Box::new(t)))),
            ),
            TypeVariant::ChangeTrustResultCode => Box::new(
                ReadXdrIter::<_, ChangeTrustResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResultCode(Box::new(t)))),
            ),
            TypeVariant::ChangeTrustResult => Box::new(
                ReadXdrIter::<_, ChangeTrustResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResult(Box::new(t)))),
            ),
            TypeVariant::AllowTrustResultCode => Box::new(
                ReadXdrIter::<_, AllowTrustResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResultCode(Box::new(t)))),
            ),
            TypeVariant::AllowTrustResult => Box::new(
                ReadXdrIter::<_, AllowTrustResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResult(Box::new(t)))),
            ),
            TypeVariant::AccountMergeResultCode => Box::new(
                ReadXdrIter::<_, AccountMergeResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountMergeResultCode(Box::new(t)))),
            ),
            TypeVariant::AccountMergeResult => Box::new(
                ReadXdrIter::<_, AccountMergeResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountMergeResult(Box::new(t)))),
            ),
            TypeVariant::InflationResultCode => Box::new(
                ReadXdrIter::<_, InflationResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResultCode(Box::new(t)))),
            ),
            TypeVariant::InflationPayout => Box::new(
                ReadXdrIter::<_, InflationPayout>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationPayout(Box::new(t)))),
            ),
            TypeVariant::InflationResult => Box::new(
                ReadXdrIter::<_, InflationResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResult(Box::new(t)))),
            ),
            TypeVariant::ManageDataResultCode => Box::new(
                ReadXdrIter::<_, ManageDataResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResultCode(Box::new(t)))),
            ),
            TypeVariant::ManageDataResult => Box::new(
                ReadXdrIter::<_, ManageDataResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResult(Box::new(t)))),
            ),
            TypeVariant::BumpSequenceResultCode => Box::new(
                ReadXdrIter::<_, BumpSequenceResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceResultCode(Box::new(t)))),
            ),
            TypeVariant::BumpSequenceResult => Box::new(
                ReadXdrIter::<_, BumpSequenceResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceResult(Box::new(t)))),
            ),
            TypeVariant::CreateClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreateClaimableBalanceResultCode(Box::new(t)))),
            ),
            TypeVariant::CreateClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateClaimableBalanceResult(Box::new(t)))),
            ),
            TypeVariant::ClaimClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimClaimableBalanceResultCode(Box::new(t)))),
            ),
            TypeVariant::ClaimClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimClaimableBalanceResult(Box::new(t)))),
            ),
            TypeVariant::BeginSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResultCode(Box::new(t)))),
            ),
            TypeVariant::BeginSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesResult>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResult(Box::new(t)))),
            ),
            TypeVariant::EndSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, EndSponsoringFutureReservesResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResultCode(Box::new(t)))),
            ),
            TypeVariant::EndSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, EndSponsoringFutureReservesResult>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResult(Box::new(t)))),
            ),
            TypeVariant::RevokeSponsorshipResultCode => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipResultCode(Box::new(t)))),
            ),
            TypeVariant::RevokeSponsorshipResult => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipResult(Box::new(t)))),
            ),
            TypeVariant::ClawbackResultCode => Box::new(
                ReadXdrIter::<_, ClawbackResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResultCode(Box::new(t)))),
            ),
            TypeVariant::ClawbackResult => Box::new(
                ReadXdrIter::<_, ClawbackResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResult(Box::new(t)))),
            ),
            TypeVariant::ClawbackClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResultCode(Box::new(t)))),
            ),
            TypeVariant::ClawbackClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceResult>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResult(Box::new(t)))),
            ),
            TypeVariant::SetTrustLineFlagsResultCode => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsResultCode(Box::new(t)))),
            ),
            TypeVariant::SetTrustLineFlagsResult => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsResult(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolDepositResultCode => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolDepositResultCode(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolDepositResult => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolDepositResult(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolWithdrawResultCode => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawResultCode>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResultCode(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolWithdrawResult => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResult(Box::new(t)))),
            ),
            TypeVariant::InvokeHostFunctionResultCode => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionResultCode(Box::new(t)))),
            ),
            TypeVariant::InvokeHostFunctionResult => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionResult(Box::new(t)))),
            ),
            TypeVariant::ExtendFootprintTtlResultCode => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlResultCode(Box::new(t)))),
            ),
            TypeVariant::ExtendFootprintTtlResult => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlResult(Box::new(t)))),
            ),
            TypeVariant::RestoreFootprintResultCode => Box::new(
                ReadXdrIter::<_, RestoreFootprintResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintResultCode(Box::new(t)))),
            ),
            TypeVariant::RestoreFootprintResult => Box::new(
                ReadXdrIter::<_, RestoreFootprintResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintResult(Box::new(t)))),
            ),
            TypeVariant::OperationResultCode => Box::new(
                ReadXdrIter::<_, OperationResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultCode(Box::new(t)))),
            ),
            TypeVariant::OperationResult => Box::new(
                ReadXdrIter::<_, OperationResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResult(Box::new(t)))),
            ),
            TypeVariant::OperationResultTr => Box::new(
                ReadXdrIter::<_, OperationResultTr>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultTr(Box::new(t)))),
            ),
            TypeVariant::TransactionResultCode => Box::new(
                ReadXdrIter::<_, TransactionResultCode>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultCode(Box::new(t)))),
            ),
            TypeVariant::InnerTransactionResult => Box::new(
                ReadXdrIter::<_, InnerTransactionResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResult(Box::new(t)))),
            ),
            TypeVariant::InnerTransactionResultResult => Box::new(
                ReadXdrIter::<_, InnerTransactionResultResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultResult(Box::new(t)))),
            ),
            TypeVariant::InnerTransactionResultExt => Box::new(
                ReadXdrIter::<_, InnerTransactionResultExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultExt(Box::new(t)))),
            ),
            TypeVariant::InnerTransactionResultPair => Box::new(
                ReadXdrIter::<_, InnerTransactionResultPair>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultPair(Box::new(t)))),
            ),
            TypeVariant::TransactionResult => Box::new(
                ReadXdrIter::<_, TransactionResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResult(Box::new(t)))),
            ),
            TypeVariant::TransactionResultResult => Box::new(
                ReadXdrIter::<_, TransactionResultResult>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultResult(Box::new(t)))),
            ),
            TypeVariant::TransactionResultExt => Box::new(
                ReadXdrIter::<_, TransactionResultExt>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultExt(Box::new(t)))),
            ),
            TypeVariant::Hash => Box::new(
                ReadXdrIter::<_, Hash>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hash(Box::new(t)))),
            ),
            TypeVariant::Uint256 => Box::new(
                ReadXdrIter::<_, Uint256>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint256(Box::new(t)))),
            ),
            TypeVariant::Uint32 => Box::new(
                ReadXdrIter::<_, Uint32>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint32(Box::new(t)))),
            ),
            TypeVariant::Int32 => Box::new(
                ReadXdrIter::<_, Int32>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int32(Box::new(t)))),
            ),
            TypeVariant::Uint64 => Box::new(
                ReadXdrIter::<_, Uint64>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint64(Box::new(t)))),
            ),
            TypeVariant::Int64 => Box::new(
                ReadXdrIter::<_, Int64>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int64(Box::new(t)))),
            ),
            TypeVariant::TimePoint => Box::new(
                ReadXdrIter::<_, TimePoint>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimePoint(Box::new(t)))),
            ),
            TypeVariant::Duration => Box::new(
                ReadXdrIter::<_, Duration>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Duration(Box::new(t)))),
            ),
            TypeVariant::ExtensionPoint => Box::new(
                ReadXdrIter::<_, ExtensionPoint>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtensionPoint(Box::new(t)))),
            ),
            TypeVariant::CryptoKeyType => Box::new(
                ReadXdrIter::<_, CryptoKeyType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CryptoKeyType(Box::new(t)))),
            ),
            TypeVariant::PublicKeyType => Box::new(
                ReadXdrIter::<_, PublicKeyType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKeyType(Box::new(t)))),
            ),
            TypeVariant::SignerKeyType => Box::new(
                ReadXdrIter::<_, SignerKeyType>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKeyType(Box::new(t)))),
            ),
            TypeVariant::PublicKey => Box::new(
                ReadXdrIter::<_, PublicKey>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKey(Box::new(t)))),
            ),
            TypeVariant::SignerKey => Box::new(
                ReadXdrIter::<_, SignerKey>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKey(Box::new(t)))),
            ),
            TypeVariant::SignerKeyEd25519SignedPayload => Box::new(
                ReadXdrIter::<_, SignerKeyEd25519SignedPayload>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignerKeyEd25519SignedPayload(Box::new(t)))),
            ),
            TypeVariant::Signature => Box::new(
                ReadXdrIter::<_, Signature>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signature(Box::new(t)))),
            ),
            TypeVariant::SignatureHint => Box::new(
                ReadXdrIter::<_, SignatureHint>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignatureHint(Box::new(t)))),
            ),
            TypeVariant::NodeId => Box::new(
                ReadXdrIter::<_, NodeId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::NodeId(Box::new(t)))),
            ),
            TypeVariant::AccountId => Box::new(
                ReadXdrIter::<_, AccountId>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountId(Box::new(t)))),
            ),
            TypeVariant::Curve25519Secret => Box::new(
                ReadXdrIter::<_, Curve25519Secret>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Secret(Box::new(t)))),
            ),
            TypeVariant::Curve25519Public => Box::new(
                ReadXdrIter::<_, Curve25519Public>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Public(Box::new(t)))),
            ),
            TypeVariant::HmacSha256Key => Box::new(
                ReadXdrIter::<_, HmacSha256Key>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Key(Box::new(t)))),
            ),
            TypeVariant::HmacSha256Mac => Box::new(
                ReadXdrIter::<_, HmacSha256Mac>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Mac(Box::new(t)))),
            ),
        }
    }

    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr_framed_iter<R: Read>(
        v: TypeVariant,
        r: &mut Limited<R>,
    ) -> Box<dyn Iterator<Item = Result<Self>> + '_> {
        match v {
            TypeVariant::Value => Box::new(
                ReadXdrIter::<_, Frame<Value>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Value(Box::new(t.0)))),
            ),
            TypeVariant::ScpBallot => Box::new(
                ReadXdrIter::<_, Frame<ScpBallot>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpBallot(Box::new(t.0)))),
            ),
            TypeVariant::ScpStatementType => Box::new(
                ReadXdrIter::<_, Frame<ScpStatementType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementType(Box::new(t.0)))),
            ),
            TypeVariant::ScpNomination => Box::new(
                ReadXdrIter::<_, Frame<ScpNomination>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpNomination(Box::new(t.0)))),
            ),
            TypeVariant::ScpStatement => Box::new(
                ReadXdrIter::<_, Frame<ScpStatement>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatement(Box::new(t.0)))),
            ),
            TypeVariant::ScpStatementPledges => Box::new(
                ReadXdrIter::<_, Frame<ScpStatementPledges>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPledges(Box::new(t.0)))),
            ),
            TypeVariant::ScpStatementPrepare => Box::new(
                ReadXdrIter::<_, Frame<ScpStatementPrepare>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPrepare(Box::new(t.0)))),
            ),
            TypeVariant::ScpStatementConfirm => Box::new(
                ReadXdrIter::<_, Frame<ScpStatementConfirm>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementConfirm(Box::new(t.0)))),
            ),
            TypeVariant::ScpStatementExternalize => Box::new(
                ReadXdrIter::<_, Frame<ScpStatementExternalize>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScpStatementExternalize(Box::new(t.0)))),
            ),
            TypeVariant::ScpEnvelope => Box::new(
                ReadXdrIter::<_, Frame<ScpEnvelope>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpEnvelope(Box::new(t.0)))),
            ),
            TypeVariant::ScpQuorumSet => Box::new(
                ReadXdrIter::<_, Frame<ScpQuorumSet>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpQuorumSet(Box::new(t.0)))),
            ),
            TypeVariant::ConfigSettingContractExecutionLanesV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractExecutionLanesV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractExecutionLanesV0(Box::new(t.0)))),
            ),
            TypeVariant::ConfigSettingContractComputeV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractComputeV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractComputeV0(Box::new(t.0)))),
            ),
            TypeVariant::ConfigSettingContractLedgerCostV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractLedgerCostV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractLedgerCostV0(Box::new(t.0)))),
            ),
            TypeVariant::ConfigSettingContractHistoricalDataV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractHistoricalDataV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractHistoricalDataV0(Box::new(t.0)))),
            ),
            TypeVariant::ConfigSettingContractEventsV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractEventsV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractEventsV0(Box::new(t.0)))),
            ),
            TypeVariant::ConfigSettingContractBandwidthV0 => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingContractBandwidthV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ConfigSettingContractBandwidthV0(Box::new(t.0)))),
            ),
            TypeVariant::ContractCostType => Box::new(
                ReadXdrIter::<_, Frame<ContractCostType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostType(Box::new(t.0)))),
            ),
            TypeVariant::ContractCostParamEntry => Box::new(
                ReadXdrIter::<_, Frame<ContractCostParamEntry>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractCostParamEntry(Box::new(t.0)))),
            ),
            TypeVariant::StateArchivalSettings => Box::new(
                ReadXdrIter::<_, Frame<StateArchivalSettings>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StateArchivalSettings(Box::new(t.0)))),
            ),
            TypeVariant::EvictionIterator => Box::new(
                ReadXdrIter::<_, Frame<EvictionIterator>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EvictionIterator(Box::new(t.0)))),
            ),
            TypeVariant::ContractCostParams => Box::new(
                ReadXdrIter::<_, Frame<ContractCostParams>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostParams(Box::new(t.0)))),
            ),
            TypeVariant::ConfigSettingId => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingId>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingId(Box::new(t.0)))),
            ),
            TypeVariant::ConfigSettingEntry => Box::new(
                ReadXdrIter::<_, Frame<ConfigSettingEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingEntry(Box::new(t.0)))),
            ),
            TypeVariant::ScEnvMetaKind => Box::new(
                ReadXdrIter::<_, Frame<ScEnvMetaKind>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaKind(Box::new(t.0)))),
            ),
            TypeVariant::ScEnvMetaEntry => Box::new(
                ReadXdrIter::<_, Frame<ScEnvMetaEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaEntry(Box::new(t.0)))),
            ),
            TypeVariant::ScMetaV0 => Box::new(
                ReadXdrIter::<_, Frame<ScMetaV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaV0(Box::new(t.0)))),
            ),
            TypeVariant::ScMetaKind => Box::new(
                ReadXdrIter::<_, Frame<ScMetaKind>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaKind(Box::new(t.0)))),
            ),
            TypeVariant::ScMetaEntry => Box::new(
                ReadXdrIter::<_, Frame<ScMetaEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaEntry(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecType => Box::new(
                ReadXdrIter::<_, Frame<ScSpecType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecType(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecTypeOption => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeOption>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeOption(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecTypeResult => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeResult(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecTypeVec => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeVec>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeVec(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecTypeMap => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeMap>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeMap(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecTypeTuple => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeTuple>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeTuple(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecTypeBytesN => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeBytesN>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeBytesN(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecTypeUdt => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeUdt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeUdt(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecTypeDef => Box::new(
                ReadXdrIter::<_, Frame<ScSpecTypeDef>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeDef(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecUdtStructFieldV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtStructFieldV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScSpecUdtStructFieldV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecUdtStructV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtStructV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtStructV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseVoidV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtUnionCaseVoidV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseVoidV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseTupleV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtUnionCaseTupleV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseTupleV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseV0Kind => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtUnionCaseV0Kind>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0Kind(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtUnionCaseV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecUdtUnionV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtUnionV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecUdtEnumCaseV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtEnumCaseV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumCaseV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecUdtEnumV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtEnumV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecUdtErrorEnumCaseV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtErrorEnumCaseV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumCaseV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecUdtErrorEnumV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecUdtErrorEnumV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecFunctionInputV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecFunctionInputV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionInputV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecFunctionV0 => Box::new(
                ReadXdrIter::<_, Frame<ScSpecFunctionV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionV0(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecEntryKind => Box::new(
                ReadXdrIter::<_, Frame<ScSpecEntryKind>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntryKind(Box::new(t.0)))),
            ),
            TypeVariant::ScSpecEntry => Box::new(
                ReadXdrIter::<_, Frame<ScSpecEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntry(Box::new(t.0)))),
            ),
            TypeVariant::ScValType => Box::new(
                ReadXdrIter::<_, Frame<ScValType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScValType(Box::new(t.0)))),
            ),
            TypeVariant::ScErrorType => Box::new(
                ReadXdrIter::<_, Frame<ScErrorType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorType(Box::new(t.0)))),
            ),
            TypeVariant::ScErrorCode => Box::new(
                ReadXdrIter::<_, Frame<ScErrorCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorCode(Box::new(t.0)))),
            ),
            TypeVariant::ScError => Box::new(
                ReadXdrIter::<_, Frame<ScError>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScError(Box::new(t.0)))),
            ),
            TypeVariant::UInt128Parts => Box::new(
                ReadXdrIter::<_, Frame<UInt128Parts>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt128Parts(Box::new(t.0)))),
            ),
            TypeVariant::Int128Parts => Box::new(
                ReadXdrIter::<_, Frame<Int128Parts>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int128Parts(Box::new(t.0)))),
            ),
            TypeVariant::UInt256Parts => Box::new(
                ReadXdrIter::<_, Frame<UInt256Parts>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt256Parts(Box::new(t.0)))),
            ),
            TypeVariant::Int256Parts => Box::new(
                ReadXdrIter::<_, Frame<Int256Parts>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int256Parts(Box::new(t.0)))),
            ),
            TypeVariant::ContractExecutableType => Box::new(
                ReadXdrIter::<_, Frame<ContractExecutableType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractExecutableType(Box::new(t.0)))),
            ),
            TypeVariant::ContractExecutable => Box::new(
                ReadXdrIter::<_, Frame<ContractExecutable>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractExecutable(Box::new(t.0)))),
            ),
            TypeVariant::ScAddressType => Box::new(
                ReadXdrIter::<_, Frame<ScAddressType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddressType(Box::new(t.0)))),
            ),
            TypeVariant::ScAddress => Box::new(
                ReadXdrIter::<_, Frame<ScAddress>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddress(Box::new(t.0)))),
            ),
            TypeVariant::ScVec => Box::new(
                ReadXdrIter::<_, Frame<ScVec>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVec(Box::new(t.0)))),
            ),
            TypeVariant::ScMap => Box::new(
                ReadXdrIter::<_, Frame<ScMap>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMap(Box::new(t.0)))),
            ),
            TypeVariant::ScBytes => Box::new(
                ReadXdrIter::<_, Frame<ScBytes>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScBytes(Box::new(t.0)))),
            ),
            TypeVariant::ScString => Box::new(
                ReadXdrIter::<_, Frame<ScString>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScString(Box::new(t.0)))),
            ),
            TypeVariant::ScSymbol => Box::new(
                ReadXdrIter::<_, Frame<ScSymbol>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSymbol(Box::new(t.0)))),
            ),
            TypeVariant::ScNonceKey => Box::new(
                ReadXdrIter::<_, Frame<ScNonceKey>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScNonceKey(Box::new(t.0)))),
            ),
            TypeVariant::ScContractInstance => Box::new(
                ReadXdrIter::<_, Frame<ScContractInstance>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScContractInstance(Box::new(t.0)))),
            ),
            TypeVariant::ScVal => Box::new(
                ReadXdrIter::<_, Frame<ScVal>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVal(Box::new(t.0)))),
            ),
            TypeVariant::ScMapEntry => Box::new(
                ReadXdrIter::<_, Frame<ScMapEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMapEntry(Box::new(t.0)))),
            ),
            TypeVariant::StoredTransactionSet => Box::new(
                ReadXdrIter::<_, Frame<StoredTransactionSet>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StoredTransactionSet(Box::new(t.0)))),
            ),
            TypeVariant::StoredDebugTransactionSet => Box::new(
                ReadXdrIter::<_, Frame<StoredDebugTransactionSet>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::StoredDebugTransactionSet(Box::new(t.0)))),
            ),
            TypeVariant::PersistedScpStateV0 => Box::new(
                ReadXdrIter::<_, Frame<PersistedScpStateV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV0(Box::new(t.0)))),
            ),
            TypeVariant::PersistedScpStateV1 => Box::new(
                ReadXdrIter::<_, Frame<PersistedScpStateV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV1(Box::new(t.0)))),
            ),
            TypeVariant::PersistedScpState => Box::new(
                ReadXdrIter::<_, Frame<PersistedScpState>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpState(Box::new(t.0)))),
            ),
            TypeVariant::Thresholds => Box::new(
                ReadXdrIter::<_, Frame<Thresholds>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Thresholds(Box::new(t.0)))),
            ),
            TypeVariant::String32 => Box::new(
                ReadXdrIter::<_, Frame<String32>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::String32(Box::new(t.0)))),
            ),
            TypeVariant::String64 => Box::new(
                ReadXdrIter::<_, Frame<String64>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::String64(Box::new(t.0)))),
            ),
            TypeVariant::SequenceNumber => Box::new(
                ReadXdrIter::<_, Frame<SequenceNumber>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SequenceNumber(Box::new(t.0)))),
            ),
            TypeVariant::DataValue => Box::new(
                ReadXdrIter::<_, Frame<DataValue>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataValue(Box::new(t.0)))),
            ),
            TypeVariant::PoolId => Box::new(
                ReadXdrIter::<_, Frame<PoolId>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PoolId(Box::new(t.0)))),
            ),
            TypeVariant::AssetCode4 => Box::new(
                ReadXdrIter::<_, Frame<AssetCode4>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode4(Box::new(t.0)))),
            ),
            TypeVariant::AssetCode12 => Box::new(
                ReadXdrIter::<_, Frame<AssetCode12>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode12(Box::new(t.0)))),
            ),
            TypeVariant::AssetType => Box::new(
                ReadXdrIter::<_, Frame<AssetType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetType(Box::new(t.0)))),
            ),
            TypeVariant::AssetCode => Box::new(
                ReadXdrIter::<_, Frame<AssetCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode(Box::new(t.0)))),
            ),
            TypeVariant::AlphaNum4 => Box::new(
                ReadXdrIter::<_, Frame<AlphaNum4>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum4(Box::new(t.0)))),
            ),
            TypeVariant::AlphaNum12 => Box::new(
                ReadXdrIter::<_, Frame<AlphaNum12>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum12(Box::new(t.0)))),
            ),
            TypeVariant::Asset => Box::new(
                ReadXdrIter::<_, Frame<Asset>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Asset(Box::new(t.0)))),
            ),
            TypeVariant::Price => Box::new(
                ReadXdrIter::<_, Frame<Price>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Price(Box::new(t.0)))),
            ),
            TypeVariant::Liabilities => Box::new(
                ReadXdrIter::<_, Frame<Liabilities>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Liabilities(Box::new(t.0)))),
            ),
            TypeVariant::ThresholdIndexes => Box::new(
                ReadXdrIter::<_, Frame<ThresholdIndexes>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ThresholdIndexes(Box::new(t.0)))),
            ),
            TypeVariant::LedgerEntryType => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryType(Box::new(t.0)))),
            ),
            TypeVariant::Signer => Box::new(
                ReadXdrIter::<_, Frame<Signer>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signer(Box::new(t.0)))),
            ),
            TypeVariant::AccountFlags => Box::new(
                ReadXdrIter::<_, Frame<AccountFlags>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountFlags(Box::new(t.0)))),
            ),
            TypeVariant::SponsorshipDescriptor => Box::new(
                ReadXdrIter::<_, Frame<SponsorshipDescriptor>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SponsorshipDescriptor(Box::new(t.0)))),
            ),
            TypeVariant::AccountEntryExtensionV3 => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExtensionV3>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountEntryExtensionV3(Box::new(t.0)))),
            ),
            TypeVariant::AccountEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExtensionV2>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountEntryExtensionV2(Box::new(t.0)))),
            ),
            TypeVariant::AccountEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExtensionV2Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountEntryExtensionV2Ext(Box::new(t.0)))),
            ),
            TypeVariant::AccountEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExtensionV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountEntryExtensionV1(Box::new(t.0)))),
            ),
            TypeVariant::AccountEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExtensionV1Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountEntryExtensionV1Ext(Box::new(t.0)))),
            ),
            TypeVariant::AccountEntry => Box::new(
                ReadXdrIter::<_, Frame<AccountEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntry(Box::new(t.0)))),
            ),
            TypeVariant::AccountEntryExt => Box::new(
                ReadXdrIter::<_, Frame<AccountEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExt(Box::new(t.0)))),
            ),
            TypeVariant::TrustLineFlags => Box::new(
                ReadXdrIter::<_, Frame<TrustLineFlags>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineFlags(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolType => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolType(Box::new(t.0)))),
            ),
            TypeVariant::TrustLineAsset => Box::new(
                ReadXdrIter::<_, Frame<TrustLineAsset>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineAsset(Box::new(t.0)))),
            ),
            TypeVariant::TrustLineEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntryExtensionV2>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2(Box::new(t.0)))),
            ),
            TypeVariant::TrustLineEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntryExtensionV2Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2Ext(Box::new(t.0)))),
            ),
            TypeVariant::TrustLineEntry => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntry(Box::new(t.0)))),
            ),
            TypeVariant::TrustLineEntryExt => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExt(Box::new(t.0)))),
            ),
            TypeVariant::TrustLineEntryV1 => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntryV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1(Box::new(t.0)))),
            ),
            TypeVariant::TrustLineEntryV1Ext => Box::new(
                ReadXdrIter::<_, Frame<TrustLineEntryV1Ext>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1Ext(Box::new(t.0)))),
            ),
            TypeVariant::OfferEntryFlags => Box::new(
                ReadXdrIter::<_, Frame<OfferEntryFlags>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryFlags(Box::new(t.0)))),
            ),
            TypeVariant::OfferEntry => Box::new(
                ReadXdrIter::<_, Frame<OfferEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntry(Box::new(t.0)))),
            ),
            TypeVariant::OfferEntryExt => Box::new(
                ReadXdrIter::<_, Frame<OfferEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryExt(Box::new(t.0)))),
            ),
            TypeVariant::DataEntry => Box::new(
                ReadXdrIter::<_, Frame<DataEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntry(Box::new(t.0)))),
            ),
            TypeVariant::DataEntryExt => Box::new(
                ReadXdrIter::<_, Frame<DataEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntryExt(Box::new(t.0)))),
            ),
            TypeVariant::ClaimPredicateType => Box::new(
                ReadXdrIter::<_, Frame<ClaimPredicateType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicateType(Box::new(t.0)))),
            ),
            TypeVariant::ClaimPredicate => Box::new(
                ReadXdrIter::<_, Frame<ClaimPredicate>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicate(Box::new(t.0)))),
            ),
            TypeVariant::ClaimantType => Box::new(
                ReadXdrIter::<_, Frame<ClaimantType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantType(Box::new(t.0)))),
            ),
            TypeVariant::Claimant => Box::new(
                ReadXdrIter::<_, Frame<Claimant>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Claimant(Box::new(t.0)))),
            ),
            TypeVariant::ClaimantV0 => Box::new(
                ReadXdrIter::<_, Frame<ClaimantV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantV0(Box::new(t.0)))),
            ),
            TypeVariant::ClaimableBalanceIdType => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceIdType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceIdType(Box::new(t.0)))),
            ),
            TypeVariant::ClaimableBalanceId => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceId>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceId(Box::new(t.0)))),
            ),
            TypeVariant::ClaimableBalanceFlags => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceFlags>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceFlags(Box::new(t.0)))),
            ),
            TypeVariant::ClaimableBalanceEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceEntryExtensionV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1(Box::new(t.0)))),
            ),
            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceEntryExtensionV1Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(t.0)))),
            ),
            TypeVariant::ClaimableBalanceEntry => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntry(Box::new(t.0)))),
            ),
            TypeVariant::ClaimableBalanceEntryExt => Box::new(
                ReadXdrIter::<_, Frame<ClaimableBalanceEntryExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimableBalanceEntryExt(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolConstantProductParameters => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolConstantProductParameters>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolConstantProductParameters(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolEntry => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntry(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolEntryBody => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolEntryBody>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolEntryBody(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolEntryConstantProduct => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolEntryConstantProduct>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolEntryConstantProduct(Box::new(t.0)))),
            ),
            TypeVariant::ContractDataDurability => Box::new(
                ReadXdrIter::<_, Frame<ContractDataDurability>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractDataDurability(Box::new(t.0)))),
            ),
            TypeVariant::ContractDataEntry => Box::new(
                ReadXdrIter::<_, Frame<ContractDataEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractDataEntry(Box::new(t.0)))),
            ),
            TypeVariant::ContractCodeCostInputs => Box::new(
                ReadXdrIter::<_, Frame<ContractCodeCostInputs>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractCodeCostInputs(Box::new(t.0)))),
            ),
            TypeVariant::ContractCodeEntry => Box::new(
                ReadXdrIter::<_, Frame<ContractCodeEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntry(Box::new(t.0)))),
            ),
            TypeVariant::ContractCodeEntryExt => Box::new(
                ReadXdrIter::<_, Frame<ContractCodeEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryExt(Box::new(t.0)))),
            ),
            TypeVariant::ContractCodeEntryV1 => Box::new(
                ReadXdrIter::<_, Frame<ContractCodeEntryV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryV1(Box::new(t.0)))),
            ),
            TypeVariant::TtlEntry => Box::new(
                ReadXdrIter::<_, Frame<TtlEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TtlEntry(Box::new(t.0)))),
            ),
            TypeVariant::LedgerEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryExtensionV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerEntryExtensionV1(Box::new(t.0)))),
            ),
            TypeVariant::LedgerEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryExtensionV1Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerEntryExtensionV1Ext(Box::new(t.0)))),
            ),
            TypeVariant::LedgerEntry => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntry(Box::new(t.0)))),
            ),
            TypeVariant::LedgerEntryData => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryData>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryData(Box::new(t.0)))),
            ),
            TypeVariant::LedgerEntryExt => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExt(Box::new(t.0)))),
            ),
            TypeVariant::LedgerKey => Box::new(
                ReadXdrIter::<_, Frame<LedgerKey>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKey(Box::new(t.0)))),
            ),
            TypeVariant::LedgerKeyAccount => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyAccount>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyAccount(Box::new(t.0)))),
            ),
            TypeVariant::LedgerKeyTrustLine => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyTrustLine>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTrustLine(Box::new(t.0)))),
            ),
            TypeVariant::LedgerKeyOffer => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyOffer>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyOffer(Box::new(t.0)))),
            ),
            TypeVariant::LedgerKeyData => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyData>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyData(Box::new(t.0)))),
            ),
            TypeVariant::LedgerKeyClaimableBalance => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyClaimableBalance>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerKeyClaimableBalance(Box::new(t.0)))),
            ),
            TypeVariant::LedgerKeyLiquidityPool => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyLiquidityPool>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerKeyLiquidityPool(Box::new(t.0)))),
            ),
            TypeVariant::LedgerKeyContractData => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyContractData>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractData(Box::new(t.0)))),
            ),
            TypeVariant::LedgerKeyContractCode => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyContractCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractCode(Box::new(t.0)))),
            ),
            TypeVariant::LedgerKeyConfigSetting => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyConfigSetting>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerKeyConfigSetting(Box::new(t.0)))),
            ),
            TypeVariant::LedgerKeyTtl => Box::new(
                ReadXdrIter::<_, Frame<LedgerKeyTtl>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTtl(Box::new(t.0)))),
            ),
            TypeVariant::EnvelopeType => Box::new(
                ReadXdrIter::<_, Frame<EnvelopeType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EnvelopeType(Box::new(t.0)))),
            ),
            TypeVariant::UpgradeType => Box::new(
                ReadXdrIter::<_, Frame<UpgradeType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeType(Box::new(t.0)))),
            ),
            TypeVariant::StellarValueType => Box::new(
                ReadXdrIter::<_, Frame<StellarValueType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueType(Box::new(t.0)))),
            ),
            TypeVariant::LedgerCloseValueSignature => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseValueSignature>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerCloseValueSignature(Box::new(t.0)))),
            ),
            TypeVariant::StellarValue => Box::new(
                ReadXdrIter::<_, Frame<StellarValue>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValue(Box::new(t.0)))),
            ),
            TypeVariant::StellarValueExt => Box::new(
                ReadXdrIter::<_, Frame<StellarValueExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueExt(Box::new(t.0)))),
            ),
            TypeVariant::LedgerHeaderFlags => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderFlags>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderFlags(Box::new(t.0)))),
            ),
            TypeVariant::LedgerHeaderExtensionV1 => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderExtensionV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1(Box::new(t.0)))),
            ),
            TypeVariant::LedgerHeaderExtensionV1Ext => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderExtensionV1Ext>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1Ext(Box::new(t.0)))),
            ),
            TypeVariant::LedgerHeader => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeader>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeader(Box::new(t.0)))),
            ),
            TypeVariant::LedgerHeaderExt => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExt(Box::new(t.0)))),
            ),
            TypeVariant::LedgerUpgradeType => Box::new(
                ReadXdrIter::<_, Frame<LedgerUpgradeType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgradeType(Box::new(t.0)))),
            ),
            TypeVariant::ConfigUpgradeSetKey => Box::new(
                ReadXdrIter::<_, Frame<ConfigUpgradeSetKey>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSetKey(Box::new(t.0)))),
            ),
            TypeVariant::LedgerUpgrade => Box::new(
                ReadXdrIter::<_, Frame<LedgerUpgrade>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgrade(Box::new(t.0)))),
            ),
            TypeVariant::ConfigUpgradeSet => Box::new(
                ReadXdrIter::<_, Frame<ConfigUpgradeSet>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSet(Box::new(t.0)))),
            ),
            TypeVariant::BucketEntryType => Box::new(
                ReadXdrIter::<_, Frame<BucketEntryType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntryType(Box::new(t.0)))),
            ),
            TypeVariant::BucketMetadata => Box::new(
                ReadXdrIter::<_, Frame<BucketMetadata>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadata(Box::new(t.0)))),
            ),
            TypeVariant::BucketMetadataExt => Box::new(
                ReadXdrIter::<_, Frame<BucketMetadataExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadataExt(Box::new(t.0)))),
            ),
            TypeVariant::BucketEntry => Box::new(
                ReadXdrIter::<_, Frame<BucketEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntry(Box::new(t.0)))),
            ),
            TypeVariant::TxSetComponentType => Box::new(
                ReadXdrIter::<_, Frame<TxSetComponentType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponentType(Box::new(t.0)))),
            ),
            TypeVariant::TxSetComponent => Box::new(
                ReadXdrIter::<_, Frame<TxSetComponent>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponent(Box::new(t.0)))),
            ),
            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => Box::new(
                ReadXdrIter::<_, Frame<TxSetComponentTxsMaybeDiscountedFee>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(t.0)))),
            ),
            TypeVariant::TransactionPhase => Box::new(
                ReadXdrIter::<_, Frame<TransactionPhase>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionPhase(Box::new(t.0)))),
            ),
            TypeVariant::TransactionSet => Box::new(
                ReadXdrIter::<_, Frame<TransactionSet>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSet(Box::new(t.0)))),
            ),
            TypeVariant::TransactionSetV1 => Box::new(
                ReadXdrIter::<_, Frame<TransactionSetV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSetV1(Box::new(t.0)))),
            ),
            TypeVariant::GeneralizedTransactionSet => Box::new(
                ReadXdrIter::<_, Frame<GeneralizedTransactionSet>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::GeneralizedTransactionSet(Box::new(t.0)))),
            ),
            TypeVariant::TransactionResultPair => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultPair>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultPair(Box::new(t.0)))),
            ),
            TypeVariant::TransactionResultSet => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultSet>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultSet(Box::new(t.0)))),
            ),
            TypeVariant::TransactionHistoryEntry => Box::new(
                ReadXdrIter::<_, Frame<TransactionHistoryEntry>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryEntry(Box::new(t.0)))),
            ),
            TypeVariant::TransactionHistoryEntryExt => Box::new(
                ReadXdrIter::<_, Frame<TransactionHistoryEntryExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryEntryExt(Box::new(t.0)))),
            ),
            TypeVariant::TransactionHistoryResultEntry => Box::new(
                ReadXdrIter::<_, Frame<TransactionHistoryResultEntry>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryResultEntry(Box::new(t.0)))),
            ),
            TypeVariant::TransactionHistoryResultEntryExt => Box::new(
                ReadXdrIter::<_, Frame<TransactionHistoryResultEntryExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionHistoryResultEntryExt(Box::new(t.0)))),
            ),
            TypeVariant::LedgerHeaderHistoryEntry => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderHistoryEntry>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntry(Box::new(t.0)))),
            ),
            TypeVariant::LedgerHeaderHistoryEntryExt => Box::new(
                ReadXdrIter::<_, Frame<LedgerHeaderHistoryEntryExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntryExt(Box::new(t.0)))),
            ),
            TypeVariant::LedgerScpMessages => Box::new(
                ReadXdrIter::<_, Frame<LedgerScpMessages>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerScpMessages(Box::new(t.0)))),
            ),
            TypeVariant::ScpHistoryEntryV0 => Box::new(
                ReadXdrIter::<_, Frame<ScpHistoryEntryV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntryV0(Box::new(t.0)))),
            ),
            TypeVariant::ScpHistoryEntry => Box::new(
                ReadXdrIter::<_, Frame<ScpHistoryEntry>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntry(Box::new(t.0)))),
            ),
            TypeVariant::LedgerEntryChangeType => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryChangeType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChangeType(Box::new(t.0)))),
            ),
            TypeVariant::LedgerEntryChange => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryChange>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChange(Box::new(t.0)))),
            ),
            TypeVariant::LedgerEntryChanges => Box::new(
                ReadXdrIter::<_, Frame<LedgerEntryChanges>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChanges(Box::new(t.0)))),
            ),
            TypeVariant::OperationMeta => Box::new(
                ReadXdrIter::<_, Frame<OperationMeta>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationMeta(Box::new(t.0)))),
            ),
            TypeVariant::TransactionMetaV1 => Box::new(
                ReadXdrIter::<_, Frame<TransactionMetaV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV1(Box::new(t.0)))),
            ),
            TypeVariant::TransactionMetaV2 => Box::new(
                ReadXdrIter::<_, Frame<TransactionMetaV2>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV2(Box::new(t.0)))),
            ),
            TypeVariant::ContractEventType => Box::new(
                ReadXdrIter::<_, Frame<ContractEventType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventType(Box::new(t.0)))),
            ),
            TypeVariant::ContractEvent => Box::new(
                ReadXdrIter::<_, Frame<ContractEvent>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEvent(Box::new(t.0)))),
            ),
            TypeVariant::ContractEventBody => Box::new(
                ReadXdrIter::<_, Frame<ContractEventBody>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventBody(Box::new(t.0)))),
            ),
            TypeVariant::ContractEventV0 => Box::new(
                ReadXdrIter::<_, Frame<ContractEventV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventV0(Box::new(t.0)))),
            ),
            TypeVariant::DiagnosticEvent => Box::new(
                ReadXdrIter::<_, Frame<DiagnosticEvent>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DiagnosticEvent(Box::new(t.0)))),
            ),
            TypeVariant::SorobanTransactionMetaExtV1 => Box::new(
                ReadXdrIter::<_, Frame<SorobanTransactionMetaExtV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanTransactionMetaExtV1(Box::new(t.0)))),
            ),
            TypeVariant::SorobanTransactionMetaExt => Box::new(
                ReadXdrIter::<_, Frame<SorobanTransactionMetaExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanTransactionMetaExt(Box::new(t.0)))),
            ),
            TypeVariant::SorobanTransactionMeta => Box::new(
                ReadXdrIter::<_, Frame<SorobanTransactionMeta>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanTransactionMeta(Box::new(t.0)))),
            ),
            TypeVariant::TransactionMetaV3 => Box::new(
                ReadXdrIter::<_, Frame<TransactionMetaV3>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV3(Box::new(t.0)))),
            ),
            TypeVariant::InvokeHostFunctionSuccessPreImage => Box::new(
                ReadXdrIter::<_, Frame<InvokeHostFunctionSuccessPreImage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InvokeHostFunctionSuccessPreImage(Box::new(t.0)))),
            ),
            TypeVariant::TransactionMeta => Box::new(
                ReadXdrIter::<_, Frame<TransactionMeta>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMeta(Box::new(t.0)))),
            ),
            TypeVariant::TransactionResultMeta => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultMeta>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultMeta(Box::new(t.0)))),
            ),
            TypeVariant::UpgradeEntryMeta => Box::new(
                ReadXdrIter::<_, Frame<UpgradeEntryMeta>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeEntryMeta(Box::new(t.0)))),
            ),
            TypeVariant::LedgerCloseMetaV0 => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMetaV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV0(Box::new(t.0)))),
            ),
            TypeVariant::LedgerCloseMetaExtV1 => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMetaExtV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExtV1(Box::new(t.0)))),
            ),
            TypeVariant::LedgerCloseMetaExt => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMetaExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExt(Box::new(t.0)))),
            ),
            TypeVariant::LedgerCloseMetaV1 => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMetaV1>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV1(Box::new(t.0)))),
            ),
            TypeVariant::LedgerCloseMeta => Box::new(
                ReadXdrIter::<_, Frame<LedgerCloseMeta>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMeta(Box::new(t.0)))),
            ),
            TypeVariant::ErrorCode => Box::new(
                ReadXdrIter::<_, Frame<ErrorCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ErrorCode(Box::new(t.0)))),
            ),
            TypeVariant::SError => Box::new(
                ReadXdrIter::<_, Frame<SError>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SError(Box::new(t.0)))),
            ),
            TypeVariant::SendMore => Box::new(
                ReadXdrIter::<_, Frame<SendMore>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMore(Box::new(t.0)))),
            ),
            TypeVariant::SendMoreExtended => Box::new(
                ReadXdrIter::<_, Frame<SendMoreExtended>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMoreExtended(Box::new(t.0)))),
            ),
            TypeVariant::AuthCert => Box::new(
                ReadXdrIter::<_, Frame<AuthCert>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthCert(Box::new(t.0)))),
            ),
            TypeVariant::Hello => Box::new(
                ReadXdrIter::<_, Frame<Hello>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hello(Box::new(t.0)))),
            ),
            TypeVariant::Auth => Box::new(
                ReadXdrIter::<_, Frame<Auth>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Auth(Box::new(t.0)))),
            ),
            TypeVariant::IpAddrType => Box::new(
                ReadXdrIter::<_, Frame<IpAddrType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::IpAddrType(Box::new(t.0)))),
            ),
            TypeVariant::PeerAddress => Box::new(
                ReadXdrIter::<_, Frame<PeerAddress>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddress(Box::new(t.0)))),
            ),
            TypeVariant::PeerAddressIp => Box::new(
                ReadXdrIter::<_, Frame<PeerAddressIp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddressIp(Box::new(t.0)))),
            ),
            TypeVariant::MessageType => Box::new(
                ReadXdrIter::<_, Frame<MessageType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MessageType(Box::new(t.0)))),
            ),
            TypeVariant::DontHave => Box::new(
                ReadXdrIter::<_, Frame<DontHave>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DontHave(Box::new(t.0)))),
            ),
            TypeVariant::SurveyMessageCommandType => Box::new(
                ReadXdrIter::<_, Frame<SurveyMessageCommandType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SurveyMessageCommandType(Box::new(t.0)))),
            ),
            TypeVariant::SurveyMessageResponseType => Box::new(
                ReadXdrIter::<_, Frame<SurveyMessageResponseType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SurveyMessageResponseType(Box::new(t.0)))),
            ),
            TypeVariant::SurveyRequestMessage => Box::new(
                ReadXdrIter::<_, Frame<SurveyRequestMessage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyRequestMessage(Box::new(t.0)))),
            ),
            TypeVariant::SignedSurveyRequestMessage => Box::new(
                ReadXdrIter::<_, Frame<SignedSurveyRequestMessage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignedSurveyRequestMessage(Box::new(t.0)))),
            ),
            TypeVariant::EncryptedBody => Box::new(
                ReadXdrIter::<_, Frame<EncryptedBody>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::EncryptedBody(Box::new(t.0)))),
            ),
            TypeVariant::SurveyResponseMessage => Box::new(
                ReadXdrIter::<_, Frame<SurveyResponseMessage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseMessage(Box::new(t.0)))),
            ),
            TypeVariant::SignedSurveyResponseMessage => Box::new(
                ReadXdrIter::<_, Frame<SignedSurveyResponseMessage>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignedSurveyResponseMessage(Box::new(t.0)))),
            ),
            TypeVariant::PeerStats => Box::new(
                ReadXdrIter::<_, Frame<PeerStats>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerStats(Box::new(t.0)))),
            ),
            TypeVariant::PeerStatList => Box::new(
                ReadXdrIter::<_, Frame<PeerStatList>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerStatList(Box::new(t.0)))),
            ),
            TypeVariant::TopologyResponseBodyV0 => Box::new(
                ReadXdrIter::<_, Frame<TopologyResponseBodyV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TopologyResponseBodyV0(Box::new(t.0)))),
            ),
            TypeVariant::TopologyResponseBodyV1 => Box::new(
                ReadXdrIter::<_, Frame<TopologyResponseBodyV1>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TopologyResponseBodyV1(Box::new(t.0)))),
            ),
            TypeVariant::SurveyResponseBody => Box::new(
                ReadXdrIter::<_, Frame<SurveyResponseBody>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseBody(Box::new(t.0)))),
            ),
            TypeVariant::TxAdvertVector => Box::new(
                ReadXdrIter::<_, Frame<TxAdvertVector>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxAdvertVector(Box::new(t.0)))),
            ),
            TypeVariant::FloodAdvert => Box::new(
                ReadXdrIter::<_, Frame<FloodAdvert>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodAdvert(Box::new(t.0)))),
            ),
            TypeVariant::TxDemandVector => Box::new(
                ReadXdrIter::<_, Frame<TxDemandVector>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxDemandVector(Box::new(t.0)))),
            ),
            TypeVariant::FloodDemand => Box::new(
                ReadXdrIter::<_, Frame<FloodDemand>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodDemand(Box::new(t.0)))),
            ),
            TypeVariant::StellarMessage => Box::new(
                ReadXdrIter::<_, Frame<StellarMessage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarMessage(Box::new(t.0)))),
            ),
            TypeVariant::AuthenticatedMessage => Box::new(
                ReadXdrIter::<_, Frame<AuthenticatedMessage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthenticatedMessage(Box::new(t.0)))),
            ),
            TypeVariant::AuthenticatedMessageV0 => Box::new(
                ReadXdrIter::<_, Frame<AuthenticatedMessageV0>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AuthenticatedMessageV0(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolParameters => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolParameters>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolParameters(Box::new(t.0)))),
            ),
            TypeVariant::MuxedAccount => Box::new(
                ReadXdrIter::<_, Frame<MuxedAccount>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccount(Box::new(t.0)))),
            ),
            TypeVariant::MuxedAccountMed25519 => Box::new(
                ReadXdrIter::<_, Frame<MuxedAccountMed25519>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccountMed25519(Box::new(t.0)))),
            ),
            TypeVariant::DecoratedSignature => Box::new(
                ReadXdrIter::<_, Frame<DecoratedSignature>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::DecoratedSignature(Box::new(t.0)))),
            ),
            TypeVariant::OperationType => Box::new(
                ReadXdrIter::<_, Frame<OperationType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationType(Box::new(t.0)))),
            ),
            TypeVariant::CreateAccountOp => Box::new(
                ReadXdrIter::<_, Frame<CreateAccountOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountOp(Box::new(t.0)))),
            ),
            TypeVariant::PaymentOp => Box::new(
                ReadXdrIter::<_, Frame<PaymentOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentOp(Box::new(t.0)))),
            ),
            TypeVariant::PathPaymentStrictReceiveOp => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictReceiveOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveOp(Box::new(t.0)))),
            ),
            TypeVariant::PathPaymentStrictSendOp => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictSendOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendOp(Box::new(t.0)))),
            ),
            TypeVariant::ManageSellOfferOp => Box::new(
                ReadXdrIter::<_, Frame<ManageSellOfferOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferOp(Box::new(t.0)))),
            ),
            TypeVariant::ManageBuyOfferOp => Box::new(
                ReadXdrIter::<_, Frame<ManageBuyOfferOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferOp(Box::new(t.0)))),
            ),
            TypeVariant::CreatePassiveSellOfferOp => Box::new(
                ReadXdrIter::<_, Frame<CreatePassiveSellOfferOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreatePassiveSellOfferOp(Box::new(t.0)))),
            ),
            TypeVariant::SetOptionsOp => Box::new(
                ReadXdrIter::<_, Frame<SetOptionsOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsOp(Box::new(t.0)))),
            ),
            TypeVariant::ChangeTrustAsset => Box::new(
                ReadXdrIter::<_, Frame<ChangeTrustAsset>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustAsset(Box::new(t.0)))),
            ),
            TypeVariant::ChangeTrustOp => Box::new(
                ReadXdrIter::<_, Frame<ChangeTrustOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustOp(Box::new(t.0)))),
            ),
            TypeVariant::AllowTrustOp => Box::new(
                ReadXdrIter::<_, Frame<AllowTrustOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustOp(Box::new(t.0)))),
            ),
            TypeVariant::ManageDataOp => Box::new(
                ReadXdrIter::<_, Frame<ManageDataOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataOp(Box::new(t.0)))),
            ),
            TypeVariant::BumpSequenceOp => Box::new(
                ReadXdrIter::<_, Frame<BumpSequenceOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceOp(Box::new(t.0)))),
            ),
            TypeVariant::CreateClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, Frame<CreateClaimableBalanceOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreateClaimableBalanceOp(Box::new(t.0)))),
            ),
            TypeVariant::ClaimClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, Frame<ClaimClaimableBalanceOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimClaimableBalanceOp(Box::new(t.0)))),
            ),
            TypeVariant::BeginSponsoringFutureReservesOp => Box::new(
                ReadXdrIter::<_, Frame<BeginSponsoringFutureReservesOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesOp(Box::new(t.0)))),
            ),
            TypeVariant::RevokeSponsorshipType => Box::new(
                ReadXdrIter::<_, Frame<RevokeSponsorshipType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipType(Box::new(t.0)))),
            ),
            TypeVariant::RevokeSponsorshipOp => Box::new(
                ReadXdrIter::<_, Frame<RevokeSponsorshipOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipOp(Box::new(t.0)))),
            ),
            TypeVariant::RevokeSponsorshipOpSigner => Box::new(
                ReadXdrIter::<_, Frame<RevokeSponsorshipOpSigner>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::RevokeSponsorshipOpSigner(Box::new(t.0)))),
            ),
            TypeVariant::ClawbackOp => Box::new(
                ReadXdrIter::<_, Frame<ClawbackOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackOp(Box::new(t.0)))),
            ),
            TypeVariant::ClawbackClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, Frame<ClawbackClaimableBalanceOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClawbackClaimableBalanceOp(Box::new(t.0)))),
            ),
            TypeVariant::SetTrustLineFlagsOp => Box::new(
                ReadXdrIter::<_, Frame<SetTrustLineFlagsOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsOp(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolDepositOp => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolDepositOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolDepositOp(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolWithdrawOp => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolWithdrawOp>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolWithdrawOp(Box::new(t.0)))),
            ),
            TypeVariant::HostFunctionType => Box::new(
                ReadXdrIter::<_, Frame<HostFunctionType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunctionType(Box::new(t.0)))),
            ),
            TypeVariant::ContractIdPreimageType => Box::new(
                ReadXdrIter::<_, Frame<ContractIdPreimageType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractIdPreimageType(Box::new(t.0)))),
            ),
            TypeVariant::ContractIdPreimage => Box::new(
                ReadXdrIter::<_, Frame<ContractIdPreimage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimage(Box::new(t.0)))),
            ),
            TypeVariant::ContractIdPreimageFromAddress => Box::new(
                ReadXdrIter::<_, Frame<ContractIdPreimageFromAddress>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ContractIdPreimageFromAddress(Box::new(t.0)))),
            ),
            TypeVariant::CreateContractArgs => Box::new(
                ReadXdrIter::<_, Frame<CreateContractArgs>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateContractArgs(Box::new(t.0)))),
            ),
            TypeVariant::InvokeContractArgs => Box::new(
                ReadXdrIter::<_, Frame<InvokeContractArgs>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeContractArgs(Box::new(t.0)))),
            ),
            TypeVariant::HostFunction => Box::new(
                ReadXdrIter::<_, Frame<HostFunction>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunction(Box::new(t.0)))),
            ),
            TypeVariant::SorobanAuthorizedFunctionType => Box::new(
                ReadXdrIter::<_, Frame<SorobanAuthorizedFunctionType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAuthorizedFunctionType(Box::new(t.0)))),
            ),
            TypeVariant::SorobanAuthorizedFunction => Box::new(
                ReadXdrIter::<_, Frame<SorobanAuthorizedFunction>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAuthorizedFunction(Box::new(t.0)))),
            ),
            TypeVariant::SorobanAuthorizedInvocation => Box::new(
                ReadXdrIter::<_, Frame<SorobanAuthorizedInvocation>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAuthorizedInvocation(Box::new(t.0)))),
            ),
            TypeVariant::SorobanAddressCredentials => Box::new(
                ReadXdrIter::<_, Frame<SorobanAddressCredentials>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAddressCredentials(Box::new(t.0)))),
            ),
            TypeVariant::SorobanCredentialsType => Box::new(
                ReadXdrIter::<_, Frame<SorobanCredentialsType>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanCredentialsType(Box::new(t.0)))),
            ),
            TypeVariant::SorobanCredentials => Box::new(
                ReadXdrIter::<_, Frame<SorobanCredentials>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanCredentials(Box::new(t.0)))),
            ),
            TypeVariant::SorobanAuthorizationEntry => Box::new(
                ReadXdrIter::<_, Frame<SorobanAuthorizationEntry>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanAuthorizationEntry(Box::new(t.0)))),
            ),
            TypeVariant::InvokeHostFunctionOp => Box::new(
                ReadXdrIter::<_, Frame<InvokeHostFunctionOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionOp(Box::new(t.0)))),
            ),
            TypeVariant::ExtendFootprintTtlOp => Box::new(
                ReadXdrIter::<_, Frame<ExtendFootprintTtlOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlOp(Box::new(t.0)))),
            ),
            TypeVariant::RestoreFootprintOp => Box::new(
                ReadXdrIter::<_, Frame<RestoreFootprintOp>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintOp(Box::new(t.0)))),
            ),
            TypeVariant::Operation => Box::new(
                ReadXdrIter::<_, Frame<Operation>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Operation(Box::new(t.0)))),
            ),
            TypeVariant::OperationBody => Box::new(
                ReadXdrIter::<_, Frame<OperationBody>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationBody(Box::new(t.0)))),
            ),
            TypeVariant::HashIdPreimage => Box::new(
                ReadXdrIter::<_, Frame<HashIdPreimage>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimage(Box::new(t.0)))),
            ),
            TypeVariant::HashIdPreimageOperationId => Box::new(
                ReadXdrIter::<_, Frame<HashIdPreimageOperationId>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::HashIdPreimageOperationId(Box::new(t.0)))),
            ),
            TypeVariant::HashIdPreimageRevokeId => Box::new(
                ReadXdrIter::<_, Frame<HashIdPreimageRevokeId>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::HashIdPreimageRevokeId(Box::new(t.0)))),
            ),
            TypeVariant::HashIdPreimageContractId => Box::new(
                ReadXdrIter::<_, Frame<HashIdPreimageContractId>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::HashIdPreimageContractId(Box::new(t.0)))),
            ),
            TypeVariant::HashIdPreimageSorobanAuthorization => Box::new(
                ReadXdrIter::<_, Frame<HashIdPreimageSorobanAuthorization>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::HashIdPreimageSorobanAuthorization(Box::new(t.0)))),
            ),
            TypeVariant::MemoType => Box::new(
                ReadXdrIter::<_, Frame<MemoType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::MemoType(Box::new(t.0)))),
            ),
            TypeVariant::Memo => Box::new(
                ReadXdrIter::<_, Frame<Memo>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Memo(Box::new(t.0)))),
            ),
            TypeVariant::TimeBounds => Box::new(
                ReadXdrIter::<_, Frame<TimeBounds>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeBounds(Box::new(t.0)))),
            ),
            TypeVariant::LedgerBounds => Box::new(
                ReadXdrIter::<_, Frame<LedgerBounds>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerBounds(Box::new(t.0)))),
            ),
            TypeVariant::PreconditionsV2 => Box::new(
                ReadXdrIter::<_, Frame<PreconditionsV2>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionsV2(Box::new(t.0)))),
            ),
            TypeVariant::PreconditionType => Box::new(
                ReadXdrIter::<_, Frame<PreconditionType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionType(Box::new(t.0)))),
            ),
            TypeVariant::Preconditions => Box::new(
                ReadXdrIter::<_, Frame<Preconditions>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Preconditions(Box::new(t.0)))),
            ),
            TypeVariant::LedgerFootprint => Box::new(
                ReadXdrIter::<_, Frame<LedgerFootprint>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerFootprint(Box::new(t.0)))),
            ),
            TypeVariant::SorobanResources => Box::new(
                ReadXdrIter::<_, Frame<SorobanResources>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanResources(Box::new(t.0)))),
            ),
            TypeVariant::SorobanTransactionData => Box::new(
                ReadXdrIter::<_, Frame<SorobanTransactionData>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SorobanTransactionData(Box::new(t.0)))),
            ),
            TypeVariant::TransactionV0 => Box::new(
                ReadXdrIter::<_, Frame<TransactionV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0(Box::new(t.0)))),
            ),
            TypeVariant::TransactionV0Ext => Box::new(
                ReadXdrIter::<_, Frame<TransactionV0Ext>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Ext(Box::new(t.0)))),
            ),
            TypeVariant::TransactionV0Envelope => Box::new(
                ReadXdrIter::<_, Frame<TransactionV0Envelope>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Envelope(Box::new(t.0)))),
            ),
            TypeVariant::Transaction => Box::new(
                ReadXdrIter::<_, Frame<Transaction>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Transaction(Box::new(t.0)))),
            ),
            TypeVariant::TransactionExt => Box::new(
                ReadXdrIter::<_, Frame<TransactionExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionExt(Box::new(t.0)))),
            ),
            TypeVariant::TransactionV1Envelope => Box::new(
                ReadXdrIter::<_, Frame<TransactionV1Envelope>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV1Envelope(Box::new(t.0)))),
            ),
            TypeVariant::FeeBumpTransaction => Box::new(
                ReadXdrIter::<_, Frame<FeeBumpTransaction>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransaction(Box::new(t.0)))),
            ),
            TypeVariant::FeeBumpTransactionInnerTx => Box::new(
                ReadXdrIter::<_, Frame<FeeBumpTransactionInnerTx>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::FeeBumpTransactionInnerTx(Box::new(t.0)))),
            ),
            TypeVariant::FeeBumpTransactionExt => Box::new(
                ReadXdrIter::<_, Frame<FeeBumpTransactionExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionExt(Box::new(t.0)))),
            ),
            TypeVariant::FeeBumpTransactionEnvelope => Box::new(
                ReadXdrIter::<_, Frame<FeeBumpTransactionEnvelope>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::FeeBumpTransactionEnvelope(Box::new(t.0)))),
            ),
            TypeVariant::TransactionEnvelope => Box::new(
                ReadXdrIter::<_, Frame<TransactionEnvelope>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEnvelope(Box::new(t.0)))),
            ),
            TypeVariant::TransactionSignaturePayload => Box::new(
                ReadXdrIter::<_, Frame<TransactionSignaturePayload>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionSignaturePayload(Box::new(t.0)))),
            ),
            TypeVariant::TransactionSignaturePayloadTaggedTransaction => Box::new(
                ReadXdrIter::<_, Frame<TransactionSignaturePayloadTaggedTransaction>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| {
                    r.map(|t| Self::TransactionSignaturePayloadTaggedTransaction(Box::new(t.0)))
                }),
            ),
            TypeVariant::ClaimAtomType => Box::new(
                ReadXdrIter::<_, Frame<ClaimAtomType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtomType(Box::new(t.0)))),
            ),
            TypeVariant::ClaimOfferAtomV0 => Box::new(
                ReadXdrIter::<_, Frame<ClaimOfferAtomV0>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtomV0(Box::new(t.0)))),
            ),
            TypeVariant::ClaimOfferAtom => Box::new(
                ReadXdrIter::<_, Frame<ClaimOfferAtom>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtom(Box::new(t.0)))),
            ),
            TypeVariant::ClaimLiquidityAtom => Box::new(
                ReadXdrIter::<_, Frame<ClaimLiquidityAtom>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimLiquidityAtom(Box::new(t.0)))),
            ),
            TypeVariant::ClaimAtom => Box::new(
                ReadXdrIter::<_, Frame<ClaimAtom>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtom(Box::new(t.0)))),
            ),
            TypeVariant::CreateAccountResultCode => Box::new(
                ReadXdrIter::<_, Frame<CreateAccountResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreateAccountResultCode(Box::new(t.0)))),
            ),
            TypeVariant::CreateAccountResult => Box::new(
                ReadXdrIter::<_, Frame<CreateAccountResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountResult(Box::new(t.0)))),
            ),
            TypeVariant::PaymentResultCode => Box::new(
                ReadXdrIter::<_, Frame<PaymentResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResultCode(Box::new(t.0)))),
            ),
            TypeVariant::PaymentResult => Box::new(
                ReadXdrIter::<_, Frame<PaymentResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResult(Box::new(t.0)))),
            ),
            TypeVariant::PathPaymentStrictReceiveResultCode => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictReceiveResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultCode(Box::new(t.0)))),
            ),
            TypeVariant::SimplePaymentResult => Box::new(
                ReadXdrIter::<_, Frame<SimplePaymentResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SimplePaymentResult(Box::new(t.0)))),
            ),
            TypeVariant::PathPaymentStrictReceiveResult => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictReceiveResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResult(Box::new(t.0)))),
            ),
            TypeVariant::PathPaymentStrictReceiveResultSuccess => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictReceiveResultSuccess>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultSuccess(Box::new(t.0)))),
            ),
            TypeVariant::PathPaymentStrictSendResultCode => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictSendResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendResultCode(Box::new(t.0)))),
            ),
            TypeVariant::PathPaymentStrictSendResult => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictSendResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendResult(Box::new(t.0)))),
            ),
            TypeVariant::PathPaymentStrictSendResultSuccess => Box::new(
                ReadXdrIter::<_, Frame<PathPaymentStrictSendResultSuccess>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::PathPaymentStrictSendResultSuccess(Box::new(t.0)))),
            ),
            TypeVariant::ManageSellOfferResultCode => Box::new(
                ReadXdrIter::<_, Frame<ManageSellOfferResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ManageSellOfferResultCode(Box::new(t.0)))),
            ),
            TypeVariant::ManageOfferEffect => Box::new(
                ReadXdrIter::<_, Frame<ManageOfferEffect>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferEffect(Box::new(t.0)))),
            ),
            TypeVariant::ManageOfferSuccessResult => Box::new(
                ReadXdrIter::<_, Frame<ManageOfferSuccessResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ManageOfferSuccessResult(Box::new(t.0)))),
            ),
            TypeVariant::ManageOfferSuccessResultOffer => Box::new(
                ReadXdrIter::<_, Frame<ManageOfferSuccessResultOffer>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ManageOfferSuccessResultOffer(Box::new(t.0)))),
            ),
            TypeVariant::ManageSellOfferResult => Box::new(
                ReadXdrIter::<_, Frame<ManageSellOfferResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferResult(Box::new(t.0)))),
            ),
            TypeVariant::ManageBuyOfferResultCode => Box::new(
                ReadXdrIter::<_, Frame<ManageBuyOfferResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ManageBuyOfferResultCode(Box::new(t.0)))),
            ),
            TypeVariant::ManageBuyOfferResult => Box::new(
                ReadXdrIter::<_, Frame<ManageBuyOfferResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferResult(Box::new(t.0)))),
            ),
            TypeVariant::SetOptionsResultCode => Box::new(
                ReadXdrIter::<_, Frame<SetOptionsResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResultCode(Box::new(t.0)))),
            ),
            TypeVariant::SetOptionsResult => Box::new(
                ReadXdrIter::<_, Frame<SetOptionsResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResult(Box::new(t.0)))),
            ),
            TypeVariant::ChangeTrustResultCode => Box::new(
                ReadXdrIter::<_, Frame<ChangeTrustResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResultCode(Box::new(t.0)))),
            ),
            TypeVariant::ChangeTrustResult => Box::new(
                ReadXdrIter::<_, Frame<ChangeTrustResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResult(Box::new(t.0)))),
            ),
            TypeVariant::AllowTrustResultCode => Box::new(
                ReadXdrIter::<_, Frame<AllowTrustResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResultCode(Box::new(t.0)))),
            ),
            TypeVariant::AllowTrustResult => Box::new(
                ReadXdrIter::<_, Frame<AllowTrustResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResult(Box::new(t.0)))),
            ),
            TypeVariant::AccountMergeResultCode => Box::new(
                ReadXdrIter::<_, Frame<AccountMergeResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::AccountMergeResultCode(Box::new(t.0)))),
            ),
            TypeVariant::AccountMergeResult => Box::new(
                ReadXdrIter::<_, Frame<AccountMergeResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountMergeResult(Box::new(t.0)))),
            ),
            TypeVariant::InflationResultCode => Box::new(
                ReadXdrIter::<_, Frame<InflationResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResultCode(Box::new(t.0)))),
            ),
            TypeVariant::InflationPayout => Box::new(
                ReadXdrIter::<_, Frame<InflationPayout>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationPayout(Box::new(t.0)))),
            ),
            TypeVariant::InflationResult => Box::new(
                ReadXdrIter::<_, Frame<InflationResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResult(Box::new(t.0)))),
            ),
            TypeVariant::ManageDataResultCode => Box::new(
                ReadXdrIter::<_, Frame<ManageDataResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResultCode(Box::new(t.0)))),
            ),
            TypeVariant::ManageDataResult => Box::new(
                ReadXdrIter::<_, Frame<ManageDataResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResult(Box::new(t.0)))),
            ),
            TypeVariant::BumpSequenceResultCode => Box::new(
                ReadXdrIter::<_, Frame<BumpSequenceResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BumpSequenceResultCode(Box::new(t.0)))),
            ),
            TypeVariant::BumpSequenceResult => Box::new(
                ReadXdrIter::<_, Frame<BumpSequenceResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceResult(Box::new(t.0)))),
            ),
            TypeVariant::CreateClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, Frame<CreateClaimableBalanceResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreateClaimableBalanceResultCode(Box::new(t.0)))),
            ),
            TypeVariant::CreateClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, Frame<CreateClaimableBalanceResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::CreateClaimableBalanceResult(Box::new(t.0)))),
            ),
            TypeVariant::ClaimClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, Frame<ClaimClaimableBalanceResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimClaimableBalanceResultCode(Box::new(t.0)))),
            ),
            TypeVariant::ClaimClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, Frame<ClaimClaimableBalanceResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClaimClaimableBalanceResult(Box::new(t.0)))),
            ),
            TypeVariant::BeginSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, Frame<BeginSponsoringFutureReservesResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResultCode(Box::new(t.0)))),
            ),
            TypeVariant::BeginSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, Frame<BeginSponsoringFutureReservesResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResult(Box::new(t.0)))),
            ),
            TypeVariant::EndSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, Frame<EndSponsoringFutureReservesResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResultCode(Box::new(t.0)))),
            ),
            TypeVariant::EndSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, Frame<EndSponsoringFutureReservesResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResult(Box::new(t.0)))),
            ),
            TypeVariant::RevokeSponsorshipResultCode => Box::new(
                ReadXdrIter::<_, Frame<RevokeSponsorshipResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::RevokeSponsorshipResultCode(Box::new(t.0)))),
            ),
            TypeVariant::RevokeSponsorshipResult => Box::new(
                ReadXdrIter::<_, Frame<RevokeSponsorshipResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::RevokeSponsorshipResult(Box::new(t.0)))),
            ),
            TypeVariant::ClawbackResultCode => Box::new(
                ReadXdrIter::<_, Frame<ClawbackResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResultCode(Box::new(t.0)))),
            ),
            TypeVariant::ClawbackResult => Box::new(
                ReadXdrIter::<_, Frame<ClawbackResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResult(Box::new(t.0)))),
            ),
            TypeVariant::ClawbackClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, Frame<ClawbackClaimableBalanceResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResultCode(Box::new(t.0)))),
            ),
            TypeVariant::ClawbackClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, Frame<ClawbackClaimableBalanceResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResult(Box::new(t.0)))),
            ),
            TypeVariant::SetTrustLineFlagsResultCode => Box::new(
                ReadXdrIter::<_, Frame<SetTrustLineFlagsResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SetTrustLineFlagsResultCode(Box::new(t.0)))),
            ),
            TypeVariant::SetTrustLineFlagsResult => Box::new(
                ReadXdrIter::<_, Frame<SetTrustLineFlagsResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SetTrustLineFlagsResult(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolDepositResultCode => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolDepositResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolDepositResultCode(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolDepositResult => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolDepositResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolDepositResult(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolWithdrawResultCode => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolWithdrawResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResultCode(Box::new(t.0)))),
            ),
            TypeVariant::LiquidityPoolWithdrawResult => Box::new(
                ReadXdrIter::<_, Frame<LiquidityPoolWithdrawResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResult(Box::new(t.0)))),
            ),
            TypeVariant::InvokeHostFunctionResultCode => Box::new(
                ReadXdrIter::<_, Frame<InvokeHostFunctionResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InvokeHostFunctionResultCode(Box::new(t.0)))),
            ),
            TypeVariant::InvokeHostFunctionResult => Box::new(
                ReadXdrIter::<_, Frame<InvokeHostFunctionResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InvokeHostFunctionResult(Box::new(t.0)))),
            ),
            TypeVariant::ExtendFootprintTtlResultCode => Box::new(
                ReadXdrIter::<_, Frame<ExtendFootprintTtlResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ExtendFootprintTtlResultCode(Box::new(t.0)))),
            ),
            TypeVariant::ExtendFootprintTtlResult => Box::new(
                ReadXdrIter::<_, Frame<ExtendFootprintTtlResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::ExtendFootprintTtlResult(Box::new(t.0)))),
            ),
            TypeVariant::RestoreFootprintResultCode => Box::new(
                ReadXdrIter::<_, Frame<RestoreFootprintResultCode>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::RestoreFootprintResultCode(Box::new(t.0)))),
            ),
            TypeVariant::RestoreFootprintResult => Box::new(
                ReadXdrIter::<_, Frame<RestoreFootprintResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::RestoreFootprintResult(Box::new(t.0)))),
            ),
            TypeVariant::OperationResultCode => Box::new(
                ReadXdrIter::<_, Frame<OperationResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultCode(Box::new(t.0)))),
            ),
            TypeVariant::OperationResult => Box::new(
                ReadXdrIter::<_, Frame<OperationResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResult(Box::new(t.0)))),
            ),
            TypeVariant::OperationResultTr => Box::new(
                ReadXdrIter::<_, Frame<OperationResultTr>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultTr(Box::new(t.0)))),
            ),
            TypeVariant::TransactionResultCode => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultCode>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultCode(Box::new(t.0)))),
            ),
            TypeVariant::InnerTransactionResult => Box::new(
                ReadXdrIter::<_, Frame<InnerTransactionResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InnerTransactionResult(Box::new(t.0)))),
            ),
            TypeVariant::InnerTransactionResultResult => Box::new(
                ReadXdrIter::<_, Frame<InnerTransactionResultResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InnerTransactionResultResult(Box::new(t.0)))),
            ),
            TypeVariant::InnerTransactionResultExt => Box::new(
                ReadXdrIter::<_, Frame<InnerTransactionResultExt>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InnerTransactionResultExt(Box::new(t.0)))),
            ),
            TypeVariant::InnerTransactionResultPair => Box::new(
                ReadXdrIter::<_, Frame<InnerTransactionResultPair>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::InnerTransactionResultPair(Box::new(t.0)))),
            ),
            TypeVariant::TransactionResult => Box::new(
                ReadXdrIter::<_, Frame<TransactionResult>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResult(Box::new(t.0)))),
            ),
            TypeVariant::TransactionResultResult => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultResult>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::TransactionResultResult(Box::new(t.0)))),
            ),
            TypeVariant::TransactionResultExt => Box::new(
                ReadXdrIter::<_, Frame<TransactionResultExt>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultExt(Box::new(t.0)))),
            ),
            TypeVariant::Hash => Box::new(
                ReadXdrIter::<_, Frame<Hash>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hash(Box::new(t.0)))),
            ),
            TypeVariant::Uint256 => Box::new(
                ReadXdrIter::<_, Frame<Uint256>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint256(Box::new(t.0)))),
            ),
            TypeVariant::Uint32 => Box::new(
                ReadXdrIter::<_, Frame<Uint32>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint32(Box::new(t.0)))),
            ),
            TypeVariant::Int32 => Box::new(
                ReadXdrIter::<_, Frame<Int32>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int32(Box::new(t.0)))),
            ),
            TypeVariant::Uint64 => Box::new(
                ReadXdrIter::<_, Frame<Uint64>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint64(Box::new(t.0)))),
            ),
            TypeVariant::Int64 => Box::new(
                ReadXdrIter::<_, Frame<Int64>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int64(Box::new(t.0)))),
            ),
            TypeVariant::TimePoint => Box::new(
                ReadXdrIter::<_, Frame<TimePoint>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimePoint(Box::new(t.0)))),
            ),
            TypeVariant::Duration => Box::new(
                ReadXdrIter::<_, Frame<Duration>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Duration(Box::new(t.0)))),
            ),
            TypeVariant::ExtensionPoint => Box::new(
                ReadXdrIter::<_, Frame<ExtensionPoint>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtensionPoint(Box::new(t.0)))),
            ),
            TypeVariant::CryptoKeyType => Box::new(
                ReadXdrIter::<_, Frame<CryptoKeyType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::CryptoKeyType(Box::new(t.0)))),
            ),
            TypeVariant::PublicKeyType => Box::new(
                ReadXdrIter::<_, Frame<PublicKeyType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKeyType(Box::new(t.0)))),
            ),
            TypeVariant::SignerKeyType => Box::new(
                ReadXdrIter::<_, Frame<SignerKeyType>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKeyType(Box::new(t.0)))),
            ),
            TypeVariant::PublicKey => Box::new(
                ReadXdrIter::<_, Frame<PublicKey>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKey(Box::new(t.0)))),
            ),
            TypeVariant::SignerKey => Box::new(
                ReadXdrIter::<_, Frame<SignerKey>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKey(Box::new(t.0)))),
            ),
            TypeVariant::SignerKeyEd25519SignedPayload => Box::new(
                ReadXdrIter::<_, Frame<SignerKeyEd25519SignedPayload>>::new(
                    &mut r.inner,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::SignerKeyEd25519SignedPayload(Box::new(t.0)))),
            ),
            TypeVariant::Signature => Box::new(
                ReadXdrIter::<_, Frame<Signature>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signature(Box::new(t.0)))),
            ),
            TypeVariant::SignatureHint => Box::new(
                ReadXdrIter::<_, Frame<SignatureHint>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignatureHint(Box::new(t.0)))),
            ),
            TypeVariant::NodeId => Box::new(
                ReadXdrIter::<_, Frame<NodeId>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::NodeId(Box::new(t.0)))),
            ),
            TypeVariant::AccountId => Box::new(
                ReadXdrIter::<_, Frame<AccountId>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountId(Box::new(t.0)))),
            ),
            TypeVariant::Curve25519Secret => Box::new(
                ReadXdrIter::<_, Frame<Curve25519Secret>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Secret(Box::new(t.0)))),
            ),
            TypeVariant::Curve25519Public => Box::new(
                ReadXdrIter::<_, Frame<Curve25519Public>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Public(Box::new(t.0)))),
            ),
            TypeVariant::HmacSha256Key => Box::new(
                ReadXdrIter::<_, Frame<HmacSha256Key>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Key(Box::new(t.0)))),
            ),
            TypeVariant::HmacSha256Mac => Box::new(
                ReadXdrIter::<_, Frame<HmacSha256Mac>>::new(&mut r.inner, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Mac(Box::new(t.0)))),
            ),
        }
    }

    #[cfg(feature = "base64")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr_base64_iter<R: Read>(
        v: TypeVariant,
        r: &mut Limited<R>,
    ) -> Box<dyn Iterator<Item = Result<Self>> + '_> {
        let dec = base64::read::DecoderReader::new(&mut r.inner, base64::STANDARD);
        match v {
            TypeVariant::Value => Box::new(
                ReadXdrIter::<_, Value>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Value(Box::new(t)))),
            ),
            TypeVariant::ScpBallot => Box::new(
                ReadXdrIter::<_, ScpBallot>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpBallot(Box::new(t)))),
            ),
            TypeVariant::ScpStatementType => Box::new(
                ReadXdrIter::<_, ScpStatementType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementType(Box::new(t)))),
            ),
            TypeVariant::ScpNomination => Box::new(
                ReadXdrIter::<_, ScpNomination>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpNomination(Box::new(t)))),
            ),
            TypeVariant::ScpStatement => Box::new(
                ReadXdrIter::<_, ScpStatement>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatement(Box::new(t)))),
            ),
            TypeVariant::ScpStatementPledges => Box::new(
                ReadXdrIter::<_, ScpStatementPledges>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPledges(Box::new(t)))),
            ),
            TypeVariant::ScpStatementPrepare => Box::new(
                ReadXdrIter::<_, ScpStatementPrepare>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementPrepare(Box::new(t)))),
            ),
            TypeVariant::ScpStatementConfirm => Box::new(
                ReadXdrIter::<_, ScpStatementConfirm>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementConfirm(Box::new(t)))),
            ),
            TypeVariant::ScpStatementExternalize => Box::new(
                ReadXdrIter::<_, ScpStatementExternalize>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpStatementExternalize(Box::new(t)))),
            ),
            TypeVariant::ScpEnvelope => Box::new(
                ReadXdrIter::<_, ScpEnvelope>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpEnvelope(Box::new(t)))),
            ),
            TypeVariant::ScpQuorumSet => Box::new(
                ReadXdrIter::<_, ScpQuorumSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpQuorumSet(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractExecutionLanesV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractExecutionLanesV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractExecutionLanesV0(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractComputeV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractComputeV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractComputeV0(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractLedgerCostV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractLedgerCostV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractLedgerCostV0(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractHistoricalDataV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractHistoricalDataV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractHistoricalDataV0(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractEventsV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractEventsV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractEventsV0(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingContractBandwidthV0 => Box::new(
                ReadXdrIter::<_, ConfigSettingContractBandwidthV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingContractBandwidthV0(Box::new(t)))),
            ),
            TypeVariant::ContractCostType => Box::new(
                ReadXdrIter::<_, ContractCostType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostType(Box::new(t)))),
            ),
            TypeVariant::ContractCostParamEntry => Box::new(
                ReadXdrIter::<_, ContractCostParamEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostParamEntry(Box::new(t)))),
            ),
            TypeVariant::StateArchivalSettings => Box::new(
                ReadXdrIter::<_, StateArchivalSettings>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StateArchivalSettings(Box::new(t)))),
            ),
            TypeVariant::EvictionIterator => Box::new(
                ReadXdrIter::<_, EvictionIterator>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::EvictionIterator(Box::new(t)))),
            ),
            TypeVariant::ContractCostParams => Box::new(
                ReadXdrIter::<_, ContractCostParams>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCostParams(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingId => Box::new(
                ReadXdrIter::<_, ConfigSettingId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingId(Box::new(t)))),
            ),
            TypeVariant::ConfigSettingEntry => Box::new(
                ReadXdrIter::<_, ConfigSettingEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigSettingEntry(Box::new(t)))),
            ),
            TypeVariant::ScEnvMetaKind => Box::new(
                ReadXdrIter::<_, ScEnvMetaKind>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaKind(Box::new(t)))),
            ),
            TypeVariant::ScEnvMetaEntry => Box::new(
                ReadXdrIter::<_, ScEnvMetaEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScEnvMetaEntry(Box::new(t)))),
            ),
            TypeVariant::ScMetaV0 => Box::new(
                ReadXdrIter::<_, ScMetaV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaV0(Box::new(t)))),
            ),
            TypeVariant::ScMetaKind => Box::new(
                ReadXdrIter::<_, ScMetaKind>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaKind(Box::new(t)))),
            ),
            TypeVariant::ScMetaEntry => Box::new(
                ReadXdrIter::<_, ScMetaEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMetaEntry(Box::new(t)))),
            ),
            TypeVariant::ScSpecType => Box::new(
                ReadXdrIter::<_, ScSpecType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecType(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeOption => Box::new(
                ReadXdrIter::<_, ScSpecTypeOption>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeOption(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeResult => Box::new(
                ReadXdrIter::<_, ScSpecTypeResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeResult(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeVec => Box::new(
                ReadXdrIter::<_, ScSpecTypeVec>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeVec(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeMap => Box::new(
                ReadXdrIter::<_, ScSpecTypeMap>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeMap(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeTuple => Box::new(
                ReadXdrIter::<_, ScSpecTypeTuple>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeTuple(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeBytesN => Box::new(
                ReadXdrIter::<_, ScSpecTypeBytesN>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeBytesN(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeUdt => Box::new(
                ReadXdrIter::<_, ScSpecTypeUdt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeUdt(Box::new(t)))),
            ),
            TypeVariant::ScSpecTypeDef => Box::new(
                ReadXdrIter::<_, ScSpecTypeDef>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecTypeDef(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtStructFieldV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtStructFieldV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtStructFieldV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtStructV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtStructV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtStructV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseVoidV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseVoidV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseVoidV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseTupleV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseTupleV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseTupleV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseV0Kind => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseV0Kind>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0Kind(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtUnionCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionCaseV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionCaseV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtUnionV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtUnionV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtUnionV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtEnumCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtEnumCaseV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumCaseV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtEnumV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtEnumV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtEnumV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtErrorEnumCaseV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtErrorEnumCaseV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumCaseV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecUdtErrorEnumV0 => Box::new(
                ReadXdrIter::<_, ScSpecUdtErrorEnumV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecUdtErrorEnumV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecFunctionInputV0 => Box::new(
                ReadXdrIter::<_, ScSpecFunctionInputV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionInputV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecFunctionV0 => Box::new(
                ReadXdrIter::<_, ScSpecFunctionV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecFunctionV0(Box::new(t)))),
            ),
            TypeVariant::ScSpecEntryKind => Box::new(
                ReadXdrIter::<_, ScSpecEntryKind>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntryKind(Box::new(t)))),
            ),
            TypeVariant::ScSpecEntry => Box::new(
                ReadXdrIter::<_, ScSpecEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSpecEntry(Box::new(t)))),
            ),
            TypeVariant::ScValType => Box::new(
                ReadXdrIter::<_, ScValType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScValType(Box::new(t)))),
            ),
            TypeVariant::ScErrorType => Box::new(
                ReadXdrIter::<_, ScErrorType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorType(Box::new(t)))),
            ),
            TypeVariant::ScErrorCode => Box::new(
                ReadXdrIter::<_, ScErrorCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScErrorCode(Box::new(t)))),
            ),
            TypeVariant::ScError => Box::new(
                ReadXdrIter::<_, ScError>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScError(Box::new(t)))),
            ),
            TypeVariant::UInt128Parts => Box::new(
                ReadXdrIter::<_, UInt128Parts>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt128Parts(Box::new(t)))),
            ),
            TypeVariant::Int128Parts => Box::new(
                ReadXdrIter::<_, Int128Parts>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int128Parts(Box::new(t)))),
            ),
            TypeVariant::UInt256Parts => Box::new(
                ReadXdrIter::<_, UInt256Parts>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::UInt256Parts(Box::new(t)))),
            ),
            TypeVariant::Int256Parts => Box::new(
                ReadXdrIter::<_, Int256Parts>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int256Parts(Box::new(t)))),
            ),
            TypeVariant::ContractExecutableType => Box::new(
                ReadXdrIter::<_, ContractExecutableType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractExecutableType(Box::new(t)))),
            ),
            TypeVariant::ContractExecutable => Box::new(
                ReadXdrIter::<_, ContractExecutable>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractExecutable(Box::new(t)))),
            ),
            TypeVariant::ScAddressType => Box::new(
                ReadXdrIter::<_, ScAddressType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddressType(Box::new(t)))),
            ),
            TypeVariant::ScAddress => Box::new(
                ReadXdrIter::<_, ScAddress>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScAddress(Box::new(t)))),
            ),
            TypeVariant::ScVec => Box::new(
                ReadXdrIter::<_, ScVec>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVec(Box::new(t)))),
            ),
            TypeVariant::ScMap => Box::new(
                ReadXdrIter::<_, ScMap>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMap(Box::new(t)))),
            ),
            TypeVariant::ScBytes => Box::new(
                ReadXdrIter::<_, ScBytes>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScBytes(Box::new(t)))),
            ),
            TypeVariant::ScString => Box::new(
                ReadXdrIter::<_, ScString>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScString(Box::new(t)))),
            ),
            TypeVariant::ScSymbol => Box::new(
                ReadXdrIter::<_, ScSymbol>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScSymbol(Box::new(t)))),
            ),
            TypeVariant::ScNonceKey => Box::new(
                ReadXdrIter::<_, ScNonceKey>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScNonceKey(Box::new(t)))),
            ),
            TypeVariant::ScContractInstance => Box::new(
                ReadXdrIter::<_, ScContractInstance>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScContractInstance(Box::new(t)))),
            ),
            TypeVariant::ScVal => Box::new(
                ReadXdrIter::<_, ScVal>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScVal(Box::new(t)))),
            ),
            TypeVariant::ScMapEntry => Box::new(
                ReadXdrIter::<_, ScMapEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScMapEntry(Box::new(t)))),
            ),
            TypeVariant::StoredTransactionSet => Box::new(
                ReadXdrIter::<_, StoredTransactionSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StoredTransactionSet(Box::new(t)))),
            ),
            TypeVariant::StoredDebugTransactionSet => Box::new(
                ReadXdrIter::<_, StoredDebugTransactionSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StoredDebugTransactionSet(Box::new(t)))),
            ),
            TypeVariant::PersistedScpStateV0 => Box::new(
                ReadXdrIter::<_, PersistedScpStateV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV0(Box::new(t)))),
            ),
            TypeVariant::PersistedScpStateV1 => Box::new(
                ReadXdrIter::<_, PersistedScpStateV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpStateV1(Box::new(t)))),
            ),
            TypeVariant::PersistedScpState => Box::new(
                ReadXdrIter::<_, PersistedScpState>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PersistedScpState(Box::new(t)))),
            ),
            TypeVariant::Thresholds => Box::new(
                ReadXdrIter::<_, Thresholds>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Thresholds(Box::new(t)))),
            ),
            TypeVariant::String32 => Box::new(
                ReadXdrIter::<_, String32>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::String32(Box::new(t)))),
            ),
            TypeVariant::String64 => Box::new(
                ReadXdrIter::<_, String64>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::String64(Box::new(t)))),
            ),
            TypeVariant::SequenceNumber => Box::new(
                ReadXdrIter::<_, SequenceNumber>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SequenceNumber(Box::new(t)))),
            ),
            TypeVariant::DataValue => Box::new(
                ReadXdrIter::<_, DataValue>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataValue(Box::new(t)))),
            ),
            TypeVariant::PoolId => Box::new(
                ReadXdrIter::<_, PoolId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PoolId(Box::new(t)))),
            ),
            TypeVariant::AssetCode4 => Box::new(
                ReadXdrIter::<_, AssetCode4>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode4(Box::new(t)))),
            ),
            TypeVariant::AssetCode12 => Box::new(
                ReadXdrIter::<_, AssetCode12>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode12(Box::new(t)))),
            ),
            TypeVariant::AssetType => Box::new(
                ReadXdrIter::<_, AssetType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetType(Box::new(t)))),
            ),
            TypeVariant::AssetCode => Box::new(
                ReadXdrIter::<_, AssetCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AssetCode(Box::new(t)))),
            ),
            TypeVariant::AlphaNum4 => Box::new(
                ReadXdrIter::<_, AlphaNum4>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum4(Box::new(t)))),
            ),
            TypeVariant::AlphaNum12 => Box::new(
                ReadXdrIter::<_, AlphaNum12>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AlphaNum12(Box::new(t)))),
            ),
            TypeVariant::Asset => Box::new(
                ReadXdrIter::<_, Asset>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Asset(Box::new(t)))),
            ),
            TypeVariant::Price => Box::new(
                ReadXdrIter::<_, Price>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Price(Box::new(t)))),
            ),
            TypeVariant::Liabilities => Box::new(
                ReadXdrIter::<_, Liabilities>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Liabilities(Box::new(t)))),
            ),
            TypeVariant::ThresholdIndexes => Box::new(
                ReadXdrIter::<_, ThresholdIndexes>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ThresholdIndexes(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryType => Box::new(
                ReadXdrIter::<_, LedgerEntryType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryType(Box::new(t)))),
            ),
            TypeVariant::Signer => Box::new(
                ReadXdrIter::<_, Signer>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signer(Box::new(t)))),
            ),
            TypeVariant::AccountFlags => Box::new(
                ReadXdrIter::<_, AccountFlags>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountFlags(Box::new(t)))),
            ),
            TypeVariant::SponsorshipDescriptor => Box::new(
                ReadXdrIter::<_, SponsorshipDescriptor>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SponsorshipDescriptor(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExtensionV3 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV3>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV3(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV2(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV2Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV2Ext(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV1(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, AccountEntryExtensionV1Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExtensionV1Ext(Box::new(t)))),
            ),
            TypeVariant::AccountEntry => Box::new(
                ReadXdrIter::<_, AccountEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntry(Box::new(t)))),
            ),
            TypeVariant::AccountEntryExt => Box::new(
                ReadXdrIter::<_, AccountEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountEntryExt(Box::new(t)))),
            ),
            TypeVariant::TrustLineFlags => Box::new(
                ReadXdrIter::<_, TrustLineFlags>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineFlags(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolType => Box::new(
                ReadXdrIter::<_, LiquidityPoolType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolType(Box::new(t)))),
            ),
            TypeVariant::TrustLineAsset => Box::new(
                ReadXdrIter::<_, TrustLineAsset>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineAsset(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntryExtensionV2 => Box::new(
                ReadXdrIter::<_, TrustLineEntryExtensionV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntryExtensionV2Ext => Box::new(
                ReadXdrIter::<_, TrustLineEntryExtensionV2Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExtensionV2Ext(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntry => Box::new(
                ReadXdrIter::<_, TrustLineEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntry(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntryExt => Box::new(
                ReadXdrIter::<_, TrustLineEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryExt(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntryV1 => Box::new(
                ReadXdrIter::<_, TrustLineEntryV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1(Box::new(t)))),
            ),
            TypeVariant::TrustLineEntryV1Ext => Box::new(
                ReadXdrIter::<_, TrustLineEntryV1Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TrustLineEntryV1Ext(Box::new(t)))),
            ),
            TypeVariant::OfferEntryFlags => Box::new(
                ReadXdrIter::<_, OfferEntryFlags>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryFlags(Box::new(t)))),
            ),
            TypeVariant::OfferEntry => Box::new(
                ReadXdrIter::<_, OfferEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntry(Box::new(t)))),
            ),
            TypeVariant::OfferEntryExt => Box::new(
                ReadXdrIter::<_, OfferEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OfferEntryExt(Box::new(t)))),
            ),
            TypeVariant::DataEntry => Box::new(
                ReadXdrIter::<_, DataEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntry(Box::new(t)))),
            ),
            TypeVariant::DataEntryExt => Box::new(
                ReadXdrIter::<_, DataEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DataEntryExt(Box::new(t)))),
            ),
            TypeVariant::ClaimPredicateType => Box::new(
                ReadXdrIter::<_, ClaimPredicateType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicateType(Box::new(t)))),
            ),
            TypeVariant::ClaimPredicate => Box::new(
                ReadXdrIter::<_, ClaimPredicate>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimPredicate(Box::new(t)))),
            ),
            TypeVariant::ClaimantType => Box::new(
                ReadXdrIter::<_, ClaimantType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantType(Box::new(t)))),
            ),
            TypeVariant::Claimant => Box::new(
                ReadXdrIter::<_, Claimant>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Claimant(Box::new(t)))),
            ),
            TypeVariant::ClaimantV0 => Box::new(
                ReadXdrIter::<_, ClaimantV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimantV0(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceIdType => Box::new(
                ReadXdrIter::<_, ClaimableBalanceIdType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceIdType(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceId => Box::new(
                ReadXdrIter::<_, ClaimableBalanceId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceId(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceFlags => Box::new(
                ReadXdrIter::<_, ClaimableBalanceFlags>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceFlags(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExtensionV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExtensionV1Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceEntry => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntry(Box::new(t)))),
            ),
            TypeVariant::ClaimableBalanceEntryExt => Box::new(
                ReadXdrIter::<_, ClaimableBalanceEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimableBalanceEntryExt(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolConstantProductParameters => Box::new(
                ReadXdrIter::<_, LiquidityPoolConstantProductParameters>::new(
                    dec,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::LiquidityPoolConstantProductParameters(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolEntry => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntry(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolEntryBody => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntryBody>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntryBody(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolEntryConstantProduct => Box::new(
                ReadXdrIter::<_, LiquidityPoolEntryConstantProduct>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolEntryConstantProduct(Box::new(t)))),
            ),
            TypeVariant::ContractDataDurability => Box::new(
                ReadXdrIter::<_, ContractDataDurability>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractDataDurability(Box::new(t)))),
            ),
            TypeVariant::ContractDataEntry => Box::new(
                ReadXdrIter::<_, ContractDataEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractDataEntry(Box::new(t)))),
            ),
            TypeVariant::ContractCodeCostInputs => Box::new(
                ReadXdrIter::<_, ContractCodeCostInputs>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeCostInputs(Box::new(t)))),
            ),
            TypeVariant::ContractCodeEntry => Box::new(
                ReadXdrIter::<_, ContractCodeEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntry(Box::new(t)))),
            ),
            TypeVariant::ContractCodeEntryExt => Box::new(
                ReadXdrIter::<_, ContractCodeEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryExt(Box::new(t)))),
            ),
            TypeVariant::ContractCodeEntryV1 => Box::new(
                ReadXdrIter::<_, ContractCodeEntryV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractCodeEntryV1(Box::new(t)))),
            ),
            TypeVariant::TtlEntry => Box::new(
                ReadXdrIter::<_, TtlEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TtlEntry(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryExtensionV1 => Box::new(
                ReadXdrIter::<_, LedgerEntryExtensionV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExtensionV1(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryExtensionV1Ext => Box::new(
                ReadXdrIter::<_, LedgerEntryExtensionV1Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExtensionV1Ext(Box::new(t)))),
            ),
            TypeVariant::LedgerEntry => Box::new(
                ReadXdrIter::<_, LedgerEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntry(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryData => Box::new(
                ReadXdrIter::<_, LedgerEntryData>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryData(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryExt => Box::new(
                ReadXdrIter::<_, LedgerEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryExt(Box::new(t)))),
            ),
            TypeVariant::LedgerKey => Box::new(
                ReadXdrIter::<_, LedgerKey>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKey(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyAccount => Box::new(
                ReadXdrIter::<_, LedgerKeyAccount>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyAccount(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyTrustLine => Box::new(
                ReadXdrIter::<_, LedgerKeyTrustLine>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTrustLine(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyOffer => Box::new(
                ReadXdrIter::<_, LedgerKeyOffer>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyOffer(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyData => Box::new(
                ReadXdrIter::<_, LedgerKeyData>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyData(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyClaimableBalance => Box::new(
                ReadXdrIter::<_, LedgerKeyClaimableBalance>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyClaimableBalance(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyLiquidityPool => Box::new(
                ReadXdrIter::<_, LedgerKeyLiquidityPool>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyLiquidityPool(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyContractData => Box::new(
                ReadXdrIter::<_, LedgerKeyContractData>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractData(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyContractCode => Box::new(
                ReadXdrIter::<_, LedgerKeyContractCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyContractCode(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyConfigSetting => Box::new(
                ReadXdrIter::<_, LedgerKeyConfigSetting>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyConfigSetting(Box::new(t)))),
            ),
            TypeVariant::LedgerKeyTtl => Box::new(
                ReadXdrIter::<_, LedgerKeyTtl>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerKeyTtl(Box::new(t)))),
            ),
            TypeVariant::EnvelopeType => Box::new(
                ReadXdrIter::<_, EnvelopeType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::EnvelopeType(Box::new(t)))),
            ),
            TypeVariant::UpgradeType => Box::new(
                ReadXdrIter::<_, UpgradeType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeType(Box::new(t)))),
            ),
            TypeVariant::StellarValueType => Box::new(
                ReadXdrIter::<_, StellarValueType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueType(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseValueSignature => Box::new(
                ReadXdrIter::<_, LedgerCloseValueSignature>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseValueSignature(Box::new(t)))),
            ),
            TypeVariant::StellarValue => Box::new(
                ReadXdrIter::<_, StellarValue>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValue(Box::new(t)))),
            ),
            TypeVariant::StellarValueExt => Box::new(
                ReadXdrIter::<_, StellarValueExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarValueExt(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderFlags => Box::new(
                ReadXdrIter::<_, LedgerHeaderFlags>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderFlags(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderExtensionV1 => Box::new(
                ReadXdrIter::<_, LedgerHeaderExtensionV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderExtensionV1Ext => Box::new(
                ReadXdrIter::<_, LedgerHeaderExtensionV1Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExtensionV1Ext(Box::new(t)))),
            ),
            TypeVariant::LedgerHeader => Box::new(
                ReadXdrIter::<_, LedgerHeader>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeader(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderExt => Box::new(
                ReadXdrIter::<_, LedgerHeaderExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderExt(Box::new(t)))),
            ),
            TypeVariant::LedgerUpgradeType => Box::new(
                ReadXdrIter::<_, LedgerUpgradeType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgradeType(Box::new(t)))),
            ),
            TypeVariant::ConfigUpgradeSetKey => Box::new(
                ReadXdrIter::<_, ConfigUpgradeSetKey>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSetKey(Box::new(t)))),
            ),
            TypeVariant::LedgerUpgrade => Box::new(
                ReadXdrIter::<_, LedgerUpgrade>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerUpgrade(Box::new(t)))),
            ),
            TypeVariant::ConfigUpgradeSet => Box::new(
                ReadXdrIter::<_, ConfigUpgradeSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ConfigUpgradeSet(Box::new(t)))),
            ),
            TypeVariant::BucketEntryType => Box::new(
                ReadXdrIter::<_, BucketEntryType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntryType(Box::new(t)))),
            ),
            TypeVariant::BucketMetadata => Box::new(
                ReadXdrIter::<_, BucketMetadata>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadata(Box::new(t)))),
            ),
            TypeVariant::BucketMetadataExt => Box::new(
                ReadXdrIter::<_, BucketMetadataExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketMetadataExt(Box::new(t)))),
            ),
            TypeVariant::BucketEntry => Box::new(
                ReadXdrIter::<_, BucketEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BucketEntry(Box::new(t)))),
            ),
            TypeVariant::TxSetComponentType => Box::new(
                ReadXdrIter::<_, TxSetComponentType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponentType(Box::new(t)))),
            ),
            TypeVariant::TxSetComponent => Box::new(
                ReadXdrIter::<_, TxSetComponent>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponent(Box::new(t)))),
            ),
            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => Box::new(
                ReadXdrIter::<_, TxSetComponentTxsMaybeDiscountedFee>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(t)))),
            ),
            TypeVariant::TransactionPhase => Box::new(
                ReadXdrIter::<_, TransactionPhase>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionPhase(Box::new(t)))),
            ),
            TypeVariant::TransactionSet => Box::new(
                ReadXdrIter::<_, TransactionSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSet(Box::new(t)))),
            ),
            TypeVariant::TransactionSetV1 => Box::new(
                ReadXdrIter::<_, TransactionSetV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSetV1(Box::new(t)))),
            ),
            TypeVariant::GeneralizedTransactionSet => Box::new(
                ReadXdrIter::<_, GeneralizedTransactionSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::GeneralizedTransactionSet(Box::new(t)))),
            ),
            TypeVariant::TransactionResultPair => Box::new(
                ReadXdrIter::<_, TransactionResultPair>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultPair(Box::new(t)))),
            ),
            TypeVariant::TransactionResultSet => Box::new(
                ReadXdrIter::<_, TransactionResultSet>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultSet(Box::new(t)))),
            ),
            TypeVariant::TransactionHistoryEntry => Box::new(
                ReadXdrIter::<_, TransactionHistoryEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryEntry(Box::new(t)))),
            ),
            TypeVariant::TransactionHistoryEntryExt => Box::new(
                ReadXdrIter::<_, TransactionHistoryEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryEntryExt(Box::new(t)))),
            ),
            TypeVariant::TransactionHistoryResultEntry => Box::new(
                ReadXdrIter::<_, TransactionHistoryResultEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryResultEntry(Box::new(t)))),
            ),
            TypeVariant::TransactionHistoryResultEntryExt => Box::new(
                ReadXdrIter::<_, TransactionHistoryResultEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionHistoryResultEntryExt(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderHistoryEntry => Box::new(
                ReadXdrIter::<_, LedgerHeaderHistoryEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntry(Box::new(t)))),
            ),
            TypeVariant::LedgerHeaderHistoryEntryExt => Box::new(
                ReadXdrIter::<_, LedgerHeaderHistoryEntryExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerHeaderHistoryEntryExt(Box::new(t)))),
            ),
            TypeVariant::LedgerScpMessages => Box::new(
                ReadXdrIter::<_, LedgerScpMessages>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerScpMessages(Box::new(t)))),
            ),
            TypeVariant::ScpHistoryEntryV0 => Box::new(
                ReadXdrIter::<_, ScpHistoryEntryV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntryV0(Box::new(t)))),
            ),
            TypeVariant::ScpHistoryEntry => Box::new(
                ReadXdrIter::<_, ScpHistoryEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ScpHistoryEntry(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryChangeType => Box::new(
                ReadXdrIter::<_, LedgerEntryChangeType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChangeType(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryChange => Box::new(
                ReadXdrIter::<_, LedgerEntryChange>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChange(Box::new(t)))),
            ),
            TypeVariant::LedgerEntryChanges => Box::new(
                ReadXdrIter::<_, LedgerEntryChanges>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerEntryChanges(Box::new(t)))),
            ),
            TypeVariant::OperationMeta => Box::new(
                ReadXdrIter::<_, OperationMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationMeta(Box::new(t)))),
            ),
            TypeVariant::TransactionMetaV1 => Box::new(
                ReadXdrIter::<_, TransactionMetaV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV1(Box::new(t)))),
            ),
            TypeVariant::TransactionMetaV2 => Box::new(
                ReadXdrIter::<_, TransactionMetaV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV2(Box::new(t)))),
            ),
            TypeVariant::ContractEventType => Box::new(
                ReadXdrIter::<_, ContractEventType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventType(Box::new(t)))),
            ),
            TypeVariant::ContractEvent => Box::new(
                ReadXdrIter::<_, ContractEvent>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEvent(Box::new(t)))),
            ),
            TypeVariant::ContractEventBody => Box::new(
                ReadXdrIter::<_, ContractEventBody>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventBody(Box::new(t)))),
            ),
            TypeVariant::ContractEventV0 => Box::new(
                ReadXdrIter::<_, ContractEventV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractEventV0(Box::new(t)))),
            ),
            TypeVariant::DiagnosticEvent => Box::new(
                ReadXdrIter::<_, DiagnosticEvent>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DiagnosticEvent(Box::new(t)))),
            ),
            TypeVariant::SorobanTransactionMetaExtV1 => Box::new(
                ReadXdrIter::<_, SorobanTransactionMetaExtV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMetaExtV1(Box::new(t)))),
            ),
            TypeVariant::SorobanTransactionMetaExt => Box::new(
                ReadXdrIter::<_, SorobanTransactionMetaExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMetaExt(Box::new(t)))),
            ),
            TypeVariant::SorobanTransactionMeta => Box::new(
                ReadXdrIter::<_, SorobanTransactionMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionMeta(Box::new(t)))),
            ),
            TypeVariant::TransactionMetaV3 => Box::new(
                ReadXdrIter::<_, TransactionMetaV3>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMetaV3(Box::new(t)))),
            ),
            TypeVariant::InvokeHostFunctionSuccessPreImage => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionSuccessPreImage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionSuccessPreImage(Box::new(t)))),
            ),
            TypeVariant::TransactionMeta => Box::new(
                ReadXdrIter::<_, TransactionMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionMeta(Box::new(t)))),
            ),
            TypeVariant::TransactionResultMeta => Box::new(
                ReadXdrIter::<_, TransactionResultMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultMeta(Box::new(t)))),
            ),
            TypeVariant::UpgradeEntryMeta => Box::new(
                ReadXdrIter::<_, UpgradeEntryMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::UpgradeEntryMeta(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseMetaV0 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV0(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseMetaExtV1 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaExtV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExtV1(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseMetaExt => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaExt(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseMetaV1 => Box::new(
                ReadXdrIter::<_, LedgerCloseMetaV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMetaV1(Box::new(t)))),
            ),
            TypeVariant::LedgerCloseMeta => Box::new(
                ReadXdrIter::<_, LedgerCloseMeta>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerCloseMeta(Box::new(t)))),
            ),
            TypeVariant::ErrorCode => Box::new(
                ReadXdrIter::<_, ErrorCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ErrorCode(Box::new(t)))),
            ),
            TypeVariant::SError => Box::new(
                ReadXdrIter::<_, SError>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SError(Box::new(t)))),
            ),
            TypeVariant::SendMore => Box::new(
                ReadXdrIter::<_, SendMore>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMore(Box::new(t)))),
            ),
            TypeVariant::SendMoreExtended => Box::new(
                ReadXdrIter::<_, SendMoreExtended>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SendMoreExtended(Box::new(t)))),
            ),
            TypeVariant::AuthCert => Box::new(
                ReadXdrIter::<_, AuthCert>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthCert(Box::new(t)))),
            ),
            TypeVariant::Hello => Box::new(
                ReadXdrIter::<_, Hello>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hello(Box::new(t)))),
            ),
            TypeVariant::Auth => Box::new(
                ReadXdrIter::<_, Auth>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Auth(Box::new(t)))),
            ),
            TypeVariant::IpAddrType => Box::new(
                ReadXdrIter::<_, IpAddrType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::IpAddrType(Box::new(t)))),
            ),
            TypeVariant::PeerAddress => Box::new(
                ReadXdrIter::<_, PeerAddress>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddress(Box::new(t)))),
            ),
            TypeVariant::PeerAddressIp => Box::new(
                ReadXdrIter::<_, PeerAddressIp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerAddressIp(Box::new(t)))),
            ),
            TypeVariant::MessageType => Box::new(
                ReadXdrIter::<_, MessageType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::MessageType(Box::new(t)))),
            ),
            TypeVariant::DontHave => Box::new(
                ReadXdrIter::<_, DontHave>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DontHave(Box::new(t)))),
            ),
            TypeVariant::SurveyMessageCommandType => Box::new(
                ReadXdrIter::<_, SurveyMessageCommandType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyMessageCommandType(Box::new(t)))),
            ),
            TypeVariant::SurveyMessageResponseType => Box::new(
                ReadXdrIter::<_, SurveyMessageResponseType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyMessageResponseType(Box::new(t)))),
            ),
            TypeVariant::SurveyRequestMessage => Box::new(
                ReadXdrIter::<_, SurveyRequestMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyRequestMessage(Box::new(t)))),
            ),
            TypeVariant::SignedSurveyRequestMessage => Box::new(
                ReadXdrIter::<_, SignedSurveyRequestMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignedSurveyRequestMessage(Box::new(t)))),
            ),
            TypeVariant::EncryptedBody => Box::new(
                ReadXdrIter::<_, EncryptedBody>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::EncryptedBody(Box::new(t)))),
            ),
            TypeVariant::SurveyResponseMessage => Box::new(
                ReadXdrIter::<_, SurveyResponseMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseMessage(Box::new(t)))),
            ),
            TypeVariant::SignedSurveyResponseMessage => Box::new(
                ReadXdrIter::<_, SignedSurveyResponseMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignedSurveyResponseMessage(Box::new(t)))),
            ),
            TypeVariant::PeerStats => Box::new(
                ReadXdrIter::<_, PeerStats>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerStats(Box::new(t)))),
            ),
            TypeVariant::PeerStatList => Box::new(
                ReadXdrIter::<_, PeerStatList>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PeerStatList(Box::new(t)))),
            ),
            TypeVariant::TopologyResponseBodyV0 => Box::new(
                ReadXdrIter::<_, TopologyResponseBodyV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TopologyResponseBodyV0(Box::new(t)))),
            ),
            TypeVariant::TopologyResponseBodyV1 => Box::new(
                ReadXdrIter::<_, TopologyResponseBodyV1>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TopologyResponseBodyV1(Box::new(t)))),
            ),
            TypeVariant::SurveyResponseBody => Box::new(
                ReadXdrIter::<_, SurveyResponseBody>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SurveyResponseBody(Box::new(t)))),
            ),
            TypeVariant::TxAdvertVector => Box::new(
                ReadXdrIter::<_, TxAdvertVector>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxAdvertVector(Box::new(t)))),
            ),
            TypeVariant::FloodAdvert => Box::new(
                ReadXdrIter::<_, FloodAdvert>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodAdvert(Box::new(t)))),
            ),
            TypeVariant::TxDemandVector => Box::new(
                ReadXdrIter::<_, TxDemandVector>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TxDemandVector(Box::new(t)))),
            ),
            TypeVariant::FloodDemand => Box::new(
                ReadXdrIter::<_, FloodDemand>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FloodDemand(Box::new(t)))),
            ),
            TypeVariant::StellarMessage => Box::new(
                ReadXdrIter::<_, StellarMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::StellarMessage(Box::new(t)))),
            ),
            TypeVariant::AuthenticatedMessage => Box::new(
                ReadXdrIter::<_, AuthenticatedMessage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthenticatedMessage(Box::new(t)))),
            ),
            TypeVariant::AuthenticatedMessageV0 => Box::new(
                ReadXdrIter::<_, AuthenticatedMessageV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AuthenticatedMessageV0(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolParameters => Box::new(
                ReadXdrIter::<_, LiquidityPoolParameters>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolParameters(Box::new(t)))),
            ),
            TypeVariant::MuxedAccount => Box::new(
                ReadXdrIter::<_, MuxedAccount>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccount(Box::new(t)))),
            ),
            TypeVariant::MuxedAccountMed25519 => Box::new(
                ReadXdrIter::<_, MuxedAccountMed25519>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::MuxedAccountMed25519(Box::new(t)))),
            ),
            TypeVariant::DecoratedSignature => Box::new(
                ReadXdrIter::<_, DecoratedSignature>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::DecoratedSignature(Box::new(t)))),
            ),
            TypeVariant::OperationType => Box::new(
                ReadXdrIter::<_, OperationType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationType(Box::new(t)))),
            ),
            TypeVariant::CreateAccountOp => Box::new(
                ReadXdrIter::<_, CreateAccountOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountOp(Box::new(t)))),
            ),
            TypeVariant::PaymentOp => Box::new(
                ReadXdrIter::<_, PaymentOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentOp(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictReceiveOp => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictReceiveOp(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictSendOp => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendOp(Box::new(t)))),
            ),
            TypeVariant::ManageSellOfferOp => Box::new(
                ReadXdrIter::<_, ManageSellOfferOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferOp(Box::new(t)))),
            ),
            TypeVariant::ManageBuyOfferOp => Box::new(
                ReadXdrIter::<_, ManageBuyOfferOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferOp(Box::new(t)))),
            ),
            TypeVariant::CreatePassiveSellOfferOp => Box::new(
                ReadXdrIter::<_, CreatePassiveSellOfferOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreatePassiveSellOfferOp(Box::new(t)))),
            ),
            TypeVariant::SetOptionsOp => Box::new(
                ReadXdrIter::<_, SetOptionsOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsOp(Box::new(t)))),
            ),
            TypeVariant::ChangeTrustAsset => Box::new(
                ReadXdrIter::<_, ChangeTrustAsset>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustAsset(Box::new(t)))),
            ),
            TypeVariant::ChangeTrustOp => Box::new(
                ReadXdrIter::<_, ChangeTrustOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustOp(Box::new(t)))),
            ),
            TypeVariant::AllowTrustOp => Box::new(
                ReadXdrIter::<_, AllowTrustOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustOp(Box::new(t)))),
            ),
            TypeVariant::ManageDataOp => Box::new(
                ReadXdrIter::<_, ManageDataOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataOp(Box::new(t)))),
            ),
            TypeVariant::BumpSequenceOp => Box::new(
                ReadXdrIter::<_, BumpSequenceOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceOp(Box::new(t)))),
            ),
            TypeVariant::CreateClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateClaimableBalanceOp(Box::new(t)))),
            ),
            TypeVariant::ClaimClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimClaimableBalanceOp(Box::new(t)))),
            ),
            TypeVariant::BeginSponsoringFutureReservesOp => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesOp(Box::new(t)))),
            ),
            TypeVariant::RevokeSponsorshipType => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipType(Box::new(t)))),
            ),
            TypeVariant::RevokeSponsorshipOp => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipOp(Box::new(t)))),
            ),
            TypeVariant::RevokeSponsorshipOpSigner => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipOpSigner>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipOpSigner(Box::new(t)))),
            ),
            TypeVariant::ClawbackOp => Box::new(
                ReadXdrIter::<_, ClawbackOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackOp(Box::new(t)))),
            ),
            TypeVariant::ClawbackClaimableBalanceOp => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackClaimableBalanceOp(Box::new(t)))),
            ),
            TypeVariant::SetTrustLineFlagsOp => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsOp(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolDepositOp => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolDepositOp(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolWithdrawOp => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolWithdrawOp(Box::new(t)))),
            ),
            TypeVariant::HostFunctionType => Box::new(
                ReadXdrIter::<_, HostFunctionType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunctionType(Box::new(t)))),
            ),
            TypeVariant::ContractIdPreimageType => Box::new(
                ReadXdrIter::<_, ContractIdPreimageType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimageType(Box::new(t)))),
            ),
            TypeVariant::ContractIdPreimage => Box::new(
                ReadXdrIter::<_, ContractIdPreimage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimage(Box::new(t)))),
            ),
            TypeVariant::ContractIdPreimageFromAddress => Box::new(
                ReadXdrIter::<_, ContractIdPreimageFromAddress>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ContractIdPreimageFromAddress(Box::new(t)))),
            ),
            TypeVariant::CreateContractArgs => Box::new(
                ReadXdrIter::<_, CreateContractArgs>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateContractArgs(Box::new(t)))),
            ),
            TypeVariant::InvokeContractArgs => Box::new(
                ReadXdrIter::<_, InvokeContractArgs>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeContractArgs(Box::new(t)))),
            ),
            TypeVariant::HostFunction => Box::new(
                ReadXdrIter::<_, HostFunction>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HostFunction(Box::new(t)))),
            ),
            TypeVariant::SorobanAuthorizedFunctionType => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedFunctionType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizedFunctionType(Box::new(t)))),
            ),
            TypeVariant::SorobanAuthorizedFunction => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedFunction>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizedFunction(Box::new(t)))),
            ),
            TypeVariant::SorobanAuthorizedInvocation => Box::new(
                ReadXdrIter::<_, SorobanAuthorizedInvocation>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizedInvocation(Box::new(t)))),
            ),
            TypeVariant::SorobanAddressCredentials => Box::new(
                ReadXdrIter::<_, SorobanAddressCredentials>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAddressCredentials(Box::new(t)))),
            ),
            TypeVariant::SorobanCredentialsType => Box::new(
                ReadXdrIter::<_, SorobanCredentialsType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanCredentialsType(Box::new(t)))),
            ),
            TypeVariant::SorobanCredentials => Box::new(
                ReadXdrIter::<_, SorobanCredentials>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanCredentials(Box::new(t)))),
            ),
            TypeVariant::SorobanAuthorizationEntry => Box::new(
                ReadXdrIter::<_, SorobanAuthorizationEntry>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanAuthorizationEntry(Box::new(t)))),
            ),
            TypeVariant::InvokeHostFunctionOp => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionOp(Box::new(t)))),
            ),
            TypeVariant::ExtendFootprintTtlOp => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlOp(Box::new(t)))),
            ),
            TypeVariant::RestoreFootprintOp => Box::new(
                ReadXdrIter::<_, RestoreFootprintOp>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintOp(Box::new(t)))),
            ),
            TypeVariant::Operation => Box::new(
                ReadXdrIter::<_, Operation>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Operation(Box::new(t)))),
            ),
            TypeVariant::OperationBody => Box::new(
                ReadXdrIter::<_, OperationBody>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationBody(Box::new(t)))),
            ),
            TypeVariant::HashIdPreimage => Box::new(
                ReadXdrIter::<_, HashIdPreimage>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimage(Box::new(t)))),
            ),
            TypeVariant::HashIdPreimageOperationId => Box::new(
                ReadXdrIter::<_, HashIdPreimageOperationId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageOperationId(Box::new(t)))),
            ),
            TypeVariant::HashIdPreimageRevokeId => Box::new(
                ReadXdrIter::<_, HashIdPreimageRevokeId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageRevokeId(Box::new(t)))),
            ),
            TypeVariant::HashIdPreimageContractId => Box::new(
                ReadXdrIter::<_, HashIdPreimageContractId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageContractId(Box::new(t)))),
            ),
            TypeVariant::HashIdPreimageSorobanAuthorization => Box::new(
                ReadXdrIter::<_, HashIdPreimageSorobanAuthorization>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HashIdPreimageSorobanAuthorization(Box::new(t)))),
            ),
            TypeVariant::MemoType => Box::new(
                ReadXdrIter::<_, MemoType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::MemoType(Box::new(t)))),
            ),
            TypeVariant::Memo => Box::new(
                ReadXdrIter::<_, Memo>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Memo(Box::new(t)))),
            ),
            TypeVariant::TimeBounds => Box::new(
                ReadXdrIter::<_, TimeBounds>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimeBounds(Box::new(t)))),
            ),
            TypeVariant::LedgerBounds => Box::new(
                ReadXdrIter::<_, LedgerBounds>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerBounds(Box::new(t)))),
            ),
            TypeVariant::PreconditionsV2 => Box::new(
                ReadXdrIter::<_, PreconditionsV2>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionsV2(Box::new(t)))),
            ),
            TypeVariant::PreconditionType => Box::new(
                ReadXdrIter::<_, PreconditionType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PreconditionType(Box::new(t)))),
            ),
            TypeVariant::Preconditions => Box::new(
                ReadXdrIter::<_, Preconditions>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Preconditions(Box::new(t)))),
            ),
            TypeVariant::LedgerFootprint => Box::new(
                ReadXdrIter::<_, LedgerFootprint>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LedgerFootprint(Box::new(t)))),
            ),
            TypeVariant::SorobanResources => Box::new(
                ReadXdrIter::<_, SorobanResources>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanResources(Box::new(t)))),
            ),
            TypeVariant::SorobanTransactionData => Box::new(
                ReadXdrIter::<_, SorobanTransactionData>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SorobanTransactionData(Box::new(t)))),
            ),
            TypeVariant::TransactionV0 => Box::new(
                ReadXdrIter::<_, TransactionV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0(Box::new(t)))),
            ),
            TypeVariant::TransactionV0Ext => Box::new(
                ReadXdrIter::<_, TransactionV0Ext>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Ext(Box::new(t)))),
            ),
            TypeVariant::TransactionV0Envelope => Box::new(
                ReadXdrIter::<_, TransactionV0Envelope>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV0Envelope(Box::new(t)))),
            ),
            TypeVariant::Transaction => Box::new(
                ReadXdrIter::<_, Transaction>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Transaction(Box::new(t)))),
            ),
            TypeVariant::TransactionExt => Box::new(
                ReadXdrIter::<_, TransactionExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionExt(Box::new(t)))),
            ),
            TypeVariant::TransactionV1Envelope => Box::new(
                ReadXdrIter::<_, TransactionV1Envelope>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionV1Envelope(Box::new(t)))),
            ),
            TypeVariant::FeeBumpTransaction => Box::new(
                ReadXdrIter::<_, FeeBumpTransaction>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransaction(Box::new(t)))),
            ),
            TypeVariant::FeeBumpTransactionInnerTx => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionInnerTx>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionInnerTx(Box::new(t)))),
            ),
            TypeVariant::FeeBumpTransactionExt => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionExt(Box::new(t)))),
            ),
            TypeVariant::FeeBumpTransactionEnvelope => Box::new(
                ReadXdrIter::<_, FeeBumpTransactionEnvelope>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::FeeBumpTransactionEnvelope(Box::new(t)))),
            ),
            TypeVariant::TransactionEnvelope => Box::new(
                ReadXdrIter::<_, TransactionEnvelope>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionEnvelope(Box::new(t)))),
            ),
            TypeVariant::TransactionSignaturePayload => Box::new(
                ReadXdrIter::<_, TransactionSignaturePayload>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionSignaturePayload(Box::new(t)))),
            ),
            TypeVariant::TransactionSignaturePayloadTaggedTransaction => Box::new(
                ReadXdrIter::<_, TransactionSignaturePayloadTaggedTransaction>::new(
                    dec,
                    r.limits.clone(),
                )
                .map(|r| {
                    r.map(|t| Self::TransactionSignaturePayloadTaggedTransaction(Box::new(t)))
                }),
            ),
            TypeVariant::ClaimAtomType => Box::new(
                ReadXdrIter::<_, ClaimAtomType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtomType(Box::new(t)))),
            ),
            TypeVariant::ClaimOfferAtomV0 => Box::new(
                ReadXdrIter::<_, ClaimOfferAtomV0>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtomV0(Box::new(t)))),
            ),
            TypeVariant::ClaimOfferAtom => Box::new(
                ReadXdrIter::<_, ClaimOfferAtom>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimOfferAtom(Box::new(t)))),
            ),
            TypeVariant::ClaimLiquidityAtom => Box::new(
                ReadXdrIter::<_, ClaimLiquidityAtom>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimLiquidityAtom(Box::new(t)))),
            ),
            TypeVariant::ClaimAtom => Box::new(
                ReadXdrIter::<_, ClaimAtom>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimAtom(Box::new(t)))),
            ),
            TypeVariant::CreateAccountResultCode => Box::new(
                ReadXdrIter::<_, CreateAccountResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountResultCode(Box::new(t)))),
            ),
            TypeVariant::CreateAccountResult => Box::new(
                ReadXdrIter::<_, CreateAccountResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateAccountResult(Box::new(t)))),
            ),
            TypeVariant::PaymentResultCode => Box::new(
                ReadXdrIter::<_, PaymentResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResultCode(Box::new(t)))),
            ),
            TypeVariant::PaymentResult => Box::new(
                ReadXdrIter::<_, PaymentResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PaymentResult(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictReceiveResultCode => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultCode(Box::new(t)))),
            ),
            TypeVariant::SimplePaymentResult => Box::new(
                ReadXdrIter::<_, SimplePaymentResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SimplePaymentResult(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictReceiveResult => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResult(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictReceiveResultSuccess => Box::new(
                ReadXdrIter::<_, PathPaymentStrictReceiveResultSuccess>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictReceiveResultSuccess(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictSendResultCode => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendResultCode(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictSendResult => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendResult(Box::new(t)))),
            ),
            TypeVariant::PathPaymentStrictSendResultSuccess => Box::new(
                ReadXdrIter::<_, PathPaymentStrictSendResultSuccess>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PathPaymentStrictSendResultSuccess(Box::new(t)))),
            ),
            TypeVariant::ManageSellOfferResultCode => Box::new(
                ReadXdrIter::<_, ManageSellOfferResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferResultCode(Box::new(t)))),
            ),
            TypeVariant::ManageOfferEffect => Box::new(
                ReadXdrIter::<_, ManageOfferEffect>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferEffect(Box::new(t)))),
            ),
            TypeVariant::ManageOfferSuccessResult => Box::new(
                ReadXdrIter::<_, ManageOfferSuccessResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferSuccessResult(Box::new(t)))),
            ),
            TypeVariant::ManageOfferSuccessResultOffer => Box::new(
                ReadXdrIter::<_, ManageOfferSuccessResultOffer>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageOfferSuccessResultOffer(Box::new(t)))),
            ),
            TypeVariant::ManageSellOfferResult => Box::new(
                ReadXdrIter::<_, ManageSellOfferResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageSellOfferResult(Box::new(t)))),
            ),
            TypeVariant::ManageBuyOfferResultCode => Box::new(
                ReadXdrIter::<_, ManageBuyOfferResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferResultCode(Box::new(t)))),
            ),
            TypeVariant::ManageBuyOfferResult => Box::new(
                ReadXdrIter::<_, ManageBuyOfferResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageBuyOfferResult(Box::new(t)))),
            ),
            TypeVariant::SetOptionsResultCode => Box::new(
                ReadXdrIter::<_, SetOptionsResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResultCode(Box::new(t)))),
            ),
            TypeVariant::SetOptionsResult => Box::new(
                ReadXdrIter::<_, SetOptionsResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetOptionsResult(Box::new(t)))),
            ),
            TypeVariant::ChangeTrustResultCode => Box::new(
                ReadXdrIter::<_, ChangeTrustResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResultCode(Box::new(t)))),
            ),
            TypeVariant::ChangeTrustResult => Box::new(
                ReadXdrIter::<_, ChangeTrustResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ChangeTrustResult(Box::new(t)))),
            ),
            TypeVariant::AllowTrustResultCode => Box::new(
                ReadXdrIter::<_, AllowTrustResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResultCode(Box::new(t)))),
            ),
            TypeVariant::AllowTrustResult => Box::new(
                ReadXdrIter::<_, AllowTrustResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AllowTrustResult(Box::new(t)))),
            ),
            TypeVariant::AccountMergeResultCode => Box::new(
                ReadXdrIter::<_, AccountMergeResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountMergeResultCode(Box::new(t)))),
            ),
            TypeVariant::AccountMergeResult => Box::new(
                ReadXdrIter::<_, AccountMergeResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountMergeResult(Box::new(t)))),
            ),
            TypeVariant::InflationResultCode => Box::new(
                ReadXdrIter::<_, InflationResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResultCode(Box::new(t)))),
            ),
            TypeVariant::InflationPayout => Box::new(
                ReadXdrIter::<_, InflationPayout>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationPayout(Box::new(t)))),
            ),
            TypeVariant::InflationResult => Box::new(
                ReadXdrIter::<_, InflationResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InflationResult(Box::new(t)))),
            ),
            TypeVariant::ManageDataResultCode => Box::new(
                ReadXdrIter::<_, ManageDataResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResultCode(Box::new(t)))),
            ),
            TypeVariant::ManageDataResult => Box::new(
                ReadXdrIter::<_, ManageDataResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ManageDataResult(Box::new(t)))),
            ),
            TypeVariant::BumpSequenceResultCode => Box::new(
                ReadXdrIter::<_, BumpSequenceResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceResultCode(Box::new(t)))),
            ),
            TypeVariant::BumpSequenceResult => Box::new(
                ReadXdrIter::<_, BumpSequenceResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BumpSequenceResult(Box::new(t)))),
            ),
            TypeVariant::CreateClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateClaimableBalanceResultCode(Box::new(t)))),
            ),
            TypeVariant::CreateClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, CreateClaimableBalanceResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CreateClaimableBalanceResult(Box::new(t)))),
            ),
            TypeVariant::ClaimClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimClaimableBalanceResultCode(Box::new(t)))),
            ),
            TypeVariant::ClaimClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, ClaimClaimableBalanceResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClaimClaimableBalanceResult(Box::new(t)))),
            ),
            TypeVariant::BeginSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesResultCode>::new(
                    dec,
                    r.limits.clone(),
                )
                .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResultCode(Box::new(t)))),
            ),
            TypeVariant::BeginSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, BeginSponsoringFutureReservesResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::BeginSponsoringFutureReservesResult(Box::new(t)))),
            ),
            TypeVariant::EndSponsoringFutureReservesResultCode => Box::new(
                ReadXdrIter::<_, EndSponsoringFutureReservesResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResultCode(Box::new(t)))),
            ),
            TypeVariant::EndSponsoringFutureReservesResult => Box::new(
                ReadXdrIter::<_, EndSponsoringFutureReservesResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::EndSponsoringFutureReservesResult(Box::new(t)))),
            ),
            TypeVariant::RevokeSponsorshipResultCode => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipResultCode(Box::new(t)))),
            ),
            TypeVariant::RevokeSponsorshipResult => Box::new(
                ReadXdrIter::<_, RevokeSponsorshipResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RevokeSponsorshipResult(Box::new(t)))),
            ),
            TypeVariant::ClawbackResultCode => Box::new(
                ReadXdrIter::<_, ClawbackResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResultCode(Box::new(t)))),
            ),
            TypeVariant::ClawbackResult => Box::new(
                ReadXdrIter::<_, ClawbackResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackResult(Box::new(t)))),
            ),
            TypeVariant::ClawbackClaimableBalanceResultCode => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResultCode(Box::new(t)))),
            ),
            TypeVariant::ClawbackClaimableBalanceResult => Box::new(
                ReadXdrIter::<_, ClawbackClaimableBalanceResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ClawbackClaimableBalanceResult(Box::new(t)))),
            ),
            TypeVariant::SetTrustLineFlagsResultCode => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsResultCode(Box::new(t)))),
            ),
            TypeVariant::SetTrustLineFlagsResult => Box::new(
                ReadXdrIter::<_, SetTrustLineFlagsResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SetTrustLineFlagsResult(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolDepositResultCode => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolDepositResultCode(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolDepositResult => Box::new(
                ReadXdrIter::<_, LiquidityPoolDepositResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolDepositResult(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolWithdrawResultCode => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResultCode(Box::new(t)))),
            ),
            TypeVariant::LiquidityPoolWithdrawResult => Box::new(
                ReadXdrIter::<_, LiquidityPoolWithdrawResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::LiquidityPoolWithdrawResult(Box::new(t)))),
            ),
            TypeVariant::InvokeHostFunctionResultCode => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionResultCode(Box::new(t)))),
            ),
            TypeVariant::InvokeHostFunctionResult => Box::new(
                ReadXdrIter::<_, InvokeHostFunctionResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InvokeHostFunctionResult(Box::new(t)))),
            ),
            TypeVariant::ExtendFootprintTtlResultCode => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlResultCode(Box::new(t)))),
            ),
            TypeVariant::ExtendFootprintTtlResult => Box::new(
                ReadXdrIter::<_, ExtendFootprintTtlResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtendFootprintTtlResult(Box::new(t)))),
            ),
            TypeVariant::RestoreFootprintResultCode => Box::new(
                ReadXdrIter::<_, RestoreFootprintResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintResultCode(Box::new(t)))),
            ),
            TypeVariant::RestoreFootprintResult => Box::new(
                ReadXdrIter::<_, RestoreFootprintResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::RestoreFootprintResult(Box::new(t)))),
            ),
            TypeVariant::OperationResultCode => Box::new(
                ReadXdrIter::<_, OperationResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultCode(Box::new(t)))),
            ),
            TypeVariant::OperationResult => Box::new(
                ReadXdrIter::<_, OperationResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResult(Box::new(t)))),
            ),
            TypeVariant::OperationResultTr => Box::new(
                ReadXdrIter::<_, OperationResultTr>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::OperationResultTr(Box::new(t)))),
            ),
            TypeVariant::TransactionResultCode => Box::new(
                ReadXdrIter::<_, TransactionResultCode>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultCode(Box::new(t)))),
            ),
            TypeVariant::InnerTransactionResult => Box::new(
                ReadXdrIter::<_, InnerTransactionResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResult(Box::new(t)))),
            ),
            TypeVariant::InnerTransactionResultResult => Box::new(
                ReadXdrIter::<_, InnerTransactionResultResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultResult(Box::new(t)))),
            ),
            TypeVariant::InnerTransactionResultExt => Box::new(
                ReadXdrIter::<_, InnerTransactionResultExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultExt(Box::new(t)))),
            ),
            TypeVariant::InnerTransactionResultPair => Box::new(
                ReadXdrIter::<_, InnerTransactionResultPair>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::InnerTransactionResultPair(Box::new(t)))),
            ),
            TypeVariant::TransactionResult => Box::new(
                ReadXdrIter::<_, TransactionResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResult(Box::new(t)))),
            ),
            TypeVariant::TransactionResultResult => Box::new(
                ReadXdrIter::<_, TransactionResultResult>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultResult(Box::new(t)))),
            ),
            TypeVariant::TransactionResultExt => Box::new(
                ReadXdrIter::<_, TransactionResultExt>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TransactionResultExt(Box::new(t)))),
            ),
            TypeVariant::Hash => Box::new(
                ReadXdrIter::<_, Hash>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Hash(Box::new(t)))),
            ),
            TypeVariant::Uint256 => Box::new(
                ReadXdrIter::<_, Uint256>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint256(Box::new(t)))),
            ),
            TypeVariant::Uint32 => Box::new(
                ReadXdrIter::<_, Uint32>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint32(Box::new(t)))),
            ),
            TypeVariant::Int32 => Box::new(
                ReadXdrIter::<_, Int32>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int32(Box::new(t)))),
            ),
            TypeVariant::Uint64 => Box::new(
                ReadXdrIter::<_, Uint64>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Uint64(Box::new(t)))),
            ),
            TypeVariant::Int64 => Box::new(
                ReadXdrIter::<_, Int64>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Int64(Box::new(t)))),
            ),
            TypeVariant::TimePoint => Box::new(
                ReadXdrIter::<_, TimePoint>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::TimePoint(Box::new(t)))),
            ),
            TypeVariant::Duration => Box::new(
                ReadXdrIter::<_, Duration>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Duration(Box::new(t)))),
            ),
            TypeVariant::ExtensionPoint => Box::new(
                ReadXdrIter::<_, ExtensionPoint>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::ExtensionPoint(Box::new(t)))),
            ),
            TypeVariant::CryptoKeyType => Box::new(
                ReadXdrIter::<_, CryptoKeyType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::CryptoKeyType(Box::new(t)))),
            ),
            TypeVariant::PublicKeyType => Box::new(
                ReadXdrIter::<_, PublicKeyType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKeyType(Box::new(t)))),
            ),
            TypeVariant::SignerKeyType => Box::new(
                ReadXdrIter::<_, SignerKeyType>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKeyType(Box::new(t)))),
            ),
            TypeVariant::PublicKey => Box::new(
                ReadXdrIter::<_, PublicKey>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::PublicKey(Box::new(t)))),
            ),
            TypeVariant::SignerKey => Box::new(
                ReadXdrIter::<_, SignerKey>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKey(Box::new(t)))),
            ),
            TypeVariant::SignerKeyEd25519SignedPayload => Box::new(
                ReadXdrIter::<_, SignerKeyEd25519SignedPayload>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignerKeyEd25519SignedPayload(Box::new(t)))),
            ),
            TypeVariant::Signature => Box::new(
                ReadXdrIter::<_, Signature>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Signature(Box::new(t)))),
            ),
            TypeVariant::SignatureHint => Box::new(
                ReadXdrIter::<_, SignatureHint>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::SignatureHint(Box::new(t)))),
            ),
            TypeVariant::NodeId => Box::new(
                ReadXdrIter::<_, NodeId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::NodeId(Box::new(t)))),
            ),
            TypeVariant::AccountId => Box::new(
                ReadXdrIter::<_, AccountId>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::AccountId(Box::new(t)))),
            ),
            TypeVariant::Curve25519Secret => Box::new(
                ReadXdrIter::<_, Curve25519Secret>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Secret(Box::new(t)))),
            ),
            TypeVariant::Curve25519Public => Box::new(
                ReadXdrIter::<_, Curve25519Public>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::Curve25519Public(Box::new(t)))),
            ),
            TypeVariant::HmacSha256Key => Box::new(
                ReadXdrIter::<_, HmacSha256Key>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Key(Box::new(t)))),
            ),
            TypeVariant::HmacSha256Mac => Box::new(
                ReadXdrIter::<_, HmacSha256Mac>::new(dec, r.limits.clone())
                    .map(|r| r.map(|t| Self::HmacSha256Mac(Box::new(t)))),
            ),
        }
    }

    #[cfg(feature = "std")]
    pub fn from_xdr<B: AsRef<[u8]>>(v: TypeVariant, bytes: B, limits: Limits) -> Result<Self> {
        let mut cursor = Limited::new(Cursor::new(bytes.as_ref()), limits);
        let t = Self::read_xdr_to_end(v, &mut cursor)?;
        Ok(t)
    }

    #[cfg(feature = "base64")]
    pub fn from_xdr_base64(v: TypeVariant, b64: impl AsRef<[u8]>, limits: Limits) -> Result<Self> {
        let mut b64_reader = Cursor::new(b64);
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(&mut b64_reader, base64::STANDARD),
            limits,
        );
        let t = Self::read_xdr_to_end(v, &mut dec)?;
        Ok(t)
    }

    #[cfg(all(feature = "std", feature = "serde_json"))]
    #[allow(clippy::too_many_lines)]
    pub fn read_json(v: TypeVariant, r: impl Read) -> Result<Self> {
        match v {
            TypeVariant::Value => Ok(Self::Value(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScpBallot => Ok(Self::ScpBallot(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScpStatementType => Ok(Self::ScpStatementType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScpNomination => {
                Ok(Self::ScpNomination(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScpStatement => {
                Ok(Self::ScpStatement(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScpStatementPledges => Ok(Self::ScpStatementPledges(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScpStatementPrepare => Ok(Self::ScpStatementPrepare(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScpStatementConfirm => Ok(Self::ScpStatementConfirm(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScpStatementExternalize => Ok(Self::ScpStatementExternalize(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScpEnvelope => {
                Ok(Self::ScpEnvelope(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScpQuorumSet => {
                Ok(Self::ScpQuorumSet(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ConfigSettingContractExecutionLanesV0 => Ok(
                Self::ConfigSettingContractExecutionLanesV0(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::ConfigSettingContractComputeV0 => Ok(
                Self::ConfigSettingContractComputeV0(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::ConfigSettingContractLedgerCostV0 => Ok(
                Self::ConfigSettingContractLedgerCostV0(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::ConfigSettingContractHistoricalDataV0 => Ok(
                Self::ConfigSettingContractHistoricalDataV0(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::ConfigSettingContractEventsV0 => Ok(Self::ConfigSettingContractEventsV0(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::ConfigSettingContractBandwidthV0 => Ok(
                Self::ConfigSettingContractBandwidthV0(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::ContractCostType => Ok(Self::ContractCostType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractCostParamEntry => Ok(Self::ContractCostParamEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::StateArchivalSettings => Ok(Self::StateArchivalSettings(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::EvictionIterator => Ok(Self::EvictionIterator(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractCostParams => Ok(Self::ContractCostParams(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ConfigSettingId => {
                Ok(Self::ConfigSettingId(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ConfigSettingEntry => Ok(Self::ConfigSettingEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScEnvMetaKind => {
                Ok(Self::ScEnvMetaKind(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScEnvMetaEntry => {
                Ok(Self::ScEnvMetaEntry(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScMetaV0 => Ok(Self::ScMetaV0(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScMetaKind => Ok(Self::ScMetaKind(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScMetaEntry => {
                Ok(Self::ScMetaEntry(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScSpecType => Ok(Self::ScSpecType(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScSpecTypeOption => Ok(Self::ScSpecTypeOption(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecTypeResult => Ok(Self::ScSpecTypeResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecTypeVec => {
                Ok(Self::ScSpecTypeVec(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScSpecTypeMap => {
                Ok(Self::ScSpecTypeMap(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScSpecTypeTuple => {
                Ok(Self::ScSpecTypeTuple(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScSpecTypeBytesN => Ok(Self::ScSpecTypeBytesN(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecTypeUdt => {
                Ok(Self::ScSpecTypeUdt(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScSpecTypeDef => {
                Ok(Self::ScSpecTypeDef(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScSpecUdtStructFieldV0 => Ok(Self::ScSpecUdtStructFieldV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecUdtStructV0 => Ok(Self::ScSpecUdtStructV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecUdtUnionCaseVoidV0 => Ok(Self::ScSpecUdtUnionCaseVoidV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecUdtUnionCaseTupleV0 => Ok(Self::ScSpecUdtUnionCaseTupleV0(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::ScSpecUdtUnionCaseV0Kind => Ok(Self::ScSpecUdtUnionCaseV0Kind(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecUdtUnionCaseV0 => Ok(Self::ScSpecUdtUnionCaseV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecUdtUnionV0 => Ok(Self::ScSpecUdtUnionV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecUdtEnumCaseV0 => Ok(Self::ScSpecUdtEnumCaseV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecUdtEnumV0 => {
                Ok(Self::ScSpecUdtEnumV0(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScSpecUdtErrorEnumCaseV0 => Ok(Self::ScSpecUdtErrorEnumCaseV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecUdtErrorEnumV0 => Ok(Self::ScSpecUdtErrorEnumV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecFunctionInputV0 => Ok(Self::ScSpecFunctionInputV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecFunctionV0 => Ok(Self::ScSpecFunctionV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScSpecEntryKind => {
                Ok(Self::ScSpecEntryKind(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScSpecEntry => {
                Ok(Self::ScSpecEntry(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScValType => Ok(Self::ScValType(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScErrorType => {
                Ok(Self::ScErrorType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScErrorCode => {
                Ok(Self::ScErrorCode(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScError => Ok(Self::ScError(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::UInt128Parts => {
                Ok(Self::UInt128Parts(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::Int128Parts => {
                Ok(Self::Int128Parts(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::UInt256Parts => {
                Ok(Self::UInt256Parts(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::Int256Parts => {
                Ok(Self::Int256Parts(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ContractExecutableType => Ok(Self::ContractExecutableType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractExecutable => Ok(Self::ContractExecutable(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScAddressType => {
                Ok(Self::ScAddressType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ScAddress => Ok(Self::ScAddress(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScVec => Ok(Self::ScVec(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScMap => Ok(Self::ScMap(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScBytes => Ok(Self::ScBytes(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScString => Ok(Self::ScString(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScSymbol => Ok(Self::ScSymbol(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScNonceKey => Ok(Self::ScNonceKey(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScContractInstance => Ok(Self::ScContractInstance(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScVal => Ok(Self::ScVal(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ScMapEntry => Ok(Self::ScMapEntry(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::StoredTransactionSet => Ok(Self::StoredTransactionSet(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::StoredDebugTransactionSet => Ok(Self::StoredDebugTransactionSet(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::PersistedScpStateV0 => Ok(Self::PersistedScpStateV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::PersistedScpStateV1 => Ok(Self::PersistedScpStateV1(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::PersistedScpState => Ok(Self::PersistedScpState(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::Thresholds => Ok(Self::Thresholds(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::String32 => Ok(Self::String32(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::String64 => Ok(Self::String64(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::SequenceNumber => {
                Ok(Self::SequenceNumber(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::DataValue => Ok(Self::DataValue(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::PoolId => Ok(Self::PoolId(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::AssetCode4 => Ok(Self::AssetCode4(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::AssetCode12 => {
                Ok(Self::AssetCode12(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::AssetType => Ok(Self::AssetType(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::AssetCode => Ok(Self::AssetCode(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::AlphaNum4 => Ok(Self::AlphaNum4(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::AlphaNum12 => Ok(Self::AlphaNum12(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Asset => Ok(Self::Asset(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Price => Ok(Self::Price(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Liabilities => {
                Ok(Self::Liabilities(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ThresholdIndexes => Ok(Self::ThresholdIndexes(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerEntryType => {
                Ok(Self::LedgerEntryType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::Signer => Ok(Self::Signer(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::AccountFlags => {
                Ok(Self::AccountFlags(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::SponsorshipDescriptor => Ok(Self::SponsorshipDescriptor(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::AccountEntryExtensionV3 => Ok(Self::AccountEntryExtensionV3(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::AccountEntryExtensionV2 => Ok(Self::AccountEntryExtensionV2(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::AccountEntryExtensionV2Ext => Ok(Self::AccountEntryExtensionV2Ext(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::AccountEntryExtensionV1 => Ok(Self::AccountEntryExtensionV1(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::AccountEntryExtensionV1Ext => Ok(Self::AccountEntryExtensionV1Ext(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::AccountEntry => {
                Ok(Self::AccountEntry(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::AccountEntryExt => {
                Ok(Self::AccountEntryExt(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TrustLineFlags => {
                Ok(Self::TrustLineFlags(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::LiquidityPoolType => Ok(Self::LiquidityPoolType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TrustLineAsset => {
                Ok(Self::TrustLineAsset(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TrustLineEntryExtensionV2 => Ok(Self::TrustLineEntryExtensionV2(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::TrustLineEntryExtensionV2Ext => Ok(Self::TrustLineEntryExtensionV2Ext(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::TrustLineEntry => {
                Ok(Self::TrustLineEntry(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TrustLineEntryExt => Ok(Self::TrustLineEntryExt(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TrustLineEntryV1 => Ok(Self::TrustLineEntryV1(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TrustLineEntryV1Ext => Ok(Self::TrustLineEntryV1Ext(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::OfferEntryFlags => {
                Ok(Self::OfferEntryFlags(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::OfferEntry => Ok(Self::OfferEntry(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::OfferEntryExt => {
                Ok(Self::OfferEntryExt(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::DataEntry => Ok(Self::DataEntry(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::DataEntryExt => {
                Ok(Self::DataEntryExt(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ClaimPredicateType => Ok(Self::ClaimPredicateType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ClaimPredicate => {
                Ok(Self::ClaimPredicate(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ClaimantType => {
                Ok(Self::ClaimantType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::Claimant => Ok(Self::Claimant(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ClaimantV0 => Ok(Self::ClaimantV0(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ClaimableBalanceIdType => Ok(Self::ClaimableBalanceIdType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ClaimableBalanceId => Ok(Self::ClaimableBalanceId(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ClaimableBalanceFlags => Ok(Self::ClaimableBalanceFlags(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ClaimableBalanceEntryExtensionV1 => Ok(
                Self::ClaimableBalanceEntryExtensionV1(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::ClaimableBalanceEntryExtensionV1Ext => Ok(
                Self::ClaimableBalanceEntryExtensionV1Ext(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::ClaimableBalanceEntry => Ok(Self::ClaimableBalanceEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ClaimableBalanceEntryExt => Ok(Self::ClaimableBalanceEntryExt(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LiquidityPoolConstantProductParameters => Ok(
                Self::LiquidityPoolConstantProductParameters(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::LiquidityPoolEntry => Ok(Self::LiquidityPoolEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LiquidityPoolEntryBody => Ok(Self::LiquidityPoolEntryBody(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LiquidityPoolEntryConstantProduct => Ok(
                Self::LiquidityPoolEntryConstantProduct(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::ContractDataDurability => Ok(Self::ContractDataDurability(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractDataEntry => Ok(Self::ContractDataEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractCodeCostInputs => Ok(Self::ContractCodeCostInputs(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractCodeEntry => Ok(Self::ContractCodeEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractCodeEntryExt => Ok(Self::ContractCodeEntryExt(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractCodeEntryV1 => Ok(Self::ContractCodeEntryV1(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TtlEntry => Ok(Self::TtlEntry(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::LedgerEntryExtensionV1 => Ok(Self::LedgerEntryExtensionV1(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerEntryExtensionV1Ext => Ok(Self::LedgerEntryExtensionV1Ext(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::LedgerEntry => {
                Ok(Self::LedgerEntry(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::LedgerEntryData => {
                Ok(Self::LedgerEntryData(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::LedgerEntryExt => {
                Ok(Self::LedgerEntryExt(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::LedgerKey => Ok(Self::LedgerKey(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::LedgerKeyAccount => Ok(Self::LedgerKeyAccount(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerKeyTrustLine => Ok(Self::LedgerKeyTrustLine(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerKeyOffer => {
                Ok(Self::LedgerKeyOffer(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::LedgerKeyData => {
                Ok(Self::LedgerKeyData(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::LedgerKeyClaimableBalance => Ok(Self::LedgerKeyClaimableBalance(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::LedgerKeyLiquidityPool => Ok(Self::LedgerKeyLiquidityPool(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerKeyContractData => Ok(Self::LedgerKeyContractData(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerKeyContractCode => Ok(Self::LedgerKeyContractCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerKeyConfigSetting => Ok(Self::LedgerKeyConfigSetting(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerKeyTtl => {
                Ok(Self::LedgerKeyTtl(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::EnvelopeType => {
                Ok(Self::EnvelopeType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::UpgradeType => {
                Ok(Self::UpgradeType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::StellarValueType => Ok(Self::StellarValueType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerCloseValueSignature => Ok(Self::LedgerCloseValueSignature(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::StellarValue => {
                Ok(Self::StellarValue(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::StellarValueExt => {
                Ok(Self::StellarValueExt(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::LedgerHeaderFlags => Ok(Self::LedgerHeaderFlags(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerHeaderExtensionV1 => Ok(Self::LedgerHeaderExtensionV1(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerHeaderExtensionV1Ext => Ok(Self::LedgerHeaderExtensionV1Ext(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::LedgerHeader => {
                Ok(Self::LedgerHeader(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::LedgerHeaderExt => {
                Ok(Self::LedgerHeaderExt(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::LedgerUpgradeType => Ok(Self::LedgerUpgradeType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ConfigUpgradeSetKey => Ok(Self::ConfigUpgradeSetKey(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerUpgrade => {
                Ok(Self::LedgerUpgrade(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ConfigUpgradeSet => Ok(Self::ConfigUpgradeSet(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::BucketEntryType => {
                Ok(Self::BucketEntryType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::BucketMetadata => {
                Ok(Self::BucketMetadata(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::BucketMetadataExt => Ok(Self::BucketMetadataExt(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::BucketEntry => {
                Ok(Self::BucketEntry(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TxSetComponentType => Ok(Self::TxSetComponentType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TxSetComponent => {
                Ok(Self::TxSetComponent(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TxSetComponentTxsMaybeDiscountedFee => Ok(
                Self::TxSetComponentTxsMaybeDiscountedFee(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::TransactionPhase => Ok(Self::TransactionPhase(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionSet => {
                Ok(Self::TransactionSet(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TransactionSetV1 => Ok(Self::TransactionSetV1(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::GeneralizedTransactionSet => Ok(Self::GeneralizedTransactionSet(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::TransactionResultPair => Ok(Self::TransactionResultPair(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionResultSet => Ok(Self::TransactionResultSet(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionHistoryEntry => Ok(Self::TransactionHistoryEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionHistoryEntryExt => Ok(Self::TransactionHistoryEntryExt(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::TransactionHistoryResultEntry => Ok(Self::TransactionHistoryResultEntry(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::TransactionHistoryResultEntryExt => Ok(
                Self::TransactionHistoryResultEntryExt(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::LedgerHeaderHistoryEntry => Ok(Self::LedgerHeaderHistoryEntry(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerHeaderHistoryEntryExt => Ok(Self::LedgerHeaderHistoryEntryExt(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::LedgerScpMessages => Ok(Self::LedgerScpMessages(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScpHistoryEntryV0 => Ok(Self::ScpHistoryEntryV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ScpHistoryEntry => {
                Ok(Self::ScpHistoryEntry(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::LedgerEntryChangeType => Ok(Self::LedgerEntryChangeType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerEntryChange => Ok(Self::LedgerEntryChange(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerEntryChanges => Ok(Self::LedgerEntryChanges(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::OperationMeta => {
                Ok(Self::OperationMeta(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TransactionMetaV1 => Ok(Self::TransactionMetaV1(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionMetaV2 => Ok(Self::TransactionMetaV2(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractEventType => Ok(Self::ContractEventType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractEvent => {
                Ok(Self::ContractEvent(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ContractEventBody => Ok(Self::ContractEventBody(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractEventV0 => {
                Ok(Self::ContractEventV0(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::DiagnosticEvent => {
                Ok(Self::DiagnosticEvent(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::SorobanTransactionMetaExtV1 => Ok(Self::SorobanTransactionMetaExtV1(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::SorobanTransactionMetaExt => Ok(Self::SorobanTransactionMetaExt(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::SorobanTransactionMeta => Ok(Self::SorobanTransactionMeta(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionMetaV3 => Ok(Self::TransactionMetaV3(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::InvokeHostFunctionSuccessPreImage => Ok(
                Self::InvokeHostFunctionSuccessPreImage(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::TransactionMeta => {
                Ok(Self::TransactionMeta(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TransactionResultMeta => Ok(Self::TransactionResultMeta(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::UpgradeEntryMeta => Ok(Self::UpgradeEntryMeta(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerCloseMetaV0 => Ok(Self::LedgerCloseMetaV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerCloseMetaExtV1 => Ok(Self::LedgerCloseMetaExtV1(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerCloseMetaExt => Ok(Self::LedgerCloseMetaExt(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerCloseMetaV1 => Ok(Self::LedgerCloseMetaV1(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LedgerCloseMeta => {
                Ok(Self::LedgerCloseMeta(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ErrorCode => Ok(Self::ErrorCode(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::SError => Ok(Self::SError(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::SendMore => Ok(Self::SendMore(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::SendMoreExtended => Ok(Self::SendMoreExtended(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::AuthCert => Ok(Self::AuthCert(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Hello => Ok(Self::Hello(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Auth => Ok(Self::Auth(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::IpAddrType => Ok(Self::IpAddrType(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::PeerAddress => {
                Ok(Self::PeerAddress(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::PeerAddressIp => {
                Ok(Self::PeerAddressIp(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::MessageType => {
                Ok(Self::MessageType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::DontHave => Ok(Self::DontHave(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::SurveyMessageCommandType => Ok(Self::SurveyMessageCommandType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::SurveyMessageResponseType => Ok(Self::SurveyMessageResponseType(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::SurveyRequestMessage => Ok(Self::SurveyRequestMessage(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::SignedSurveyRequestMessage => Ok(Self::SignedSurveyRequestMessage(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::EncryptedBody => {
                Ok(Self::EncryptedBody(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::SurveyResponseMessage => Ok(Self::SurveyResponseMessage(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::SignedSurveyResponseMessage => Ok(Self::SignedSurveyResponseMessage(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::PeerStats => Ok(Self::PeerStats(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::PeerStatList => {
                Ok(Self::PeerStatList(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TopologyResponseBodyV0 => Ok(Self::TopologyResponseBodyV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TopologyResponseBodyV1 => Ok(Self::TopologyResponseBodyV1(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::SurveyResponseBody => Ok(Self::SurveyResponseBody(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TxAdvertVector => {
                Ok(Self::TxAdvertVector(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::FloodAdvert => {
                Ok(Self::FloodAdvert(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TxDemandVector => {
                Ok(Self::TxDemandVector(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::FloodDemand => {
                Ok(Self::FloodDemand(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::StellarMessage => {
                Ok(Self::StellarMessage(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::AuthenticatedMessage => Ok(Self::AuthenticatedMessage(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::AuthenticatedMessageV0 => Ok(Self::AuthenticatedMessageV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LiquidityPoolParameters => Ok(Self::LiquidityPoolParameters(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::MuxedAccount => {
                Ok(Self::MuxedAccount(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::MuxedAccountMed25519 => Ok(Self::MuxedAccountMed25519(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::DecoratedSignature => Ok(Self::DecoratedSignature(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::OperationType => {
                Ok(Self::OperationType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::CreateAccountOp => {
                Ok(Self::CreateAccountOp(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::PaymentOp => Ok(Self::PaymentOp(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::PathPaymentStrictReceiveOp => Ok(Self::PathPaymentStrictReceiveOp(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::PathPaymentStrictSendOp => Ok(Self::PathPaymentStrictSendOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ManageSellOfferOp => Ok(Self::ManageSellOfferOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ManageBuyOfferOp => Ok(Self::ManageBuyOfferOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::CreatePassiveSellOfferOp => Ok(Self::CreatePassiveSellOfferOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::SetOptionsOp => {
                Ok(Self::SetOptionsOp(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ChangeTrustAsset => Ok(Self::ChangeTrustAsset(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ChangeTrustOp => {
                Ok(Self::ChangeTrustOp(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::AllowTrustOp => {
                Ok(Self::AllowTrustOp(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ManageDataOp => {
                Ok(Self::ManageDataOp(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::BumpSequenceOp => {
                Ok(Self::BumpSequenceOp(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::CreateClaimableBalanceOp => Ok(Self::CreateClaimableBalanceOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ClaimClaimableBalanceOp => Ok(Self::ClaimClaimableBalanceOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::BeginSponsoringFutureReservesOp => Ok(
                Self::BeginSponsoringFutureReservesOp(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::RevokeSponsorshipType => Ok(Self::RevokeSponsorshipType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::RevokeSponsorshipOp => Ok(Self::RevokeSponsorshipOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::RevokeSponsorshipOpSigner => Ok(Self::RevokeSponsorshipOpSigner(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::ClawbackOp => Ok(Self::ClawbackOp(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ClawbackClaimableBalanceOp => Ok(Self::ClawbackClaimableBalanceOp(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::SetTrustLineFlagsOp => Ok(Self::SetTrustLineFlagsOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LiquidityPoolDepositOp => Ok(Self::LiquidityPoolDepositOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LiquidityPoolWithdrawOp => Ok(Self::LiquidityPoolWithdrawOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::HostFunctionType => Ok(Self::HostFunctionType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractIdPreimageType => Ok(Self::ContractIdPreimageType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractIdPreimage => Ok(Self::ContractIdPreimage(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ContractIdPreimageFromAddress => Ok(Self::ContractIdPreimageFromAddress(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::CreateContractArgs => Ok(Self::CreateContractArgs(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::InvokeContractArgs => Ok(Self::InvokeContractArgs(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::HostFunction => {
                Ok(Self::HostFunction(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::SorobanAuthorizedFunctionType => Ok(Self::SorobanAuthorizedFunctionType(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::SorobanAuthorizedFunction => Ok(Self::SorobanAuthorizedFunction(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::SorobanAuthorizedInvocation => Ok(Self::SorobanAuthorizedInvocation(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::SorobanAddressCredentials => Ok(Self::SorobanAddressCredentials(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::SorobanCredentialsType => Ok(Self::SorobanCredentialsType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::SorobanCredentials => Ok(Self::SorobanCredentials(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::SorobanAuthorizationEntry => Ok(Self::SorobanAuthorizationEntry(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::InvokeHostFunctionOp => Ok(Self::InvokeHostFunctionOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ExtendFootprintTtlOp => Ok(Self::ExtendFootprintTtlOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::RestoreFootprintOp => Ok(Self::RestoreFootprintOp(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::Operation => Ok(Self::Operation(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::OperationBody => {
                Ok(Self::OperationBody(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::HashIdPreimage => {
                Ok(Self::HashIdPreimage(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::HashIdPreimageOperationId => Ok(Self::HashIdPreimageOperationId(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::HashIdPreimageRevokeId => Ok(Self::HashIdPreimageRevokeId(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::HashIdPreimageContractId => Ok(Self::HashIdPreimageContractId(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::HashIdPreimageSorobanAuthorization => Ok(
                Self::HashIdPreimageSorobanAuthorization(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::MemoType => Ok(Self::MemoType(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Memo => Ok(Self::Memo(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::TimeBounds => Ok(Self::TimeBounds(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::LedgerBounds => {
                Ok(Self::LedgerBounds(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::PreconditionsV2 => {
                Ok(Self::PreconditionsV2(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::PreconditionType => Ok(Self::PreconditionType(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::Preconditions => {
                Ok(Self::Preconditions(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::LedgerFootprint => {
                Ok(Self::LedgerFootprint(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::SorobanResources => Ok(Self::SorobanResources(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::SorobanTransactionData => Ok(Self::SorobanTransactionData(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionV0 => {
                Ok(Self::TransactionV0(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TransactionV0Ext => Ok(Self::TransactionV0Ext(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionV0Envelope => Ok(Self::TransactionV0Envelope(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::Transaction => {
                Ok(Self::Transaction(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TransactionExt => {
                Ok(Self::TransactionExt(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::TransactionV1Envelope => Ok(Self::TransactionV1Envelope(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::FeeBumpTransaction => Ok(Self::FeeBumpTransaction(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::FeeBumpTransactionInnerTx => Ok(Self::FeeBumpTransactionInnerTx(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::FeeBumpTransactionExt => Ok(Self::FeeBumpTransactionExt(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::FeeBumpTransactionEnvelope => Ok(Self::FeeBumpTransactionEnvelope(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::TransactionEnvelope => Ok(Self::TransactionEnvelope(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionSignaturePayload => Ok(Self::TransactionSignaturePayload(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::TransactionSignaturePayloadTaggedTransaction => {
                Ok(Self::TransactionSignaturePayloadTaggedTransaction(
                    Box::new(serde_json::from_reader(r)?),
                ))
            }
            TypeVariant::ClaimAtomType => {
                Ok(Self::ClaimAtomType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ClaimOfferAtomV0 => Ok(Self::ClaimOfferAtomV0(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ClaimOfferAtom => {
                Ok(Self::ClaimOfferAtom(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ClaimLiquidityAtom => Ok(Self::ClaimLiquidityAtom(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ClaimAtom => Ok(Self::ClaimAtom(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::CreateAccountResultCode => Ok(Self::CreateAccountResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::CreateAccountResult => Ok(Self::CreateAccountResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::PaymentResultCode => Ok(Self::PaymentResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::PaymentResult => {
                Ok(Self::PaymentResult(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::PathPaymentStrictReceiveResultCode => Ok(
                Self::PathPaymentStrictReceiveResultCode(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::SimplePaymentResult => Ok(Self::SimplePaymentResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::PathPaymentStrictReceiveResult => Ok(
                Self::PathPaymentStrictReceiveResult(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::PathPaymentStrictReceiveResultSuccess => Ok(
                Self::PathPaymentStrictReceiveResultSuccess(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::PathPaymentStrictSendResultCode => Ok(
                Self::PathPaymentStrictSendResultCode(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::PathPaymentStrictSendResult => Ok(Self::PathPaymentStrictSendResult(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::PathPaymentStrictSendResultSuccess => Ok(
                Self::PathPaymentStrictSendResultSuccess(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::ManageSellOfferResultCode => Ok(Self::ManageSellOfferResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::ManageOfferEffect => Ok(Self::ManageOfferEffect(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ManageOfferSuccessResult => Ok(Self::ManageOfferSuccessResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ManageOfferSuccessResultOffer => Ok(Self::ManageOfferSuccessResultOffer(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::ManageSellOfferResult => Ok(Self::ManageSellOfferResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ManageBuyOfferResultCode => Ok(Self::ManageBuyOfferResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ManageBuyOfferResult => Ok(Self::ManageBuyOfferResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::SetOptionsResultCode => Ok(Self::SetOptionsResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::SetOptionsResult => Ok(Self::SetOptionsResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ChangeTrustResultCode => Ok(Self::ChangeTrustResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ChangeTrustResult => Ok(Self::ChangeTrustResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::AllowTrustResultCode => Ok(Self::AllowTrustResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::AllowTrustResult => Ok(Self::AllowTrustResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::AccountMergeResultCode => Ok(Self::AccountMergeResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::AccountMergeResult => Ok(Self::AccountMergeResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::InflationResultCode => Ok(Self::InflationResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::InflationPayout => {
                Ok(Self::InflationPayout(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::InflationResult => {
                Ok(Self::InflationResult(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ManageDataResultCode => Ok(Self::ManageDataResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ManageDataResult => Ok(Self::ManageDataResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::BumpSequenceResultCode => Ok(Self::BumpSequenceResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::BumpSequenceResult => Ok(Self::BumpSequenceResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::CreateClaimableBalanceResultCode => Ok(
                Self::CreateClaimableBalanceResultCode(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::CreateClaimableBalanceResult => Ok(Self::CreateClaimableBalanceResult(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::ClaimClaimableBalanceResultCode => Ok(
                Self::ClaimClaimableBalanceResultCode(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::ClaimClaimableBalanceResult => Ok(Self::ClaimClaimableBalanceResult(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::BeginSponsoringFutureReservesResultCode => {
                Ok(Self::BeginSponsoringFutureReservesResultCode(Box::new(
                    serde_json::from_reader(r)?,
                )))
            }
            TypeVariant::BeginSponsoringFutureReservesResult => Ok(
                Self::BeginSponsoringFutureReservesResult(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::EndSponsoringFutureReservesResultCode => Ok(
                Self::EndSponsoringFutureReservesResultCode(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::EndSponsoringFutureReservesResult => Ok(
                Self::EndSponsoringFutureReservesResult(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::RevokeSponsorshipResultCode => Ok(Self::RevokeSponsorshipResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::RevokeSponsorshipResult => Ok(Self::RevokeSponsorshipResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ClawbackResultCode => Ok(Self::ClawbackResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ClawbackResult => {
                Ok(Self::ClawbackResult(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::ClawbackClaimableBalanceResultCode => Ok(
                Self::ClawbackClaimableBalanceResultCode(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::ClawbackClaimableBalanceResult => Ok(
                Self::ClawbackClaimableBalanceResult(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::SetTrustLineFlagsResultCode => Ok(Self::SetTrustLineFlagsResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::SetTrustLineFlagsResult => Ok(Self::SetTrustLineFlagsResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::LiquidityPoolDepositResultCode => Ok(
                Self::LiquidityPoolDepositResultCode(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::LiquidityPoolDepositResult => Ok(Self::LiquidityPoolDepositResult(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::LiquidityPoolWithdrawResultCode => Ok(
                Self::LiquidityPoolWithdrawResultCode(Box::new(serde_json::from_reader(r)?)),
            ),
            TypeVariant::LiquidityPoolWithdrawResult => Ok(Self::LiquidityPoolWithdrawResult(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::InvokeHostFunctionResultCode => Ok(Self::InvokeHostFunctionResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::InvokeHostFunctionResult => Ok(Self::InvokeHostFunctionResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::ExtendFootprintTtlResultCode => Ok(Self::ExtendFootprintTtlResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::ExtendFootprintTtlResult => Ok(Self::ExtendFootprintTtlResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::RestoreFootprintResultCode => Ok(Self::RestoreFootprintResultCode(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::RestoreFootprintResult => Ok(Self::RestoreFootprintResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::OperationResultCode => Ok(Self::OperationResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::OperationResult => {
                Ok(Self::OperationResult(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::OperationResultTr => Ok(Self::OperationResultTr(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionResultCode => Ok(Self::TransactionResultCode(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::InnerTransactionResult => Ok(Self::InnerTransactionResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::InnerTransactionResultResult => Ok(Self::InnerTransactionResultResult(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::InnerTransactionResultExt => Ok(Self::InnerTransactionResultExt(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::InnerTransactionResultPair => Ok(Self::InnerTransactionResultPair(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::TransactionResult => Ok(Self::TransactionResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionResultResult => Ok(Self::TransactionResultResult(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::TransactionResultExt => Ok(Self::TransactionResultExt(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::Hash => Ok(Self::Hash(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Uint256 => Ok(Self::Uint256(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Uint32 => Ok(Self::Uint32(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Int32 => Ok(Self::Int32(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Uint64 => Ok(Self::Uint64(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Int64 => Ok(Self::Int64(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::TimePoint => Ok(Self::TimePoint(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Duration => Ok(Self::Duration(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::ExtensionPoint => {
                Ok(Self::ExtensionPoint(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::CryptoKeyType => {
                Ok(Self::CryptoKeyType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::PublicKeyType => {
                Ok(Self::PublicKeyType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::SignerKeyType => {
                Ok(Self::SignerKeyType(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::PublicKey => Ok(Self::PublicKey(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::SignerKey => Ok(Self::SignerKey(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::SignerKeyEd25519SignedPayload => Ok(Self::SignerKeyEd25519SignedPayload(
                Box::new(serde_json::from_reader(r)?),
            )),
            TypeVariant::Signature => Ok(Self::Signature(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::SignatureHint => {
                Ok(Self::SignatureHint(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::NodeId => Ok(Self::NodeId(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::AccountId => Ok(Self::AccountId(Box::new(serde_json::from_reader(r)?))),
            TypeVariant::Curve25519Secret => Ok(Self::Curve25519Secret(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::Curve25519Public => Ok(Self::Curve25519Public(Box::new(
                serde_json::from_reader(r)?,
            ))),
            TypeVariant::HmacSha256Key => {
                Ok(Self::HmacSha256Key(Box::new(serde_json::from_reader(r)?)))
            }
            TypeVariant::HmacSha256Mac => {
                Ok(Self::HmacSha256Mac(Box::new(serde_json::from_reader(r)?)))
            }
        }
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub fn value(&self) -> &dyn core::any::Any {
        #[allow(clippy::match_same_arms)]
        match self {
            Self::Value(ref v) => v.as_ref(),
            Self::ScpBallot(ref v) => v.as_ref(),
            Self::ScpStatementType(ref v) => v.as_ref(),
            Self::ScpNomination(ref v) => v.as_ref(),
            Self::ScpStatement(ref v) => v.as_ref(),
            Self::ScpStatementPledges(ref v) => v.as_ref(),
            Self::ScpStatementPrepare(ref v) => v.as_ref(),
            Self::ScpStatementConfirm(ref v) => v.as_ref(),
            Self::ScpStatementExternalize(ref v) => v.as_ref(),
            Self::ScpEnvelope(ref v) => v.as_ref(),
            Self::ScpQuorumSet(ref v) => v.as_ref(),
            Self::ConfigSettingContractExecutionLanesV0(ref v) => v.as_ref(),
            Self::ConfigSettingContractComputeV0(ref v) => v.as_ref(),
            Self::ConfigSettingContractLedgerCostV0(ref v) => v.as_ref(),
            Self::ConfigSettingContractHistoricalDataV0(ref v) => v.as_ref(),
            Self::ConfigSettingContractEventsV0(ref v) => v.as_ref(),
            Self::ConfigSettingContractBandwidthV0(ref v) => v.as_ref(),
            Self::ContractCostType(ref v) => v.as_ref(),
            Self::ContractCostParamEntry(ref v) => v.as_ref(),
            Self::StateArchivalSettings(ref v) => v.as_ref(),
            Self::EvictionIterator(ref v) => v.as_ref(),
            Self::ContractCostParams(ref v) => v.as_ref(),
            Self::ConfigSettingId(ref v) => v.as_ref(),
            Self::ConfigSettingEntry(ref v) => v.as_ref(),
            Self::ScEnvMetaKind(ref v) => v.as_ref(),
            Self::ScEnvMetaEntry(ref v) => v.as_ref(),
            Self::ScMetaV0(ref v) => v.as_ref(),
            Self::ScMetaKind(ref v) => v.as_ref(),
            Self::ScMetaEntry(ref v) => v.as_ref(),
            Self::ScSpecType(ref v) => v.as_ref(),
            Self::ScSpecTypeOption(ref v) => v.as_ref(),
            Self::ScSpecTypeResult(ref v) => v.as_ref(),
            Self::ScSpecTypeVec(ref v) => v.as_ref(),
            Self::ScSpecTypeMap(ref v) => v.as_ref(),
            Self::ScSpecTypeTuple(ref v) => v.as_ref(),
            Self::ScSpecTypeBytesN(ref v) => v.as_ref(),
            Self::ScSpecTypeUdt(ref v) => v.as_ref(),
            Self::ScSpecTypeDef(ref v) => v.as_ref(),
            Self::ScSpecUdtStructFieldV0(ref v) => v.as_ref(),
            Self::ScSpecUdtStructV0(ref v) => v.as_ref(),
            Self::ScSpecUdtUnionCaseVoidV0(ref v) => v.as_ref(),
            Self::ScSpecUdtUnionCaseTupleV0(ref v) => v.as_ref(),
            Self::ScSpecUdtUnionCaseV0Kind(ref v) => v.as_ref(),
            Self::ScSpecUdtUnionCaseV0(ref v) => v.as_ref(),
            Self::ScSpecUdtUnionV0(ref v) => v.as_ref(),
            Self::ScSpecUdtEnumCaseV0(ref v) => v.as_ref(),
            Self::ScSpecUdtEnumV0(ref v) => v.as_ref(),
            Self::ScSpecUdtErrorEnumCaseV0(ref v) => v.as_ref(),
            Self::ScSpecUdtErrorEnumV0(ref v) => v.as_ref(),
            Self::ScSpecFunctionInputV0(ref v) => v.as_ref(),
            Self::ScSpecFunctionV0(ref v) => v.as_ref(),
            Self::ScSpecEntryKind(ref v) => v.as_ref(),
            Self::ScSpecEntry(ref v) => v.as_ref(),
            Self::ScValType(ref v) => v.as_ref(),
            Self::ScErrorType(ref v) => v.as_ref(),
            Self::ScErrorCode(ref v) => v.as_ref(),
            Self::ScError(ref v) => v.as_ref(),
            Self::UInt128Parts(ref v) => v.as_ref(),
            Self::Int128Parts(ref v) => v.as_ref(),
            Self::UInt256Parts(ref v) => v.as_ref(),
            Self::Int256Parts(ref v) => v.as_ref(),
            Self::ContractExecutableType(ref v) => v.as_ref(),
            Self::ContractExecutable(ref v) => v.as_ref(),
            Self::ScAddressType(ref v) => v.as_ref(),
            Self::ScAddress(ref v) => v.as_ref(),
            Self::ScVec(ref v) => v.as_ref(),
            Self::ScMap(ref v) => v.as_ref(),
            Self::ScBytes(ref v) => v.as_ref(),
            Self::ScString(ref v) => v.as_ref(),
            Self::ScSymbol(ref v) => v.as_ref(),
            Self::ScNonceKey(ref v) => v.as_ref(),
            Self::ScContractInstance(ref v) => v.as_ref(),
            Self::ScVal(ref v) => v.as_ref(),
            Self::ScMapEntry(ref v) => v.as_ref(),
            Self::StoredTransactionSet(ref v) => v.as_ref(),
            Self::StoredDebugTransactionSet(ref v) => v.as_ref(),
            Self::PersistedScpStateV0(ref v) => v.as_ref(),
            Self::PersistedScpStateV1(ref v) => v.as_ref(),
            Self::PersistedScpState(ref v) => v.as_ref(),
            Self::Thresholds(ref v) => v.as_ref(),
            Self::String32(ref v) => v.as_ref(),
            Self::String64(ref v) => v.as_ref(),
            Self::SequenceNumber(ref v) => v.as_ref(),
            Self::DataValue(ref v) => v.as_ref(),
            Self::PoolId(ref v) => v.as_ref(),
            Self::AssetCode4(ref v) => v.as_ref(),
            Self::AssetCode12(ref v) => v.as_ref(),
            Self::AssetType(ref v) => v.as_ref(),
            Self::AssetCode(ref v) => v.as_ref(),
            Self::AlphaNum4(ref v) => v.as_ref(),
            Self::AlphaNum12(ref v) => v.as_ref(),
            Self::Asset(ref v) => v.as_ref(),
            Self::Price(ref v) => v.as_ref(),
            Self::Liabilities(ref v) => v.as_ref(),
            Self::ThresholdIndexes(ref v) => v.as_ref(),
            Self::LedgerEntryType(ref v) => v.as_ref(),
            Self::Signer(ref v) => v.as_ref(),
            Self::AccountFlags(ref v) => v.as_ref(),
            Self::SponsorshipDescriptor(ref v) => v.as_ref(),
            Self::AccountEntryExtensionV3(ref v) => v.as_ref(),
            Self::AccountEntryExtensionV2(ref v) => v.as_ref(),
            Self::AccountEntryExtensionV2Ext(ref v) => v.as_ref(),
            Self::AccountEntryExtensionV1(ref v) => v.as_ref(),
            Self::AccountEntryExtensionV1Ext(ref v) => v.as_ref(),
            Self::AccountEntry(ref v) => v.as_ref(),
            Self::AccountEntryExt(ref v) => v.as_ref(),
            Self::TrustLineFlags(ref v) => v.as_ref(),
            Self::LiquidityPoolType(ref v) => v.as_ref(),
            Self::TrustLineAsset(ref v) => v.as_ref(),
            Self::TrustLineEntryExtensionV2(ref v) => v.as_ref(),
            Self::TrustLineEntryExtensionV2Ext(ref v) => v.as_ref(),
            Self::TrustLineEntry(ref v) => v.as_ref(),
            Self::TrustLineEntryExt(ref v) => v.as_ref(),
            Self::TrustLineEntryV1(ref v) => v.as_ref(),
            Self::TrustLineEntryV1Ext(ref v) => v.as_ref(),
            Self::OfferEntryFlags(ref v) => v.as_ref(),
            Self::OfferEntry(ref v) => v.as_ref(),
            Self::OfferEntryExt(ref v) => v.as_ref(),
            Self::DataEntry(ref v) => v.as_ref(),
            Self::DataEntryExt(ref v) => v.as_ref(),
            Self::ClaimPredicateType(ref v) => v.as_ref(),
            Self::ClaimPredicate(ref v) => v.as_ref(),
            Self::ClaimantType(ref v) => v.as_ref(),
            Self::Claimant(ref v) => v.as_ref(),
            Self::ClaimantV0(ref v) => v.as_ref(),
            Self::ClaimableBalanceIdType(ref v) => v.as_ref(),
            Self::ClaimableBalanceId(ref v) => v.as_ref(),
            Self::ClaimableBalanceFlags(ref v) => v.as_ref(),
            Self::ClaimableBalanceEntryExtensionV1(ref v) => v.as_ref(),
            Self::ClaimableBalanceEntryExtensionV1Ext(ref v) => v.as_ref(),
            Self::ClaimableBalanceEntry(ref v) => v.as_ref(),
            Self::ClaimableBalanceEntryExt(ref v) => v.as_ref(),
            Self::LiquidityPoolConstantProductParameters(ref v) => v.as_ref(),
            Self::LiquidityPoolEntry(ref v) => v.as_ref(),
            Self::LiquidityPoolEntryBody(ref v) => v.as_ref(),
            Self::LiquidityPoolEntryConstantProduct(ref v) => v.as_ref(),
            Self::ContractDataDurability(ref v) => v.as_ref(),
            Self::ContractDataEntry(ref v) => v.as_ref(),
            Self::ContractCodeCostInputs(ref v) => v.as_ref(),
            Self::ContractCodeEntry(ref v) => v.as_ref(),
            Self::ContractCodeEntryExt(ref v) => v.as_ref(),
            Self::ContractCodeEntryV1(ref v) => v.as_ref(),
            Self::TtlEntry(ref v) => v.as_ref(),
            Self::LedgerEntryExtensionV1(ref v) => v.as_ref(),
            Self::LedgerEntryExtensionV1Ext(ref v) => v.as_ref(),
            Self::LedgerEntry(ref v) => v.as_ref(),
            Self::LedgerEntryData(ref v) => v.as_ref(),
            Self::LedgerEntryExt(ref v) => v.as_ref(),
            Self::LedgerKey(ref v) => v.as_ref(),
            Self::LedgerKeyAccount(ref v) => v.as_ref(),
            Self::LedgerKeyTrustLine(ref v) => v.as_ref(),
            Self::LedgerKeyOffer(ref v) => v.as_ref(),
            Self::LedgerKeyData(ref v) => v.as_ref(),
            Self::LedgerKeyClaimableBalance(ref v) => v.as_ref(),
            Self::LedgerKeyLiquidityPool(ref v) => v.as_ref(),
            Self::LedgerKeyContractData(ref v) => v.as_ref(),
            Self::LedgerKeyContractCode(ref v) => v.as_ref(),
            Self::LedgerKeyConfigSetting(ref v) => v.as_ref(),
            Self::LedgerKeyTtl(ref v) => v.as_ref(),
            Self::EnvelopeType(ref v) => v.as_ref(),
            Self::UpgradeType(ref v) => v.as_ref(),
            Self::StellarValueType(ref v) => v.as_ref(),
            Self::LedgerCloseValueSignature(ref v) => v.as_ref(),
            Self::StellarValue(ref v) => v.as_ref(),
            Self::StellarValueExt(ref v) => v.as_ref(),
            Self::LedgerHeaderFlags(ref v) => v.as_ref(),
            Self::LedgerHeaderExtensionV1(ref v) => v.as_ref(),
            Self::LedgerHeaderExtensionV1Ext(ref v) => v.as_ref(),
            Self::LedgerHeader(ref v) => v.as_ref(),
            Self::LedgerHeaderExt(ref v) => v.as_ref(),
            Self::LedgerUpgradeType(ref v) => v.as_ref(),
            Self::ConfigUpgradeSetKey(ref v) => v.as_ref(),
            Self::LedgerUpgrade(ref v) => v.as_ref(),
            Self::ConfigUpgradeSet(ref v) => v.as_ref(),
            Self::BucketEntryType(ref v) => v.as_ref(),
            Self::BucketMetadata(ref v) => v.as_ref(),
            Self::BucketMetadataExt(ref v) => v.as_ref(),
            Self::BucketEntry(ref v) => v.as_ref(),
            Self::TxSetComponentType(ref v) => v.as_ref(),
            Self::TxSetComponent(ref v) => v.as_ref(),
            Self::TxSetComponentTxsMaybeDiscountedFee(ref v) => v.as_ref(),
            Self::TransactionPhase(ref v) => v.as_ref(),
            Self::TransactionSet(ref v) => v.as_ref(),
            Self::TransactionSetV1(ref v) => v.as_ref(),
            Self::GeneralizedTransactionSet(ref v) => v.as_ref(),
            Self::TransactionResultPair(ref v) => v.as_ref(),
            Self::TransactionResultSet(ref v) => v.as_ref(),
            Self::TransactionHistoryEntry(ref v) => v.as_ref(),
            Self::TransactionHistoryEntryExt(ref v) => v.as_ref(),
            Self::TransactionHistoryResultEntry(ref v) => v.as_ref(),
            Self::TransactionHistoryResultEntryExt(ref v) => v.as_ref(),
            Self::LedgerHeaderHistoryEntry(ref v) => v.as_ref(),
            Self::LedgerHeaderHistoryEntryExt(ref v) => v.as_ref(),
            Self::LedgerScpMessages(ref v) => v.as_ref(),
            Self::ScpHistoryEntryV0(ref v) => v.as_ref(),
            Self::ScpHistoryEntry(ref v) => v.as_ref(),
            Self::LedgerEntryChangeType(ref v) => v.as_ref(),
            Self::LedgerEntryChange(ref v) => v.as_ref(),
            Self::LedgerEntryChanges(ref v) => v.as_ref(),
            Self::OperationMeta(ref v) => v.as_ref(),
            Self::TransactionMetaV1(ref v) => v.as_ref(),
            Self::TransactionMetaV2(ref v) => v.as_ref(),
            Self::ContractEventType(ref v) => v.as_ref(),
            Self::ContractEvent(ref v) => v.as_ref(),
            Self::ContractEventBody(ref v) => v.as_ref(),
            Self::ContractEventV0(ref v) => v.as_ref(),
            Self::DiagnosticEvent(ref v) => v.as_ref(),
            Self::SorobanTransactionMetaExtV1(ref v) => v.as_ref(),
            Self::SorobanTransactionMetaExt(ref v) => v.as_ref(),
            Self::SorobanTransactionMeta(ref v) => v.as_ref(),
            Self::TransactionMetaV3(ref v) => v.as_ref(),
            Self::InvokeHostFunctionSuccessPreImage(ref v) => v.as_ref(),
            Self::TransactionMeta(ref v) => v.as_ref(),
            Self::TransactionResultMeta(ref v) => v.as_ref(),
            Self::UpgradeEntryMeta(ref v) => v.as_ref(),
            Self::LedgerCloseMetaV0(ref v) => v.as_ref(),
            Self::LedgerCloseMetaExtV1(ref v) => v.as_ref(),
            Self::LedgerCloseMetaExt(ref v) => v.as_ref(),
            Self::LedgerCloseMetaV1(ref v) => v.as_ref(),
            Self::LedgerCloseMeta(ref v) => v.as_ref(),
            Self::ErrorCode(ref v) => v.as_ref(),
            Self::SError(ref v) => v.as_ref(),
            Self::SendMore(ref v) => v.as_ref(),
            Self::SendMoreExtended(ref v) => v.as_ref(),
            Self::AuthCert(ref v) => v.as_ref(),
            Self::Hello(ref v) => v.as_ref(),
            Self::Auth(ref v) => v.as_ref(),
            Self::IpAddrType(ref v) => v.as_ref(),
            Self::PeerAddress(ref v) => v.as_ref(),
            Self::PeerAddressIp(ref v) => v.as_ref(),
            Self::MessageType(ref v) => v.as_ref(),
            Self::DontHave(ref v) => v.as_ref(),
            Self::SurveyMessageCommandType(ref v) => v.as_ref(),
            Self::SurveyMessageResponseType(ref v) => v.as_ref(),
            Self::SurveyRequestMessage(ref v) => v.as_ref(),
            Self::SignedSurveyRequestMessage(ref v) => v.as_ref(),
            Self::EncryptedBody(ref v) => v.as_ref(),
            Self::SurveyResponseMessage(ref v) => v.as_ref(),
            Self::SignedSurveyResponseMessage(ref v) => v.as_ref(),
            Self::PeerStats(ref v) => v.as_ref(),
            Self::PeerStatList(ref v) => v.as_ref(),
            Self::TopologyResponseBodyV0(ref v) => v.as_ref(),
            Self::TopologyResponseBodyV1(ref v) => v.as_ref(),
            Self::SurveyResponseBody(ref v) => v.as_ref(),
            Self::TxAdvertVector(ref v) => v.as_ref(),
            Self::FloodAdvert(ref v) => v.as_ref(),
            Self::TxDemandVector(ref v) => v.as_ref(),
            Self::FloodDemand(ref v) => v.as_ref(),
            Self::StellarMessage(ref v) => v.as_ref(),
            Self::AuthenticatedMessage(ref v) => v.as_ref(),
            Self::AuthenticatedMessageV0(ref v) => v.as_ref(),
            Self::LiquidityPoolParameters(ref v) => v.as_ref(),
            Self::MuxedAccount(ref v) => v.as_ref(),
            Self::MuxedAccountMed25519(ref v) => v.as_ref(),
            Self::DecoratedSignature(ref v) => v.as_ref(),
            Self::OperationType(ref v) => v.as_ref(),
            Self::CreateAccountOp(ref v) => v.as_ref(),
            Self::PaymentOp(ref v) => v.as_ref(),
            Self::PathPaymentStrictReceiveOp(ref v) => v.as_ref(),
            Self::PathPaymentStrictSendOp(ref v) => v.as_ref(),
            Self::ManageSellOfferOp(ref v) => v.as_ref(),
            Self::ManageBuyOfferOp(ref v) => v.as_ref(),
            Self::CreatePassiveSellOfferOp(ref v) => v.as_ref(),
            Self::SetOptionsOp(ref v) => v.as_ref(),
            Self::ChangeTrustAsset(ref v) => v.as_ref(),
            Self::ChangeTrustOp(ref v) => v.as_ref(),
            Self::AllowTrustOp(ref v) => v.as_ref(),
            Self::ManageDataOp(ref v) => v.as_ref(),
            Self::BumpSequenceOp(ref v) => v.as_ref(),
            Self::CreateClaimableBalanceOp(ref v) => v.as_ref(),
            Self::ClaimClaimableBalanceOp(ref v) => v.as_ref(),
            Self::BeginSponsoringFutureReservesOp(ref v) => v.as_ref(),
            Self::RevokeSponsorshipType(ref v) => v.as_ref(),
            Self::RevokeSponsorshipOp(ref v) => v.as_ref(),
            Self::RevokeSponsorshipOpSigner(ref v) => v.as_ref(),
            Self::ClawbackOp(ref v) => v.as_ref(),
            Self::ClawbackClaimableBalanceOp(ref v) => v.as_ref(),
            Self::SetTrustLineFlagsOp(ref v) => v.as_ref(),
            Self::LiquidityPoolDepositOp(ref v) => v.as_ref(),
            Self::LiquidityPoolWithdrawOp(ref v) => v.as_ref(),
            Self::HostFunctionType(ref v) => v.as_ref(),
            Self::ContractIdPreimageType(ref v) => v.as_ref(),
            Self::ContractIdPreimage(ref v) => v.as_ref(),
            Self::ContractIdPreimageFromAddress(ref v) => v.as_ref(),
            Self::CreateContractArgs(ref v) => v.as_ref(),
            Self::InvokeContractArgs(ref v) => v.as_ref(),
            Self::HostFunction(ref v) => v.as_ref(),
            Self::SorobanAuthorizedFunctionType(ref v) => v.as_ref(),
            Self::SorobanAuthorizedFunction(ref v) => v.as_ref(),
            Self::SorobanAuthorizedInvocation(ref v) => v.as_ref(),
            Self::SorobanAddressCredentials(ref v) => v.as_ref(),
            Self::SorobanCredentialsType(ref v) => v.as_ref(),
            Self::SorobanCredentials(ref v) => v.as_ref(),
            Self::SorobanAuthorizationEntry(ref v) => v.as_ref(),
            Self::InvokeHostFunctionOp(ref v) => v.as_ref(),
            Self::ExtendFootprintTtlOp(ref v) => v.as_ref(),
            Self::RestoreFootprintOp(ref v) => v.as_ref(),
            Self::Operation(ref v) => v.as_ref(),
            Self::OperationBody(ref v) => v.as_ref(),
            Self::HashIdPreimage(ref v) => v.as_ref(),
            Self::HashIdPreimageOperationId(ref v) => v.as_ref(),
            Self::HashIdPreimageRevokeId(ref v) => v.as_ref(),
            Self::HashIdPreimageContractId(ref v) => v.as_ref(),
            Self::HashIdPreimageSorobanAuthorization(ref v) => v.as_ref(),
            Self::MemoType(ref v) => v.as_ref(),
            Self::Memo(ref v) => v.as_ref(),
            Self::TimeBounds(ref v) => v.as_ref(),
            Self::LedgerBounds(ref v) => v.as_ref(),
            Self::PreconditionsV2(ref v) => v.as_ref(),
            Self::PreconditionType(ref v) => v.as_ref(),
            Self::Preconditions(ref v) => v.as_ref(),
            Self::LedgerFootprint(ref v) => v.as_ref(),
            Self::SorobanResources(ref v) => v.as_ref(),
            Self::SorobanTransactionData(ref v) => v.as_ref(),
            Self::TransactionV0(ref v) => v.as_ref(),
            Self::TransactionV0Ext(ref v) => v.as_ref(),
            Self::TransactionV0Envelope(ref v) => v.as_ref(),
            Self::Transaction(ref v) => v.as_ref(),
            Self::TransactionExt(ref v) => v.as_ref(),
            Self::TransactionV1Envelope(ref v) => v.as_ref(),
            Self::FeeBumpTransaction(ref v) => v.as_ref(),
            Self::FeeBumpTransactionInnerTx(ref v) => v.as_ref(),
            Self::FeeBumpTransactionExt(ref v) => v.as_ref(),
            Self::FeeBumpTransactionEnvelope(ref v) => v.as_ref(),
            Self::TransactionEnvelope(ref v) => v.as_ref(),
            Self::TransactionSignaturePayload(ref v) => v.as_ref(),
            Self::TransactionSignaturePayloadTaggedTransaction(ref v) => v.as_ref(),
            Self::ClaimAtomType(ref v) => v.as_ref(),
            Self::ClaimOfferAtomV0(ref v) => v.as_ref(),
            Self::ClaimOfferAtom(ref v) => v.as_ref(),
            Self::ClaimLiquidityAtom(ref v) => v.as_ref(),
            Self::ClaimAtom(ref v) => v.as_ref(),
            Self::CreateAccountResultCode(ref v) => v.as_ref(),
            Self::CreateAccountResult(ref v) => v.as_ref(),
            Self::PaymentResultCode(ref v) => v.as_ref(),
            Self::PaymentResult(ref v) => v.as_ref(),
            Self::PathPaymentStrictReceiveResultCode(ref v) => v.as_ref(),
            Self::SimplePaymentResult(ref v) => v.as_ref(),
            Self::PathPaymentStrictReceiveResult(ref v) => v.as_ref(),
            Self::PathPaymentStrictReceiveResultSuccess(ref v) => v.as_ref(),
            Self::PathPaymentStrictSendResultCode(ref v) => v.as_ref(),
            Self::PathPaymentStrictSendResult(ref v) => v.as_ref(),
            Self::PathPaymentStrictSendResultSuccess(ref v) => v.as_ref(),
            Self::ManageSellOfferResultCode(ref v) => v.as_ref(),
            Self::ManageOfferEffect(ref v) => v.as_ref(),
            Self::ManageOfferSuccessResult(ref v) => v.as_ref(),
            Self::ManageOfferSuccessResultOffer(ref v) => v.as_ref(),
            Self::ManageSellOfferResult(ref v) => v.as_ref(),
            Self::ManageBuyOfferResultCode(ref v) => v.as_ref(),
            Self::ManageBuyOfferResult(ref v) => v.as_ref(),
            Self::SetOptionsResultCode(ref v) => v.as_ref(),
            Self::SetOptionsResult(ref v) => v.as_ref(),
            Self::ChangeTrustResultCode(ref v) => v.as_ref(),
            Self::ChangeTrustResult(ref v) => v.as_ref(),
            Self::AllowTrustResultCode(ref v) => v.as_ref(),
            Self::AllowTrustResult(ref v) => v.as_ref(),
            Self::AccountMergeResultCode(ref v) => v.as_ref(),
            Self::AccountMergeResult(ref v) => v.as_ref(),
            Self::InflationResultCode(ref v) => v.as_ref(),
            Self::InflationPayout(ref v) => v.as_ref(),
            Self::InflationResult(ref v) => v.as_ref(),
            Self::ManageDataResultCode(ref v) => v.as_ref(),
            Self::ManageDataResult(ref v) => v.as_ref(),
            Self::BumpSequenceResultCode(ref v) => v.as_ref(),
            Self::BumpSequenceResult(ref v) => v.as_ref(),
            Self::CreateClaimableBalanceResultCode(ref v) => v.as_ref(),
            Self::CreateClaimableBalanceResult(ref v) => v.as_ref(),
            Self::ClaimClaimableBalanceResultCode(ref v) => v.as_ref(),
            Self::ClaimClaimableBalanceResult(ref v) => v.as_ref(),
            Self::BeginSponsoringFutureReservesResultCode(ref v) => v.as_ref(),
            Self::BeginSponsoringFutureReservesResult(ref v) => v.as_ref(),
            Self::EndSponsoringFutureReservesResultCode(ref v) => v.as_ref(),
            Self::EndSponsoringFutureReservesResult(ref v) => v.as_ref(),
            Self::RevokeSponsorshipResultCode(ref v) => v.as_ref(),
            Self::RevokeSponsorshipResult(ref v) => v.as_ref(),
            Self::ClawbackResultCode(ref v) => v.as_ref(),
            Self::ClawbackResult(ref v) => v.as_ref(),
            Self::ClawbackClaimableBalanceResultCode(ref v) => v.as_ref(),
            Self::ClawbackClaimableBalanceResult(ref v) => v.as_ref(),
            Self::SetTrustLineFlagsResultCode(ref v) => v.as_ref(),
            Self::SetTrustLineFlagsResult(ref v) => v.as_ref(),
            Self::LiquidityPoolDepositResultCode(ref v) => v.as_ref(),
            Self::LiquidityPoolDepositResult(ref v) => v.as_ref(),
            Self::LiquidityPoolWithdrawResultCode(ref v) => v.as_ref(),
            Self::LiquidityPoolWithdrawResult(ref v) => v.as_ref(),
            Self::InvokeHostFunctionResultCode(ref v) => v.as_ref(),
            Self::InvokeHostFunctionResult(ref v) => v.as_ref(),
            Self::ExtendFootprintTtlResultCode(ref v) => v.as_ref(),
            Self::ExtendFootprintTtlResult(ref v) => v.as_ref(),
            Self::RestoreFootprintResultCode(ref v) => v.as_ref(),
            Self::RestoreFootprintResult(ref v) => v.as_ref(),
            Self::OperationResultCode(ref v) => v.as_ref(),
            Self::OperationResult(ref v) => v.as_ref(),
            Self::OperationResultTr(ref v) => v.as_ref(),
            Self::TransactionResultCode(ref v) => v.as_ref(),
            Self::InnerTransactionResult(ref v) => v.as_ref(),
            Self::InnerTransactionResultResult(ref v) => v.as_ref(),
            Self::InnerTransactionResultExt(ref v) => v.as_ref(),
            Self::InnerTransactionResultPair(ref v) => v.as_ref(),
            Self::TransactionResult(ref v) => v.as_ref(),
            Self::TransactionResultResult(ref v) => v.as_ref(),
            Self::TransactionResultExt(ref v) => v.as_ref(),
            Self::Hash(ref v) => v.as_ref(),
            Self::Uint256(ref v) => v.as_ref(),
            Self::Uint32(ref v) => v.as_ref(),
            Self::Int32(ref v) => v.as_ref(),
            Self::Uint64(ref v) => v.as_ref(),
            Self::Int64(ref v) => v.as_ref(),
            Self::TimePoint(ref v) => v.as_ref(),
            Self::Duration(ref v) => v.as_ref(),
            Self::ExtensionPoint(ref v) => v.as_ref(),
            Self::CryptoKeyType(ref v) => v.as_ref(),
            Self::PublicKeyType(ref v) => v.as_ref(),
            Self::SignerKeyType(ref v) => v.as_ref(),
            Self::PublicKey(ref v) => v.as_ref(),
            Self::SignerKey(ref v) => v.as_ref(),
            Self::SignerKeyEd25519SignedPayload(ref v) => v.as_ref(),
            Self::Signature(ref v) => v.as_ref(),
            Self::SignatureHint(ref v) => v.as_ref(),
            Self::NodeId(ref v) => v.as_ref(),
            Self::AccountId(ref v) => v.as_ref(),
            Self::Curve25519Secret(ref v) => v.as_ref(),
            Self::Curve25519Public(ref v) => v.as_ref(),
            Self::HmacSha256Key(ref v) => v.as_ref(),
            Self::HmacSha256Mac(ref v) => v.as_ref(),
        }
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn name(&self) -> &'static str {
        match self {
            Self::Value(_) => "Value",
            Self::ScpBallot(_) => "ScpBallot",
            Self::ScpStatementType(_) => "ScpStatementType",
            Self::ScpNomination(_) => "ScpNomination",
            Self::ScpStatement(_) => "ScpStatement",
            Self::ScpStatementPledges(_) => "ScpStatementPledges",
            Self::ScpStatementPrepare(_) => "ScpStatementPrepare",
            Self::ScpStatementConfirm(_) => "ScpStatementConfirm",
            Self::ScpStatementExternalize(_) => "ScpStatementExternalize",
            Self::ScpEnvelope(_) => "ScpEnvelope",
            Self::ScpQuorumSet(_) => "ScpQuorumSet",
            Self::ConfigSettingContractExecutionLanesV0(_) => {
                "ConfigSettingContractExecutionLanesV0"
            }
            Self::ConfigSettingContractComputeV0(_) => "ConfigSettingContractComputeV0",
            Self::ConfigSettingContractLedgerCostV0(_) => "ConfigSettingContractLedgerCostV0",
            Self::ConfigSettingContractHistoricalDataV0(_) => {
                "ConfigSettingContractHistoricalDataV0"
            }
            Self::ConfigSettingContractEventsV0(_) => "ConfigSettingContractEventsV0",
            Self::ConfigSettingContractBandwidthV0(_) => "ConfigSettingContractBandwidthV0",
            Self::ContractCostType(_) => "ContractCostType",
            Self::ContractCostParamEntry(_) => "ContractCostParamEntry",
            Self::StateArchivalSettings(_) => "StateArchivalSettings",
            Self::EvictionIterator(_) => "EvictionIterator",
            Self::ContractCostParams(_) => "ContractCostParams",
            Self::ConfigSettingId(_) => "ConfigSettingId",
            Self::ConfigSettingEntry(_) => "ConfigSettingEntry",
            Self::ScEnvMetaKind(_) => "ScEnvMetaKind",
            Self::ScEnvMetaEntry(_) => "ScEnvMetaEntry",
            Self::ScMetaV0(_) => "ScMetaV0",
            Self::ScMetaKind(_) => "ScMetaKind",
            Self::ScMetaEntry(_) => "ScMetaEntry",
            Self::ScSpecType(_) => "ScSpecType",
            Self::ScSpecTypeOption(_) => "ScSpecTypeOption",
            Self::ScSpecTypeResult(_) => "ScSpecTypeResult",
            Self::ScSpecTypeVec(_) => "ScSpecTypeVec",
            Self::ScSpecTypeMap(_) => "ScSpecTypeMap",
            Self::ScSpecTypeTuple(_) => "ScSpecTypeTuple",
            Self::ScSpecTypeBytesN(_) => "ScSpecTypeBytesN",
            Self::ScSpecTypeUdt(_) => "ScSpecTypeUdt",
            Self::ScSpecTypeDef(_) => "ScSpecTypeDef",
            Self::ScSpecUdtStructFieldV0(_) => "ScSpecUdtStructFieldV0",
            Self::ScSpecUdtStructV0(_) => "ScSpecUdtStructV0",
            Self::ScSpecUdtUnionCaseVoidV0(_) => "ScSpecUdtUnionCaseVoidV0",
            Self::ScSpecUdtUnionCaseTupleV0(_) => "ScSpecUdtUnionCaseTupleV0",
            Self::ScSpecUdtUnionCaseV0Kind(_) => "ScSpecUdtUnionCaseV0Kind",
            Self::ScSpecUdtUnionCaseV0(_) => "ScSpecUdtUnionCaseV0",
            Self::ScSpecUdtUnionV0(_) => "ScSpecUdtUnionV0",
            Self::ScSpecUdtEnumCaseV0(_) => "ScSpecUdtEnumCaseV0",
            Self::ScSpecUdtEnumV0(_) => "ScSpecUdtEnumV0",
            Self::ScSpecUdtErrorEnumCaseV0(_) => "ScSpecUdtErrorEnumCaseV0",
            Self::ScSpecUdtErrorEnumV0(_) => "ScSpecUdtErrorEnumV0",
            Self::ScSpecFunctionInputV0(_) => "ScSpecFunctionInputV0",
            Self::ScSpecFunctionV0(_) => "ScSpecFunctionV0",
            Self::ScSpecEntryKind(_) => "ScSpecEntryKind",
            Self::ScSpecEntry(_) => "ScSpecEntry",
            Self::ScValType(_) => "ScValType",
            Self::ScErrorType(_) => "ScErrorType",
            Self::ScErrorCode(_) => "ScErrorCode",
            Self::ScError(_) => "ScError",
            Self::UInt128Parts(_) => "UInt128Parts",
            Self::Int128Parts(_) => "Int128Parts",
            Self::UInt256Parts(_) => "UInt256Parts",
            Self::Int256Parts(_) => "Int256Parts",
            Self::ContractExecutableType(_) => "ContractExecutableType",
            Self::ContractExecutable(_) => "ContractExecutable",
            Self::ScAddressType(_) => "ScAddressType",
            Self::ScAddress(_) => "ScAddress",
            Self::ScVec(_) => "ScVec",
            Self::ScMap(_) => "ScMap",
            Self::ScBytes(_) => "ScBytes",
            Self::ScString(_) => "ScString",
            Self::ScSymbol(_) => "ScSymbol",
            Self::ScNonceKey(_) => "ScNonceKey",
            Self::ScContractInstance(_) => "ScContractInstance",
            Self::ScVal(_) => "ScVal",
            Self::ScMapEntry(_) => "ScMapEntry",
            Self::StoredTransactionSet(_) => "StoredTransactionSet",
            Self::StoredDebugTransactionSet(_) => "StoredDebugTransactionSet",
            Self::PersistedScpStateV0(_) => "PersistedScpStateV0",
            Self::PersistedScpStateV1(_) => "PersistedScpStateV1",
            Self::PersistedScpState(_) => "PersistedScpState",
            Self::Thresholds(_) => "Thresholds",
            Self::String32(_) => "String32",
            Self::String64(_) => "String64",
            Self::SequenceNumber(_) => "SequenceNumber",
            Self::DataValue(_) => "DataValue",
            Self::PoolId(_) => "PoolId",
            Self::AssetCode4(_) => "AssetCode4",
            Self::AssetCode12(_) => "AssetCode12",
            Self::AssetType(_) => "AssetType",
            Self::AssetCode(_) => "AssetCode",
            Self::AlphaNum4(_) => "AlphaNum4",
            Self::AlphaNum12(_) => "AlphaNum12",
            Self::Asset(_) => "Asset",
            Self::Price(_) => "Price",
            Self::Liabilities(_) => "Liabilities",
            Self::ThresholdIndexes(_) => "ThresholdIndexes",
            Self::LedgerEntryType(_) => "LedgerEntryType",
            Self::Signer(_) => "Signer",
            Self::AccountFlags(_) => "AccountFlags",
            Self::SponsorshipDescriptor(_) => "SponsorshipDescriptor",
            Self::AccountEntryExtensionV3(_) => "AccountEntryExtensionV3",
            Self::AccountEntryExtensionV2(_) => "AccountEntryExtensionV2",
            Self::AccountEntryExtensionV2Ext(_) => "AccountEntryExtensionV2Ext",
            Self::AccountEntryExtensionV1(_) => "AccountEntryExtensionV1",
            Self::AccountEntryExtensionV1Ext(_) => "AccountEntryExtensionV1Ext",
            Self::AccountEntry(_) => "AccountEntry",
            Self::AccountEntryExt(_) => "AccountEntryExt",
            Self::TrustLineFlags(_) => "TrustLineFlags",
            Self::LiquidityPoolType(_) => "LiquidityPoolType",
            Self::TrustLineAsset(_) => "TrustLineAsset",
            Self::TrustLineEntryExtensionV2(_) => "TrustLineEntryExtensionV2",
            Self::TrustLineEntryExtensionV2Ext(_) => "TrustLineEntryExtensionV2Ext",
            Self::TrustLineEntry(_) => "TrustLineEntry",
            Self::TrustLineEntryExt(_) => "TrustLineEntryExt",
            Self::TrustLineEntryV1(_) => "TrustLineEntryV1",
            Self::TrustLineEntryV1Ext(_) => "TrustLineEntryV1Ext",
            Self::OfferEntryFlags(_) => "OfferEntryFlags",
            Self::OfferEntry(_) => "OfferEntry",
            Self::OfferEntryExt(_) => "OfferEntryExt",
            Self::DataEntry(_) => "DataEntry",
            Self::DataEntryExt(_) => "DataEntryExt",
            Self::ClaimPredicateType(_) => "ClaimPredicateType",
            Self::ClaimPredicate(_) => "ClaimPredicate",
            Self::ClaimantType(_) => "ClaimantType",
            Self::Claimant(_) => "Claimant",
            Self::ClaimantV0(_) => "ClaimantV0",
            Self::ClaimableBalanceIdType(_) => "ClaimableBalanceIdType",
            Self::ClaimableBalanceId(_) => "ClaimableBalanceId",
            Self::ClaimableBalanceFlags(_) => "ClaimableBalanceFlags",
            Self::ClaimableBalanceEntryExtensionV1(_) => "ClaimableBalanceEntryExtensionV1",
            Self::ClaimableBalanceEntryExtensionV1Ext(_) => "ClaimableBalanceEntryExtensionV1Ext",
            Self::ClaimableBalanceEntry(_) => "ClaimableBalanceEntry",
            Self::ClaimableBalanceEntryExt(_) => "ClaimableBalanceEntryExt",
            Self::LiquidityPoolConstantProductParameters(_) => {
                "LiquidityPoolConstantProductParameters"
            }
            Self::LiquidityPoolEntry(_) => "LiquidityPoolEntry",
            Self::LiquidityPoolEntryBody(_) => "LiquidityPoolEntryBody",
            Self::LiquidityPoolEntryConstantProduct(_) => "LiquidityPoolEntryConstantProduct",
            Self::ContractDataDurability(_) => "ContractDataDurability",
            Self::ContractDataEntry(_) => "ContractDataEntry",
            Self::ContractCodeCostInputs(_) => "ContractCodeCostInputs",
            Self::ContractCodeEntry(_) => "ContractCodeEntry",
            Self::ContractCodeEntryExt(_) => "ContractCodeEntryExt",
            Self::ContractCodeEntryV1(_) => "ContractCodeEntryV1",
            Self::TtlEntry(_) => "TtlEntry",
            Self::LedgerEntryExtensionV1(_) => "LedgerEntryExtensionV1",
            Self::LedgerEntryExtensionV1Ext(_) => "LedgerEntryExtensionV1Ext",
            Self::LedgerEntry(_) => "LedgerEntry",
            Self::LedgerEntryData(_) => "LedgerEntryData",
            Self::LedgerEntryExt(_) => "LedgerEntryExt",
            Self::LedgerKey(_) => "LedgerKey",
            Self::LedgerKeyAccount(_) => "LedgerKeyAccount",
            Self::LedgerKeyTrustLine(_) => "LedgerKeyTrustLine",
            Self::LedgerKeyOffer(_) => "LedgerKeyOffer",
            Self::LedgerKeyData(_) => "LedgerKeyData",
            Self::LedgerKeyClaimableBalance(_) => "LedgerKeyClaimableBalance",
            Self::LedgerKeyLiquidityPool(_) => "LedgerKeyLiquidityPool",
            Self::LedgerKeyContractData(_) => "LedgerKeyContractData",
            Self::LedgerKeyContractCode(_) => "LedgerKeyContractCode",
            Self::LedgerKeyConfigSetting(_) => "LedgerKeyConfigSetting",
            Self::LedgerKeyTtl(_) => "LedgerKeyTtl",
            Self::EnvelopeType(_) => "EnvelopeType",
            Self::UpgradeType(_) => "UpgradeType",
            Self::StellarValueType(_) => "StellarValueType",
            Self::LedgerCloseValueSignature(_) => "LedgerCloseValueSignature",
            Self::StellarValue(_) => "StellarValue",
            Self::StellarValueExt(_) => "StellarValueExt",
            Self::LedgerHeaderFlags(_) => "LedgerHeaderFlags",
            Self::LedgerHeaderExtensionV1(_) => "LedgerHeaderExtensionV1",
            Self::LedgerHeaderExtensionV1Ext(_) => "LedgerHeaderExtensionV1Ext",
            Self::LedgerHeader(_) => "LedgerHeader",
            Self::LedgerHeaderExt(_) => "LedgerHeaderExt",
            Self::LedgerUpgradeType(_) => "LedgerUpgradeType",
            Self::ConfigUpgradeSetKey(_) => "ConfigUpgradeSetKey",
            Self::LedgerUpgrade(_) => "LedgerUpgrade",
            Self::ConfigUpgradeSet(_) => "ConfigUpgradeSet",
            Self::BucketEntryType(_) => "BucketEntryType",
            Self::BucketMetadata(_) => "BucketMetadata",
            Self::BucketMetadataExt(_) => "BucketMetadataExt",
            Self::BucketEntry(_) => "BucketEntry",
            Self::TxSetComponentType(_) => "TxSetComponentType",
            Self::TxSetComponent(_) => "TxSetComponent",
            Self::TxSetComponentTxsMaybeDiscountedFee(_) => "TxSetComponentTxsMaybeDiscountedFee",
            Self::TransactionPhase(_) => "TransactionPhase",
            Self::TransactionSet(_) => "TransactionSet",
            Self::TransactionSetV1(_) => "TransactionSetV1",
            Self::GeneralizedTransactionSet(_) => "GeneralizedTransactionSet",
            Self::TransactionResultPair(_) => "TransactionResultPair",
            Self::TransactionResultSet(_) => "TransactionResultSet",
            Self::TransactionHistoryEntry(_) => "TransactionHistoryEntry",
            Self::TransactionHistoryEntryExt(_) => "TransactionHistoryEntryExt",
            Self::TransactionHistoryResultEntry(_) => "TransactionHistoryResultEntry",
            Self::TransactionHistoryResultEntryExt(_) => "TransactionHistoryResultEntryExt",
            Self::LedgerHeaderHistoryEntry(_) => "LedgerHeaderHistoryEntry",
            Self::LedgerHeaderHistoryEntryExt(_) => "LedgerHeaderHistoryEntryExt",
            Self::LedgerScpMessages(_) => "LedgerScpMessages",
            Self::ScpHistoryEntryV0(_) => "ScpHistoryEntryV0",
            Self::ScpHistoryEntry(_) => "ScpHistoryEntry",
            Self::LedgerEntryChangeType(_) => "LedgerEntryChangeType",
            Self::LedgerEntryChange(_) => "LedgerEntryChange",
            Self::LedgerEntryChanges(_) => "LedgerEntryChanges",
            Self::OperationMeta(_) => "OperationMeta",
            Self::TransactionMetaV1(_) => "TransactionMetaV1",
            Self::TransactionMetaV2(_) => "TransactionMetaV2",
            Self::ContractEventType(_) => "ContractEventType",
            Self::ContractEvent(_) => "ContractEvent",
            Self::ContractEventBody(_) => "ContractEventBody",
            Self::ContractEventV0(_) => "ContractEventV0",
            Self::DiagnosticEvent(_) => "DiagnosticEvent",
            Self::SorobanTransactionMetaExtV1(_) => "SorobanTransactionMetaExtV1",
            Self::SorobanTransactionMetaExt(_) => "SorobanTransactionMetaExt",
            Self::SorobanTransactionMeta(_) => "SorobanTransactionMeta",
            Self::TransactionMetaV3(_) => "TransactionMetaV3",
            Self::InvokeHostFunctionSuccessPreImage(_) => "InvokeHostFunctionSuccessPreImage",
            Self::TransactionMeta(_) => "TransactionMeta",
            Self::TransactionResultMeta(_) => "TransactionResultMeta",
            Self::UpgradeEntryMeta(_) => "UpgradeEntryMeta",
            Self::LedgerCloseMetaV0(_) => "LedgerCloseMetaV0",
            Self::LedgerCloseMetaExtV1(_) => "LedgerCloseMetaExtV1",
            Self::LedgerCloseMetaExt(_) => "LedgerCloseMetaExt",
            Self::LedgerCloseMetaV1(_) => "LedgerCloseMetaV1",
            Self::LedgerCloseMeta(_) => "LedgerCloseMeta",
            Self::ErrorCode(_) => "ErrorCode",
            Self::SError(_) => "SError",
            Self::SendMore(_) => "SendMore",
            Self::SendMoreExtended(_) => "SendMoreExtended",
            Self::AuthCert(_) => "AuthCert",
            Self::Hello(_) => "Hello",
            Self::Auth(_) => "Auth",
            Self::IpAddrType(_) => "IpAddrType",
            Self::PeerAddress(_) => "PeerAddress",
            Self::PeerAddressIp(_) => "PeerAddressIp",
            Self::MessageType(_) => "MessageType",
            Self::DontHave(_) => "DontHave",
            Self::SurveyMessageCommandType(_) => "SurveyMessageCommandType",
            Self::SurveyMessageResponseType(_) => "SurveyMessageResponseType",
            Self::SurveyRequestMessage(_) => "SurveyRequestMessage",
            Self::SignedSurveyRequestMessage(_) => "SignedSurveyRequestMessage",
            Self::EncryptedBody(_) => "EncryptedBody",
            Self::SurveyResponseMessage(_) => "SurveyResponseMessage",
            Self::SignedSurveyResponseMessage(_) => "SignedSurveyResponseMessage",
            Self::PeerStats(_) => "PeerStats",
            Self::PeerStatList(_) => "PeerStatList",
            Self::TopologyResponseBodyV0(_) => "TopologyResponseBodyV0",
            Self::TopologyResponseBodyV1(_) => "TopologyResponseBodyV1",
            Self::SurveyResponseBody(_) => "SurveyResponseBody",
            Self::TxAdvertVector(_) => "TxAdvertVector",
            Self::FloodAdvert(_) => "FloodAdvert",
            Self::TxDemandVector(_) => "TxDemandVector",
            Self::FloodDemand(_) => "FloodDemand",
            Self::StellarMessage(_) => "StellarMessage",
            Self::AuthenticatedMessage(_) => "AuthenticatedMessage",
            Self::AuthenticatedMessageV0(_) => "AuthenticatedMessageV0",
            Self::LiquidityPoolParameters(_) => "LiquidityPoolParameters",
            Self::MuxedAccount(_) => "MuxedAccount",
            Self::MuxedAccountMed25519(_) => "MuxedAccountMed25519",
            Self::DecoratedSignature(_) => "DecoratedSignature",
            Self::OperationType(_) => "OperationType",
            Self::CreateAccountOp(_) => "CreateAccountOp",
            Self::PaymentOp(_) => "PaymentOp",
            Self::PathPaymentStrictReceiveOp(_) => "PathPaymentStrictReceiveOp",
            Self::PathPaymentStrictSendOp(_) => "PathPaymentStrictSendOp",
            Self::ManageSellOfferOp(_) => "ManageSellOfferOp",
            Self::ManageBuyOfferOp(_) => "ManageBuyOfferOp",
            Self::CreatePassiveSellOfferOp(_) => "CreatePassiveSellOfferOp",
            Self::SetOptionsOp(_) => "SetOptionsOp",
            Self::ChangeTrustAsset(_) => "ChangeTrustAsset",
            Self::ChangeTrustOp(_) => "ChangeTrustOp",
            Self::AllowTrustOp(_) => "AllowTrustOp",
            Self::ManageDataOp(_) => "ManageDataOp",
            Self::BumpSequenceOp(_) => "BumpSequenceOp",
            Self::CreateClaimableBalanceOp(_) => "CreateClaimableBalanceOp",
            Self::ClaimClaimableBalanceOp(_) => "ClaimClaimableBalanceOp",
            Self::BeginSponsoringFutureReservesOp(_) => "BeginSponsoringFutureReservesOp",
            Self::RevokeSponsorshipType(_) => "RevokeSponsorshipType",
            Self::RevokeSponsorshipOp(_) => "RevokeSponsorshipOp",
            Self::RevokeSponsorshipOpSigner(_) => "RevokeSponsorshipOpSigner",
            Self::ClawbackOp(_) => "ClawbackOp",
            Self::ClawbackClaimableBalanceOp(_) => "ClawbackClaimableBalanceOp",
            Self::SetTrustLineFlagsOp(_) => "SetTrustLineFlagsOp",
            Self::LiquidityPoolDepositOp(_) => "LiquidityPoolDepositOp",
            Self::LiquidityPoolWithdrawOp(_) => "LiquidityPoolWithdrawOp",
            Self::HostFunctionType(_) => "HostFunctionType",
            Self::ContractIdPreimageType(_) => "ContractIdPreimageType",
            Self::ContractIdPreimage(_) => "ContractIdPreimage",
            Self::ContractIdPreimageFromAddress(_) => "ContractIdPreimageFromAddress",
            Self::CreateContractArgs(_) => "CreateContractArgs",
            Self::InvokeContractArgs(_) => "InvokeContractArgs",
            Self::HostFunction(_) => "HostFunction",
            Self::SorobanAuthorizedFunctionType(_) => "SorobanAuthorizedFunctionType",
            Self::SorobanAuthorizedFunction(_) => "SorobanAuthorizedFunction",
            Self::SorobanAuthorizedInvocation(_) => "SorobanAuthorizedInvocation",
            Self::SorobanAddressCredentials(_) => "SorobanAddressCredentials",
            Self::SorobanCredentialsType(_) => "SorobanCredentialsType",
            Self::SorobanCredentials(_) => "SorobanCredentials",
            Self::SorobanAuthorizationEntry(_) => "SorobanAuthorizationEntry",
            Self::InvokeHostFunctionOp(_) => "InvokeHostFunctionOp",
            Self::ExtendFootprintTtlOp(_) => "ExtendFootprintTtlOp",
            Self::RestoreFootprintOp(_) => "RestoreFootprintOp",
            Self::Operation(_) => "Operation",
            Self::OperationBody(_) => "OperationBody",
            Self::HashIdPreimage(_) => "HashIdPreimage",
            Self::HashIdPreimageOperationId(_) => "HashIdPreimageOperationId",
            Self::HashIdPreimageRevokeId(_) => "HashIdPreimageRevokeId",
            Self::HashIdPreimageContractId(_) => "HashIdPreimageContractId",
            Self::HashIdPreimageSorobanAuthorization(_) => "HashIdPreimageSorobanAuthorization",
            Self::MemoType(_) => "MemoType",
            Self::Memo(_) => "Memo",
            Self::TimeBounds(_) => "TimeBounds",
            Self::LedgerBounds(_) => "LedgerBounds",
            Self::PreconditionsV2(_) => "PreconditionsV2",
            Self::PreconditionType(_) => "PreconditionType",
            Self::Preconditions(_) => "Preconditions",
            Self::LedgerFootprint(_) => "LedgerFootprint",
            Self::SorobanResources(_) => "SorobanResources",
            Self::SorobanTransactionData(_) => "SorobanTransactionData",
            Self::TransactionV0(_) => "TransactionV0",
            Self::TransactionV0Ext(_) => "TransactionV0Ext",
            Self::TransactionV0Envelope(_) => "TransactionV0Envelope",
            Self::Transaction(_) => "Transaction",
            Self::TransactionExt(_) => "TransactionExt",
            Self::TransactionV1Envelope(_) => "TransactionV1Envelope",
            Self::FeeBumpTransaction(_) => "FeeBumpTransaction",
            Self::FeeBumpTransactionInnerTx(_) => "FeeBumpTransactionInnerTx",
            Self::FeeBumpTransactionExt(_) => "FeeBumpTransactionExt",
            Self::FeeBumpTransactionEnvelope(_) => "FeeBumpTransactionEnvelope",
            Self::TransactionEnvelope(_) => "TransactionEnvelope",
            Self::TransactionSignaturePayload(_) => "TransactionSignaturePayload",
            Self::TransactionSignaturePayloadTaggedTransaction(_) => {
                "TransactionSignaturePayloadTaggedTransaction"
            }
            Self::ClaimAtomType(_) => "ClaimAtomType",
            Self::ClaimOfferAtomV0(_) => "ClaimOfferAtomV0",
            Self::ClaimOfferAtom(_) => "ClaimOfferAtom",
            Self::ClaimLiquidityAtom(_) => "ClaimLiquidityAtom",
            Self::ClaimAtom(_) => "ClaimAtom",
            Self::CreateAccountResultCode(_) => "CreateAccountResultCode",
            Self::CreateAccountResult(_) => "CreateAccountResult",
            Self::PaymentResultCode(_) => "PaymentResultCode",
            Self::PaymentResult(_) => "PaymentResult",
            Self::PathPaymentStrictReceiveResultCode(_) => "PathPaymentStrictReceiveResultCode",
            Self::SimplePaymentResult(_) => "SimplePaymentResult",
            Self::PathPaymentStrictReceiveResult(_) => "PathPaymentStrictReceiveResult",
            Self::PathPaymentStrictReceiveResultSuccess(_) => {
                "PathPaymentStrictReceiveResultSuccess"
            }
            Self::PathPaymentStrictSendResultCode(_) => "PathPaymentStrictSendResultCode",
            Self::PathPaymentStrictSendResult(_) => "PathPaymentStrictSendResult",
            Self::PathPaymentStrictSendResultSuccess(_) => "PathPaymentStrictSendResultSuccess",
            Self::ManageSellOfferResultCode(_) => "ManageSellOfferResultCode",
            Self::ManageOfferEffect(_) => "ManageOfferEffect",
            Self::ManageOfferSuccessResult(_) => "ManageOfferSuccessResult",
            Self::ManageOfferSuccessResultOffer(_) => "ManageOfferSuccessResultOffer",
            Self::ManageSellOfferResult(_) => "ManageSellOfferResult",
            Self::ManageBuyOfferResultCode(_) => "ManageBuyOfferResultCode",
            Self::ManageBuyOfferResult(_) => "ManageBuyOfferResult",
            Self::SetOptionsResultCode(_) => "SetOptionsResultCode",
            Self::SetOptionsResult(_) => "SetOptionsResult",
            Self::ChangeTrustResultCode(_) => "ChangeTrustResultCode",
            Self::ChangeTrustResult(_) => "ChangeTrustResult",
            Self::AllowTrustResultCode(_) => "AllowTrustResultCode",
            Self::AllowTrustResult(_) => "AllowTrustResult",
            Self::AccountMergeResultCode(_) => "AccountMergeResultCode",
            Self::AccountMergeResult(_) => "AccountMergeResult",
            Self::InflationResultCode(_) => "InflationResultCode",
            Self::InflationPayout(_) => "InflationPayout",
            Self::InflationResult(_) => "InflationResult",
            Self::ManageDataResultCode(_) => "ManageDataResultCode",
            Self::ManageDataResult(_) => "ManageDataResult",
            Self::BumpSequenceResultCode(_) => "BumpSequenceResultCode",
            Self::BumpSequenceResult(_) => "BumpSequenceResult",
            Self::CreateClaimableBalanceResultCode(_) => "CreateClaimableBalanceResultCode",
            Self::CreateClaimableBalanceResult(_) => "CreateClaimableBalanceResult",
            Self::ClaimClaimableBalanceResultCode(_) => "ClaimClaimableBalanceResultCode",
            Self::ClaimClaimableBalanceResult(_) => "ClaimClaimableBalanceResult",
            Self::BeginSponsoringFutureReservesResultCode(_) => {
                "BeginSponsoringFutureReservesResultCode"
            }
            Self::BeginSponsoringFutureReservesResult(_) => "BeginSponsoringFutureReservesResult",
            Self::EndSponsoringFutureReservesResultCode(_) => {
                "EndSponsoringFutureReservesResultCode"
            }
            Self::EndSponsoringFutureReservesResult(_) => "EndSponsoringFutureReservesResult",
            Self::RevokeSponsorshipResultCode(_) => "RevokeSponsorshipResultCode",
            Self::RevokeSponsorshipResult(_) => "RevokeSponsorshipResult",
            Self::ClawbackResultCode(_) => "ClawbackResultCode",
            Self::ClawbackResult(_) => "ClawbackResult",
            Self::ClawbackClaimableBalanceResultCode(_) => "ClawbackClaimableBalanceResultCode",
            Self::ClawbackClaimableBalanceResult(_) => "ClawbackClaimableBalanceResult",
            Self::SetTrustLineFlagsResultCode(_) => "SetTrustLineFlagsResultCode",
            Self::SetTrustLineFlagsResult(_) => "SetTrustLineFlagsResult",
            Self::LiquidityPoolDepositResultCode(_) => "LiquidityPoolDepositResultCode",
            Self::LiquidityPoolDepositResult(_) => "LiquidityPoolDepositResult",
            Self::LiquidityPoolWithdrawResultCode(_) => "LiquidityPoolWithdrawResultCode",
            Self::LiquidityPoolWithdrawResult(_) => "LiquidityPoolWithdrawResult",
            Self::InvokeHostFunctionResultCode(_) => "InvokeHostFunctionResultCode",
            Self::InvokeHostFunctionResult(_) => "InvokeHostFunctionResult",
            Self::ExtendFootprintTtlResultCode(_) => "ExtendFootprintTtlResultCode",
            Self::ExtendFootprintTtlResult(_) => "ExtendFootprintTtlResult",
            Self::RestoreFootprintResultCode(_) => "RestoreFootprintResultCode",
            Self::RestoreFootprintResult(_) => "RestoreFootprintResult",
            Self::OperationResultCode(_) => "OperationResultCode",
            Self::OperationResult(_) => "OperationResult",
            Self::OperationResultTr(_) => "OperationResultTr",
            Self::TransactionResultCode(_) => "TransactionResultCode",
            Self::InnerTransactionResult(_) => "InnerTransactionResult",
            Self::InnerTransactionResultResult(_) => "InnerTransactionResultResult",
            Self::InnerTransactionResultExt(_) => "InnerTransactionResultExt",
            Self::InnerTransactionResultPair(_) => "InnerTransactionResultPair",
            Self::TransactionResult(_) => "TransactionResult",
            Self::TransactionResultResult(_) => "TransactionResultResult",
            Self::TransactionResultExt(_) => "TransactionResultExt",
            Self::Hash(_) => "Hash",
            Self::Uint256(_) => "Uint256",
            Self::Uint32(_) => "Uint32",
            Self::Int32(_) => "Int32",
            Self::Uint64(_) => "Uint64",
            Self::Int64(_) => "Int64",
            Self::TimePoint(_) => "TimePoint",
            Self::Duration(_) => "Duration",
            Self::ExtensionPoint(_) => "ExtensionPoint",
            Self::CryptoKeyType(_) => "CryptoKeyType",
            Self::PublicKeyType(_) => "PublicKeyType",
            Self::SignerKeyType(_) => "SignerKeyType",
            Self::PublicKey(_) => "PublicKey",
            Self::SignerKey(_) => "SignerKey",
            Self::SignerKeyEd25519SignedPayload(_) => "SignerKeyEd25519SignedPayload",
            Self::Signature(_) => "Signature",
            Self::SignatureHint(_) => "SignatureHint",
            Self::NodeId(_) => "NodeId",
            Self::AccountId(_) => "AccountId",
            Self::Curve25519Secret(_) => "Curve25519Secret",
            Self::Curve25519Public(_) => "Curve25519Public",
            Self::HmacSha256Key(_) => "HmacSha256Key",
            Self::HmacSha256Mac(_) => "HmacSha256Mac",
        }
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn variants() -> [TypeVariant; 425] {
        Self::VARIANTS
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn variant(&self) -> TypeVariant {
        match self {
            Self::Value(_) => TypeVariant::Value,
            Self::ScpBallot(_) => TypeVariant::ScpBallot,
            Self::ScpStatementType(_) => TypeVariant::ScpStatementType,
            Self::ScpNomination(_) => TypeVariant::ScpNomination,
            Self::ScpStatement(_) => TypeVariant::ScpStatement,
            Self::ScpStatementPledges(_) => TypeVariant::ScpStatementPledges,
            Self::ScpStatementPrepare(_) => TypeVariant::ScpStatementPrepare,
            Self::ScpStatementConfirm(_) => TypeVariant::ScpStatementConfirm,
            Self::ScpStatementExternalize(_) => TypeVariant::ScpStatementExternalize,
            Self::ScpEnvelope(_) => TypeVariant::ScpEnvelope,
            Self::ScpQuorumSet(_) => TypeVariant::ScpQuorumSet,
            Self::ConfigSettingContractExecutionLanesV0(_) => {
                TypeVariant::ConfigSettingContractExecutionLanesV0
            }
            Self::ConfigSettingContractComputeV0(_) => TypeVariant::ConfigSettingContractComputeV0,
            Self::ConfigSettingContractLedgerCostV0(_) => {
                TypeVariant::ConfigSettingContractLedgerCostV0
            }
            Self::ConfigSettingContractHistoricalDataV0(_) => {
                TypeVariant::ConfigSettingContractHistoricalDataV0
            }
            Self::ConfigSettingContractEventsV0(_) => TypeVariant::ConfigSettingContractEventsV0,
            Self::ConfigSettingContractBandwidthV0(_) => {
                TypeVariant::ConfigSettingContractBandwidthV0
            }
            Self::ContractCostType(_) => TypeVariant::ContractCostType,
            Self::ContractCostParamEntry(_) => TypeVariant::ContractCostParamEntry,
            Self::StateArchivalSettings(_) => TypeVariant::StateArchivalSettings,
            Self::EvictionIterator(_) => TypeVariant::EvictionIterator,
            Self::ContractCostParams(_) => TypeVariant::ContractCostParams,
            Self::ConfigSettingId(_) => TypeVariant::ConfigSettingId,
            Self::ConfigSettingEntry(_) => TypeVariant::ConfigSettingEntry,
            Self::ScEnvMetaKind(_) => TypeVariant::ScEnvMetaKind,
            Self::ScEnvMetaEntry(_) => TypeVariant::ScEnvMetaEntry,
            Self::ScMetaV0(_) => TypeVariant::ScMetaV0,
            Self::ScMetaKind(_) => TypeVariant::ScMetaKind,
            Self::ScMetaEntry(_) => TypeVariant::ScMetaEntry,
            Self::ScSpecType(_) => TypeVariant::ScSpecType,
            Self::ScSpecTypeOption(_) => TypeVariant::ScSpecTypeOption,
            Self::ScSpecTypeResult(_) => TypeVariant::ScSpecTypeResult,
            Self::ScSpecTypeVec(_) => TypeVariant::ScSpecTypeVec,
            Self::ScSpecTypeMap(_) => TypeVariant::ScSpecTypeMap,
            Self::ScSpecTypeTuple(_) => TypeVariant::ScSpecTypeTuple,
            Self::ScSpecTypeBytesN(_) => TypeVariant::ScSpecTypeBytesN,
            Self::ScSpecTypeUdt(_) => TypeVariant::ScSpecTypeUdt,
            Self::ScSpecTypeDef(_) => TypeVariant::ScSpecTypeDef,
            Self::ScSpecUdtStructFieldV0(_) => TypeVariant::ScSpecUdtStructFieldV0,
            Self::ScSpecUdtStructV0(_) => TypeVariant::ScSpecUdtStructV0,
            Self::ScSpecUdtUnionCaseVoidV0(_) => TypeVariant::ScSpecUdtUnionCaseVoidV0,
            Self::ScSpecUdtUnionCaseTupleV0(_) => TypeVariant::ScSpecUdtUnionCaseTupleV0,
            Self::ScSpecUdtUnionCaseV0Kind(_) => TypeVariant::ScSpecUdtUnionCaseV0Kind,
            Self::ScSpecUdtUnionCaseV0(_) => TypeVariant::ScSpecUdtUnionCaseV0,
            Self::ScSpecUdtUnionV0(_) => TypeVariant::ScSpecUdtUnionV0,
            Self::ScSpecUdtEnumCaseV0(_) => TypeVariant::ScSpecUdtEnumCaseV0,
            Self::ScSpecUdtEnumV0(_) => TypeVariant::ScSpecUdtEnumV0,
            Self::ScSpecUdtErrorEnumCaseV0(_) => TypeVariant::ScSpecUdtErrorEnumCaseV0,
            Self::ScSpecUdtErrorEnumV0(_) => TypeVariant::ScSpecUdtErrorEnumV0,
            Self::ScSpecFunctionInputV0(_) => TypeVariant::ScSpecFunctionInputV0,
            Self::ScSpecFunctionV0(_) => TypeVariant::ScSpecFunctionV0,
            Self::ScSpecEntryKind(_) => TypeVariant::ScSpecEntryKind,
            Self::ScSpecEntry(_) => TypeVariant::ScSpecEntry,
            Self::ScValType(_) => TypeVariant::ScValType,
            Self::ScErrorType(_) => TypeVariant::ScErrorType,
            Self::ScErrorCode(_) => TypeVariant::ScErrorCode,
            Self::ScError(_) => TypeVariant::ScError,
            Self::UInt128Parts(_) => TypeVariant::UInt128Parts,
            Self::Int128Parts(_) => TypeVariant::Int128Parts,
            Self::UInt256Parts(_) => TypeVariant::UInt256Parts,
            Self::Int256Parts(_) => TypeVariant::Int256Parts,
            Self::ContractExecutableType(_) => TypeVariant::ContractExecutableType,
            Self::ContractExecutable(_) => TypeVariant::ContractExecutable,
            Self::ScAddressType(_) => TypeVariant::ScAddressType,
            Self::ScAddress(_) => TypeVariant::ScAddress,
            Self::ScVec(_) => TypeVariant::ScVec,
            Self::ScMap(_) => TypeVariant::ScMap,
            Self::ScBytes(_) => TypeVariant::ScBytes,
            Self::ScString(_) => TypeVariant::ScString,
            Self::ScSymbol(_) => TypeVariant::ScSymbol,
            Self::ScNonceKey(_) => TypeVariant::ScNonceKey,
            Self::ScContractInstance(_) => TypeVariant::ScContractInstance,
            Self::ScVal(_) => TypeVariant::ScVal,
            Self::ScMapEntry(_) => TypeVariant::ScMapEntry,
            Self::StoredTransactionSet(_) => TypeVariant::StoredTransactionSet,
            Self::StoredDebugTransactionSet(_) => TypeVariant::StoredDebugTransactionSet,
            Self::PersistedScpStateV0(_) => TypeVariant::PersistedScpStateV0,
            Self::PersistedScpStateV1(_) => TypeVariant::PersistedScpStateV1,
            Self::PersistedScpState(_) => TypeVariant::PersistedScpState,
            Self::Thresholds(_) => TypeVariant::Thresholds,
            Self::String32(_) => TypeVariant::String32,
            Self::String64(_) => TypeVariant::String64,
            Self::SequenceNumber(_) => TypeVariant::SequenceNumber,
            Self::DataValue(_) => TypeVariant::DataValue,
            Self::PoolId(_) => TypeVariant::PoolId,
            Self::AssetCode4(_) => TypeVariant::AssetCode4,
            Self::AssetCode12(_) => TypeVariant::AssetCode12,
            Self::AssetType(_) => TypeVariant::AssetType,
            Self::AssetCode(_) => TypeVariant::AssetCode,
            Self::AlphaNum4(_) => TypeVariant::AlphaNum4,
            Self::AlphaNum12(_) => TypeVariant::AlphaNum12,
            Self::Asset(_) => TypeVariant::Asset,
            Self::Price(_) => TypeVariant::Price,
            Self::Liabilities(_) => TypeVariant::Liabilities,
            Self::ThresholdIndexes(_) => TypeVariant::ThresholdIndexes,
            Self::LedgerEntryType(_) => TypeVariant::LedgerEntryType,
            Self::Signer(_) => TypeVariant::Signer,
            Self::AccountFlags(_) => TypeVariant::AccountFlags,
            Self::SponsorshipDescriptor(_) => TypeVariant::SponsorshipDescriptor,
            Self::AccountEntryExtensionV3(_) => TypeVariant::AccountEntryExtensionV3,
            Self::AccountEntryExtensionV2(_) => TypeVariant::AccountEntryExtensionV2,
            Self::AccountEntryExtensionV2Ext(_) => TypeVariant::AccountEntryExtensionV2Ext,
            Self::AccountEntryExtensionV1(_) => TypeVariant::AccountEntryExtensionV1,
            Self::AccountEntryExtensionV1Ext(_) => TypeVariant::AccountEntryExtensionV1Ext,
            Self::AccountEntry(_) => TypeVariant::AccountEntry,
            Self::AccountEntryExt(_) => TypeVariant::AccountEntryExt,
            Self::TrustLineFlags(_) => TypeVariant::TrustLineFlags,
            Self::LiquidityPoolType(_) => TypeVariant::LiquidityPoolType,
            Self::TrustLineAsset(_) => TypeVariant::TrustLineAsset,
            Self::TrustLineEntryExtensionV2(_) => TypeVariant::TrustLineEntryExtensionV2,
            Self::TrustLineEntryExtensionV2Ext(_) => TypeVariant::TrustLineEntryExtensionV2Ext,
            Self::TrustLineEntry(_) => TypeVariant::TrustLineEntry,
            Self::TrustLineEntryExt(_) => TypeVariant::TrustLineEntryExt,
            Self::TrustLineEntryV1(_) => TypeVariant::TrustLineEntryV1,
            Self::TrustLineEntryV1Ext(_) => TypeVariant::TrustLineEntryV1Ext,
            Self::OfferEntryFlags(_) => TypeVariant::OfferEntryFlags,
            Self::OfferEntry(_) => TypeVariant::OfferEntry,
            Self::OfferEntryExt(_) => TypeVariant::OfferEntryExt,
            Self::DataEntry(_) => TypeVariant::DataEntry,
            Self::DataEntryExt(_) => TypeVariant::DataEntryExt,
            Self::ClaimPredicateType(_) => TypeVariant::ClaimPredicateType,
            Self::ClaimPredicate(_) => TypeVariant::ClaimPredicate,
            Self::ClaimantType(_) => TypeVariant::ClaimantType,
            Self::Claimant(_) => TypeVariant::Claimant,
            Self::ClaimantV0(_) => TypeVariant::ClaimantV0,
            Self::ClaimableBalanceIdType(_) => TypeVariant::ClaimableBalanceIdType,
            Self::ClaimableBalanceId(_) => TypeVariant::ClaimableBalanceId,
            Self::ClaimableBalanceFlags(_) => TypeVariant::ClaimableBalanceFlags,
            Self::ClaimableBalanceEntryExtensionV1(_) => {
                TypeVariant::ClaimableBalanceEntryExtensionV1
            }
            Self::ClaimableBalanceEntryExtensionV1Ext(_) => {
                TypeVariant::ClaimableBalanceEntryExtensionV1Ext
            }
            Self::ClaimableBalanceEntry(_) => TypeVariant::ClaimableBalanceEntry,
            Self::ClaimableBalanceEntryExt(_) => TypeVariant::ClaimableBalanceEntryExt,
            Self::LiquidityPoolConstantProductParameters(_) => {
                TypeVariant::LiquidityPoolConstantProductParameters
            }
            Self::LiquidityPoolEntry(_) => TypeVariant::LiquidityPoolEntry,
            Self::LiquidityPoolEntryBody(_) => TypeVariant::LiquidityPoolEntryBody,
            Self::LiquidityPoolEntryConstantProduct(_) => {
                TypeVariant::LiquidityPoolEntryConstantProduct
            }
            Self::ContractDataDurability(_) => TypeVariant::ContractDataDurability,
            Self::ContractDataEntry(_) => TypeVariant::ContractDataEntry,
            Self::ContractCodeCostInputs(_) => TypeVariant::ContractCodeCostInputs,
            Self::ContractCodeEntry(_) => TypeVariant::ContractCodeEntry,
            Self::ContractCodeEntryExt(_) => TypeVariant::ContractCodeEntryExt,
            Self::ContractCodeEntryV1(_) => TypeVariant::ContractCodeEntryV1,
            Self::TtlEntry(_) => TypeVariant::TtlEntry,
            Self::LedgerEntryExtensionV1(_) => TypeVariant::LedgerEntryExtensionV1,
            Self::LedgerEntryExtensionV1Ext(_) => TypeVariant::LedgerEntryExtensionV1Ext,
            Self::LedgerEntry(_) => TypeVariant::LedgerEntry,
            Self::LedgerEntryData(_) => TypeVariant::LedgerEntryData,
            Self::LedgerEntryExt(_) => TypeVariant::LedgerEntryExt,
            Self::LedgerKey(_) => TypeVariant::LedgerKey,
            Self::LedgerKeyAccount(_) => TypeVariant::LedgerKeyAccount,
            Self::LedgerKeyTrustLine(_) => TypeVariant::LedgerKeyTrustLine,
            Self::LedgerKeyOffer(_) => TypeVariant::LedgerKeyOffer,
            Self::LedgerKeyData(_) => TypeVariant::LedgerKeyData,
            Self::LedgerKeyClaimableBalance(_) => TypeVariant::LedgerKeyClaimableBalance,
            Self::LedgerKeyLiquidityPool(_) => TypeVariant::LedgerKeyLiquidityPool,
            Self::LedgerKeyContractData(_) => TypeVariant::LedgerKeyContractData,
            Self::LedgerKeyContractCode(_) => TypeVariant::LedgerKeyContractCode,
            Self::LedgerKeyConfigSetting(_) => TypeVariant::LedgerKeyConfigSetting,
            Self::LedgerKeyTtl(_) => TypeVariant::LedgerKeyTtl,
            Self::EnvelopeType(_) => TypeVariant::EnvelopeType,
            Self::UpgradeType(_) => TypeVariant::UpgradeType,
            Self::StellarValueType(_) => TypeVariant::StellarValueType,
            Self::LedgerCloseValueSignature(_) => TypeVariant::LedgerCloseValueSignature,
            Self::StellarValue(_) => TypeVariant::StellarValue,
            Self::StellarValueExt(_) => TypeVariant::StellarValueExt,
            Self::LedgerHeaderFlags(_) => TypeVariant::LedgerHeaderFlags,
            Self::LedgerHeaderExtensionV1(_) => TypeVariant::LedgerHeaderExtensionV1,
            Self::LedgerHeaderExtensionV1Ext(_) => TypeVariant::LedgerHeaderExtensionV1Ext,
            Self::LedgerHeader(_) => TypeVariant::LedgerHeader,
            Self::LedgerHeaderExt(_) => TypeVariant::LedgerHeaderExt,
            Self::LedgerUpgradeType(_) => TypeVariant::LedgerUpgradeType,
            Self::ConfigUpgradeSetKey(_) => TypeVariant::ConfigUpgradeSetKey,
            Self::LedgerUpgrade(_) => TypeVariant::LedgerUpgrade,
            Self::ConfigUpgradeSet(_) => TypeVariant::ConfigUpgradeSet,
            Self::BucketEntryType(_) => TypeVariant::BucketEntryType,
            Self::BucketMetadata(_) => TypeVariant::BucketMetadata,
            Self::BucketMetadataExt(_) => TypeVariant::BucketMetadataExt,
            Self::BucketEntry(_) => TypeVariant::BucketEntry,
            Self::TxSetComponentType(_) => TypeVariant::TxSetComponentType,
            Self::TxSetComponent(_) => TypeVariant::TxSetComponent,
            Self::TxSetComponentTxsMaybeDiscountedFee(_) => {
                TypeVariant::TxSetComponentTxsMaybeDiscountedFee
            }
            Self::TransactionPhase(_) => TypeVariant::TransactionPhase,
            Self::TransactionSet(_) => TypeVariant::TransactionSet,
            Self::TransactionSetV1(_) => TypeVariant::TransactionSetV1,
            Self::GeneralizedTransactionSet(_) => TypeVariant::GeneralizedTransactionSet,
            Self::TransactionResultPair(_) => TypeVariant::TransactionResultPair,
            Self::TransactionResultSet(_) => TypeVariant::TransactionResultSet,
            Self::TransactionHistoryEntry(_) => TypeVariant::TransactionHistoryEntry,
            Self::TransactionHistoryEntryExt(_) => TypeVariant::TransactionHistoryEntryExt,
            Self::TransactionHistoryResultEntry(_) => TypeVariant::TransactionHistoryResultEntry,
            Self::TransactionHistoryResultEntryExt(_) => {
                TypeVariant::TransactionHistoryResultEntryExt
            }
            Self::LedgerHeaderHistoryEntry(_) => TypeVariant::LedgerHeaderHistoryEntry,
            Self::LedgerHeaderHistoryEntryExt(_) => TypeVariant::LedgerHeaderHistoryEntryExt,
            Self::LedgerScpMessages(_) => TypeVariant::LedgerScpMessages,
            Self::ScpHistoryEntryV0(_) => TypeVariant::ScpHistoryEntryV0,
            Self::ScpHistoryEntry(_) => TypeVariant::ScpHistoryEntry,
            Self::LedgerEntryChangeType(_) => TypeVariant::LedgerEntryChangeType,
            Self::LedgerEntryChange(_) => TypeVariant::LedgerEntryChange,
            Self::LedgerEntryChanges(_) => TypeVariant::LedgerEntryChanges,
            Self::OperationMeta(_) => TypeVariant::OperationMeta,
            Self::TransactionMetaV1(_) => TypeVariant::TransactionMetaV1,
            Self::TransactionMetaV2(_) => TypeVariant::TransactionMetaV2,
            Self::ContractEventType(_) => TypeVariant::ContractEventType,
            Self::ContractEvent(_) => TypeVariant::ContractEvent,
            Self::ContractEventBody(_) => TypeVariant::ContractEventBody,
            Self::ContractEventV0(_) => TypeVariant::ContractEventV0,
            Self::DiagnosticEvent(_) => TypeVariant::DiagnosticEvent,
            Self::SorobanTransactionMetaExtV1(_) => TypeVariant::SorobanTransactionMetaExtV1,
            Self::SorobanTransactionMetaExt(_) => TypeVariant::SorobanTransactionMetaExt,
            Self::SorobanTransactionMeta(_) => TypeVariant::SorobanTransactionMeta,
            Self::TransactionMetaV3(_) => TypeVariant::TransactionMetaV3,
            Self::InvokeHostFunctionSuccessPreImage(_) => {
                TypeVariant::InvokeHostFunctionSuccessPreImage
            }
            Self::TransactionMeta(_) => TypeVariant::TransactionMeta,
            Self::TransactionResultMeta(_) => TypeVariant::TransactionResultMeta,
            Self::UpgradeEntryMeta(_) => TypeVariant::UpgradeEntryMeta,
            Self::LedgerCloseMetaV0(_) => TypeVariant::LedgerCloseMetaV0,
            Self::LedgerCloseMetaExtV1(_) => TypeVariant::LedgerCloseMetaExtV1,
            Self::LedgerCloseMetaExt(_) => TypeVariant::LedgerCloseMetaExt,
            Self::LedgerCloseMetaV1(_) => TypeVariant::LedgerCloseMetaV1,
            Self::LedgerCloseMeta(_) => TypeVariant::LedgerCloseMeta,
            Self::ErrorCode(_) => TypeVariant::ErrorCode,
            Self::SError(_) => TypeVariant::SError,
            Self::SendMore(_) => TypeVariant::SendMore,
            Self::SendMoreExtended(_) => TypeVariant::SendMoreExtended,
            Self::AuthCert(_) => TypeVariant::AuthCert,
            Self::Hello(_) => TypeVariant::Hello,
            Self::Auth(_) => TypeVariant::Auth,
            Self::IpAddrType(_) => TypeVariant::IpAddrType,
            Self::PeerAddress(_) => TypeVariant::PeerAddress,
            Self::PeerAddressIp(_) => TypeVariant::PeerAddressIp,
            Self::MessageType(_) => TypeVariant::MessageType,
            Self::DontHave(_) => TypeVariant::DontHave,
            Self::SurveyMessageCommandType(_) => TypeVariant::SurveyMessageCommandType,
            Self::SurveyMessageResponseType(_) => TypeVariant::SurveyMessageResponseType,
            Self::SurveyRequestMessage(_) => TypeVariant::SurveyRequestMessage,
            Self::SignedSurveyRequestMessage(_) => TypeVariant::SignedSurveyRequestMessage,
            Self::EncryptedBody(_) => TypeVariant::EncryptedBody,
            Self::SurveyResponseMessage(_) => TypeVariant::SurveyResponseMessage,
            Self::SignedSurveyResponseMessage(_) => TypeVariant::SignedSurveyResponseMessage,
            Self::PeerStats(_) => TypeVariant::PeerStats,
            Self::PeerStatList(_) => TypeVariant::PeerStatList,
            Self::TopologyResponseBodyV0(_) => TypeVariant::TopologyResponseBodyV0,
            Self::TopologyResponseBodyV1(_) => TypeVariant::TopologyResponseBodyV1,
            Self::SurveyResponseBody(_) => TypeVariant::SurveyResponseBody,
            Self::TxAdvertVector(_) => TypeVariant::TxAdvertVector,
            Self::FloodAdvert(_) => TypeVariant::FloodAdvert,
            Self::TxDemandVector(_) => TypeVariant::TxDemandVector,
            Self::FloodDemand(_) => TypeVariant::FloodDemand,
            Self::StellarMessage(_) => TypeVariant::StellarMessage,
            Self::AuthenticatedMessage(_) => TypeVariant::AuthenticatedMessage,
            Self::AuthenticatedMessageV0(_) => TypeVariant::AuthenticatedMessageV0,
            Self::LiquidityPoolParameters(_) => TypeVariant::LiquidityPoolParameters,
            Self::MuxedAccount(_) => TypeVariant::MuxedAccount,
            Self::MuxedAccountMed25519(_) => TypeVariant::MuxedAccountMed25519,
            Self::DecoratedSignature(_) => TypeVariant::DecoratedSignature,
            Self::OperationType(_) => TypeVariant::OperationType,
            Self::CreateAccountOp(_) => TypeVariant::CreateAccountOp,
            Self::PaymentOp(_) => TypeVariant::PaymentOp,
            Self::PathPaymentStrictReceiveOp(_) => TypeVariant::PathPaymentStrictReceiveOp,
            Self::PathPaymentStrictSendOp(_) => TypeVariant::PathPaymentStrictSendOp,
            Self::ManageSellOfferOp(_) => TypeVariant::ManageSellOfferOp,
            Self::ManageBuyOfferOp(_) => TypeVariant::ManageBuyOfferOp,
            Self::CreatePassiveSellOfferOp(_) => TypeVariant::CreatePassiveSellOfferOp,
            Self::SetOptionsOp(_) => TypeVariant::SetOptionsOp,
            Self::ChangeTrustAsset(_) => TypeVariant::ChangeTrustAsset,
            Self::ChangeTrustOp(_) => TypeVariant::ChangeTrustOp,
            Self::AllowTrustOp(_) => TypeVariant::AllowTrustOp,
            Self::ManageDataOp(_) => TypeVariant::ManageDataOp,
            Self::BumpSequenceOp(_) => TypeVariant::BumpSequenceOp,
            Self::CreateClaimableBalanceOp(_) => TypeVariant::CreateClaimableBalanceOp,
            Self::ClaimClaimableBalanceOp(_) => TypeVariant::ClaimClaimableBalanceOp,
            Self::BeginSponsoringFutureReservesOp(_) => {
                TypeVariant::BeginSponsoringFutureReservesOp
            }
            Self::RevokeSponsorshipType(_) => TypeVariant::RevokeSponsorshipType,
            Self::RevokeSponsorshipOp(_) => TypeVariant::RevokeSponsorshipOp,
            Self::RevokeSponsorshipOpSigner(_) => TypeVariant::RevokeSponsorshipOpSigner,
            Self::ClawbackOp(_) => TypeVariant::ClawbackOp,
            Self::ClawbackClaimableBalanceOp(_) => TypeVariant::ClawbackClaimableBalanceOp,
            Self::SetTrustLineFlagsOp(_) => TypeVariant::SetTrustLineFlagsOp,
            Self::LiquidityPoolDepositOp(_) => TypeVariant::LiquidityPoolDepositOp,
            Self::LiquidityPoolWithdrawOp(_) => TypeVariant::LiquidityPoolWithdrawOp,
            Self::HostFunctionType(_) => TypeVariant::HostFunctionType,
            Self::ContractIdPreimageType(_) => TypeVariant::ContractIdPreimageType,
            Self::ContractIdPreimage(_) => TypeVariant::ContractIdPreimage,
            Self::ContractIdPreimageFromAddress(_) => TypeVariant::ContractIdPreimageFromAddress,
            Self::CreateContractArgs(_) => TypeVariant::CreateContractArgs,
            Self::InvokeContractArgs(_) => TypeVariant::InvokeContractArgs,
            Self::HostFunction(_) => TypeVariant::HostFunction,
            Self::SorobanAuthorizedFunctionType(_) => TypeVariant::SorobanAuthorizedFunctionType,
            Self::SorobanAuthorizedFunction(_) => TypeVariant::SorobanAuthorizedFunction,
            Self::SorobanAuthorizedInvocation(_) => TypeVariant::SorobanAuthorizedInvocation,
            Self::SorobanAddressCredentials(_) => TypeVariant::SorobanAddressCredentials,
            Self::SorobanCredentialsType(_) => TypeVariant::SorobanCredentialsType,
            Self::SorobanCredentials(_) => TypeVariant::SorobanCredentials,
            Self::SorobanAuthorizationEntry(_) => TypeVariant::SorobanAuthorizationEntry,
            Self::InvokeHostFunctionOp(_) => TypeVariant::InvokeHostFunctionOp,
            Self::ExtendFootprintTtlOp(_) => TypeVariant::ExtendFootprintTtlOp,
            Self::RestoreFootprintOp(_) => TypeVariant::RestoreFootprintOp,
            Self::Operation(_) => TypeVariant::Operation,
            Self::OperationBody(_) => TypeVariant::OperationBody,
            Self::HashIdPreimage(_) => TypeVariant::HashIdPreimage,
            Self::HashIdPreimageOperationId(_) => TypeVariant::HashIdPreimageOperationId,
            Self::HashIdPreimageRevokeId(_) => TypeVariant::HashIdPreimageRevokeId,
            Self::HashIdPreimageContractId(_) => TypeVariant::HashIdPreimageContractId,
            Self::HashIdPreimageSorobanAuthorization(_) => {
                TypeVariant::HashIdPreimageSorobanAuthorization
            }
            Self::MemoType(_) => TypeVariant::MemoType,
            Self::Memo(_) => TypeVariant::Memo,
            Self::TimeBounds(_) => TypeVariant::TimeBounds,
            Self::LedgerBounds(_) => TypeVariant::LedgerBounds,
            Self::PreconditionsV2(_) => TypeVariant::PreconditionsV2,
            Self::PreconditionType(_) => TypeVariant::PreconditionType,
            Self::Preconditions(_) => TypeVariant::Preconditions,
            Self::LedgerFootprint(_) => TypeVariant::LedgerFootprint,
            Self::SorobanResources(_) => TypeVariant::SorobanResources,
            Self::SorobanTransactionData(_) => TypeVariant::SorobanTransactionData,
            Self::TransactionV0(_) => TypeVariant::TransactionV0,
            Self::TransactionV0Ext(_) => TypeVariant::TransactionV0Ext,
            Self::TransactionV0Envelope(_) => TypeVariant::TransactionV0Envelope,
            Self::Transaction(_) => TypeVariant::Transaction,
            Self::TransactionExt(_) => TypeVariant::TransactionExt,
            Self::TransactionV1Envelope(_) => TypeVariant::TransactionV1Envelope,
            Self::FeeBumpTransaction(_) => TypeVariant::FeeBumpTransaction,
            Self::FeeBumpTransactionInnerTx(_) => TypeVariant::FeeBumpTransactionInnerTx,
            Self::FeeBumpTransactionExt(_) => TypeVariant::FeeBumpTransactionExt,
            Self::FeeBumpTransactionEnvelope(_) => TypeVariant::FeeBumpTransactionEnvelope,
            Self::TransactionEnvelope(_) => TypeVariant::TransactionEnvelope,
            Self::TransactionSignaturePayload(_) => TypeVariant::TransactionSignaturePayload,
            Self::TransactionSignaturePayloadTaggedTransaction(_) => {
                TypeVariant::TransactionSignaturePayloadTaggedTransaction
            }
            Self::ClaimAtomType(_) => TypeVariant::ClaimAtomType,
            Self::ClaimOfferAtomV0(_) => TypeVariant::ClaimOfferAtomV0,
            Self::ClaimOfferAtom(_) => TypeVariant::ClaimOfferAtom,
            Self::ClaimLiquidityAtom(_) => TypeVariant::ClaimLiquidityAtom,
            Self::ClaimAtom(_) => TypeVariant::ClaimAtom,
            Self::CreateAccountResultCode(_) => TypeVariant::CreateAccountResultCode,
            Self::CreateAccountResult(_) => TypeVariant::CreateAccountResult,
            Self::PaymentResultCode(_) => TypeVariant::PaymentResultCode,
            Self::PaymentResult(_) => TypeVariant::PaymentResult,
            Self::PathPaymentStrictReceiveResultCode(_) => {
                TypeVariant::PathPaymentStrictReceiveResultCode
            }
            Self::SimplePaymentResult(_) => TypeVariant::SimplePaymentResult,
            Self::PathPaymentStrictReceiveResult(_) => TypeVariant::PathPaymentStrictReceiveResult,
            Self::PathPaymentStrictReceiveResultSuccess(_) => {
                TypeVariant::PathPaymentStrictReceiveResultSuccess
            }
            Self::PathPaymentStrictSendResultCode(_) => {
                TypeVariant::PathPaymentStrictSendResultCode
            }
            Self::PathPaymentStrictSendResult(_) => TypeVariant::PathPaymentStrictSendResult,
            Self::PathPaymentStrictSendResultSuccess(_) => {
                TypeVariant::PathPaymentStrictSendResultSuccess
            }
            Self::ManageSellOfferResultCode(_) => TypeVariant::ManageSellOfferResultCode,
            Self::ManageOfferEffect(_) => TypeVariant::ManageOfferEffect,
            Self::ManageOfferSuccessResult(_) => TypeVariant::ManageOfferSuccessResult,
            Self::ManageOfferSuccessResultOffer(_) => TypeVariant::ManageOfferSuccessResultOffer,
            Self::ManageSellOfferResult(_) => TypeVariant::ManageSellOfferResult,
            Self::ManageBuyOfferResultCode(_) => TypeVariant::ManageBuyOfferResultCode,
            Self::ManageBuyOfferResult(_) => TypeVariant::ManageBuyOfferResult,
            Self::SetOptionsResultCode(_) => TypeVariant::SetOptionsResultCode,
            Self::SetOptionsResult(_) => TypeVariant::SetOptionsResult,
            Self::ChangeTrustResultCode(_) => TypeVariant::ChangeTrustResultCode,
            Self::ChangeTrustResult(_) => TypeVariant::ChangeTrustResult,
            Self::AllowTrustResultCode(_) => TypeVariant::AllowTrustResultCode,
            Self::AllowTrustResult(_) => TypeVariant::AllowTrustResult,
            Self::AccountMergeResultCode(_) => TypeVariant::AccountMergeResultCode,
            Self::AccountMergeResult(_) => TypeVariant::AccountMergeResult,
            Self::InflationResultCode(_) => TypeVariant::InflationResultCode,
            Self::InflationPayout(_) => TypeVariant::InflationPayout,
            Self::InflationResult(_) => TypeVariant::InflationResult,
            Self::ManageDataResultCode(_) => TypeVariant::ManageDataResultCode,
            Self::ManageDataResult(_) => TypeVariant::ManageDataResult,
            Self::BumpSequenceResultCode(_) => TypeVariant::BumpSequenceResultCode,
            Self::BumpSequenceResult(_) => TypeVariant::BumpSequenceResult,
            Self::CreateClaimableBalanceResultCode(_) => {
                TypeVariant::CreateClaimableBalanceResultCode
            }
            Self::CreateClaimableBalanceResult(_) => TypeVariant::CreateClaimableBalanceResult,
            Self::ClaimClaimableBalanceResultCode(_) => {
                TypeVariant::ClaimClaimableBalanceResultCode
            }
            Self::ClaimClaimableBalanceResult(_) => TypeVariant::ClaimClaimableBalanceResult,
            Self::BeginSponsoringFutureReservesResultCode(_) => {
                TypeVariant::BeginSponsoringFutureReservesResultCode
            }
            Self::BeginSponsoringFutureReservesResult(_) => {
                TypeVariant::BeginSponsoringFutureReservesResult
            }
            Self::EndSponsoringFutureReservesResultCode(_) => {
                TypeVariant::EndSponsoringFutureReservesResultCode
            }
            Self::EndSponsoringFutureReservesResult(_) => {
                TypeVariant::EndSponsoringFutureReservesResult
            }
            Self::RevokeSponsorshipResultCode(_) => TypeVariant::RevokeSponsorshipResultCode,
            Self::RevokeSponsorshipResult(_) => TypeVariant::RevokeSponsorshipResult,
            Self::ClawbackResultCode(_) => TypeVariant::ClawbackResultCode,
            Self::ClawbackResult(_) => TypeVariant::ClawbackResult,
            Self::ClawbackClaimableBalanceResultCode(_) => {
                TypeVariant::ClawbackClaimableBalanceResultCode
            }
            Self::ClawbackClaimableBalanceResult(_) => TypeVariant::ClawbackClaimableBalanceResult,
            Self::SetTrustLineFlagsResultCode(_) => TypeVariant::SetTrustLineFlagsResultCode,
            Self::SetTrustLineFlagsResult(_) => TypeVariant::SetTrustLineFlagsResult,
            Self::LiquidityPoolDepositResultCode(_) => TypeVariant::LiquidityPoolDepositResultCode,
            Self::LiquidityPoolDepositResult(_) => TypeVariant::LiquidityPoolDepositResult,
            Self::LiquidityPoolWithdrawResultCode(_) => {
                TypeVariant::LiquidityPoolWithdrawResultCode
            }
            Self::LiquidityPoolWithdrawResult(_) => TypeVariant::LiquidityPoolWithdrawResult,
            Self::InvokeHostFunctionResultCode(_) => TypeVariant::InvokeHostFunctionResultCode,
            Self::InvokeHostFunctionResult(_) => TypeVariant::InvokeHostFunctionResult,
            Self::ExtendFootprintTtlResultCode(_) => TypeVariant::ExtendFootprintTtlResultCode,
            Self::ExtendFootprintTtlResult(_) => TypeVariant::ExtendFootprintTtlResult,
            Self::RestoreFootprintResultCode(_) => TypeVariant::RestoreFootprintResultCode,
            Self::RestoreFootprintResult(_) => TypeVariant::RestoreFootprintResult,
            Self::OperationResultCode(_) => TypeVariant::OperationResultCode,
            Self::OperationResult(_) => TypeVariant::OperationResult,
            Self::OperationResultTr(_) => TypeVariant::OperationResultTr,
            Self::TransactionResultCode(_) => TypeVariant::TransactionResultCode,
            Self::InnerTransactionResult(_) => TypeVariant::InnerTransactionResult,
            Self::InnerTransactionResultResult(_) => TypeVariant::InnerTransactionResultResult,
            Self::InnerTransactionResultExt(_) => TypeVariant::InnerTransactionResultExt,
            Self::InnerTransactionResultPair(_) => TypeVariant::InnerTransactionResultPair,
            Self::TransactionResult(_) => TypeVariant::TransactionResult,
            Self::TransactionResultResult(_) => TypeVariant::TransactionResultResult,
            Self::TransactionResultExt(_) => TypeVariant::TransactionResultExt,
            Self::Hash(_) => TypeVariant::Hash,
            Self::Uint256(_) => TypeVariant::Uint256,
            Self::Uint32(_) => TypeVariant::Uint32,
            Self::Int32(_) => TypeVariant::Int32,
            Self::Uint64(_) => TypeVariant::Uint64,
            Self::Int64(_) => TypeVariant::Int64,
            Self::TimePoint(_) => TypeVariant::TimePoint,
            Self::Duration(_) => TypeVariant::Duration,
            Self::ExtensionPoint(_) => TypeVariant::ExtensionPoint,
            Self::CryptoKeyType(_) => TypeVariant::CryptoKeyType,
            Self::PublicKeyType(_) => TypeVariant::PublicKeyType,
            Self::SignerKeyType(_) => TypeVariant::SignerKeyType,
            Self::PublicKey(_) => TypeVariant::PublicKey,
            Self::SignerKey(_) => TypeVariant::SignerKey,
            Self::SignerKeyEd25519SignedPayload(_) => TypeVariant::SignerKeyEd25519SignedPayload,
            Self::Signature(_) => TypeVariant::Signature,
            Self::SignatureHint(_) => TypeVariant::SignatureHint,
            Self::NodeId(_) => TypeVariant::NodeId,
            Self::AccountId(_) => TypeVariant::AccountId,
            Self::Curve25519Secret(_) => TypeVariant::Curve25519Secret,
            Self::Curve25519Public(_) => TypeVariant::Curve25519Public,
            Self::HmacSha256Key(_) => TypeVariant::HmacSha256Key,
            Self::HmacSha256Mac(_) => TypeVariant::HmacSha256Mac,
        }
    }
}

impl Name for Type {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TypeVariant> for Type {
    fn variants() -> slice::Iter<'static, TypeVariant> {
        Self::VARIANTS.iter()
    }
}

impl WriteXdr for Type {
    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<()> {
        match self {
            Self::Value(v) => v.write_xdr(w),
            Self::ScpBallot(v) => v.write_xdr(w),
            Self::ScpStatementType(v) => v.write_xdr(w),
            Self::ScpNomination(v) => v.write_xdr(w),
            Self::ScpStatement(v) => v.write_xdr(w),
            Self::ScpStatementPledges(v) => v.write_xdr(w),
            Self::ScpStatementPrepare(v) => v.write_xdr(w),
            Self::ScpStatementConfirm(v) => v.write_xdr(w),
            Self::ScpStatementExternalize(v) => v.write_xdr(w),
            Self::ScpEnvelope(v) => v.write_xdr(w),
            Self::ScpQuorumSet(v) => v.write_xdr(w),
            Self::ConfigSettingContractExecutionLanesV0(v) => v.write_xdr(w),
            Self::ConfigSettingContractComputeV0(v) => v.write_xdr(w),
            Self::ConfigSettingContractLedgerCostV0(v) => v.write_xdr(w),
            Self::ConfigSettingContractHistoricalDataV0(v) => v.write_xdr(w),
            Self::ConfigSettingContractEventsV0(v) => v.write_xdr(w),
            Self::ConfigSettingContractBandwidthV0(v) => v.write_xdr(w),
            Self::ContractCostType(v) => v.write_xdr(w),
            Self::ContractCostParamEntry(v) => v.write_xdr(w),
            Self::StateArchivalSettings(v) => v.write_xdr(w),
            Self::EvictionIterator(v) => v.write_xdr(w),
            Self::ContractCostParams(v) => v.write_xdr(w),
            Self::ConfigSettingId(v) => v.write_xdr(w),
            Self::ConfigSettingEntry(v) => v.write_xdr(w),
            Self::ScEnvMetaKind(v) => v.write_xdr(w),
            Self::ScEnvMetaEntry(v) => v.write_xdr(w),
            Self::ScMetaV0(v) => v.write_xdr(w),
            Self::ScMetaKind(v) => v.write_xdr(w),
            Self::ScMetaEntry(v) => v.write_xdr(w),
            Self::ScSpecType(v) => v.write_xdr(w),
            Self::ScSpecTypeOption(v) => v.write_xdr(w),
            Self::ScSpecTypeResult(v) => v.write_xdr(w),
            Self::ScSpecTypeVec(v) => v.write_xdr(w),
            Self::ScSpecTypeMap(v) => v.write_xdr(w),
            Self::ScSpecTypeTuple(v) => v.write_xdr(w),
            Self::ScSpecTypeBytesN(v) => v.write_xdr(w),
            Self::ScSpecTypeUdt(v) => v.write_xdr(w),
            Self::ScSpecTypeDef(v) => v.write_xdr(w),
            Self::ScSpecUdtStructFieldV0(v) => v.write_xdr(w),
            Self::ScSpecUdtStructV0(v) => v.write_xdr(w),
            Self::ScSpecUdtUnionCaseVoidV0(v) => v.write_xdr(w),
            Self::ScSpecUdtUnionCaseTupleV0(v) => v.write_xdr(w),
            Self::ScSpecUdtUnionCaseV0Kind(v) => v.write_xdr(w),
            Self::ScSpecUdtUnionCaseV0(v) => v.write_xdr(w),
            Self::ScSpecUdtUnionV0(v) => v.write_xdr(w),
            Self::ScSpecUdtEnumCaseV0(v) => v.write_xdr(w),
            Self::ScSpecUdtEnumV0(v) => v.write_xdr(w),
            Self::ScSpecUdtErrorEnumCaseV0(v) => v.write_xdr(w),
            Self::ScSpecUdtErrorEnumV0(v) => v.write_xdr(w),
            Self::ScSpecFunctionInputV0(v) => v.write_xdr(w),
            Self::ScSpecFunctionV0(v) => v.write_xdr(w),
            Self::ScSpecEntryKind(v) => v.write_xdr(w),
            Self::ScSpecEntry(v) => v.write_xdr(w),
            Self::ScValType(v) => v.write_xdr(w),
            Self::ScErrorType(v) => v.write_xdr(w),
            Self::ScErrorCode(v) => v.write_xdr(w),
            Self::ScError(v) => v.write_xdr(w),
            Self::UInt128Parts(v) => v.write_xdr(w),
            Self::Int128Parts(v) => v.write_xdr(w),
            Self::UInt256Parts(v) => v.write_xdr(w),
            Self::Int256Parts(v) => v.write_xdr(w),
            Self::ContractExecutableType(v) => v.write_xdr(w),
            Self::ContractExecutable(v) => v.write_xdr(w),
            Self::ScAddressType(v) => v.write_xdr(w),
            Self::ScAddress(v) => v.write_xdr(w),
            Self::ScVec(v) => v.write_xdr(w),
            Self::ScMap(v) => v.write_xdr(w),
            Self::ScBytes(v) => v.write_xdr(w),
            Self::ScString(v) => v.write_xdr(w),
            Self::ScSymbol(v) => v.write_xdr(w),
            Self::ScNonceKey(v) => v.write_xdr(w),
            Self::ScContractInstance(v) => v.write_xdr(w),
            Self::ScVal(v) => v.write_xdr(w),
            Self::ScMapEntry(v) => v.write_xdr(w),
            Self::StoredTransactionSet(v) => v.write_xdr(w),
            Self::StoredDebugTransactionSet(v) => v.write_xdr(w),
            Self::PersistedScpStateV0(v) => v.write_xdr(w),
            Self::PersistedScpStateV1(v) => v.write_xdr(w),
            Self::PersistedScpState(v) => v.write_xdr(w),
            Self::Thresholds(v) => v.write_xdr(w),
            Self::String32(v) => v.write_xdr(w),
            Self::String64(v) => v.write_xdr(w),
            Self::SequenceNumber(v) => v.write_xdr(w),
            Self::DataValue(v) => v.write_xdr(w),
            Self::PoolId(v) => v.write_xdr(w),
            Self::AssetCode4(v) => v.write_xdr(w),
            Self::AssetCode12(v) => v.write_xdr(w),
            Self::AssetType(v) => v.write_xdr(w),
            Self::AssetCode(v) => v.write_xdr(w),
            Self::AlphaNum4(v) => v.write_xdr(w),
            Self::AlphaNum12(v) => v.write_xdr(w),
            Self::Asset(v) => v.write_xdr(w),
            Self::Price(v) => v.write_xdr(w),
            Self::Liabilities(v) => v.write_xdr(w),
            Self::ThresholdIndexes(v) => v.write_xdr(w),
            Self::LedgerEntryType(v) => v.write_xdr(w),
            Self::Signer(v) => v.write_xdr(w),
            Self::AccountFlags(v) => v.write_xdr(w),
            Self::SponsorshipDescriptor(v) => v.write_xdr(w),
            Self::AccountEntryExtensionV3(v) => v.write_xdr(w),
            Self::AccountEntryExtensionV2(v) => v.write_xdr(w),
            Self::AccountEntryExtensionV2Ext(v) => v.write_xdr(w),
            Self::AccountEntryExtensionV1(v) => v.write_xdr(w),
            Self::AccountEntryExtensionV1Ext(v) => v.write_xdr(w),
            Self::AccountEntry(v) => v.write_xdr(w),
            Self::AccountEntryExt(v) => v.write_xdr(w),
            Self::TrustLineFlags(v) => v.write_xdr(w),
            Self::LiquidityPoolType(v) => v.write_xdr(w),
            Self::TrustLineAsset(v) => v.write_xdr(w),
            Self::TrustLineEntryExtensionV2(v) => v.write_xdr(w),
            Self::TrustLineEntryExtensionV2Ext(v) => v.write_xdr(w),
            Self::TrustLineEntry(v) => v.write_xdr(w),
            Self::TrustLineEntryExt(v) => v.write_xdr(w),
            Self::TrustLineEntryV1(v) => v.write_xdr(w),
            Self::TrustLineEntryV1Ext(v) => v.write_xdr(w),
            Self::OfferEntryFlags(v) => v.write_xdr(w),
            Self::OfferEntry(v) => v.write_xdr(w),
            Self::OfferEntryExt(v) => v.write_xdr(w),
            Self::DataEntry(v) => v.write_xdr(w),
            Self::DataEntryExt(v) => v.write_xdr(w),
            Self::ClaimPredicateType(v) => v.write_xdr(w),
            Self::ClaimPredicate(v) => v.write_xdr(w),
            Self::ClaimantType(v) => v.write_xdr(w),
            Self::Claimant(v) => v.write_xdr(w),
            Self::ClaimantV0(v) => v.write_xdr(w),
            Self::ClaimableBalanceIdType(v) => v.write_xdr(w),
            Self::ClaimableBalanceId(v) => v.write_xdr(w),
            Self::ClaimableBalanceFlags(v) => v.write_xdr(w),
            Self::ClaimableBalanceEntryExtensionV1(v) => v.write_xdr(w),
            Self::ClaimableBalanceEntryExtensionV1Ext(v) => v.write_xdr(w),
            Self::ClaimableBalanceEntry(v) => v.write_xdr(w),
            Self::ClaimableBalanceEntryExt(v) => v.write_xdr(w),
            Self::LiquidityPoolConstantProductParameters(v) => v.write_xdr(w),
            Self::LiquidityPoolEntry(v) => v.write_xdr(w),
            Self::LiquidityPoolEntryBody(v) => v.write_xdr(w),
            Self::LiquidityPoolEntryConstantProduct(v) => v.write_xdr(w),
            Self::ContractDataDurability(v) => v.write_xdr(w),
            Self::ContractDataEntry(v) => v.write_xdr(w),
            Self::ContractCodeCostInputs(v) => v.write_xdr(w),
            Self::ContractCodeEntry(v) => v.write_xdr(w),
            Self::ContractCodeEntryExt(v) => v.write_xdr(w),
            Self::ContractCodeEntryV1(v) => v.write_xdr(w),
            Self::TtlEntry(v) => v.write_xdr(w),
            Self::LedgerEntryExtensionV1(v) => v.write_xdr(w),
            Self::LedgerEntryExtensionV1Ext(v) => v.write_xdr(w),
            Self::LedgerEntry(v) => v.write_xdr(w),
            Self::LedgerEntryData(v) => v.write_xdr(w),
            Self::LedgerEntryExt(v) => v.write_xdr(w),
            Self::LedgerKey(v) => v.write_xdr(w),
            Self::LedgerKeyAccount(v) => v.write_xdr(w),
            Self::LedgerKeyTrustLine(v) => v.write_xdr(w),
            Self::LedgerKeyOffer(v) => v.write_xdr(w),
            Self::LedgerKeyData(v) => v.write_xdr(w),
            Self::LedgerKeyClaimableBalance(v) => v.write_xdr(w),
            Self::LedgerKeyLiquidityPool(v) => v.write_xdr(w),
            Self::LedgerKeyContractData(v) => v.write_xdr(w),
            Self::LedgerKeyContractCode(v) => v.write_xdr(w),
            Self::LedgerKeyConfigSetting(v) => v.write_xdr(w),
            Self::LedgerKeyTtl(v) => v.write_xdr(w),
            Self::EnvelopeType(v) => v.write_xdr(w),
            Self::UpgradeType(v) => v.write_xdr(w),
            Self::StellarValueType(v) => v.write_xdr(w),
            Self::LedgerCloseValueSignature(v) => v.write_xdr(w),
            Self::StellarValue(v) => v.write_xdr(w),
            Self::StellarValueExt(v) => v.write_xdr(w),
            Self::LedgerHeaderFlags(v) => v.write_xdr(w),
            Self::LedgerHeaderExtensionV1(v) => v.write_xdr(w),
            Self::LedgerHeaderExtensionV1Ext(v) => v.write_xdr(w),
            Self::LedgerHeader(v) => v.write_xdr(w),
            Self::LedgerHeaderExt(v) => v.write_xdr(w),
            Self::LedgerUpgradeType(v) => v.write_xdr(w),
            Self::ConfigUpgradeSetKey(v) => v.write_xdr(w),
            Self::LedgerUpgrade(v) => v.write_xdr(w),
            Self::ConfigUpgradeSet(v) => v.write_xdr(w),
            Self::BucketEntryType(v) => v.write_xdr(w),
            Self::BucketMetadata(v) => v.write_xdr(w),
            Self::BucketMetadataExt(v) => v.write_xdr(w),
            Self::BucketEntry(v) => v.write_xdr(w),
            Self::TxSetComponentType(v) => v.write_xdr(w),
            Self::TxSetComponent(v) => v.write_xdr(w),
            Self::TxSetComponentTxsMaybeDiscountedFee(v) => v.write_xdr(w),
            Self::TransactionPhase(v) => v.write_xdr(w),
            Self::TransactionSet(v) => v.write_xdr(w),
            Self::TransactionSetV1(v) => v.write_xdr(w),
            Self::GeneralizedTransactionSet(v) => v.write_xdr(w),
            Self::TransactionResultPair(v) => v.write_xdr(w),
            Self::TransactionResultSet(v) => v.write_xdr(w),
            Self::TransactionHistoryEntry(v) => v.write_xdr(w),
            Self::TransactionHistoryEntryExt(v) => v.write_xdr(w),
            Self::TransactionHistoryResultEntry(v) => v.write_xdr(w),
            Self::TransactionHistoryResultEntryExt(v) => v.write_xdr(w),
            Self::LedgerHeaderHistoryEntry(v) => v.write_xdr(w),
            Self::LedgerHeaderHistoryEntryExt(v) => v.write_xdr(w),
            Self::LedgerScpMessages(v) => v.write_xdr(w),
            Self::ScpHistoryEntryV0(v) => v.write_xdr(w),
            Self::ScpHistoryEntry(v) => v.write_xdr(w),
            Self::LedgerEntryChangeType(v) => v.write_xdr(w),
            Self::LedgerEntryChange(v) => v.write_xdr(w),
            Self::LedgerEntryChanges(v) => v.write_xdr(w),
            Self::OperationMeta(v) => v.write_xdr(w),
            Self::TransactionMetaV1(v) => v.write_xdr(w),
            Self::TransactionMetaV2(v) => v.write_xdr(w),
            Self::ContractEventType(v) => v.write_xdr(w),
            Self::ContractEvent(v) => v.write_xdr(w),
            Self::ContractEventBody(v) => v.write_xdr(w),
            Self::ContractEventV0(v) => v.write_xdr(w),
            Self::DiagnosticEvent(v) => v.write_xdr(w),
            Self::SorobanTransactionMetaExtV1(v) => v.write_xdr(w),
            Self::SorobanTransactionMetaExt(v) => v.write_xdr(w),
            Self::SorobanTransactionMeta(v) => v.write_xdr(w),
            Self::TransactionMetaV3(v) => v.write_xdr(w),
            Self::InvokeHostFunctionSuccessPreImage(v) => v.write_xdr(w),
            Self::TransactionMeta(v) => v.write_xdr(w),
            Self::TransactionResultMeta(v) => v.write_xdr(w),
            Self::UpgradeEntryMeta(v) => v.write_xdr(w),
            Self::LedgerCloseMetaV0(v) => v.write_xdr(w),
            Self::LedgerCloseMetaExtV1(v) => v.write_xdr(w),
            Self::LedgerCloseMetaExt(v) => v.write_xdr(w),
            Self::LedgerCloseMetaV1(v) => v.write_xdr(w),
            Self::LedgerCloseMeta(v) => v.write_xdr(w),
            Self::ErrorCode(v) => v.write_xdr(w),
            Self::SError(v) => v.write_xdr(w),
            Self::SendMore(v) => v.write_xdr(w),
            Self::SendMoreExtended(v) => v.write_xdr(w),
            Self::AuthCert(v) => v.write_xdr(w),
            Self::Hello(v) => v.write_xdr(w),
            Self::Auth(v) => v.write_xdr(w),
            Self::IpAddrType(v) => v.write_xdr(w),
            Self::PeerAddress(v) => v.write_xdr(w),
            Self::PeerAddressIp(v) => v.write_xdr(w),
            Self::MessageType(v) => v.write_xdr(w),
            Self::DontHave(v) => v.write_xdr(w),
            Self::SurveyMessageCommandType(v) => v.write_xdr(w),
            Self::SurveyMessageResponseType(v) => v.write_xdr(w),
            Self::SurveyRequestMessage(v) => v.write_xdr(w),
            Self::SignedSurveyRequestMessage(v) => v.write_xdr(w),
            Self::EncryptedBody(v) => v.write_xdr(w),
            Self::SurveyResponseMessage(v) => v.write_xdr(w),
            Self::SignedSurveyResponseMessage(v) => v.write_xdr(w),
            Self::PeerStats(v) => v.write_xdr(w),
            Self::PeerStatList(v) => v.write_xdr(w),
            Self::TopologyResponseBodyV0(v) => v.write_xdr(w),
            Self::TopologyResponseBodyV1(v) => v.write_xdr(w),
            Self::SurveyResponseBody(v) => v.write_xdr(w),
            Self::TxAdvertVector(v) => v.write_xdr(w),
            Self::FloodAdvert(v) => v.write_xdr(w),
            Self::TxDemandVector(v) => v.write_xdr(w),
            Self::FloodDemand(v) => v.write_xdr(w),
            Self::StellarMessage(v) => v.write_xdr(w),
            Self::AuthenticatedMessage(v) => v.write_xdr(w),
            Self::AuthenticatedMessageV0(v) => v.write_xdr(w),
            Self::LiquidityPoolParameters(v) => v.write_xdr(w),
            Self::MuxedAccount(v) => v.write_xdr(w),
            Self::MuxedAccountMed25519(v) => v.write_xdr(w),
            Self::DecoratedSignature(v) => v.write_xdr(w),
            Self::OperationType(v) => v.write_xdr(w),
            Self::CreateAccountOp(v) => v.write_xdr(w),
            Self::PaymentOp(v) => v.write_xdr(w),
            Self::PathPaymentStrictReceiveOp(v) => v.write_xdr(w),
            Self::PathPaymentStrictSendOp(v) => v.write_xdr(w),
            Self::ManageSellOfferOp(v) => v.write_xdr(w),
            Self::ManageBuyOfferOp(v) => v.write_xdr(w),
            Self::CreatePassiveSellOfferOp(v) => v.write_xdr(w),
            Self::SetOptionsOp(v) => v.write_xdr(w),
            Self::ChangeTrustAsset(v) => v.write_xdr(w),
            Self::ChangeTrustOp(v) => v.write_xdr(w),
            Self::AllowTrustOp(v) => v.write_xdr(w),
            Self::ManageDataOp(v) => v.write_xdr(w),
            Self::BumpSequenceOp(v) => v.write_xdr(w),
            Self::CreateClaimableBalanceOp(v) => v.write_xdr(w),
            Self::ClaimClaimableBalanceOp(v) => v.write_xdr(w),
            Self::BeginSponsoringFutureReservesOp(v) => v.write_xdr(w),
            Self::RevokeSponsorshipType(v) => v.write_xdr(w),
            Self::RevokeSponsorshipOp(v) => v.write_xdr(w),
            Self::RevokeSponsorshipOpSigner(v) => v.write_xdr(w),
            Self::ClawbackOp(v) => v.write_xdr(w),
            Self::ClawbackClaimableBalanceOp(v) => v.write_xdr(w),
            Self::SetTrustLineFlagsOp(v) => v.write_xdr(w),
            Self::LiquidityPoolDepositOp(v) => v.write_xdr(w),
            Self::LiquidityPoolWithdrawOp(v) => v.write_xdr(w),
            Self::HostFunctionType(v) => v.write_xdr(w),
            Self::ContractIdPreimageType(v) => v.write_xdr(w),
            Self::ContractIdPreimage(v) => v.write_xdr(w),
            Self::ContractIdPreimageFromAddress(v) => v.write_xdr(w),
            Self::CreateContractArgs(v) => v.write_xdr(w),
            Self::InvokeContractArgs(v) => v.write_xdr(w),
            Self::HostFunction(v) => v.write_xdr(w),
            Self::SorobanAuthorizedFunctionType(v) => v.write_xdr(w),
            Self::SorobanAuthorizedFunction(v) => v.write_xdr(w),
            Self::SorobanAuthorizedInvocation(v) => v.write_xdr(w),
            Self::SorobanAddressCredentials(v) => v.write_xdr(w),
            Self::SorobanCredentialsType(v) => v.write_xdr(w),
            Self::SorobanCredentials(v) => v.write_xdr(w),
            Self::SorobanAuthorizationEntry(v) => v.write_xdr(w),
            Self::InvokeHostFunctionOp(v) => v.write_xdr(w),
            Self::ExtendFootprintTtlOp(v) => v.write_xdr(w),
            Self::RestoreFootprintOp(v) => v.write_xdr(w),
            Self::Operation(v) => v.write_xdr(w),
            Self::OperationBody(v) => v.write_xdr(w),
            Self::HashIdPreimage(v) => v.write_xdr(w),
            Self::HashIdPreimageOperationId(v) => v.write_xdr(w),
            Self::HashIdPreimageRevokeId(v) => v.write_xdr(w),
            Self::HashIdPreimageContractId(v) => v.write_xdr(w),
            Self::HashIdPreimageSorobanAuthorization(v) => v.write_xdr(w),
            Self::MemoType(v) => v.write_xdr(w),
            Self::Memo(v) => v.write_xdr(w),
            Self::TimeBounds(v) => v.write_xdr(w),
            Self::LedgerBounds(v) => v.write_xdr(w),
            Self::PreconditionsV2(v) => v.write_xdr(w),
            Self::PreconditionType(v) => v.write_xdr(w),
            Self::Preconditions(v) => v.write_xdr(w),
            Self::LedgerFootprint(v) => v.write_xdr(w),
            Self::SorobanResources(v) => v.write_xdr(w),
            Self::SorobanTransactionData(v) => v.write_xdr(w),
            Self::TransactionV0(v) => v.write_xdr(w),
            Self::TransactionV0Ext(v) => v.write_xdr(w),
            Self::TransactionV0Envelope(v) => v.write_xdr(w),
            Self::Transaction(v) => v.write_xdr(w),
            Self::TransactionExt(v) => v.write_xdr(w),
            Self::TransactionV1Envelope(v) => v.write_xdr(w),
            Self::FeeBumpTransaction(v) => v.write_xdr(w),
            Self::FeeBumpTransactionInnerTx(v) => v.write_xdr(w),
            Self::FeeBumpTransactionExt(v) => v.write_xdr(w),
            Self::FeeBumpTransactionEnvelope(v) => v.write_xdr(w),
            Self::TransactionEnvelope(v) => v.write_xdr(w),
            Self::TransactionSignaturePayload(v) => v.write_xdr(w),
            Self::TransactionSignaturePayloadTaggedTransaction(v) => v.write_xdr(w),
            Self::ClaimAtomType(v) => v.write_xdr(w),
            Self::ClaimOfferAtomV0(v) => v.write_xdr(w),
            Self::ClaimOfferAtom(v) => v.write_xdr(w),
            Self::ClaimLiquidityAtom(v) => v.write_xdr(w),
            Self::ClaimAtom(v) => v.write_xdr(w),
            Self::CreateAccountResultCode(v) => v.write_xdr(w),
            Self::CreateAccountResult(v) => v.write_xdr(w),
            Self::PaymentResultCode(v) => v.write_xdr(w),
            Self::PaymentResult(v) => v.write_xdr(w),
            Self::PathPaymentStrictReceiveResultCode(v) => v.write_xdr(w),
            Self::SimplePaymentResult(v) => v.write_xdr(w),
            Self::PathPaymentStrictReceiveResult(v) => v.write_xdr(w),
            Self::PathPaymentStrictReceiveResultSuccess(v) => v.write_xdr(w),
            Self::PathPaymentStrictSendResultCode(v) => v.write_xdr(w),
            Self::PathPaymentStrictSendResult(v) => v.write_xdr(w),
            Self::PathPaymentStrictSendResultSuccess(v) => v.write_xdr(w),
            Self::ManageSellOfferResultCode(v) => v.write_xdr(w),
            Self::ManageOfferEffect(v) => v.write_xdr(w),
            Self::ManageOfferSuccessResult(v) => v.write_xdr(w),
            Self::ManageOfferSuccessResultOffer(v) => v.write_xdr(w),
            Self::ManageSellOfferResult(v) => v.write_xdr(w),
            Self::ManageBuyOfferResultCode(v) => v.write_xdr(w),
            Self::ManageBuyOfferResult(v) => v.write_xdr(w),
            Self::SetOptionsResultCode(v) => v.write_xdr(w),
            Self::SetOptionsResult(v) => v.write_xdr(w),
            Self::ChangeTrustResultCode(v) => v.write_xdr(w),
            Self::ChangeTrustResult(v) => v.write_xdr(w),
            Self::AllowTrustResultCode(v) => v.write_xdr(w),
            Self::AllowTrustResult(v) => v.write_xdr(w),
            Self::AccountMergeResultCode(v) => v.write_xdr(w),
            Self::AccountMergeResult(v) => v.write_xdr(w),
            Self::InflationResultCode(v) => v.write_xdr(w),
            Self::InflationPayout(v) => v.write_xdr(w),
            Self::InflationResult(v) => v.write_xdr(w),
            Self::ManageDataResultCode(v) => v.write_xdr(w),
            Self::ManageDataResult(v) => v.write_xdr(w),
            Self::BumpSequenceResultCode(v) => v.write_xdr(w),
            Self::BumpSequenceResult(v) => v.write_xdr(w),
            Self::CreateClaimableBalanceResultCode(v) => v.write_xdr(w),
            Self::CreateClaimableBalanceResult(v) => v.write_xdr(w),
            Self::ClaimClaimableBalanceResultCode(v) => v.write_xdr(w),
            Self::ClaimClaimableBalanceResult(v) => v.write_xdr(w),
            Self::BeginSponsoringFutureReservesResultCode(v) => v.write_xdr(w),
            Self::BeginSponsoringFutureReservesResult(v) => v.write_xdr(w),
            Self::EndSponsoringFutureReservesResultCode(v) => v.write_xdr(w),
            Self::EndSponsoringFutureReservesResult(v) => v.write_xdr(w),
            Self::RevokeSponsorshipResultCode(v) => v.write_xdr(w),
            Self::RevokeSponsorshipResult(v) => v.write_xdr(w),
            Self::ClawbackResultCode(v) => v.write_xdr(w),
            Self::ClawbackResult(v) => v.write_xdr(w),
            Self::ClawbackClaimableBalanceResultCode(v) => v.write_xdr(w),
            Self::ClawbackClaimableBalanceResult(v) => v.write_xdr(w),
            Self::SetTrustLineFlagsResultCode(v) => v.write_xdr(w),
            Self::SetTrustLineFlagsResult(v) => v.write_xdr(w),
            Self::LiquidityPoolDepositResultCode(v) => v.write_xdr(w),
            Self::LiquidityPoolDepositResult(v) => v.write_xdr(w),
            Self::LiquidityPoolWithdrawResultCode(v) => v.write_xdr(w),
            Self::LiquidityPoolWithdrawResult(v) => v.write_xdr(w),
            Self::InvokeHostFunctionResultCode(v) => v.write_xdr(w),
            Self::InvokeHostFunctionResult(v) => v.write_xdr(w),
            Self::ExtendFootprintTtlResultCode(v) => v.write_xdr(w),
            Self::ExtendFootprintTtlResult(v) => v.write_xdr(w),
            Self::RestoreFootprintResultCode(v) => v.write_xdr(w),
            Self::RestoreFootprintResult(v) => v.write_xdr(w),
            Self::OperationResultCode(v) => v.write_xdr(w),
            Self::OperationResult(v) => v.write_xdr(w),
            Self::OperationResultTr(v) => v.write_xdr(w),
            Self::TransactionResultCode(v) => v.write_xdr(w),
            Self::InnerTransactionResult(v) => v.write_xdr(w),
            Self::InnerTransactionResultResult(v) => v.write_xdr(w),
            Self::InnerTransactionResultExt(v) => v.write_xdr(w),
            Self::InnerTransactionResultPair(v) => v.write_xdr(w),
            Self::TransactionResult(v) => v.write_xdr(w),
            Self::TransactionResultResult(v) => v.write_xdr(w),
            Self::TransactionResultExt(v) => v.write_xdr(w),
            Self::Hash(v) => v.write_xdr(w),
            Self::Uint256(v) => v.write_xdr(w),
            Self::Uint32(v) => v.write_xdr(w),
            Self::Int32(v) => v.write_xdr(w),
            Self::Uint64(v) => v.write_xdr(w),
            Self::Int64(v) => v.write_xdr(w),
            Self::TimePoint(v) => v.write_xdr(w),
            Self::Duration(v) => v.write_xdr(w),
            Self::ExtensionPoint(v) => v.write_xdr(w),
            Self::CryptoKeyType(v) => v.write_xdr(w),
            Self::PublicKeyType(v) => v.write_xdr(w),
            Self::SignerKeyType(v) => v.write_xdr(w),
            Self::PublicKey(v) => v.write_xdr(w),
            Self::SignerKey(v) => v.write_xdr(w),
            Self::SignerKeyEd25519SignedPayload(v) => v.write_xdr(w),
            Self::Signature(v) => v.write_xdr(w),
            Self::SignatureHint(v) => v.write_xdr(w),
            Self::NodeId(v) => v.write_xdr(w),
            Self::AccountId(v) => v.write_xdr(w),
            Self::Curve25519Secret(v) => v.write_xdr(w),
            Self::Curve25519Public(v) => v.write_xdr(w),
            Self::HmacSha256Key(v) => v.write_xdr(w),
            Self::HmacSha256Mac(v) => v.write_xdr(w),
        }
    }
}
