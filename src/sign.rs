#![allow(clippy::missing_errors_doc)]

use crate::WriteXdr;

/// Sign implementations produce signatures for XDR types.
pub trait Sign {
    type Error;
    type Signature;
    /// Sign produces a signature for the XDR generated by the `WriteXdr`
    /// implementation.
    fn sign(&self, w: impl WriteXdr) -> Result<Self::Signature, Self::Error>;
}

#[cfg(feature = "ed25519")]
pub mod ed25519 {
    #[derive(Debug)]
    pub enum Error {
        XdrError(crate::Error),
        Ed25519SignatureError(ed25519_dalek::SignatureError),
    }

    #[cfg(feature = "std")]
    impl std::error::Error for Error {
        #[must_use]
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            match self {
                Self::XdrError(e) => e.source(),
                Self::Ed25519SignatureError(e) => e.source(),
            }
        }
    }

    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            match self {
                Self::XdrError(e) => write!(f, "{}", e),
                Self::Ed25519SignatureError(e) => write!(f, "{}", e),
            }
        }
    }

    impl From<crate::Error> for Error {
        fn from(e: crate::Error) -> Self {
            Error::XdrError(e)
        }
    }

    impl From<ed25519_dalek::SignatureError> for Error {
        fn from(e: ed25519_dalek::SignatureError) -> Self {
            Error::Ed25519SignatureError(e)
        }
    }

    impl<S> super::Sign for S
    where
        S: ed25519_dalek::Signer<ed25519_dalek::Signature>,
    {
        type Error = Error;
        type Signature = [u8; 64];
        fn sign(&self, w: impl super::WriteXdr) -> Result<Self::Signature, Self::Error> {
            let mut buf = Vec::<u8>::new();
            w.write_xdr(&mut buf)?;
            Ok(self.try_sign(&buf)?.to_bytes())
        }
    }

    #[cfg(test)]
    mod test {
        use ed25519_dalek::{Keypair, PublicKey, SecretKey};

        use crate::sign::Sign;

        #[test]
        fn sign() {
            let sk = SecretKey::from_bytes(
                &hex::decode("5acc7253295dfc356c046297925a369f3d2762d00afdf2583ecbe92180b07c37")
                    .unwrap(),
            )
            .unwrap();
            let pk = PublicKey::from(&sk);
            let kp = Keypair {
                secret: sk,
                public: pk,
            };
            let sig = kp.sign(128u64).unwrap();
            assert_eq!(
                sig,
                // Verified with https://go.dev/play/p/UimGhCOj231.
                hex::decode("d69f462c8b8a283abc5e0060fd89b93f1741a8c1b0507866a41cea95f753a71ba0dec93dce822703401134758400ed20d75b655fe5098bfbf4b6c41687d40c0e").unwrap().as_slice()
            );
        }
    }
}
