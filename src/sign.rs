#![allow(clippy::missing_errors_doc)]

use crate::WriteXdr;

/// Sign implementations produce signatures for XDR types.
pub trait Sign {
    type Error;
    type Signature;
    /// Sign produces a signature for the XDR generated by the `WriteXdr`
    /// implementation.
    fn sign(&self, w: impl WriteXdr) -> Result<Self::Signature, Self::Error>;
}

#[cfg(feature = "ed25519")]
pub mod ed25519 {
    #[derive(Debug)]
    pub enum Error {
        XdrError(crate::Error),
        Ed25519SignatureError(ed25519_dalek::SignatureError),
    }

    #[cfg(feature = "std")]
    impl std::error::Error for Error {
        #[must_use]
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            match self {
                Self::XdrError(e) => e.source(),
                Self::Ed25519SignatureError(e) => e.source(),
            }
        }
    }

    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            match self {
                Self::XdrError(e) => write!(f, "{}", e),
                Self::Ed25519SignatureError(e) => write!(f, "{}", e),
            }
        }
    }

    impl From<crate::Error> for Error {
        fn from(e: crate::Error) -> Self {
            Error::XdrError(e)
        }
    }

    impl From<ed25519_dalek::SignatureError> for Error {
        fn from(e: ed25519_dalek::SignatureError) -> Self {
            Error::Ed25519SignatureError(e)
        }
    }

    impl<S> super::Sign for S
    where
        S: ed25519_dalek::Signer<ed25519_dalek::Signature>,
    {
        type Error = Error;
        type Signature = [u8; 64];
        fn sign(&self, w: impl super::WriteXdr) -> Result<Self::Signature, Self::Error> {
            let mut buf = Vec::<u8>::new();
            w.write_xdr(&mut buf)?;
            Ok(self.try_sign(&buf)?.to_bytes())
        }
    }
}
