#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub enum TypeVariant {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
    #[cfg({{ f }})]
{%- endif %}
    {{ t.name }},
{%- endfor %}
}

impl TypeVariant {
    pub const VARIANTS: &[TypeVariant] = &[
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
        #[cfg({{ f }})]
{%- endif %}
        TypeVariant::{{ t.name }},
{%- endfor %}
    ];
    pub const VARIANTS_STR: &[&str] = &[
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
        #[cfg({{ f }})]
{%- endif %}
        "{{ t.name }}",
{%- endfor %}
    ];

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn name(&self) -> &'static str {
        match self {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            Self::{{ t.name }} => "{{ t.name }}",
{%- endfor %}
        }
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn variants() -> &'static [TypeVariant] {
        Self::VARIANTS
    }

    #[cfg(feature = "schemars")]
    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub fn json_schema(&self, gen: schemars::gen::SchemaGenerator) -> schemars::schema::RootSchema {
        match self {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            Self::{{ t.name }} => gen.into_root_schema_for::<{{ t.name }}>(),
{%- endfor %}
        }
    }
}

impl Name for TypeVariant {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TypeVariant> for TypeVariant {
    fn variants() -> slice::Iter<'static, TypeVariant> {
        Self::VARIANTS.iter()
    }
}

impl core::str::FromStr for TypeVariant {
    type Err = Error;
    #[allow(clippy::too_many_lines)]
    fn from_str(s: &str) -> Result<Self, Error> {
        match s {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            "{{ t.name }}" => Ok(Self::{{ t.name }}),
{%- endfor %}
            _ => Err(Error::Invalid),
        }
    }
}

#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case"),
    serde(untagged),
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
pub enum Type {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
    #[cfg({{ f }})]
{%- endif %}
    {{ t.name }}(Box<{{ t.name }}>),
{%- endfor %}
}

impl Type {
    pub const VARIANTS: &[TypeVariant] = &[
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
        #[cfg({{ f }})]
{%- endif %}
        TypeVariant::{{ t.name }},
{%- endfor %}
    ];
    pub const VARIANTS_STR: &[&str] = &[
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
        #[cfg({{ f }})]
{%- endif %}
        "{{ t.name }}",
{%- endfor %}
    ];

    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Result<Self, Error> {
        match v {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            TypeVariant::{{ t.name }} => r.with_limited_depth(|r| Ok(Self::{{ t.name }}(Box::new({{ t.name }}::read_xdr(r)?)))),
{%- endfor %}
        }
    }

    #[cfg(feature = "base64")]
    pub fn read_xdr_base64<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Result<Self, Error> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(
                SkipWhitespace::new(&mut r.inner),
                &base64::engine::general_purpose::STANDARD,
            ),
            r.limits.clone(),
        );
        let t = Self::read_xdr(v, &mut dec)?;
        Ok(t)
    }

    #[cfg(feature = "std")]
    pub fn read_xdr_to_end<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Result<Self, Error> {
        let s = Self::read_xdr(v, r)?;
        // Check that any further reads, such as this read of one byte, read no
        // data, indicating EOF. If a byte is read the data is invalid.
        if r.read(&mut [0u8; 1])? == 0 {
            Ok(s)
        } else {
            Err(Error::Invalid)
        }
    }

    #[cfg(feature = "base64")]
    pub fn read_xdr_base64_to_end<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Result<Self, Error> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(
                SkipWhitespace::new(&mut r.inner),
                &base64::engine::general_purpose::STANDARD,
            ),
            r.limits.clone(),
        );
        let t = Self::read_xdr_to_end(v, &mut dec)?;
        Ok(t)
    }

    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr_iter<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Box<dyn Iterator<Item=Result<Self, Error>> + '_> {
        match v {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            TypeVariant::{{ t.name }} => Box::new(ReadXdrIter::<_, {{ t.name }}>::new(&mut r.inner, r.limits.clone()).map(|r| r.map(|t| Self::{{ t.name }}(Box::new(t))))),
{%- endfor %}
        }
    }

    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr_framed_iter<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Box<dyn Iterator<Item=Result<Self, Error>> + '_> {
        match v {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            TypeVariant::{{ t.name }} => Box::new(ReadXdrIter::<_, Frame<{{ t.name }}>>::new(&mut r.inner, r.limits.clone()).map(|r| r.map(|t| Self::{{ t.name }}(Box::new(t.0))))),
{%- endfor %}
        }
    }

    #[cfg(feature = "base64")]
    #[allow(clippy::too_many_lines)]
    pub fn read_xdr_base64_iter<R: Read>(v: TypeVariant, r: &mut Limited<R>) -> Box<dyn Iterator<Item=Result<Self, Error>> + '_> {
        let dec = base64::read::DecoderReader::new(
            SkipWhitespace::new(&mut r.inner),
            &base64::engine::general_purpose::STANDARD,
        );
        match v {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            TypeVariant::{{ t.name }} => Box::new(ReadXdrIter::<_, {{ t.name }}>::new(dec, r.limits.clone()).map(|r| r.map(|t| Self::{{ t.name }}(Box::new(t))))),
{%- endfor %}
        }
    }

    #[cfg(feature = "std")]
    pub fn from_xdr<B: AsRef<[u8]>>(v: TypeVariant, bytes: B, limits: Limits) -> Result<Self, Error> {
        let mut cursor = Limited::new(Cursor::new(bytes.as_ref()), limits);
        let t = Self::read_xdr_to_end(v, &mut cursor)?;
        Ok(t)
    }

    #[cfg(feature = "base64")]
    pub fn from_xdr_base64(v: TypeVariant, b64: impl AsRef<[u8]>, limits: Limits) -> Result<Self, Error> {
        let mut dec = Limited::new(
            base64::read::DecoderReader::new(
                SkipWhitespace::new(Cursor::new(b64)),
                &base64::engine::general_purpose::STANDARD,
            ),
            limits,
        );
        let t = Self::read_xdr_to_end(v, &mut dec)?;
        Ok(t)
    }

    #[cfg(all(feature = "std", feature = "serde_json"))]
    #[deprecated(note = "use from_json")]
    pub fn read_json(v: TypeVariant, r: impl Read) -> Result<Self, Error> {
        Self::from_json(v, r)
    }

    #[cfg(all(feature = "std", feature = "serde_json"))]
    #[allow(clippy::too_many_lines)]
    pub fn from_json(v: TypeVariant, r: impl Read) -> Result<Self, Error> {
        match v {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            TypeVariant::{{ t.name }} => Ok(Self::{{ t.name }}(Box::new(serde_json::from_reader(r)?))),
{%- endfor %}
        }
    }

    #[cfg(all(feature = "std", feature = "serde_json"))]
    #[allow(clippy::too_many_lines)]
    pub fn deserialize_json<'r, R: serde_json::de::Read<'r>>(v: TypeVariant, r: &mut serde_json::de::Deserializer<R>) -> Result<Self, Error> {
        match v {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            TypeVariant::{{ t.name }} => Ok(Self::{{ t.name }}(Box::new(serde::de::Deserialize::deserialize(r)?))),
{%- endfor %}
        }
    }

    #[cfg(feature = "arbitrary")]
    #[allow(clippy::too_many_lines)]
    pub fn arbitrary(v: TypeVariant, u: &mut arbitrary::Unstructured<'_>) -> Result<Self, Error> {
        match v {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            TypeVariant::{{ t.name }} => Ok(Self::{{ t.name }}(Box::new({{ t.name }}::arbitrary(u)?))),
{%- endfor %}
        }
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub fn default(v: TypeVariant) -> Self {
        match v {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            TypeVariant::{{ t.name }} => Self::{{ t.name }}(Box::default()),
{%- endfor %}
        }
    }

    #[cfg(feature = "alloc")]
    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub fn value(&self) -> &dyn core::any::Any {
        #[allow(clippy::match_same_arms)]
        match self {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            Self::{{ t.name }}(ref v) => v.as_ref(),
{%- endfor %}
        }
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn name(&self) -> &'static str {
        match self {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            Self::{{ t.name }}(_) => "{{ t.name }}",
{%- endfor %}
        }
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn variants() -> &'static [TypeVariant] {
        Self::VARIANTS
    }

    #[must_use]
    #[allow(clippy::too_many_lines)]
    pub const fn variant(&self) -> TypeVariant {
        match self {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            Self::{{ t.name }}(_) => TypeVariant::{{ t.name }},
{%- endfor %}
        }
    }
}

impl Name for Type {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Variants<TypeVariant> for Type {
    fn variants() -> slice::Iter<'static, TypeVariant> {
        Self::VARIANTS.iter()
    }
}

impl WriteXdr for Type {
    #[cfg(feature = "std")]
    #[allow(clippy::too_many_lines)]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        match self {
{%- for t in type_variant_enum.types %}
{%- if let Some(f) = t.feature %}
            #[cfg({{ f }})]
{%- endif %}
            Self::{{ t.name }}(v) => v.write_xdr(w),
{%- endfor %}
        }
    }
}
