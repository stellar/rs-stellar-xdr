{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
/// {{ t.name }}{{ t.source_comment }}
#[cfg_eval::cfg_eval]
{%- if t.has_default && !t.is_var_array %}
#[cfg_attr(feature = "alloc", derive(Default))]
{%- endif %}
{%- if t.has_default && t.is_var_array %}
#[derive(Default, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
{%- else %}
#[derive(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
{%- endif %}
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
{%- if t.is_custom_str || t.custom_display_fromstr %}
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
{%- else %}
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
{%- endif %}
{%- if !t.is_fixed_opaque %}
#[derive(Debug)]
{%- endif %}
{%- if let Some(serde_as) = t.serde_as_type %}
pub struct {{ t.name }}(
    #[cfg_attr(
        all(feature = "serde", feature = "alloc"),
        serde_as(as = "{{ serde_as }}")
    )]
    pub {{ t.type_ref }},
);
{%- else %}
pub struct {{ t.name }}(pub {{ t.type_ref }});
{%- endif %}

{% if t.custom_debug -%}
{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl core::fmt::Debug for {{ t.name }} {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        write!(f, "{{ t.name }}(")?;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        write!(f, ")")?;
        Ok(())
    }
}
{%- endif %}
{%- if t.custom_display_fromstr %}
{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl core::fmt::Display for {{ t.name }} {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let v = &self.0;
        for b in v {
            write!(f, "{b:02x}")?;
        }
        Ok(())
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
#[cfg(feature = "alloc")]
impl core::str::FromStr for {{ t.name }} {
    type Err = Error;
    fn from_str(s: &str) -> core::result::Result<Self, Self::Err> {
        hex::decode(s).map_err(|_| Error::InvalidHex)?.try_into()
    }
}
{%- endif %}
{%- if t.custom_schemars %}
{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
#[cfg(feature = "schemars")]
impl schemars::JsonSchema for {{ t.name }} {
    fn schema_name() -> String {
        "{{ t.name }}".to_string()
    }

    fn is_referenceable() -> bool {
        false
    }

    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
        let schema = String::json_schema(gen);
        if let schemars::schema::Schema::Object(mut schema) = schema {
            schema.extensions.insert(
                "contentEncoding".to_owned(),
                serde_json::Value::String("hex".to_string()),
            );
            schema.extensions.insert(
                "contentMediaType".to_owned(),
                serde_json::Value::String("application/binary".to_string()),
            );
            let string = *schema.string.unwrap_or_default().clone();
            schema.string = Some(Box::new(schemars::schema::StringValidation {
                max_length: {{ t.size.as_ref().unwrap() }}_u32.checked_mul(2).map(Some).unwrap_or_default(),
                min_length: {{ t.size.as_ref().unwrap() }}_u32.checked_mul(2).map(Some).unwrap_or_default(),
                ..string
            }));
            schema.into()
        } else {
            schema
        }
    }
}
{%- endif %}
{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl From<{{ t.name }}> for {{ t.type_ref }} {
    #[must_use]
    fn from(x: {{ t.name }}) -> Self {
        x.0
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl From<{{ t.type_ref }}> for {{ t.name }} {
    #[must_use]
    fn from(x: {{ t.type_ref }}) -> Self {
        {{ t.name }}(x)
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl AsRef<{{ t.type_ref }}> for {{ t.name }} {
    #[must_use]
    fn as_ref(&self) -> &{{ t.type_ref }} {
        &self.0
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl ReadXdr for {{ t.name }} {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let i = {{ t.read_call }}::read_xdr(r)?;
            let v = {{ t.name }}(i);
            Ok(v)
        })
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl WriteXdr for {{ t.name }} {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| { self.0.write_xdr(w) })
    }
}
{%- if t.is_fixed_array %}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl {{ t.name }} {
    #[must_use]
    pub fn as_slice(&self) -> &[{{ t.element_type }}] {
        &self.0
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
#[cfg(feature = "alloc")]
impl TryFrom<Vec<{{ t.element_type }}>> for {{ t.name }} {
    type Error = Error;
    fn try_from(x: Vec<{{ t.element_type }}>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
#[cfg(feature = "alloc")]
impl TryFrom<&Vec<{{ t.element_type }}>> for {{ t.name }} {
    type Error = Error;
    fn try_from(x: &Vec<{{ t.element_type }}>) -> Result<Self, Error> {
        x.as_slice().try_into()
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl TryFrom<&[{{ t.element_type }}]> for {{ t.name }} {
    type Error = Error;
    fn try_from(x: &[{{ t.element_type }}]) -> Result<Self, Error> {
        Ok({{ t.name }}(x.try_into()?))
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl AsRef<[{{ t.element_type }}]> for {{ t.name }} {
    #[must_use]
    fn as_ref(&self) -> &[{{ t.element_type }}] {
        &self.0
    }
}
{%- endif %}
{%- if t.is_var_array %}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl Deref for {{ t.name }} {
    type Target = {{ t.type_ref }};
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl From<{{ t.name }}> for Vec<{{ t.element_type }}> {
    #[must_use]
    fn from(x: {{ t.name }}) -> Self {
        x.0.0
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl TryFrom<Vec<{{ t.element_type }}>> for {{ t.name }} {
    type Error = Error;
    fn try_from(x: Vec<{{ t.element_type }}>) -> Result<Self, Error> {
        Ok({{ t.name }}(x.try_into()?))
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
#[cfg(feature = "alloc")]
impl TryFrom<&Vec<{{ t.element_type }}>> for {{ t.name }} {
    type Error = Error;
    fn try_from(x: &Vec<{{ t.element_type }}>) -> Result<Self, Error> {
        Ok({{ t.name }}(x.try_into()?))
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl AsRef<Vec<{{ t.element_type }}>> for {{ t.name }} {
    #[must_use]
    fn as_ref(&self) -> &Vec<{{ t.element_type }}> {
        &self.0.0
    }
}

{%- if let Some(f) = t.feature %}
#[cfg({{ f }})]
{%- endif %}
impl AsRef<[{{ t.element_type }}]> for {{ t.name }} {
    #[cfg(feature = "alloc")]
    #[must_use]
    fn as_ref(&self) -> &[{{ t.element_type }}] {
        &self.0.0
    }
    #[cfg(not(feature = "alloc"))]
    #[must_use]
    fn as_ref(&self) -> &[{{ t.element_type }}] {
        self.0.0
    }
}
{%- endif %}

