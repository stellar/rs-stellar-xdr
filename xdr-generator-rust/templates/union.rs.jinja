/// {{ u.name }}{{ u.source_comment }}
// union with discriminant {{ u.discriminant_type }}
#[cfg_eval::cfg_eval]
#[derive(Clone, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
{%- if u.is_custom_str %}
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    derive(serde_with::SerializeDisplay, serde_with::DeserializeFromStr)
)]
{%- else %}
#[cfg_attr(
    all(feature = "serde", feature = "alloc"),
    serde_with::serde_as,
    derive(serde::Serialize, serde::Deserialize),
    serde(rename_all = "snake_case")
)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
{%- endif %}
#[allow(clippy::large_enum_variant)]
pub enum {{ u.name }} {
{%- for arm in u.arms %}
{%- if arm.is_void %}
    {{ arm.case_name }},
{%- else %}
    {{ arm.case_name }}(
{%- if let Some(serde_as) = arm.serde_as_type %}
        #[cfg_attr(
            all(feature = "serde", feature = "alloc"),
            serde_as(as = "{{ serde_as }}")
        )]
{%- endif %}
        {{ arm.type_ref.as_ref().unwrap() }},
    ),
{%- endif %}
{%- endfor %}
}
{%- if u.has_default %}

#[cfg(feature = "alloc")]
impl Default for {{ u.name }} {
    fn default() -> Self {
{%- if let Some(first_type) = u.first_arm_type %}
        Self::{{ u.first_arm_case_name }}({{ first_type }}::default())
{%- else %}
        Self::{{ u.first_arm_case_name }}
{%- endif %}
    }
}
{%- endif %}

impl {{ u.name }} {
    pub const VARIANTS: [{{ u.discriminant_type }}; {{ u.arms.len() }}] = [
{%- for arm in u.arms %}
        {{ arm.case_value }},
{%- endfor %}
    ];
    pub const VARIANTS_STR: [&'static str; {{ u.arms.len() }}] = [{% for arm in u.arms %}"{{ arm.case_name }}", {% endfor %}];

    #[must_use]
    pub const fn name(&self) -> &'static str {
        match self {
{%- for arm in u.arms %}
{%- if arm.is_void %}
            Self::{{ arm.case_name }} => "{{ arm.case_name }}",
{%- else %}
            Self::{{ arm.case_name }}(_) => "{{ arm.case_name }}",
{%- endif %}
{%- endfor %}
        }
    }

    #[must_use]
    pub const fn discriminant(&self) -> {{ u.discriminant_type }} {
        #[allow(clippy::match_same_arms)]
        match self {
{%- for arm in u.arms %}
{%- if arm.is_void %}
            Self::{{ arm.case_name }} => {{ arm.case_value }},
{%- else %}
            Self::{{ arm.case_name }}(_) => {{ arm.case_value }},
{%- endif %}
{%- endfor %}
        }
    }

    #[must_use]
    pub const fn variants() -> [{{ u.discriminant_type }}; {{ u.arms.len() }}] {
        Self::VARIANTS
    }
}

impl Name for {{ u.name }} {
    #[must_use]
    fn name(&self) -> &'static str {
        Self::name(self)
    }
}

impl Discriminant<{{ u.discriminant_type }}> for {{ u.name }} {
    #[must_use]
    fn discriminant(&self) -> {{ u.discriminant_type }} {
        Self::discriminant(self)
    }
}

impl Variants<{{ u.discriminant_type }}> for {{ u.name }} {
    fn variants() -> slice::Iter<'static, {{ u.discriminant_type }}> {
        Self::VARIANTS.iter()
    }
}

impl Union<{{ u.discriminant_type }}> for {{ u.name }} {}

impl ReadXdr for {{ u.name }} {
    #[cfg(feature = "std")]
    fn read_xdr<R: Read>(r: &mut Limited<R>) -> Result<Self, Error> {
        r.with_limited_depth(|r| {
            let dv: {{ u.discriminant_type }} = <{{ u.discriminant_type }} as ReadXdr>::read_xdr(r)?;
            #[allow(clippy::match_same_arms, clippy::match_wildcard_for_single_variants)]
            let v = match dv {
{%- for arm in u.arms %}
{%- if arm.is_void %}
                {{ arm.case_value }} => Self::{{ arm.case_name }},
{%- else %}
                {{ arm.case_value }} => Self::{{ arm.case_name }}({{ arm.read_call.as_ref().unwrap() }}::read_xdr(r)?),
{%- endif %}
{%- endfor %}
                #[allow(unreachable_patterns)]
                _ => return Err(Error::Invalid),
            };
            Ok(v)
        })
    }
}

impl WriteXdr for {{ u.name }} {
    #[cfg(feature = "std")]
    fn write_xdr<W: Write>(&self, w: &mut Limited<W>) -> Result<(), Error> {
        w.with_limited_depth(|w| {
            self.discriminant().write_xdr(w)?;
            #[allow(clippy::match_same_arms)]
            match self {
{%- for arm in u.arms %}
{%- if arm.is_void %}
                Self::{{ arm.case_name }} => ().write_xdr(w)?,
{%- else %}
                Self::{{ arm.case_name }}(v) => v.write_xdr(w)?,
{%- endif %}
{%- endfor %}
            };
            Ok(())
        })
    }
}

