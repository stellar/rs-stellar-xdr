{
  "$schema": "https://json-schema.org/draft/2019-09/schema",
  "title": "LedgerCloseMetaV0",
  "description": "LedgerCloseMetaV0 is an XDR Struct defines as:\n\n```text struct LedgerCloseMetaV0 { LedgerHeaderHistoryEntry ledgerHeader; // NB: txSet is sorted in \"Hash order\" TransactionSet txSet;\n\n// NB: transactions are sorted in apply order here // fees for all transactions are processed first // followed by applying transactions TransactionResultMeta txProcessing<>;\n\n// upgrades are applied last UpgradeEntryMeta upgradesProcessing<>;\n\n// other misc information attached to the ledger close SCPHistoryEntry scpInfo<>; }; ```",
  "type": "object",
  "required": [
    "ledger_header",
    "scp_info",
    "tx_processing",
    "tx_set",
    "upgrades_processing"
  ],
  "properties": {
    "ledger_header": {
      "$ref": "#/definitions/LedgerHeaderHistoryEntry"
    },
    "scp_info": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ScpHistoryEntry"
      },
      "maxItems": 4294967295
    },
    "tx_processing": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/TransactionResultMeta"
      },
      "maxItems": 4294967295
    },
    "tx_set": {
      "$ref": "#/definitions/TransactionSet"
    },
    "upgrades_processing": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/UpgradeEntryMeta"
      },
      "maxItems": 4294967295
    }
  },
  "definitions": {
    "AccountEntry": {
      "description": "AccountEntry is an XDR Struct defines as:\n\n```text struct AccountEntry { AccountID accountID;      // master public key for this account int64 balance;            // in stroops SequenceNumber seqNum;    // last sequence number used for this account uint32 numSubEntries;     // number of sub-entries this account has // drives the reserve AccountID* inflationDest; // Account to vote for during inflation uint32 flags;             // see AccountFlags\n\nstring32 homeDomain; // can be used for reverse federation and memo lookup\n\n// fields used for signatures // thresholds stores unsigned bytes: [weight of master|low|medium|high] Thresholds thresholds;\n\nSigner signers<MAX_SIGNERS>; // possible signers for this account\n\n// reserved for future use union switch (int v) { case 0: void; case 1: AccountEntryExtensionV1 v1; } ext; }; ```",
      "type": "object",
      "required": [
        "account_id",
        "balance",
        "ext",
        "flags",
        "home_domain",
        "num_sub_entries",
        "seq_num",
        "signers",
        "thresholds"
      ],
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        },
        "balance": {
          "type": "integer",
          "format": "int64"
        },
        "ext": {
          "$ref": "#/definitions/AccountEntryExt"
        },
        "flags": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "home_domain": {
          "$ref": "#/definitions/String32"
        },
        "inflation_dest": {
          "anyOf": [
            {
              "$ref": "#/definitions/AccountId"
            },
            {
              "type": "null"
            }
          ]
        },
        "num_sub_entries": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "seq_num": {
          "$ref": "#/definitions/SequenceNumber"
        },
        "signers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Signer"
          },
          "maxItems": 20
        },
        "thresholds": {
          "type": "string",
          "maxLength": 8,
          "minLength": 8,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        }
      }
    },
    "AccountEntryExt": {
      "description": "AccountEntryExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; case 1: AccountEntryExtensionV1 v1; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v1"
          ],
          "properties": {
            "v1": {
              "$ref": "#/definitions/AccountEntryExtensionV1"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "AccountEntryExtensionV1": {
      "description": "AccountEntryExtensionV1 is an XDR Struct defines as:\n\n```text struct AccountEntryExtensionV1 { Liabilities liabilities;\n\nunion switch (int v) { case 0: void; case 2: AccountEntryExtensionV2 v2; } ext; }; ```",
      "type": "object",
      "required": [
        "ext",
        "liabilities"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/AccountEntryExtensionV1Ext"
        },
        "liabilities": {
          "$ref": "#/definitions/Liabilities"
        }
      }
    },
    "AccountEntryExtensionV1Ext": {
      "description": "AccountEntryExtensionV1Ext is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; case 2: AccountEntryExtensionV2 v2; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v2"
          ],
          "properties": {
            "v2": {
              "$ref": "#/definitions/AccountEntryExtensionV2"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "AccountEntryExtensionV2": {
      "description": "AccountEntryExtensionV2 is an XDR Struct defines as:\n\n```text struct AccountEntryExtensionV2 { uint32 numSponsored; uint32 numSponsoring; SponsorshipDescriptor signerSponsoringIDs<MAX_SIGNERS>;\n\nunion switch (int v) { case 0: void; case 3: AccountEntryExtensionV3 v3; } ext; }; ```",
      "type": "object",
      "required": [
        "ext",
        "num_sponsored",
        "num_sponsoring",
        "signer_sponsoring_i_ds"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/AccountEntryExtensionV2Ext"
        },
        "num_sponsored": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "num_sponsoring": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "signer_sponsoring_i_ds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SponsorshipDescriptor"
          },
          "maxItems": 20
        }
      }
    },
    "AccountEntryExtensionV2Ext": {
      "description": "AccountEntryExtensionV2Ext is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; case 3: AccountEntryExtensionV3 v3; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v3"
          ],
          "properties": {
            "v3": {
              "$ref": "#/definitions/AccountEntryExtensionV3"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "AccountEntryExtensionV3": {
      "description": "AccountEntryExtensionV3 is an XDR Struct defines as:\n\n```text struct AccountEntryExtensionV3 { // We can use this to add more fields, or because it is first, to // change AccountEntryExtensionV3 into a union. ExtensionPoint ext;\n\n// Ledger number at which `seqNum` took on its present value. uint32 seqLedger;\n\n// Time at which `seqNum` took on its present value. TimePoint seqTime; }; ```",
      "type": "object",
      "required": [
        "ext",
        "seq_ledger",
        "seq_time"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        },
        "seq_ledger": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "seq_time": {
          "$ref": "#/definitions/TimePoint"
        }
      }
    },
    "AccountId": {
      "type": "string"
    },
    "AccountMergeResult": {
      "description": "AccountMergeResult is an XDR Union defines as:\n\n```text union AccountMergeResult switch (AccountMergeResultCode code) { case ACCOUNT_MERGE_SUCCESS: int64 sourceAccountBalance; // how much got transferred from source account case ACCOUNT_MERGE_MALFORMED: case ACCOUNT_MERGE_NO_ACCOUNT: case ACCOUNT_MERGE_IMMUTABLE_SET: case ACCOUNT_MERGE_HAS_SUB_ENTRIES: case ACCOUNT_MERGE_SEQNUM_TOO_FAR: case ACCOUNT_MERGE_DEST_FULL: case ACCOUNT_MERGE_IS_SPONSOR: void; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "malformed",
            "no_account",
            "immutable_set",
            "has_sub_entries",
            "seqnum_too_far",
            "dest_full",
            "is_sponsor"
          ]
        },
        {
          "type": "object",
          "required": [
            "success"
          ],
          "properties": {
            "success": {
              "type": "integer",
              "format": "int64"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "AllowTrustOp": {
      "description": "AllowTrustOp is an XDR Struct defines as:\n\n```text struct AllowTrustOp { AccountID trustor; AssetCode asset;\n\n// One of 0, AUTHORIZED_FLAG, or AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG uint32 authorize; }; ```",
      "type": "object",
      "required": [
        "asset",
        "authorize",
        "trustor"
      ],
      "properties": {
        "asset": {
          "$ref": "#/definitions/AssetCode"
        },
        "authorize": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "trustor": {
          "$ref": "#/definitions/AccountId"
        }
      }
    },
    "AllowTrustResult": {
      "description": "AllowTrustResult is an XDR Union defines as:\n\n```text union AllowTrustResult switch (AllowTrustResultCode code) { case ALLOW_TRUST_SUCCESS: void; case ALLOW_TRUST_MALFORMED: case ALLOW_TRUST_NO_TRUST_LINE: case ALLOW_TRUST_TRUST_NOT_REQUIRED: case ALLOW_TRUST_CANT_REVOKE: case ALLOW_TRUST_SELF_NOT_ALLOWED: case ALLOW_TRUST_LOW_RESERVE: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "malformed",
        "no_trust_line",
        "trust_not_required",
        "cant_revoke",
        "self_not_allowed",
        "low_reserve"
      ]
    },
    "AlphaNum12": {
      "description": "AlphaNum12 is an XDR Struct defines as:\n\n```text struct AlphaNum12 { AssetCode12 assetCode; AccountID issuer; }; ```",
      "type": "object",
      "required": [
        "asset_code",
        "issuer"
      ],
      "properties": {
        "asset_code": {
          "$ref": "#/definitions/AssetCode12"
        },
        "issuer": {
          "$ref": "#/definitions/AccountId"
        }
      }
    },
    "AlphaNum4": {
      "description": "AlphaNum4 is an XDR Struct defines as:\n\n```text struct AlphaNum4 { AssetCode4 assetCode; AccountID issuer; }; ```",
      "type": "object",
      "required": [
        "asset_code",
        "issuer"
      ],
      "properties": {
        "asset_code": {
          "$ref": "#/definitions/AssetCode4"
        },
        "issuer": {
          "$ref": "#/definitions/AccountId"
        }
      }
    },
    "Asset": {
      "description": "Asset is an XDR Union defines as:\n\n```text union Asset switch (AssetType type) { case ASSET_TYPE_NATIVE: // Not credit void;\n\ncase ASSET_TYPE_CREDIT_ALPHANUM4: AlphaNum4 alphaNum4;\n\ncase ASSET_TYPE_CREDIT_ALPHANUM12: AlphaNum12 alphaNum12;\n\n// add other asset types here in the future }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "native"
          ]
        },
        {
          "type": "object",
          "required": [
            "credit_alphanum4"
          ],
          "properties": {
            "credit_alphanum4": {
              "$ref": "#/definitions/AlphaNum4"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "credit_alphanum12"
          ],
          "properties": {
            "credit_alphanum12": {
              "$ref": "#/definitions/AlphaNum12"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "AssetCode": {
      "type": "string"
    },
    "AssetCode12": {
      "type": "string"
    },
    "AssetCode4": {
      "type": "string"
    },
    "BeginSponsoringFutureReservesOp": {
      "description": "BeginSponsoringFutureReservesOp is an XDR Struct defines as:\n\n```text struct BeginSponsoringFutureReservesOp { AccountID sponsoredID; }; ```",
      "type": "object",
      "required": [
        "sponsored_id"
      ],
      "properties": {
        "sponsored_id": {
          "$ref": "#/definitions/AccountId"
        }
      }
    },
    "BeginSponsoringFutureReservesResult": {
      "description": "BeginSponsoringFutureReservesResult is an XDR Union defines as:\n\n```text union BeginSponsoringFutureReservesResult switch ( BeginSponsoringFutureReservesResultCode code) { case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS: void; case BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED: case BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED: case BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "malformed",
        "already_sponsored",
        "recursive"
      ]
    },
    "BumpSequenceOp": {
      "description": "BumpSequenceOp is an XDR Struct defines as:\n\n```text struct BumpSequenceOp { SequenceNumber bumpTo; }; ```",
      "type": "object",
      "required": [
        "bump_to"
      ],
      "properties": {
        "bump_to": {
          "$ref": "#/definitions/SequenceNumber"
        }
      }
    },
    "BumpSequenceResult": {
      "description": "BumpSequenceResult is an XDR Union defines as:\n\n```text union BumpSequenceResult switch (BumpSequenceResultCode code) { case BUMP_SEQUENCE_SUCCESS: void; case BUMP_SEQUENCE_BAD_SEQ: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "bad_seq"
      ]
    },
    "ChangeTrustAsset": {
      "description": "ChangeTrustAsset is an XDR Union defines as:\n\n```text union ChangeTrustAsset switch (AssetType type) { case ASSET_TYPE_NATIVE: // Not credit void;\n\ncase ASSET_TYPE_CREDIT_ALPHANUM4: AlphaNum4 alphaNum4;\n\ncase ASSET_TYPE_CREDIT_ALPHANUM12: AlphaNum12 alphaNum12;\n\ncase ASSET_TYPE_POOL_SHARE: LiquidityPoolParameters liquidityPool;\n\n// add other asset types here in the future }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "native"
          ]
        },
        {
          "type": "object",
          "required": [
            "credit_alphanum4"
          ],
          "properties": {
            "credit_alphanum4": {
              "$ref": "#/definitions/AlphaNum4"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "credit_alphanum12"
          ],
          "properties": {
            "credit_alphanum12": {
              "$ref": "#/definitions/AlphaNum12"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "pool_share"
          ],
          "properties": {
            "pool_share": {
              "$ref": "#/definitions/LiquidityPoolParameters"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ChangeTrustOp": {
      "description": "ChangeTrustOp is an XDR Struct defines as:\n\n```text struct ChangeTrustOp { ChangeTrustAsset line;\n\n// if limit is set to 0, deletes the trust line int64 limit; }; ```",
      "type": "object",
      "required": [
        "limit",
        "line"
      ],
      "properties": {
        "limit": {
          "type": "integer",
          "format": "int64"
        },
        "line": {
          "$ref": "#/definitions/ChangeTrustAsset"
        }
      }
    },
    "ChangeTrustResult": {
      "description": "ChangeTrustResult is an XDR Union defines as:\n\n```text union ChangeTrustResult switch (ChangeTrustResultCode code) { case CHANGE_TRUST_SUCCESS: void; case CHANGE_TRUST_MALFORMED: case CHANGE_TRUST_NO_ISSUER: case CHANGE_TRUST_INVALID_LIMIT: case CHANGE_TRUST_LOW_RESERVE: case CHANGE_TRUST_SELF_NOT_ALLOWED: case CHANGE_TRUST_TRUST_LINE_MISSING: case CHANGE_TRUST_CANNOT_DELETE: case CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "malformed",
        "no_issuer",
        "invalid_limit",
        "low_reserve",
        "self_not_allowed",
        "trust_line_missing",
        "cannot_delete",
        "not_auth_maintain_liabilities"
      ]
    },
    "ClaimAtom": {
      "description": "ClaimAtom is an XDR Union defines as:\n\n```text union ClaimAtom switch (ClaimAtomType type) { case CLAIM_ATOM_TYPE_V0: ClaimOfferAtomV0 v0; case CLAIM_ATOM_TYPE_ORDER_BOOK: ClaimOfferAtom orderBook; case CLAIM_ATOM_TYPE_LIQUIDITY_POOL: ClaimLiquidityAtom liquidityPool; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "v0"
          ],
          "properties": {
            "v0": {
              "$ref": "#/definitions/ClaimOfferAtomV0"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "order_book"
          ],
          "properties": {
            "order_book": {
              "$ref": "#/definitions/ClaimOfferAtom"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "liquidity_pool"
          ],
          "properties": {
            "liquidity_pool": {
              "$ref": "#/definitions/ClaimLiquidityAtom"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ClaimClaimableBalanceOp": {
      "description": "ClaimClaimableBalanceOp is an XDR Struct defines as:\n\n```text struct ClaimClaimableBalanceOp { ClaimableBalanceID balanceID; }; ```",
      "type": "object",
      "required": [
        "balance_id"
      ],
      "properties": {
        "balance_id": {
          "$ref": "#/definitions/ClaimableBalanceId"
        }
      }
    },
    "ClaimClaimableBalanceResult": {
      "description": "ClaimClaimableBalanceResult is an XDR Union defines as:\n\n```text union ClaimClaimableBalanceResult switch (ClaimClaimableBalanceResultCode code) { case CLAIM_CLAIMABLE_BALANCE_SUCCESS: void; case CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST: case CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM: case CLAIM_CLAIMABLE_BALANCE_LINE_FULL: case CLAIM_CLAIMABLE_BALANCE_NO_TRUST: case CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "does_not_exist",
        "cannot_claim",
        "line_full",
        "no_trust",
        "not_authorized"
      ]
    },
    "ClaimLiquidityAtom": {
      "description": "ClaimLiquidityAtom is an XDR Struct defines as:\n\n```text struct ClaimLiquidityAtom { PoolID liquidityPoolID;\n\n// amount and asset taken from the pool Asset assetSold; int64 amountSold;\n\n// amount and asset sent to the pool Asset assetBought; int64 amountBought; }; ```",
      "type": "object",
      "required": [
        "amount_bought",
        "amount_sold",
        "asset_bought",
        "asset_sold",
        "liquidity_pool_id"
      ],
      "properties": {
        "amount_bought": {
          "type": "integer",
          "format": "int64"
        },
        "amount_sold": {
          "type": "integer",
          "format": "int64"
        },
        "asset_bought": {
          "$ref": "#/definitions/Asset"
        },
        "asset_sold": {
          "$ref": "#/definitions/Asset"
        },
        "liquidity_pool_id": {
          "$ref": "#/definitions/PoolId"
        }
      }
    },
    "ClaimOfferAtom": {
      "description": "ClaimOfferAtom is an XDR Struct defines as:\n\n```text struct ClaimOfferAtom { // emitted to identify the offer AccountID sellerID; // Account that owns the offer int64 offerID;\n\n// amount and asset taken from the owner Asset assetSold; int64 amountSold;\n\n// amount and asset sent to the owner Asset assetBought; int64 amountBought; }; ```",
      "type": "object",
      "required": [
        "amount_bought",
        "amount_sold",
        "asset_bought",
        "asset_sold",
        "offer_id",
        "seller_id"
      ],
      "properties": {
        "amount_bought": {
          "type": "integer",
          "format": "int64"
        },
        "amount_sold": {
          "type": "integer",
          "format": "int64"
        },
        "asset_bought": {
          "$ref": "#/definitions/Asset"
        },
        "asset_sold": {
          "$ref": "#/definitions/Asset"
        },
        "offer_id": {
          "type": "integer",
          "format": "int64"
        },
        "seller_id": {
          "$ref": "#/definitions/AccountId"
        }
      }
    },
    "ClaimOfferAtomV0": {
      "description": "ClaimOfferAtomV0 is an XDR Struct defines as:\n\n```text struct ClaimOfferAtomV0 { // emitted to identify the offer uint256 sellerEd25519; // Account that owns the offer int64 offerID;\n\n// amount and asset taken from the owner Asset assetSold; int64 amountSold;\n\n// amount and asset sent to the owner Asset assetBought; int64 amountBought; }; ```",
      "type": "object",
      "required": [
        "amount_bought",
        "amount_sold",
        "asset_bought",
        "asset_sold",
        "offer_id",
        "seller_ed25519"
      ],
      "properties": {
        "amount_bought": {
          "type": "integer",
          "format": "int64"
        },
        "amount_sold": {
          "type": "integer",
          "format": "int64"
        },
        "asset_bought": {
          "$ref": "#/definitions/Asset"
        },
        "asset_sold": {
          "$ref": "#/definitions/Asset"
        },
        "offer_id": {
          "type": "integer",
          "format": "int64"
        },
        "seller_ed25519": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        }
      }
    },
    "ClaimPredicate": {
      "description": "ClaimPredicate is an XDR Union defines as:\n\n```text union ClaimPredicate switch (ClaimPredicateType type) { case CLAIM_PREDICATE_UNCONDITIONAL: void; case CLAIM_PREDICATE_AND: ClaimPredicate andPredicates<2>; case CLAIM_PREDICATE_OR: ClaimPredicate orPredicates<2>; case CLAIM_PREDICATE_NOT: ClaimPredicate* notPredicate; case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME: int64 absBefore; // Predicate will be true if closeTime < absBefore case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME: int64 relBefore; // Seconds since closeTime of the ledger in which the // ClaimableBalanceEntry was created }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "unconditional"
          ]
        },
        {
          "type": "object",
          "required": [
            "and"
          ],
          "properties": {
            "and": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ClaimPredicate"
              },
              "maxItems": 2
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "or"
          ],
          "properties": {
            "or": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ClaimPredicate"
              },
              "maxItems": 2
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "not"
          ],
          "properties": {
            "not": {
              "anyOf": [
                {
                  "$ref": "#/definitions/ClaimPredicate"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "before_absolute_time"
          ],
          "properties": {
            "before_absolute_time": {
              "type": "integer",
              "format": "int64"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "before_relative_time"
          ],
          "properties": {
            "before_relative_time": {
              "type": "integer",
              "format": "int64"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ClaimableBalanceEntry": {
      "description": "ClaimableBalanceEntry is an XDR Struct defines as:\n\n```text struct ClaimableBalanceEntry { // Unique identifier for this ClaimableBalanceEntry ClaimableBalanceID balanceID;\n\n// List of claimants with associated predicate Claimant claimants<10>;\n\n// Any asset including native Asset asset;\n\n// Amount of asset int64 amount;\n\n// reserved for future use union switch (int v) { case 0: void; case 1: ClaimableBalanceEntryExtensionV1 v1; } ext; }; ```",
      "type": "object",
      "required": [
        "amount",
        "asset",
        "balance_id",
        "claimants",
        "ext"
      ],
      "properties": {
        "amount": {
          "type": "integer",
          "format": "int64"
        },
        "asset": {
          "$ref": "#/definitions/Asset"
        },
        "balance_id": {
          "$ref": "#/definitions/ClaimableBalanceId"
        },
        "claimants": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Claimant"
          },
          "maxItems": 10
        },
        "ext": {
          "$ref": "#/definitions/ClaimableBalanceEntryExt"
        }
      }
    },
    "ClaimableBalanceEntryExt": {
      "description": "ClaimableBalanceEntryExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; case 1: ClaimableBalanceEntryExtensionV1 v1; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v1"
          ],
          "properties": {
            "v1": {
              "$ref": "#/definitions/ClaimableBalanceEntryExtensionV1"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ClaimableBalanceEntryExtensionV1": {
      "description": "ClaimableBalanceEntryExtensionV1 is an XDR Struct defines as:\n\n```text struct ClaimableBalanceEntryExtensionV1 { union switch (int v) { case 0: void; } ext;\n\nuint32 flags; // see ClaimableBalanceFlags }; ```",
      "type": "object",
      "required": [
        "ext",
        "flags"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/ClaimableBalanceEntryExtensionV1Ext"
        },
        "flags": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "ClaimableBalanceEntryExtensionV1Ext": {
      "description": "ClaimableBalanceEntryExtensionV1Ext is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; } ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "ClaimableBalanceId": {
      "type": "string"
    },
    "Claimant": {
      "description": "Claimant is an XDR Union defines as:\n\n```text union Claimant switch (ClaimantType type) { case CLAIMANT_TYPE_V0: struct { AccountID destination;    // The account that can use this condition ClaimPredicate predicate; // Claimable if predicate is true } v0; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "claimant_type_v0"
          ],
          "properties": {
            "claimant_type_v0": {
              "$ref": "#/definitions/ClaimantV0"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ClaimantV0": {
      "description": "ClaimantV0 is an XDR NestedStruct defines as:\n\n```text struct { AccountID destination;    // The account that can use this condition ClaimPredicate predicate; // Claimable if predicate is true } ```",
      "type": "object",
      "required": [
        "destination",
        "predicate"
      ],
      "properties": {
        "destination": {
          "$ref": "#/definitions/AccountId"
        },
        "predicate": {
          "$ref": "#/definitions/ClaimPredicate"
        }
      }
    },
    "ClawbackClaimableBalanceOp": {
      "description": "ClawbackClaimableBalanceOp is an XDR Struct defines as:\n\n```text struct ClawbackClaimableBalanceOp { ClaimableBalanceID balanceID; }; ```",
      "type": "object",
      "required": [
        "balance_id"
      ],
      "properties": {
        "balance_id": {
          "$ref": "#/definitions/ClaimableBalanceId"
        }
      }
    },
    "ClawbackClaimableBalanceResult": {
      "description": "ClawbackClaimableBalanceResult is an XDR Union defines as:\n\n```text union ClawbackClaimableBalanceResult switch ( ClawbackClaimableBalanceResultCode code) { case CLAWBACK_CLAIMABLE_BALANCE_SUCCESS: void; case CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST: case CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER: case CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "does_not_exist",
        "not_issuer",
        "not_clawback_enabled"
      ]
    },
    "ClawbackOp": {
      "description": "ClawbackOp is an XDR Struct defines as:\n\n```text struct ClawbackOp { Asset asset; MuxedAccount from; int64 amount; }; ```",
      "type": "object",
      "required": [
        "amount",
        "asset",
        "from"
      ],
      "properties": {
        "amount": {
          "type": "integer",
          "format": "int64"
        },
        "asset": {
          "$ref": "#/definitions/Asset"
        },
        "from": {
          "$ref": "#/definitions/MuxedAccount"
        }
      }
    },
    "ClawbackResult": {
      "description": "ClawbackResult is an XDR Union defines as:\n\n```text union ClawbackResult switch (ClawbackResultCode code) { case CLAWBACK_SUCCESS: void; case CLAWBACK_MALFORMED: case CLAWBACK_NOT_CLAWBACK_ENABLED: case CLAWBACK_NO_TRUST: case CLAWBACK_UNDERFUNDED: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "malformed",
        "not_clawback_enabled",
        "no_trust",
        "underfunded"
      ]
    },
    "ConfigSettingContractBandwidthV0": {
      "description": "ConfigSettingContractBandwidthV0 is an XDR Struct defines as:\n\n```text struct ConfigSettingContractBandwidthV0 { // Maximum sum of all transaction sizes in the ledger in bytes uint32 ledgerMaxTxsSizeBytes; // Maximum size in bytes for a transaction uint32 txMaxSizeBytes;\n\n// Fee for 1 KB of transaction size int64 feeTxSize1KB; }; ```",
      "type": "object",
      "required": [
        "fee_tx_size1_kb",
        "ledger_max_txs_size_bytes",
        "tx_max_size_bytes"
      ],
      "properties": {
        "fee_tx_size1_kb": {
          "type": "integer",
          "format": "int64"
        },
        "ledger_max_txs_size_bytes": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx_max_size_bytes": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "ConfigSettingContractComputeV0": {
      "description": "ConfigSettingContractComputeV0 is an XDR Struct defines as:\n\n```text struct ConfigSettingContractComputeV0 { // Maximum instructions per ledger int64 ledgerMaxInstructions; // Maximum instructions per transaction int64 txMaxInstructions; // Cost of 10000 instructions int64 feeRatePerInstructionsIncrement;\n\n// Memory limit per transaction. Unlike instructions, there is no fee // for memory, just the limit. uint32 txMemoryLimit; }; ```",
      "type": "object",
      "required": [
        "fee_rate_per_instructions_increment",
        "ledger_max_instructions",
        "tx_max_instructions",
        "tx_memory_limit"
      ],
      "properties": {
        "fee_rate_per_instructions_increment": {
          "type": "integer",
          "format": "int64"
        },
        "ledger_max_instructions": {
          "type": "integer",
          "format": "int64"
        },
        "tx_max_instructions": {
          "type": "integer",
          "format": "int64"
        },
        "tx_memory_limit": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "ConfigSettingContractEventsV0": {
      "description": "ConfigSettingContractEventsV0 is an XDR Struct defines as:\n\n```text struct ConfigSettingContractEventsV0 { // Maximum size of events that a contract call can emit. uint32 txMaxContractEventsSizeBytes; // Fee for generating 1KB of contract events. int64 feeContractEvents1KB; }; ```",
      "type": "object",
      "required": [
        "fee_contract_events1_kb",
        "tx_max_contract_events_size_bytes"
      ],
      "properties": {
        "fee_contract_events1_kb": {
          "type": "integer",
          "format": "int64"
        },
        "tx_max_contract_events_size_bytes": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "ConfigSettingContractExecutionLanesV0": {
      "description": "ConfigSettingContractExecutionLanesV0 is an XDR Struct defines as:\n\n```text struct ConfigSettingContractExecutionLanesV0 { // maximum number of Soroban transactions per ledger uint32 ledgerMaxTxCount; }; ```",
      "type": "object",
      "required": [
        "ledger_max_tx_count"
      ],
      "properties": {
        "ledger_max_tx_count": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "ConfigSettingContractHistoricalDataV0": {
      "description": "ConfigSettingContractHistoricalDataV0 is an XDR Struct defines as:\n\n```text struct ConfigSettingContractHistoricalDataV0 { int64 feeHistorical1KB; // Fee for storing 1KB in archives }; ```",
      "type": "object",
      "required": [
        "fee_historical1_kb"
      ],
      "properties": {
        "fee_historical1_kb": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "ConfigSettingContractLedgerCostExtV0": {
      "description": "ConfigSettingContractLedgerCostExtV0 is an XDR Struct defines as:\n\n```text struct ConfigSettingContractLedgerCostExtV0 { // Maximum number of in-memory ledger entry read operations per transaction uint32 txMaxInMemoryReadEntries; // Fee per 1 KB of data written to the ledger. // Unlike the rent fee, this is a flat fee that is charged for any ledger // write, independent of the type of the entry being written. int64 feeWrite1KB; }; ```",
      "type": "object",
      "required": [
        "fee_write1_kb",
        "tx_max_in_memory_read_entries"
      ],
      "properties": {
        "fee_write1_kb": {
          "type": "integer",
          "format": "int64"
        },
        "tx_max_in_memory_read_entries": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "ConfigSettingContractLedgerCostV0": {
      "description": "ConfigSettingContractLedgerCostV0 is an XDR Struct defines as:\n\n```text struct ConfigSettingContractLedgerCostV0 { // Maximum number of disk entry read operations per ledger uint32 ledgerMaxDiskReadEntries; // Maximum number of bytes of disk reads that can be performed per ledger uint32 ledgerMaxDiskReadBytes; // Maximum number of ledger entry write operations per ledger uint32 ledgerMaxWriteLedgerEntries; // Maximum number of bytes that can be written per ledger uint32 ledgerMaxWriteBytes;\n\n// Maximum number of disk entry read operations per transaction uint32 txMaxDiskReadEntries; // Maximum number of bytes of disk reads that can be performed per transaction uint32 txMaxDiskReadBytes; // Maximum number of ledger entry write operations per transaction uint32 txMaxWriteLedgerEntries; // Maximum number of bytes that can be written per transaction uint32 txMaxWriteBytes;\n\nint64 feeDiskReadLedgerEntry;  // Fee per disk ledger entry read int64 feeWriteLedgerEntry;     // Fee per ledger entry write\n\nint64 feeDiskRead1KB;          // Fee for reading 1KB disk\n\n// The following parameters determine the write fee per 1KB. // Rent fee grows linearly until soroban state reaches this size int64 sorobanStateTargetSizeBytes; // Fee per 1KB rent when the soroban state is empty int64 rentFee1KBSorobanStateSizeLow; // Fee per 1KB rent when the soroban state has reached `sorobanStateTargetSizeBytes` int64 rentFee1KBSorobanStateSizeHigh; // Rent fee multiplier for any additional data past the first `sorobanStateTargetSizeBytes` uint32 sorobanStateRentFeeGrowthFactor; }; ```",
      "type": "object",
      "required": [
        "fee_disk_read1_kb",
        "fee_disk_read_ledger_entry",
        "fee_write_ledger_entry",
        "ledger_max_disk_read_bytes",
        "ledger_max_disk_read_entries",
        "ledger_max_write_bytes",
        "ledger_max_write_ledger_entries",
        "rent_fee1_kb_soroban_state_size_high",
        "rent_fee1_kb_soroban_state_size_low",
        "soroban_state_rent_fee_growth_factor",
        "soroban_state_target_size_bytes",
        "tx_max_disk_read_bytes",
        "tx_max_disk_read_entries",
        "tx_max_write_bytes",
        "tx_max_write_ledger_entries"
      ],
      "properties": {
        "fee_disk_read1_kb": {
          "type": "integer",
          "format": "int64"
        },
        "fee_disk_read_ledger_entry": {
          "type": "integer",
          "format": "int64"
        },
        "fee_write_ledger_entry": {
          "type": "integer",
          "format": "int64"
        },
        "ledger_max_disk_read_bytes": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "ledger_max_disk_read_entries": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "ledger_max_write_bytes": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "ledger_max_write_ledger_entries": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "rent_fee1_kb_soroban_state_size_high": {
          "type": "integer",
          "format": "int64"
        },
        "rent_fee1_kb_soroban_state_size_low": {
          "type": "integer",
          "format": "int64"
        },
        "soroban_state_rent_fee_growth_factor": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "soroban_state_target_size_bytes": {
          "type": "integer",
          "format": "int64"
        },
        "tx_max_disk_read_bytes": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx_max_disk_read_entries": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx_max_write_bytes": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "tx_max_write_ledger_entries": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "ConfigSettingContractParallelComputeV0": {
      "description": "ConfigSettingContractParallelComputeV0 is an XDR Struct defines as:\n\n```text struct ConfigSettingContractParallelComputeV0 { // Maximum number of clusters with dependent transactions allowed in a // stage of parallel tx set component. // This effectively sets the lower bound on the number of physical threads // necessary to effectively apply transaction sets in parallel. uint32 ledgerMaxDependentTxClusters; }; ```",
      "type": "object",
      "required": [
        "ledger_max_dependent_tx_clusters"
      ],
      "properties": {
        "ledger_max_dependent_tx_clusters": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "ConfigSettingEntry": {
      "description": "ConfigSettingEntry is an XDR Union defines as:\n\n```text union ConfigSettingEntry switch (ConfigSettingID configSettingID) { case CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES: uint32 contractMaxSizeBytes; case CONFIG_SETTING_CONTRACT_COMPUTE_V0: ConfigSettingContractComputeV0 contractCompute; case CONFIG_SETTING_CONTRACT_LEDGER_COST_V0: ConfigSettingContractLedgerCostV0 contractLedgerCost; case CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0: ConfigSettingContractHistoricalDataV0 contractHistoricalData; case CONFIG_SETTING_CONTRACT_EVENTS_V0: ConfigSettingContractEventsV0 contractEvents; case CONFIG_SETTING_CONTRACT_BANDWIDTH_V0: ConfigSettingContractBandwidthV0 contractBandwidth; case CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS: ContractCostParams contractCostParamsCpuInsns; case CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES: ContractCostParams contractCostParamsMemBytes; case CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES: uint32 contractDataKeySizeBytes; case CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES: uint32 contractDataEntrySizeBytes; case CONFIG_SETTING_STATE_ARCHIVAL: StateArchivalSettings stateArchivalSettings; case CONFIG_SETTING_CONTRACT_EXECUTION_LANES: ConfigSettingContractExecutionLanesV0 contractExecutionLanes; case CONFIG_SETTING_LIVE_SOROBAN_STATE_SIZE_WINDOW: uint64 liveSorobanStateSizeWindow<>; case CONFIG_SETTING_EVICTION_ITERATOR: EvictionIterator evictionIterator; case CONFIG_SETTING_CONTRACT_PARALLEL_COMPUTE_V0: ConfigSettingContractParallelComputeV0 contractParallelCompute; case CONFIG_SETTING_CONTRACT_LEDGER_COST_EXT_V0: ConfigSettingContractLedgerCostExtV0 contractLedgerCostExt; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "contract_max_size_bytes"
          ],
          "properties": {
            "contract_max_size_bytes": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_compute_v0"
          ],
          "properties": {
            "contract_compute_v0": {
              "$ref": "#/definitions/ConfigSettingContractComputeV0"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_ledger_cost_v0"
          ],
          "properties": {
            "contract_ledger_cost_v0": {
              "$ref": "#/definitions/ConfigSettingContractLedgerCostV0"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_historical_data_v0"
          ],
          "properties": {
            "contract_historical_data_v0": {
              "$ref": "#/definitions/ConfigSettingContractHistoricalDataV0"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_events_v0"
          ],
          "properties": {
            "contract_events_v0": {
              "$ref": "#/definitions/ConfigSettingContractEventsV0"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_bandwidth_v0"
          ],
          "properties": {
            "contract_bandwidth_v0": {
              "$ref": "#/definitions/ConfigSettingContractBandwidthV0"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_cost_params_cpu_instructions"
          ],
          "properties": {
            "contract_cost_params_cpu_instructions": {
              "$ref": "#/definitions/ContractCostParams"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_cost_params_memory_bytes"
          ],
          "properties": {
            "contract_cost_params_memory_bytes": {
              "$ref": "#/definitions/ContractCostParams"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_data_key_size_bytes"
          ],
          "properties": {
            "contract_data_key_size_bytes": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_data_entry_size_bytes"
          ],
          "properties": {
            "contract_data_entry_size_bytes": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "state_archival"
          ],
          "properties": {
            "state_archival": {
              "$ref": "#/definitions/StateArchivalSettings"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_execution_lanes"
          ],
          "properties": {
            "contract_execution_lanes": {
              "$ref": "#/definitions/ConfigSettingContractExecutionLanesV0"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "live_soroban_state_size_window"
          ],
          "properties": {
            "live_soroban_state_size_window": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "maxItems": 4294967295
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "eviction_iterator"
          ],
          "properties": {
            "eviction_iterator": {
              "$ref": "#/definitions/EvictionIterator"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_parallel_compute_v0"
          ],
          "properties": {
            "contract_parallel_compute_v0": {
              "$ref": "#/definitions/ConfigSettingContractParallelComputeV0"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_ledger_cost_ext_v0"
          ],
          "properties": {
            "contract_ledger_cost_ext_v0": {
              "$ref": "#/definitions/ConfigSettingContractLedgerCostExtV0"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ConfigSettingId": {
      "description": "ConfigSettingId is an XDR Enum defines as:\n\n```text enum ConfigSettingID { CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES = 0, CONFIG_SETTING_CONTRACT_COMPUTE_V0 = 1, CONFIG_SETTING_CONTRACT_LEDGER_COST_V0 = 2, CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0 = 3, CONFIG_SETTING_CONTRACT_EVENTS_V0 = 4, CONFIG_SETTING_CONTRACT_BANDWIDTH_V0 = 5, CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS = 6, CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES = 7, CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES = 8, CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES = 9, CONFIG_SETTING_STATE_ARCHIVAL = 10, CONFIG_SETTING_CONTRACT_EXECUTION_LANES = 11, CONFIG_SETTING_LIVE_SOROBAN_STATE_SIZE_WINDOW = 12, CONFIG_SETTING_EVICTION_ITERATOR = 13, CONFIG_SETTING_CONTRACT_PARALLEL_COMPUTE_V0 = 14, CONFIG_SETTING_CONTRACT_LEDGER_COST_EXT_V0 = 15 }; ```",
      "type": "string",
      "enum": [
        "contract_max_size_bytes",
        "contract_compute_v0",
        "contract_ledger_cost_v0",
        "contract_historical_data_v0",
        "contract_events_v0",
        "contract_bandwidth_v0",
        "contract_cost_params_cpu_instructions",
        "contract_cost_params_memory_bytes",
        "contract_data_key_size_bytes",
        "contract_data_entry_size_bytes",
        "state_archival",
        "contract_execution_lanes",
        "live_soroban_state_size_window",
        "eviction_iterator",
        "contract_parallel_compute_v0",
        "contract_ledger_cost_ext_v0"
      ]
    },
    "ConfigUpgradeSetKey": {
      "description": "ConfigUpgradeSetKey is an XDR Struct defines as:\n\n```text struct ConfigUpgradeSetKey { ContractID contractID; Hash contentHash; }; ```",
      "type": "object",
      "required": [
        "content_hash",
        "contract_id"
      ],
      "properties": {
        "content_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "contract_id": {
          "$ref": "#/definitions/ContractId"
        }
      }
    },
    "ContractCodeCostInputs": {
      "description": "ContractCodeCostInputs is an XDR Struct defines as:\n\n```text struct ContractCodeCostInputs { ExtensionPoint ext; uint32 nInstructions; uint32 nFunctions; uint32 nGlobals; uint32 nTableEntries; uint32 nTypes; uint32 nDataSegments; uint32 nElemSegments; uint32 nImports; uint32 nExports; uint32 nDataSegmentBytes; }; ```",
      "type": "object",
      "required": [
        "ext",
        "n_data_segment_bytes",
        "n_data_segments",
        "n_elem_segments",
        "n_exports",
        "n_functions",
        "n_globals",
        "n_imports",
        "n_instructions",
        "n_table_entries",
        "n_types"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        },
        "n_data_segment_bytes": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_data_segments": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_elem_segments": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_exports": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_functions": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_globals": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_imports": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_instructions": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_table_entries": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_types": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "ContractCodeEntry": {
      "description": "ContractCodeEntry is an XDR Struct defines as:\n\n```text struct ContractCodeEntry { union switch (int v) { case 0: void; case 1: struct { ExtensionPoint ext; ContractCodeCostInputs costInputs; } v1; } ext;\n\nHash hash; opaque code<>; }; ```",
      "type": "object",
      "required": [
        "code",
        "ext",
        "hash"
      ],
      "properties": {
        "code": {
          "type": "string",
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "ext": {
          "$ref": "#/definitions/ContractCodeEntryExt"
        },
        "hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        }
      }
    },
    "ContractCodeEntryExt": {
      "description": "ContractCodeEntryExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; case 1: struct { ExtensionPoint ext; ContractCodeCostInputs costInputs; } v1; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v1"
          ],
          "properties": {
            "v1": {
              "$ref": "#/definitions/ContractCodeEntryV1"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ContractCodeEntryV1": {
      "description": "ContractCodeEntryV1 is an XDR NestedStruct defines as:\n\n```text struct { ExtensionPoint ext; ContractCodeCostInputs costInputs; } ```",
      "type": "object",
      "required": [
        "cost_inputs",
        "ext"
      ],
      "properties": {
        "cost_inputs": {
          "$ref": "#/definitions/ContractCodeCostInputs"
        },
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        }
      }
    },
    "ContractCostParamEntry": {
      "description": "ContractCostParamEntry is an XDR Struct defines as:\n\n```text struct ContractCostParamEntry { // use `ext` to add more terms (e.g. higher order polynomials) in the future ExtensionPoint ext;\n\nint64 constTerm; int64 linearTerm; }; ```",
      "type": "object",
      "required": [
        "const_term",
        "ext",
        "linear_term"
      ],
      "properties": {
        "const_term": {
          "type": "integer",
          "format": "int64"
        },
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        },
        "linear_term": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "ContractCostParams": {
      "description": "ContractCostParams is an XDR Typedef defines as:\n\n```text typedef ContractCostParamEntry ContractCostParams<CONTRACT_COST_COUNT_LIMIT>; ```",
      "type": "array",
      "items": {
        "$ref": "#/definitions/ContractCostParamEntry"
      },
      "maxItems": 1024
    },
    "ContractDataDurability": {
      "description": "ContractDataDurability is an XDR Enum defines as:\n\n```text enum ContractDataDurability { TEMPORARY = 0, PERSISTENT = 1 }; ```",
      "type": "string",
      "enum": [
        "temporary",
        "persistent"
      ]
    },
    "ContractDataEntry": {
      "description": "ContractDataEntry is an XDR Struct defines as:\n\n```text struct ContractDataEntry { ExtensionPoint ext;\n\nSCAddress contract; SCVal key; ContractDataDurability durability; SCVal val; }; ```",
      "type": "object",
      "required": [
        "contract",
        "durability",
        "ext",
        "key",
        "val"
      ],
      "properties": {
        "contract": {
          "$ref": "#/definitions/ScAddress"
        },
        "durability": {
          "$ref": "#/definitions/ContractDataDurability"
        },
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        },
        "key": {
          "$ref": "#/definitions/ScVal"
        },
        "val": {
          "$ref": "#/definitions/ScVal"
        }
      }
    },
    "ContractEvent": {
      "description": "ContractEvent is an XDR Struct defines as:\n\n```text struct ContractEvent { // We can use this to add more fields, or because it // is first, to change ContractEvent into a union. ExtensionPoint ext;\n\nContractID* contractID; ContractEventType type;\n\nunion switch (int v) { case 0: struct { SCVal topics<>; SCVal data; } v0; } body; }; ```",
      "type": "object",
      "required": [
        "body",
        "ext",
        "type_"
      ],
      "properties": {
        "body": {
          "$ref": "#/definitions/ContractEventBody"
        },
        "contract_id": {
          "anyOf": [
            {
              "$ref": "#/definitions/ContractId"
            },
            {
              "type": "null"
            }
          ]
        },
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        },
        "type_": {
          "$ref": "#/definitions/ContractEventType"
        }
      }
    },
    "ContractEventBody": {
      "description": "ContractEventBody is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: struct { SCVal topics<>; SCVal data; } v0; } ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "v0"
          ],
          "properties": {
            "v0": {
              "$ref": "#/definitions/ContractEventV0"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ContractEventType": {
      "description": "ContractEventType is an XDR Enum defines as:\n\n```text enum ContractEventType { SYSTEM = 0, CONTRACT = 1, DIAGNOSTIC = 2 }; ```",
      "type": "string",
      "enum": [
        "system",
        "contract",
        "diagnostic"
      ]
    },
    "ContractEventV0": {
      "description": "ContractEventV0 is an XDR NestedStruct defines as:\n\n```text struct { SCVal topics<>; SCVal data; } ```",
      "type": "object",
      "required": [
        "data",
        "topics"
      ],
      "properties": {
        "data": {
          "$ref": "#/definitions/ScVal"
        },
        "topics": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScVal"
          },
          "maxItems": 4294967295
        }
      }
    },
    "ContractExecutable": {
      "description": "ContractExecutable is an XDR Union defines as:\n\n```text union ContractExecutable switch (ContractExecutableType type) { case CONTRACT_EXECUTABLE_WASM: Hash wasm_hash; case CONTRACT_EXECUTABLE_STELLAR_ASSET: void; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "stellar_asset"
          ]
        },
        {
          "type": "object",
          "required": [
            "wasm"
          ],
          "properties": {
            "wasm": {
              "type": "string",
              "maxLength": 64,
              "minLength": 64,
              "contentEncoding": "hex",
              "contentMediaType": "application/binary"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ContractId": {
      "type": "string"
    },
    "ContractIdPreimage": {
      "description": "ContractIdPreimage is an XDR Union defines as:\n\n```text union ContractIDPreimage switch (ContractIDPreimageType type) { case CONTRACT_ID_PREIMAGE_FROM_ADDRESS: struct { SCAddress address; uint256 salt; } fromAddress; case CONTRACT_ID_PREIMAGE_FROM_ASSET: Asset fromAsset; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "address"
          ],
          "properties": {
            "address": {
              "$ref": "#/definitions/ContractIdPreimageFromAddress"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "asset"
          ],
          "properties": {
            "asset": {
              "$ref": "#/definitions/Asset"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ContractIdPreimageFromAddress": {
      "description": "ContractIdPreimageFromAddress is an XDR NestedStruct defines as:\n\n```text struct { SCAddress address; uint256 salt; } ```",
      "type": "object",
      "required": [
        "address",
        "salt"
      ],
      "properties": {
        "address": {
          "$ref": "#/definitions/ScAddress"
        },
        "salt": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        }
      }
    },
    "CreateAccountOp": {
      "description": "CreateAccountOp is an XDR Struct defines as:\n\n```text struct CreateAccountOp { AccountID destination; // account to create int64 startingBalance; // amount they end up with }; ```",
      "type": "object",
      "required": [
        "destination",
        "starting_balance"
      ],
      "properties": {
        "destination": {
          "$ref": "#/definitions/AccountId"
        },
        "starting_balance": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "CreateAccountResult": {
      "description": "CreateAccountResult is an XDR Union defines as:\n\n```text union CreateAccountResult switch (CreateAccountResultCode code) { case CREATE_ACCOUNT_SUCCESS: void; case CREATE_ACCOUNT_MALFORMED: case CREATE_ACCOUNT_UNDERFUNDED: case CREATE_ACCOUNT_LOW_RESERVE: case CREATE_ACCOUNT_ALREADY_EXIST: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "malformed",
        "underfunded",
        "low_reserve",
        "already_exist"
      ]
    },
    "CreateClaimableBalanceOp": {
      "description": "CreateClaimableBalanceOp is an XDR Struct defines as:\n\n```text struct CreateClaimableBalanceOp { Asset asset; int64 amount; Claimant claimants<10>; }; ```",
      "type": "object",
      "required": [
        "amount",
        "asset",
        "claimants"
      ],
      "properties": {
        "amount": {
          "type": "integer",
          "format": "int64"
        },
        "asset": {
          "$ref": "#/definitions/Asset"
        },
        "claimants": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Claimant"
          },
          "maxItems": 10
        }
      }
    },
    "CreateClaimableBalanceResult": {
      "description": "CreateClaimableBalanceResult is an XDR Union defines as:\n\n```text union CreateClaimableBalanceResult switch ( CreateClaimableBalanceResultCode code) { case CREATE_CLAIMABLE_BALANCE_SUCCESS: ClaimableBalanceID balanceID; case CREATE_CLAIMABLE_BALANCE_MALFORMED: case CREATE_CLAIMABLE_BALANCE_LOW_RESERVE: case CREATE_CLAIMABLE_BALANCE_NO_TRUST: case CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED: case CREATE_CLAIMABLE_BALANCE_UNDERFUNDED: void; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "malformed",
            "low_reserve",
            "no_trust",
            "not_authorized",
            "underfunded"
          ]
        },
        {
          "type": "object",
          "required": [
            "success"
          ],
          "properties": {
            "success": {
              "$ref": "#/definitions/ClaimableBalanceId"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "CreateContractArgs": {
      "description": "CreateContractArgs is an XDR Struct defines as:\n\n```text struct CreateContractArgs { ContractIDPreimage contractIDPreimage; ContractExecutable executable; }; ```",
      "type": "object",
      "required": [
        "contract_id_preimage",
        "executable"
      ],
      "properties": {
        "contract_id_preimage": {
          "$ref": "#/definitions/ContractIdPreimage"
        },
        "executable": {
          "$ref": "#/definitions/ContractExecutable"
        }
      }
    },
    "CreateContractArgsV2": {
      "description": "CreateContractArgsV2 is an XDR Struct defines as:\n\n```text struct CreateContractArgsV2 { ContractIDPreimage contractIDPreimage; ContractExecutable executable; // Arguments of the contract's constructor. SCVal constructorArgs<>; }; ```",
      "type": "object",
      "required": [
        "constructor_args",
        "contract_id_preimage",
        "executable"
      ],
      "properties": {
        "constructor_args": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScVal"
          },
          "maxItems": 4294967295
        },
        "contract_id_preimage": {
          "$ref": "#/definitions/ContractIdPreimage"
        },
        "executable": {
          "$ref": "#/definitions/ContractExecutable"
        }
      }
    },
    "CreatePassiveSellOfferOp": {
      "description": "CreatePassiveSellOfferOp is an XDR Struct defines as:\n\n```text struct CreatePassiveSellOfferOp { Asset selling; // A Asset buying;  // B int64 amount;  // amount taker gets Price price;   // cost of A in terms of B }; ```",
      "type": "object",
      "required": [
        "amount",
        "buying",
        "price",
        "selling"
      ],
      "properties": {
        "amount": {
          "type": "integer",
          "format": "int64"
        },
        "buying": {
          "$ref": "#/definitions/Asset"
        },
        "price": {
          "$ref": "#/definitions/Price"
        },
        "selling": {
          "$ref": "#/definitions/Asset"
        }
      }
    },
    "DataEntry": {
      "description": "DataEntry is an XDR Struct defines as:\n\n```text struct DataEntry { AccountID accountID; // account this data belongs to string64 dataName; DataValue dataValue;\n\n// reserved for future use union switch (int v) { case 0: void; } ext; }; ```",
      "type": "object",
      "required": [
        "account_id",
        "data_name",
        "data_value",
        "ext"
      ],
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        },
        "data_name": {
          "$ref": "#/definitions/String64"
        },
        "data_value": {
          "$ref": "#/definitions/DataValue"
        },
        "ext": {
          "$ref": "#/definitions/DataEntryExt"
        }
      }
    },
    "DataEntryExt": {
      "description": "DataEntryExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; } ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "DataValue": {
      "description": "DataValue is an XDR Typedef defines as:\n\n```text typedef opaque DataValue<64>; ```",
      "type": "string",
      "maxLength": 128,
      "contentEncoding": "hex",
      "contentMediaType": "application/binary"
    },
    "DecoratedSignature": {
      "description": "DecoratedSignature is an XDR Struct defines as:\n\n```text struct DecoratedSignature { SignatureHint hint;  // last 4 bytes of the public key, used as a hint Signature signature; // actual signature }; ```",
      "type": "object",
      "required": [
        "hint",
        "signature"
      ],
      "properties": {
        "hint": {
          "type": "string",
          "maxLength": 8,
          "minLength": 8,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "signature": {
          "$ref": "#/definitions/Signature"
        }
      }
    },
    "DiagnosticEvent": {
      "description": "DiagnosticEvent is an XDR Struct defines as:\n\n```text struct DiagnosticEvent { bool inSuccessfulContractCall; ContractEvent event; }; ```",
      "type": "object",
      "required": [
        "event",
        "in_successful_contract_call"
      ],
      "properties": {
        "event": {
          "$ref": "#/definitions/ContractEvent"
        },
        "in_successful_contract_call": {
          "type": "boolean"
        }
      }
    },
    "Duration": {
      "description": "Duration is an XDR Typedef defines as:\n\n```text typedef uint64 Duration; ```",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "EndSponsoringFutureReservesResult": {
      "description": "EndSponsoringFutureReservesResult is an XDR Union defines as:\n\n```text union EndSponsoringFutureReservesResult switch ( EndSponsoringFutureReservesResultCode code) { case END_SPONSORING_FUTURE_RESERVES_SUCCESS: void; case END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "not_sponsored"
      ]
    },
    "EvictionIterator": {
      "description": "EvictionIterator is an XDR Struct defines as:\n\n```text struct EvictionIterator { uint32 bucketListLevel; bool isCurrBucket; uint64 bucketFileOffset; }; ```",
      "type": "object",
      "required": [
        "bucket_file_offset",
        "bucket_list_level",
        "is_curr_bucket"
      ],
      "properties": {
        "bucket_file_offset": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "bucket_list_level": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "is_curr_bucket": {
          "type": "boolean"
        }
      }
    },
    "ExtendFootprintTtlOp": {
      "description": "ExtendFootprintTtlOp is an XDR Struct defines as:\n\n```text struct ExtendFootprintTTLOp { ExtensionPoint ext; uint32 extendTo; }; ```",
      "type": "object",
      "required": [
        "ext",
        "extend_to"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        },
        "extend_to": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "ExtendFootprintTtlResult": {
      "description": "ExtendFootprintTtlResult is an XDR Union defines as:\n\n```text union ExtendFootprintTTLResult switch (ExtendFootprintTTLResultCode code) { case EXTEND_FOOTPRINT_TTL_SUCCESS: void; case EXTEND_FOOTPRINT_TTL_MALFORMED: case EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED: case EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "malformed",
        "resource_limit_exceeded",
        "insufficient_refundable_fee"
      ]
    },
    "ExtensionPoint": {
      "description": "ExtensionPoint is an XDR Union defines as:\n\n```text union ExtensionPoint switch (int v) { case 0: void; }; ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "FeeBumpTransaction": {
      "description": "FeeBumpTransaction is an XDR Struct defines as:\n\n```text struct FeeBumpTransaction { MuxedAccount feeSource; int64 fee; union switch (EnvelopeType type) { case ENVELOPE_TYPE_TX: TransactionV1Envelope v1; } innerTx; union switch (int v) { case 0: void; } ext; }; ```",
      "type": "object",
      "required": [
        "ext",
        "fee",
        "fee_source",
        "inner_tx"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/FeeBumpTransactionExt"
        },
        "fee": {
          "type": "integer",
          "format": "int64"
        },
        "fee_source": {
          "$ref": "#/definitions/MuxedAccount"
        },
        "inner_tx": {
          "$ref": "#/definitions/FeeBumpTransactionInnerTx"
        }
      }
    },
    "FeeBumpTransactionEnvelope": {
      "description": "FeeBumpTransactionEnvelope is an XDR Struct defines as:\n\n```text struct FeeBumpTransactionEnvelope { FeeBumpTransaction tx; /* Each decorated signature is a signature over the SHA256 hash of * a TransactionSignaturePayload */ DecoratedSignature signatures<20>; }; ```",
      "type": "object",
      "required": [
        "signatures",
        "tx"
      ],
      "properties": {
        "signatures": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DecoratedSignature"
          },
          "maxItems": 20
        },
        "tx": {
          "$ref": "#/definitions/FeeBumpTransaction"
        }
      }
    },
    "FeeBumpTransactionExt": {
      "description": "FeeBumpTransactionExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; } ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "FeeBumpTransactionInnerTx": {
      "description": "FeeBumpTransactionInnerTx is an XDR NestedUnion defines as:\n\n```text union switch (EnvelopeType type) { case ENVELOPE_TYPE_TX: TransactionV1Envelope v1; } ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "tx"
          ],
          "properties": {
            "tx": {
              "$ref": "#/definitions/TransactionV1Envelope"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "HostFunction": {
      "description": "HostFunction is an XDR Union defines as:\n\n```text union HostFunction switch (HostFunctionType type) { case HOST_FUNCTION_TYPE_INVOKE_CONTRACT: InvokeContractArgs invokeContract; case HOST_FUNCTION_TYPE_CREATE_CONTRACT: CreateContractArgs createContract; case HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM: opaque wasm<>; case HOST_FUNCTION_TYPE_CREATE_CONTRACT_V2: CreateContractArgsV2 createContractV2; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "invoke_contract"
          ],
          "properties": {
            "invoke_contract": {
              "$ref": "#/definitions/InvokeContractArgs"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "create_contract"
          ],
          "properties": {
            "create_contract": {
              "$ref": "#/definitions/CreateContractArgs"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "upload_contract_wasm"
          ],
          "properties": {
            "upload_contract_wasm": {
              "type": "string",
              "contentEncoding": "hex",
              "contentMediaType": "application/binary"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "create_contract_v2"
          ],
          "properties": {
            "create_contract_v2": {
              "$ref": "#/definitions/CreateContractArgsV2"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "InflationPayout": {
      "description": "InflationPayout is an XDR Struct defines as:\n\n```text struct InflationPayout // or use PaymentResultAtom to limit types? { AccountID destination; int64 amount; }; ```",
      "type": "object",
      "required": [
        "amount",
        "destination"
      ],
      "properties": {
        "amount": {
          "type": "integer",
          "format": "int64"
        },
        "destination": {
          "$ref": "#/definitions/AccountId"
        }
      }
    },
    "InflationResult": {
      "description": "InflationResult is an XDR Union defines as:\n\n```text union InflationResult switch (InflationResultCode code) { case INFLATION_SUCCESS: InflationPayout payouts<>; case INFLATION_NOT_TIME: void; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "not_time"
          ]
        },
        {
          "type": "object",
          "required": [
            "success"
          ],
          "properties": {
            "success": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/InflationPayout"
              },
              "maxItems": 4294967295
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "InnerTransactionResult": {
      "description": "InnerTransactionResult is an XDR Struct defines as:\n\n```text struct InnerTransactionResult { // Always 0. Here for binary compatibility. int64 feeCharged;\n\nunion switch (TransactionResultCode code) { // txFEE_BUMP_INNER_SUCCESS is not included case txSUCCESS: case txFAILED: OperationResult results<>; case txTOO_EARLY: case txTOO_LATE: case txMISSING_OPERATION: case txBAD_SEQ: case txBAD_AUTH: case txINSUFFICIENT_BALANCE: case txNO_ACCOUNT: case txINSUFFICIENT_FEE: case txBAD_AUTH_EXTRA: case txINTERNAL_ERROR: case txNOT_SUPPORTED: // txFEE_BUMP_INNER_FAILED is not included case txBAD_SPONSORSHIP: case txBAD_MIN_SEQ_AGE_OR_GAP: case txMALFORMED: case txSOROBAN_INVALID: void; } result;\n\n// reserved for future use union switch (int v) { case 0: void; } ext; }; ```",
      "type": "object",
      "required": [
        "ext",
        "fee_charged",
        "result"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/InnerTransactionResultExt"
        },
        "fee_charged": {
          "type": "integer",
          "format": "int64"
        },
        "result": {
          "$ref": "#/definitions/InnerTransactionResultResult"
        }
      }
    },
    "InnerTransactionResultExt": {
      "description": "InnerTransactionResultExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; } ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "InnerTransactionResultPair": {
      "description": "InnerTransactionResultPair is an XDR Struct defines as:\n\n```text struct InnerTransactionResultPair { Hash transactionHash;          // hash of the inner transaction InnerTransactionResult result; // result for the inner transaction }; ```",
      "type": "object",
      "required": [
        "result",
        "transaction_hash"
      ],
      "properties": {
        "result": {
          "$ref": "#/definitions/InnerTransactionResult"
        },
        "transaction_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        }
      }
    },
    "InnerTransactionResultResult": {
      "description": "InnerTransactionResultResult is an XDR NestedUnion defines as:\n\n```text union switch (TransactionResultCode code) { // txFEE_BUMP_INNER_SUCCESS is not included case txSUCCESS: case txFAILED: OperationResult results<>; case txTOO_EARLY: case txTOO_LATE: case txMISSING_OPERATION: case txBAD_SEQ: case txBAD_AUTH: case txINSUFFICIENT_BALANCE: case txNO_ACCOUNT: case txINSUFFICIENT_FEE: case txBAD_AUTH_EXTRA: case txINTERNAL_ERROR: case txNOT_SUPPORTED: // txFEE_BUMP_INNER_FAILED is not included case txBAD_SPONSORSHIP: case txBAD_MIN_SEQ_AGE_OR_GAP: case txMALFORMED: case txSOROBAN_INVALID: void; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "tx_too_early",
            "tx_too_late",
            "tx_missing_operation",
            "tx_bad_seq",
            "tx_bad_auth",
            "tx_insufficient_balance",
            "tx_no_account",
            "tx_insufficient_fee",
            "tx_bad_auth_extra",
            "tx_internal_error",
            "tx_not_supported",
            "tx_bad_sponsorship",
            "tx_bad_min_seq_age_or_gap",
            "tx_malformed",
            "tx_soroban_invalid"
          ]
        },
        {
          "type": "object",
          "required": [
            "tx_success"
          ],
          "properties": {
            "tx_success": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/OperationResult"
              },
              "maxItems": 4294967295
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "tx_failed"
          ],
          "properties": {
            "tx_failed": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/OperationResult"
              },
              "maxItems": 4294967295
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Int128Parts": {
      "description": "Int128Parts is an XDR Struct defines as:\n\n```text struct Int128Parts { int64 hi; uint64 lo; }; ```",
      "type": "object",
      "required": [
        "hi",
        "lo"
      ],
      "properties": {
        "hi": {
          "type": "integer",
          "format": "int64"
        },
        "lo": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "Int256Parts": {
      "description": "Int256Parts is an XDR Struct defines as:\n\n```text struct Int256Parts { int64 hi_hi; uint64 hi_lo; uint64 lo_hi; uint64 lo_lo; }; ```",
      "type": "object",
      "required": [
        "hi_hi",
        "hi_lo",
        "lo_hi",
        "lo_lo"
      ],
      "properties": {
        "hi_hi": {
          "type": "integer",
          "format": "int64"
        },
        "hi_lo": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "lo_hi": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "lo_lo": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "InvokeContractArgs": {
      "description": "InvokeContractArgs is an XDR Struct defines as:\n\n```text struct InvokeContractArgs { SCAddress contractAddress; SCSymbol functionName; SCVal args<>; }; ```",
      "type": "object",
      "required": [
        "args",
        "contract_address",
        "function_name"
      ],
      "properties": {
        "args": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScVal"
          },
          "maxItems": 4294967295
        },
        "contract_address": {
          "$ref": "#/definitions/ScAddress"
        },
        "function_name": {
          "$ref": "#/definitions/ScSymbol"
        }
      }
    },
    "InvokeHostFunctionOp": {
      "description": "InvokeHostFunctionOp is an XDR Struct defines as:\n\n```text struct InvokeHostFunctionOp { // Host function to invoke. HostFunction hostFunction; // Per-address authorizations for this host function. SorobanAuthorizationEntry auth<>; }; ```",
      "type": "object",
      "required": [
        "auth",
        "host_function"
      ],
      "properties": {
        "auth": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SorobanAuthorizationEntry"
          },
          "maxItems": 4294967295
        },
        "host_function": {
          "$ref": "#/definitions/HostFunction"
        }
      }
    },
    "InvokeHostFunctionResult": {
      "description": "InvokeHostFunctionResult is an XDR Union defines as:\n\n```text union InvokeHostFunctionResult switch (InvokeHostFunctionResultCode code) { case INVOKE_HOST_FUNCTION_SUCCESS: Hash success; // sha256(InvokeHostFunctionSuccessPreImage) case INVOKE_HOST_FUNCTION_MALFORMED: case INVOKE_HOST_FUNCTION_TRAPPED: case INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED: case INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED: case INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE: void; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "malformed",
            "trapped",
            "resource_limit_exceeded",
            "entry_archived",
            "insufficient_refundable_fee"
          ]
        },
        {
          "type": "object",
          "required": [
            "success"
          ],
          "properties": {
            "success": {
              "type": "string",
              "maxLength": 64,
              "minLength": 64,
              "contentEncoding": "hex",
              "contentMediaType": "application/binary"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "LedgerBounds": {
      "description": "LedgerBounds is an XDR Struct defines as:\n\n```text struct LedgerBounds { uint32 minLedger; uint32 maxLedger; // 0 here means no maxLedger }; ```",
      "type": "object",
      "required": [
        "max_ledger",
        "min_ledger"
      ],
      "properties": {
        "max_ledger": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "min_ledger": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "LedgerCloseValueSignature": {
      "description": "LedgerCloseValueSignature is an XDR Struct defines as:\n\n```text struct LedgerCloseValueSignature { NodeID nodeID;       // which node introduced the value Signature signature; // nodeID's signature }; ```",
      "type": "object",
      "required": [
        "node_id",
        "signature"
      ],
      "properties": {
        "node_id": {
          "$ref": "#/definitions/NodeId"
        },
        "signature": {
          "$ref": "#/definitions/Signature"
        }
      }
    },
    "LedgerEntry": {
      "description": "LedgerEntry is an XDR Struct defines as:\n\n```text struct LedgerEntry { uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed\n\nunion switch (LedgerEntryType type) { case ACCOUNT: AccountEntry account; case TRUSTLINE: TrustLineEntry trustLine; case OFFER: OfferEntry offer; case DATA: DataEntry data; case CLAIMABLE_BALANCE: ClaimableBalanceEntry claimableBalance; case LIQUIDITY_POOL: LiquidityPoolEntry liquidityPool; case CONTRACT_DATA: ContractDataEntry contractData; case CONTRACT_CODE: ContractCodeEntry contractCode; case CONFIG_SETTING: ConfigSettingEntry configSetting; case TTL: TTLEntry ttl; } data;\n\n// reserved for future use union switch (int v) { case 0: void; case 1: LedgerEntryExtensionV1 v1; } ext; }; ```",
      "type": "object",
      "required": [
        "data",
        "ext",
        "last_modified_ledger_seq"
      ],
      "properties": {
        "data": {
          "$ref": "#/definitions/LedgerEntryData"
        },
        "ext": {
          "$ref": "#/definitions/LedgerEntryExt"
        },
        "last_modified_ledger_seq": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "LedgerEntryChange": {
      "description": "LedgerEntryChange is an XDR Union defines as:\n\n```text union LedgerEntryChange switch (LedgerEntryChangeType type) { case LEDGER_ENTRY_CREATED: LedgerEntry created; case LEDGER_ENTRY_UPDATED: LedgerEntry updated; case LEDGER_ENTRY_REMOVED: LedgerKey removed; case LEDGER_ENTRY_STATE: LedgerEntry state; case LEDGER_ENTRY_RESTORED: LedgerEntry restored; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "created"
          ],
          "properties": {
            "created": {
              "$ref": "#/definitions/LedgerEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "updated"
          ],
          "properties": {
            "updated": {
              "$ref": "#/definitions/LedgerEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "removed"
          ],
          "properties": {
            "removed": {
              "$ref": "#/definitions/LedgerKey"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "state"
          ],
          "properties": {
            "state": {
              "$ref": "#/definitions/LedgerEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "restored"
          ],
          "properties": {
            "restored": {
              "$ref": "#/definitions/LedgerEntry"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "LedgerEntryChanges": {
      "description": "LedgerEntryChanges is an XDR Typedef defines as:\n\n```text typedef LedgerEntryChange LedgerEntryChanges<>; ```",
      "type": "array",
      "items": {
        "$ref": "#/definitions/LedgerEntryChange"
      },
      "maxItems": 4294967295
    },
    "LedgerEntryData": {
      "description": "LedgerEntryData is an XDR NestedUnion defines as:\n\n```text union switch (LedgerEntryType type) { case ACCOUNT: AccountEntry account; case TRUSTLINE: TrustLineEntry trustLine; case OFFER: OfferEntry offer; case DATA: DataEntry data; case CLAIMABLE_BALANCE: ClaimableBalanceEntry claimableBalance; case LIQUIDITY_POOL: LiquidityPoolEntry liquidityPool; case CONTRACT_DATA: ContractDataEntry contractData; case CONTRACT_CODE: ContractCodeEntry contractCode; case CONFIG_SETTING: ConfigSettingEntry configSetting; case TTL: TTLEntry ttl; } ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "account"
          ],
          "properties": {
            "account": {
              "$ref": "#/definitions/AccountEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "trustline"
          ],
          "properties": {
            "trustline": {
              "$ref": "#/definitions/TrustLineEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "offer"
          ],
          "properties": {
            "offer": {
              "$ref": "#/definitions/OfferEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "data"
          ],
          "properties": {
            "data": {
              "$ref": "#/definitions/DataEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "claimable_balance"
          ],
          "properties": {
            "claimable_balance": {
              "$ref": "#/definitions/ClaimableBalanceEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "liquidity_pool"
          ],
          "properties": {
            "liquidity_pool": {
              "$ref": "#/definitions/LiquidityPoolEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_data"
          ],
          "properties": {
            "contract_data": {
              "$ref": "#/definitions/ContractDataEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_code"
          ],
          "properties": {
            "contract_code": {
              "$ref": "#/definitions/ContractCodeEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "config_setting"
          ],
          "properties": {
            "config_setting": {
              "$ref": "#/definitions/ConfigSettingEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "ttl"
          ],
          "properties": {
            "ttl": {
              "$ref": "#/definitions/TtlEntry"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "LedgerEntryExt": {
      "description": "LedgerEntryExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; case 1: LedgerEntryExtensionV1 v1; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v1"
          ],
          "properties": {
            "v1": {
              "$ref": "#/definitions/LedgerEntryExtensionV1"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "LedgerEntryExtensionV1": {
      "description": "LedgerEntryExtensionV1 is an XDR Struct defines as:\n\n```text struct LedgerEntryExtensionV1 { SponsorshipDescriptor sponsoringID;\n\nunion switch (int v) { case 0: void; } ext; }; ```",
      "type": "object",
      "required": [
        "ext",
        "sponsoring_id"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/LedgerEntryExtensionV1Ext"
        },
        "sponsoring_id": {
          "$ref": "#/definitions/SponsorshipDescriptor"
        }
      }
    },
    "LedgerEntryExtensionV1Ext": {
      "description": "LedgerEntryExtensionV1Ext is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; } ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "LedgerFootprint": {
      "description": "LedgerFootprint is an XDR Struct defines as:\n\n```text struct LedgerFootprint { LedgerKey readOnly<>; LedgerKey readWrite<>; }; ```",
      "type": "object",
      "required": [
        "read_only",
        "read_write"
      ],
      "properties": {
        "read_only": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LedgerKey"
          },
          "maxItems": 4294967295
        },
        "read_write": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/LedgerKey"
          },
          "maxItems": 4294967295
        }
      }
    },
    "LedgerHeader": {
      "description": "LedgerHeader is an XDR Struct defines as:\n\n```text struct LedgerHeader { uint32 ledgerVersion;    // the protocol version of the ledger Hash previousLedgerHash; // hash of the previous ledger header StellarValue scpValue;   // what consensus agreed to Hash txSetResultHash;    // the TransactionResultSet that led to this ledger Hash bucketListHash;     // hash of the ledger state\n\nuint32 ledgerSeq; // sequence number of this ledger\n\nint64 totalCoins; // total number of stroops in existence. // 10,000,000 stroops in 1 XLM\n\nint64 feePool;       // fees burned since last inflation run uint32 inflationSeq; // inflation sequence number\n\nuint64 idPool; // last used global ID, used for generating objects\n\nuint32 baseFee;     // base fee per operation in stroops uint32 baseReserve; // account base reserve in stroops\n\nuint32 maxTxSetSize; // maximum size a transaction set can be\n\nHash skipList[4]; // hashes of ledgers in the past. allows you to jump back // in time without walking the chain back ledger by ledger // each slot contains the oldest ledger that is mod of // either 50  5000  50000 or 500000 depending on index // skipList[0] mod(50), skipList[1] mod(5000), etc\n\n// reserved for future use union switch (int v) { case 0: void; case 1: LedgerHeaderExtensionV1 v1; } ext; }; ```",
      "type": "object",
      "required": [
        "base_fee",
        "base_reserve",
        "bucket_list_hash",
        "ext",
        "fee_pool",
        "id_pool",
        "inflation_seq",
        "ledger_seq",
        "ledger_version",
        "max_tx_set_size",
        "previous_ledger_hash",
        "scp_value",
        "skip_list",
        "total_coins",
        "tx_set_result_hash"
      ],
      "properties": {
        "base_fee": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "base_reserve": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "bucket_list_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "ext": {
          "$ref": "#/definitions/LedgerHeaderExt"
        },
        "fee_pool": {
          "type": "integer",
          "format": "int64"
        },
        "id_pool": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "inflation_seq": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "ledger_seq": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "ledger_version": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "max_tx_set_size": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "previous_ledger_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "scp_value": {
          "$ref": "#/definitions/StellarValue"
        },
        "skip_list": {
          "type": "array",
          "items": {
            "type": "string",
            "maxLength": 64,
            "minLength": 64,
            "contentEncoding": "hex",
            "contentMediaType": "application/binary"
          },
          "maxItems": 4,
          "minItems": 4
        },
        "total_coins": {
          "type": "integer",
          "format": "int64"
        },
        "tx_set_result_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        }
      }
    },
    "LedgerHeaderExt": {
      "description": "LedgerHeaderExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; case 1: LedgerHeaderExtensionV1 v1; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v1"
          ],
          "properties": {
            "v1": {
              "$ref": "#/definitions/LedgerHeaderExtensionV1"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "LedgerHeaderExtensionV1": {
      "description": "LedgerHeaderExtensionV1 is an XDR Struct defines as:\n\n```text struct LedgerHeaderExtensionV1 { uint32 flags; // LedgerHeaderFlags\n\nunion switch (int v) { case 0: void; } ext; }; ```",
      "type": "object",
      "required": [
        "ext",
        "flags"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/LedgerHeaderExtensionV1Ext"
        },
        "flags": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "LedgerHeaderExtensionV1Ext": {
      "description": "LedgerHeaderExtensionV1Ext is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; } ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "LedgerHeaderHistoryEntry": {
      "description": "LedgerHeaderHistoryEntry is an XDR Struct defines as:\n\n```text struct LedgerHeaderHistoryEntry { Hash hash; LedgerHeader header;\n\n// reserved for future use union switch (int v) { case 0: void; } ext; }; ```",
      "type": "object",
      "required": [
        "ext",
        "hash",
        "header"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/LedgerHeaderHistoryEntryExt"
        },
        "hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "header": {
          "$ref": "#/definitions/LedgerHeader"
        }
      }
    },
    "LedgerHeaderHistoryEntryExt": {
      "description": "LedgerHeaderHistoryEntryExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; } ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "LedgerKey": {
      "description": "LedgerKey is an XDR Union defines as:\n\n```text union LedgerKey switch (LedgerEntryType type) { case ACCOUNT: struct { AccountID accountID; } account;\n\ncase TRUSTLINE: struct { AccountID accountID; TrustLineAsset asset; } trustLine;\n\ncase OFFER: struct { AccountID sellerID; int64 offerID; } offer;\n\ncase DATA: struct { AccountID accountID; string64 dataName; } data;\n\ncase CLAIMABLE_BALANCE: struct { ClaimableBalanceID balanceID; } claimableBalance;\n\ncase LIQUIDITY_POOL: struct { PoolID liquidityPoolID; } liquidityPool; case CONTRACT_DATA: struct { SCAddress contract; SCVal key; ContractDataDurability durability; } contractData; case CONTRACT_CODE: struct { Hash hash; } contractCode; case CONFIG_SETTING: struct { ConfigSettingID configSettingID; } configSetting; case TTL: struct { // Hash of the LedgerKey that is associated with this TTLEntry Hash keyHash; } ttl; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "account"
          ],
          "properties": {
            "account": {
              "$ref": "#/definitions/LedgerKeyAccount"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "trustline"
          ],
          "properties": {
            "trustline": {
              "$ref": "#/definitions/LedgerKeyTrustLine"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "offer"
          ],
          "properties": {
            "offer": {
              "$ref": "#/definitions/LedgerKeyOffer"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "data"
          ],
          "properties": {
            "data": {
              "$ref": "#/definitions/LedgerKeyData"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "claimable_balance"
          ],
          "properties": {
            "claimable_balance": {
              "$ref": "#/definitions/LedgerKeyClaimableBalance"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "liquidity_pool"
          ],
          "properties": {
            "liquidity_pool": {
              "$ref": "#/definitions/LedgerKeyLiquidityPool"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_data"
          ],
          "properties": {
            "contract_data": {
              "$ref": "#/definitions/LedgerKeyContractData"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_code"
          ],
          "properties": {
            "contract_code": {
              "$ref": "#/definitions/LedgerKeyContractCode"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "config_setting"
          ],
          "properties": {
            "config_setting": {
              "$ref": "#/definitions/LedgerKeyConfigSetting"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "ttl"
          ],
          "properties": {
            "ttl": {
              "$ref": "#/definitions/LedgerKeyTtl"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "LedgerKeyAccount": {
      "description": "LedgerKeyAccount is an XDR NestedStruct defines as:\n\n```text struct { AccountID accountID; } ```",
      "type": "object",
      "required": [
        "account_id"
      ],
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        }
      }
    },
    "LedgerKeyClaimableBalance": {
      "description": "LedgerKeyClaimableBalance is an XDR NestedStruct defines as:\n\n```text struct { ClaimableBalanceID balanceID; } ```",
      "type": "object",
      "required": [
        "balance_id"
      ],
      "properties": {
        "balance_id": {
          "$ref": "#/definitions/ClaimableBalanceId"
        }
      }
    },
    "LedgerKeyConfigSetting": {
      "description": "LedgerKeyConfigSetting is an XDR NestedStruct defines as:\n\n```text struct { ConfigSettingID configSettingID; } ```",
      "type": "object",
      "required": [
        "config_setting_id"
      ],
      "properties": {
        "config_setting_id": {
          "$ref": "#/definitions/ConfigSettingId"
        }
      }
    },
    "LedgerKeyContractCode": {
      "description": "LedgerKeyContractCode is an XDR NestedStruct defines as:\n\n```text struct { Hash hash; } ```",
      "type": "object",
      "required": [
        "hash"
      ],
      "properties": {
        "hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        }
      }
    },
    "LedgerKeyContractData": {
      "description": "LedgerKeyContractData is an XDR NestedStruct defines as:\n\n```text struct { SCAddress contract; SCVal key; ContractDataDurability durability; } ```",
      "type": "object",
      "required": [
        "contract",
        "durability",
        "key"
      ],
      "properties": {
        "contract": {
          "$ref": "#/definitions/ScAddress"
        },
        "durability": {
          "$ref": "#/definitions/ContractDataDurability"
        },
        "key": {
          "$ref": "#/definitions/ScVal"
        }
      }
    },
    "LedgerKeyData": {
      "description": "LedgerKeyData is an XDR NestedStruct defines as:\n\n```text struct { AccountID accountID; string64 dataName; } ```",
      "type": "object",
      "required": [
        "account_id",
        "data_name"
      ],
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        },
        "data_name": {
          "$ref": "#/definitions/String64"
        }
      }
    },
    "LedgerKeyLiquidityPool": {
      "description": "LedgerKeyLiquidityPool is an XDR NestedStruct defines as:\n\n```text struct { PoolID liquidityPoolID; } ```",
      "type": "object",
      "required": [
        "liquidity_pool_id"
      ],
      "properties": {
        "liquidity_pool_id": {
          "$ref": "#/definitions/PoolId"
        }
      }
    },
    "LedgerKeyOffer": {
      "description": "LedgerKeyOffer is an XDR NestedStruct defines as:\n\n```text struct { AccountID sellerID; int64 offerID; } ```",
      "type": "object",
      "required": [
        "offer_id",
        "seller_id"
      ],
      "properties": {
        "offer_id": {
          "type": "integer",
          "format": "int64"
        },
        "seller_id": {
          "$ref": "#/definitions/AccountId"
        }
      }
    },
    "LedgerKeyTrustLine": {
      "description": "LedgerKeyTrustLine is an XDR NestedStruct defines as:\n\n```text struct { AccountID accountID; TrustLineAsset asset; } ```",
      "type": "object",
      "required": [
        "account_id",
        "asset"
      ],
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        },
        "asset": {
          "$ref": "#/definitions/TrustLineAsset"
        }
      }
    },
    "LedgerKeyTtl": {
      "description": "LedgerKeyTtl is an XDR NestedStruct defines as:\n\n```text struct { // Hash of the LedgerKey that is associated with this TTLEntry Hash keyHash; } ```",
      "type": "object",
      "required": [
        "key_hash"
      ],
      "properties": {
        "key_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        }
      }
    },
    "LedgerScpMessages": {
      "description": "LedgerScpMessages is an XDR Struct defines as:\n\n```text struct LedgerSCPMessages { uint32 ledgerSeq; SCPEnvelope messages<>; }; ```",
      "type": "object",
      "required": [
        "ledger_seq",
        "messages"
      ],
      "properties": {
        "ledger_seq": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "messages": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScpEnvelope"
          },
          "maxItems": 4294967295
        }
      }
    },
    "LedgerUpgrade": {
      "description": "LedgerUpgrade is an XDR Union defines as:\n\n```text union LedgerUpgrade switch (LedgerUpgradeType type) { case LEDGER_UPGRADE_VERSION: uint32 newLedgerVersion; // update ledgerVersion case LEDGER_UPGRADE_BASE_FEE: uint32 newBaseFee; // update baseFee case LEDGER_UPGRADE_MAX_TX_SET_SIZE: uint32 newMaxTxSetSize; // update maxTxSetSize case LEDGER_UPGRADE_BASE_RESERVE: uint32 newBaseReserve; // update baseReserve case LEDGER_UPGRADE_FLAGS: uint32 newFlags; // update flags case LEDGER_UPGRADE_CONFIG: // Update arbitrary `ConfigSetting` entries identified by the key. ConfigUpgradeSetKey newConfig; case LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE: // Update ConfigSettingContractExecutionLanesV0.ledgerMaxTxCount without // using `LEDGER_UPGRADE_CONFIG`. uint32 newMaxSorobanTxSetSize; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "version"
          ],
          "properties": {
            "version": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "base_fee"
          ],
          "properties": {
            "base_fee": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "max_tx_set_size"
          ],
          "properties": {
            "max_tx_set_size": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "base_reserve"
          ],
          "properties": {
            "base_reserve": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "flags"
          ],
          "properties": {
            "flags": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "config"
          ],
          "properties": {
            "config": {
              "$ref": "#/definitions/ConfigUpgradeSetKey"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "max_soroban_tx_set_size"
          ],
          "properties": {
            "max_soroban_tx_set_size": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Liabilities": {
      "description": "Liabilities is an XDR Struct defines as:\n\n```text struct Liabilities { int64 buying; int64 selling; }; ```",
      "type": "object",
      "required": [
        "buying",
        "selling"
      ],
      "properties": {
        "buying": {
          "type": "integer",
          "format": "int64"
        },
        "selling": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "LiquidityPoolConstantProductParameters": {
      "description": "LiquidityPoolConstantProductParameters is an XDR Struct defines as:\n\n```text struct LiquidityPoolConstantProductParameters { Asset assetA; // assetA < assetB Asset assetB; int32 fee; // Fee is in basis points, so the actual rate is (fee/100)% }; ```",
      "type": "object",
      "required": [
        "asset_a",
        "asset_b",
        "fee"
      ],
      "properties": {
        "asset_a": {
          "$ref": "#/definitions/Asset"
        },
        "asset_b": {
          "$ref": "#/definitions/Asset"
        },
        "fee": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "LiquidityPoolDepositOp": {
      "description": "LiquidityPoolDepositOp is an XDR Struct defines as:\n\n```text struct LiquidityPoolDepositOp { PoolID liquidityPoolID; int64 maxAmountA; // maximum amount of first asset to deposit int64 maxAmountB; // maximum amount of second asset to deposit Price minPrice;   // minimum depositA/depositB Price maxPrice;   // maximum depositA/depositB }; ```",
      "type": "object",
      "required": [
        "liquidity_pool_id",
        "max_amount_a",
        "max_amount_b",
        "max_price",
        "min_price"
      ],
      "properties": {
        "liquidity_pool_id": {
          "$ref": "#/definitions/PoolId"
        },
        "max_amount_a": {
          "type": "integer",
          "format": "int64"
        },
        "max_amount_b": {
          "type": "integer",
          "format": "int64"
        },
        "max_price": {
          "$ref": "#/definitions/Price"
        },
        "min_price": {
          "$ref": "#/definitions/Price"
        }
      }
    },
    "LiquidityPoolDepositResult": {
      "description": "LiquidityPoolDepositResult is an XDR Union defines as:\n\n```text union LiquidityPoolDepositResult switch (LiquidityPoolDepositResultCode code) { case LIQUIDITY_POOL_DEPOSIT_SUCCESS: void; case LIQUIDITY_POOL_DEPOSIT_MALFORMED: case LIQUIDITY_POOL_DEPOSIT_NO_TRUST: case LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED: case LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED: case LIQUIDITY_POOL_DEPOSIT_LINE_FULL: case LIQUIDITY_POOL_DEPOSIT_BAD_PRICE: case LIQUIDITY_POOL_DEPOSIT_POOL_FULL: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "malformed",
        "no_trust",
        "not_authorized",
        "underfunded",
        "line_full",
        "bad_price",
        "pool_full"
      ]
    },
    "LiquidityPoolEntry": {
      "description": "LiquidityPoolEntry is an XDR Struct defines as:\n\n```text struct LiquidityPoolEntry { PoolID liquidityPoolID;\n\nunion switch (LiquidityPoolType type) { case LIQUIDITY_POOL_CONSTANT_PRODUCT: struct { LiquidityPoolConstantProductParameters params;\n\nint64 reserveA;        // amount of A in the pool int64 reserveB;        // amount of B in the pool int64 totalPoolShares; // total number of pool shares issued int64 poolSharesTrustLineCount; // number of trust lines for the // associated pool shares } constantProduct; } body; }; ```",
      "type": "object",
      "required": [
        "body",
        "liquidity_pool_id"
      ],
      "properties": {
        "body": {
          "$ref": "#/definitions/LiquidityPoolEntryBody"
        },
        "liquidity_pool_id": {
          "$ref": "#/definitions/PoolId"
        }
      }
    },
    "LiquidityPoolEntryBody": {
      "description": "LiquidityPoolEntryBody is an XDR NestedUnion defines as:\n\n```text union switch (LiquidityPoolType type) { case LIQUIDITY_POOL_CONSTANT_PRODUCT: struct { LiquidityPoolConstantProductParameters params;\n\nint64 reserveA;        // amount of A in the pool int64 reserveB;        // amount of B in the pool int64 totalPoolShares; // total number of pool shares issued int64 poolSharesTrustLineCount; // number of trust lines for the // associated pool shares } constantProduct; } ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "liquidity_pool_constant_product"
          ],
          "properties": {
            "liquidity_pool_constant_product": {
              "$ref": "#/definitions/LiquidityPoolEntryConstantProduct"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "LiquidityPoolEntryConstantProduct": {
      "description": "LiquidityPoolEntryConstantProduct is an XDR NestedStruct defines as:\n\n```text struct { LiquidityPoolConstantProductParameters params;\n\nint64 reserveA;        // amount of A in the pool int64 reserveB;        // amount of B in the pool int64 totalPoolShares; // total number of pool shares issued int64 poolSharesTrustLineCount; // number of trust lines for the // associated pool shares } ```",
      "type": "object",
      "required": [
        "params",
        "pool_shares_trust_line_count",
        "reserve_a",
        "reserve_b",
        "total_pool_shares"
      ],
      "properties": {
        "params": {
          "$ref": "#/definitions/LiquidityPoolConstantProductParameters"
        },
        "pool_shares_trust_line_count": {
          "type": "integer",
          "format": "int64"
        },
        "reserve_a": {
          "type": "integer",
          "format": "int64"
        },
        "reserve_b": {
          "type": "integer",
          "format": "int64"
        },
        "total_pool_shares": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "LiquidityPoolParameters": {
      "description": "LiquidityPoolParameters is an XDR Union defines as:\n\n```text union LiquidityPoolParameters switch (LiquidityPoolType type) { case LIQUIDITY_POOL_CONSTANT_PRODUCT: LiquidityPoolConstantProductParameters constantProduct; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "liquidity_pool_constant_product"
          ],
          "properties": {
            "liquidity_pool_constant_product": {
              "$ref": "#/definitions/LiquidityPoolConstantProductParameters"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "LiquidityPoolWithdrawOp": {
      "description": "LiquidityPoolWithdrawOp is an XDR Struct defines as:\n\n```text struct LiquidityPoolWithdrawOp { PoolID liquidityPoolID; int64 amount;     // amount of pool shares to withdraw int64 minAmountA; // minimum amount of first asset to withdraw int64 minAmountB; // minimum amount of second asset to withdraw }; ```",
      "type": "object",
      "required": [
        "amount",
        "liquidity_pool_id",
        "min_amount_a",
        "min_amount_b"
      ],
      "properties": {
        "amount": {
          "type": "integer",
          "format": "int64"
        },
        "liquidity_pool_id": {
          "$ref": "#/definitions/PoolId"
        },
        "min_amount_a": {
          "type": "integer",
          "format": "int64"
        },
        "min_amount_b": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "LiquidityPoolWithdrawResult": {
      "description": "LiquidityPoolWithdrawResult is an XDR Union defines as:\n\n```text union LiquidityPoolWithdrawResult switch (LiquidityPoolWithdrawResultCode code) { case LIQUIDITY_POOL_WITHDRAW_SUCCESS: void; case LIQUIDITY_POOL_WITHDRAW_MALFORMED: case LIQUIDITY_POOL_WITHDRAW_NO_TRUST: case LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED: case LIQUIDITY_POOL_WITHDRAW_LINE_FULL: case LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "malformed",
        "no_trust",
        "underfunded",
        "line_full",
        "under_minimum"
      ]
    },
    "ManageBuyOfferOp": {
      "description": "ManageBuyOfferOp is an XDR Struct defines as:\n\n```text struct ManageBuyOfferOp { Asset selling; Asset buying; int64 buyAmount; // amount being bought. if set to 0, delete the offer Price price;     // price of thing being bought in terms of what you are // selling\n\n// 0=create a new offer, otherwise edit an existing offer int64 offerID; }; ```",
      "type": "object",
      "required": [
        "buy_amount",
        "buying",
        "offer_id",
        "price",
        "selling"
      ],
      "properties": {
        "buy_amount": {
          "type": "integer",
          "format": "int64"
        },
        "buying": {
          "$ref": "#/definitions/Asset"
        },
        "offer_id": {
          "type": "integer",
          "format": "int64"
        },
        "price": {
          "$ref": "#/definitions/Price"
        },
        "selling": {
          "$ref": "#/definitions/Asset"
        }
      }
    },
    "ManageBuyOfferResult": {
      "description": "ManageBuyOfferResult is an XDR Union defines as:\n\n```text union ManageBuyOfferResult switch (ManageBuyOfferResultCode code) { case MANAGE_BUY_OFFER_SUCCESS: ManageOfferSuccessResult success; case MANAGE_BUY_OFFER_MALFORMED: case MANAGE_BUY_OFFER_SELL_NO_TRUST: case MANAGE_BUY_OFFER_BUY_NO_TRUST: case MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED: case MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED: case MANAGE_BUY_OFFER_LINE_FULL: case MANAGE_BUY_OFFER_UNDERFUNDED: case MANAGE_BUY_OFFER_CROSS_SELF: case MANAGE_BUY_OFFER_SELL_NO_ISSUER: case MANAGE_BUY_OFFER_BUY_NO_ISSUER: case MANAGE_BUY_OFFER_NOT_FOUND: case MANAGE_BUY_OFFER_LOW_RESERVE: void; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "malformed",
            "sell_no_trust",
            "buy_no_trust",
            "sell_not_authorized",
            "buy_not_authorized",
            "line_full",
            "underfunded",
            "cross_self",
            "sell_no_issuer",
            "buy_no_issuer",
            "not_found",
            "low_reserve"
          ]
        },
        {
          "type": "object",
          "required": [
            "success"
          ],
          "properties": {
            "success": {
              "$ref": "#/definitions/ManageOfferSuccessResult"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ManageDataOp": {
      "description": "ManageDataOp is an XDR Struct defines as:\n\n```text struct ManageDataOp { string64 dataName; DataValue* dataValue; // set to null to clear }; ```",
      "type": "object",
      "required": [
        "data_name"
      ],
      "properties": {
        "data_name": {
          "$ref": "#/definitions/String64"
        },
        "data_value": {
          "anyOf": [
            {
              "$ref": "#/definitions/DataValue"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "ManageDataResult": {
      "description": "ManageDataResult is an XDR Union defines as:\n\n```text union ManageDataResult switch (ManageDataResultCode code) { case MANAGE_DATA_SUCCESS: void; case MANAGE_DATA_NOT_SUPPORTED_YET: case MANAGE_DATA_NAME_NOT_FOUND: case MANAGE_DATA_LOW_RESERVE: case MANAGE_DATA_INVALID_NAME: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "not_supported_yet",
        "name_not_found",
        "low_reserve",
        "invalid_name"
      ]
    },
    "ManageOfferSuccessResult": {
      "description": "ManageOfferSuccessResult is an XDR Struct defines as:\n\n```text struct ManageOfferSuccessResult { // offers that got claimed while creating this offer ClaimAtom offersClaimed<>;\n\nunion switch (ManageOfferEffect effect) { case MANAGE_OFFER_CREATED: case MANAGE_OFFER_UPDATED: OfferEntry offer; case MANAGE_OFFER_DELETED: void; } offer; }; ```",
      "type": "object",
      "required": [
        "offer",
        "offers_claimed"
      ],
      "properties": {
        "offer": {
          "$ref": "#/definitions/ManageOfferSuccessResultOffer"
        },
        "offers_claimed": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ClaimAtom"
          },
          "maxItems": 4294967295
        }
      }
    },
    "ManageOfferSuccessResultOffer": {
      "description": "ManageOfferSuccessResultOffer is an XDR NestedUnion defines as:\n\n```text union switch (ManageOfferEffect effect) { case MANAGE_OFFER_CREATED: case MANAGE_OFFER_UPDATED: OfferEntry offer; case MANAGE_OFFER_DELETED: void; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "deleted"
          ]
        },
        {
          "type": "object",
          "required": [
            "created"
          ],
          "properties": {
            "created": {
              "$ref": "#/definitions/OfferEntry"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "updated"
          ],
          "properties": {
            "updated": {
              "$ref": "#/definitions/OfferEntry"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ManageSellOfferOp": {
      "description": "ManageSellOfferOp is an XDR Struct defines as:\n\n```text struct ManageSellOfferOp { Asset selling; Asset buying; int64 amount; // amount being sold. if set to 0, delete the offer Price price;  // price of thing being sold in terms of what you are buying\n\n// 0=create a new offer, otherwise edit an existing offer int64 offerID; }; ```",
      "type": "object",
      "required": [
        "amount",
        "buying",
        "offer_id",
        "price",
        "selling"
      ],
      "properties": {
        "amount": {
          "type": "integer",
          "format": "int64"
        },
        "buying": {
          "$ref": "#/definitions/Asset"
        },
        "offer_id": {
          "type": "integer",
          "format": "int64"
        },
        "price": {
          "$ref": "#/definitions/Price"
        },
        "selling": {
          "$ref": "#/definitions/Asset"
        }
      }
    },
    "ManageSellOfferResult": {
      "description": "ManageSellOfferResult is an XDR Union defines as:\n\n```text union ManageSellOfferResult switch (ManageSellOfferResultCode code) { case MANAGE_SELL_OFFER_SUCCESS: ManageOfferSuccessResult success; case MANAGE_SELL_OFFER_MALFORMED: case MANAGE_SELL_OFFER_SELL_NO_TRUST: case MANAGE_SELL_OFFER_BUY_NO_TRUST: case MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED: case MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED: case MANAGE_SELL_OFFER_LINE_FULL: case MANAGE_SELL_OFFER_UNDERFUNDED: case MANAGE_SELL_OFFER_CROSS_SELF: case MANAGE_SELL_OFFER_SELL_NO_ISSUER: case MANAGE_SELL_OFFER_BUY_NO_ISSUER: case MANAGE_SELL_OFFER_NOT_FOUND: case MANAGE_SELL_OFFER_LOW_RESERVE: void; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "malformed",
            "sell_no_trust",
            "buy_no_trust",
            "sell_not_authorized",
            "buy_not_authorized",
            "line_full",
            "underfunded",
            "cross_self",
            "sell_no_issuer",
            "buy_no_issuer",
            "not_found",
            "low_reserve"
          ]
        },
        {
          "type": "object",
          "required": [
            "success"
          ],
          "properties": {
            "success": {
              "$ref": "#/definitions/ManageOfferSuccessResult"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Memo": {
      "description": "Memo is an XDR Union defines as:\n\n```text union Memo switch (MemoType type) { case MEMO_NONE: void; case MEMO_TEXT: string text<28>; case MEMO_ID: uint64 id; case MEMO_HASH: Hash hash; // the hash of what to pull from the content server case MEMO_RETURN: Hash retHash; // the hash of the tx you are rejecting }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "none"
          ]
        },
        {
          "type": "object",
          "required": [
            "text"
          ],
          "properties": {
            "text": {
              "$ref": "#/definitions/StringM<28>"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "id"
          ],
          "properties": {
            "id": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "hash"
          ],
          "properties": {
            "hash": {
              "type": "string",
              "maxLength": 64,
              "minLength": 64,
              "contentEncoding": "hex",
              "contentMediaType": "application/binary"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "return"
          ],
          "properties": {
            "return": {
              "type": "string",
              "maxLength": 64,
              "minLength": 64,
              "contentEncoding": "hex",
              "contentMediaType": "application/binary"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "MuxedAccount": {
      "type": "string"
    },
    "NodeId": {
      "type": "string"
    },
    "OfferEntry": {
      "description": "OfferEntry is an XDR Struct defines as:\n\n```text struct OfferEntry { AccountID sellerID; int64 offerID; Asset selling; // A Asset buying;  // B int64 amount;  // amount of A\n\n/* price for this offer: price of A in terms of B price=AmountB/AmountA=priceNumerator/priceDenominator price is after fees */ Price price; uint32 flags; // see OfferEntryFlags\n\n// reserved for future use union switch (int v) { case 0: void; } ext; }; ```",
      "type": "object",
      "required": [
        "amount",
        "buying",
        "ext",
        "flags",
        "offer_id",
        "price",
        "seller_id",
        "selling"
      ],
      "properties": {
        "amount": {
          "type": "integer",
          "format": "int64"
        },
        "buying": {
          "$ref": "#/definitions/Asset"
        },
        "ext": {
          "$ref": "#/definitions/OfferEntryExt"
        },
        "flags": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "offer_id": {
          "type": "integer",
          "format": "int64"
        },
        "price": {
          "$ref": "#/definitions/Price"
        },
        "seller_id": {
          "$ref": "#/definitions/AccountId"
        },
        "selling": {
          "$ref": "#/definitions/Asset"
        }
      }
    },
    "OfferEntryExt": {
      "description": "OfferEntryExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; } ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "Operation": {
      "description": "Operation is an XDR Struct defines as:\n\n```text struct Operation { // sourceAccount is the account used to run the operation // if not set, the runtime defaults to \"sourceAccount\" specified at // the transaction level MuxedAccount* sourceAccount;\n\nunion switch (OperationType type) { case CREATE_ACCOUNT: CreateAccountOp createAccountOp; case PAYMENT: PaymentOp paymentOp; case PATH_PAYMENT_STRICT_RECEIVE: PathPaymentStrictReceiveOp pathPaymentStrictReceiveOp; case MANAGE_SELL_OFFER: ManageSellOfferOp manageSellOfferOp; case CREATE_PASSIVE_SELL_OFFER: CreatePassiveSellOfferOp createPassiveSellOfferOp; case SET_OPTIONS: SetOptionsOp setOptionsOp; case CHANGE_TRUST: ChangeTrustOp changeTrustOp; case ALLOW_TRUST: AllowTrustOp allowTrustOp; case ACCOUNT_MERGE: MuxedAccount destination; case INFLATION: void; case MANAGE_DATA: ManageDataOp manageDataOp; case BUMP_SEQUENCE: BumpSequenceOp bumpSequenceOp; case MANAGE_BUY_OFFER: ManageBuyOfferOp manageBuyOfferOp; case PATH_PAYMENT_STRICT_SEND: PathPaymentStrictSendOp pathPaymentStrictSendOp; case CREATE_CLAIMABLE_BALANCE: CreateClaimableBalanceOp createClaimableBalanceOp; case CLAIM_CLAIMABLE_BALANCE: ClaimClaimableBalanceOp claimClaimableBalanceOp; case BEGIN_SPONSORING_FUTURE_RESERVES: BeginSponsoringFutureReservesOp beginSponsoringFutureReservesOp; case END_SPONSORING_FUTURE_RESERVES: void; case REVOKE_SPONSORSHIP: RevokeSponsorshipOp revokeSponsorshipOp; case CLAWBACK: ClawbackOp clawbackOp; case CLAWBACK_CLAIMABLE_BALANCE: ClawbackClaimableBalanceOp clawbackClaimableBalanceOp; case SET_TRUST_LINE_FLAGS: SetTrustLineFlagsOp setTrustLineFlagsOp; case LIQUIDITY_POOL_DEPOSIT: LiquidityPoolDepositOp liquidityPoolDepositOp; case LIQUIDITY_POOL_WITHDRAW: LiquidityPoolWithdrawOp liquidityPoolWithdrawOp; case INVOKE_HOST_FUNCTION: InvokeHostFunctionOp invokeHostFunctionOp; case EXTEND_FOOTPRINT_TTL: ExtendFootprintTTLOp extendFootprintTTLOp; case RESTORE_FOOTPRINT: RestoreFootprintOp restoreFootprintOp; } body; }; ```",
      "type": "object",
      "required": [
        "body"
      ],
      "properties": {
        "body": {
          "$ref": "#/definitions/OperationBody"
        },
        "source_account": {
          "anyOf": [
            {
              "$ref": "#/definitions/MuxedAccount"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "OperationBody": {
      "description": "OperationBody is an XDR NestedUnion defines as:\n\n```text union switch (OperationType type) { case CREATE_ACCOUNT: CreateAccountOp createAccountOp; case PAYMENT: PaymentOp paymentOp; case PATH_PAYMENT_STRICT_RECEIVE: PathPaymentStrictReceiveOp pathPaymentStrictReceiveOp; case MANAGE_SELL_OFFER: ManageSellOfferOp manageSellOfferOp; case CREATE_PASSIVE_SELL_OFFER: CreatePassiveSellOfferOp createPassiveSellOfferOp; case SET_OPTIONS: SetOptionsOp setOptionsOp; case CHANGE_TRUST: ChangeTrustOp changeTrustOp; case ALLOW_TRUST: AllowTrustOp allowTrustOp; case ACCOUNT_MERGE: MuxedAccount destination; case INFLATION: void; case MANAGE_DATA: ManageDataOp manageDataOp; case BUMP_SEQUENCE: BumpSequenceOp bumpSequenceOp; case MANAGE_BUY_OFFER: ManageBuyOfferOp manageBuyOfferOp; case PATH_PAYMENT_STRICT_SEND: PathPaymentStrictSendOp pathPaymentStrictSendOp; case CREATE_CLAIMABLE_BALANCE: CreateClaimableBalanceOp createClaimableBalanceOp; case CLAIM_CLAIMABLE_BALANCE: ClaimClaimableBalanceOp claimClaimableBalanceOp; case BEGIN_SPONSORING_FUTURE_RESERVES: BeginSponsoringFutureReservesOp beginSponsoringFutureReservesOp; case END_SPONSORING_FUTURE_RESERVES: void; case REVOKE_SPONSORSHIP: RevokeSponsorshipOp revokeSponsorshipOp; case CLAWBACK: ClawbackOp clawbackOp; case CLAWBACK_CLAIMABLE_BALANCE: ClawbackClaimableBalanceOp clawbackClaimableBalanceOp; case SET_TRUST_LINE_FLAGS: SetTrustLineFlagsOp setTrustLineFlagsOp; case LIQUIDITY_POOL_DEPOSIT: LiquidityPoolDepositOp liquidityPoolDepositOp; case LIQUIDITY_POOL_WITHDRAW: LiquidityPoolWithdrawOp liquidityPoolWithdrawOp; case INVOKE_HOST_FUNCTION: InvokeHostFunctionOp invokeHostFunctionOp; case EXTEND_FOOTPRINT_TTL: ExtendFootprintTTLOp extendFootprintTTLOp; case RESTORE_FOOTPRINT: RestoreFootprintOp restoreFootprintOp; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "inflation",
            "end_sponsoring_future_reserves"
          ]
        },
        {
          "type": "object",
          "required": [
            "create_account"
          ],
          "properties": {
            "create_account": {
              "$ref": "#/definitions/CreateAccountOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "payment"
          ],
          "properties": {
            "payment": {
              "$ref": "#/definitions/PaymentOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "path_payment_strict_receive"
          ],
          "properties": {
            "path_payment_strict_receive": {
              "$ref": "#/definitions/PathPaymentStrictReceiveOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "manage_sell_offer"
          ],
          "properties": {
            "manage_sell_offer": {
              "$ref": "#/definitions/ManageSellOfferOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "create_passive_sell_offer"
          ],
          "properties": {
            "create_passive_sell_offer": {
              "$ref": "#/definitions/CreatePassiveSellOfferOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "set_options"
          ],
          "properties": {
            "set_options": {
              "$ref": "#/definitions/SetOptionsOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "change_trust"
          ],
          "properties": {
            "change_trust": {
              "$ref": "#/definitions/ChangeTrustOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "allow_trust"
          ],
          "properties": {
            "allow_trust": {
              "$ref": "#/definitions/AllowTrustOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "account_merge"
          ],
          "properties": {
            "account_merge": {
              "$ref": "#/definitions/MuxedAccount"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "manage_data"
          ],
          "properties": {
            "manage_data": {
              "$ref": "#/definitions/ManageDataOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "bump_sequence"
          ],
          "properties": {
            "bump_sequence": {
              "$ref": "#/definitions/BumpSequenceOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "manage_buy_offer"
          ],
          "properties": {
            "manage_buy_offer": {
              "$ref": "#/definitions/ManageBuyOfferOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "path_payment_strict_send"
          ],
          "properties": {
            "path_payment_strict_send": {
              "$ref": "#/definitions/PathPaymentStrictSendOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "create_claimable_balance"
          ],
          "properties": {
            "create_claimable_balance": {
              "$ref": "#/definitions/CreateClaimableBalanceOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "claim_claimable_balance"
          ],
          "properties": {
            "claim_claimable_balance": {
              "$ref": "#/definitions/ClaimClaimableBalanceOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "begin_sponsoring_future_reserves"
          ],
          "properties": {
            "begin_sponsoring_future_reserves": {
              "$ref": "#/definitions/BeginSponsoringFutureReservesOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "revoke_sponsorship"
          ],
          "properties": {
            "revoke_sponsorship": {
              "$ref": "#/definitions/RevokeSponsorshipOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "clawback"
          ],
          "properties": {
            "clawback": {
              "$ref": "#/definitions/ClawbackOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "clawback_claimable_balance"
          ],
          "properties": {
            "clawback_claimable_balance": {
              "$ref": "#/definitions/ClawbackClaimableBalanceOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "set_trust_line_flags"
          ],
          "properties": {
            "set_trust_line_flags": {
              "$ref": "#/definitions/SetTrustLineFlagsOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "liquidity_pool_deposit"
          ],
          "properties": {
            "liquidity_pool_deposit": {
              "$ref": "#/definitions/LiquidityPoolDepositOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "liquidity_pool_withdraw"
          ],
          "properties": {
            "liquidity_pool_withdraw": {
              "$ref": "#/definitions/LiquidityPoolWithdrawOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "invoke_host_function"
          ],
          "properties": {
            "invoke_host_function": {
              "$ref": "#/definitions/InvokeHostFunctionOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "extend_footprint_ttl"
          ],
          "properties": {
            "extend_footprint_ttl": {
              "$ref": "#/definitions/ExtendFootprintTtlOp"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "restore_footprint"
          ],
          "properties": {
            "restore_footprint": {
              "$ref": "#/definitions/RestoreFootprintOp"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "OperationMeta": {
      "description": "OperationMeta is an XDR Struct defines as:\n\n```text struct OperationMeta { LedgerEntryChanges changes; }; ```",
      "type": "object",
      "required": [
        "changes"
      ],
      "properties": {
        "changes": {
          "$ref": "#/definitions/LedgerEntryChanges"
        }
      }
    },
    "OperationMetaV2": {
      "description": "OperationMetaV2 is an XDR Struct defines as:\n\n```text struct OperationMetaV2 { ExtensionPoint ext;\n\nLedgerEntryChanges changes;\n\nContractEvent events<>; }; ```",
      "type": "object",
      "required": [
        "changes",
        "events",
        "ext"
      ],
      "properties": {
        "changes": {
          "$ref": "#/definitions/LedgerEntryChanges"
        },
        "events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContractEvent"
          },
          "maxItems": 4294967295
        },
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        }
      }
    },
    "OperationResult": {
      "description": "OperationResult is an XDR Union defines as:\n\n```text union OperationResult switch (OperationResultCode code) { case opINNER: union switch (OperationType type) { case CREATE_ACCOUNT: CreateAccountResult createAccountResult; case PAYMENT: PaymentResult paymentResult; case PATH_PAYMENT_STRICT_RECEIVE: PathPaymentStrictReceiveResult pathPaymentStrictReceiveResult; case MANAGE_SELL_OFFER: ManageSellOfferResult manageSellOfferResult; case CREATE_PASSIVE_SELL_OFFER: ManageSellOfferResult createPassiveSellOfferResult; case SET_OPTIONS: SetOptionsResult setOptionsResult; case CHANGE_TRUST: ChangeTrustResult changeTrustResult; case ALLOW_TRUST: AllowTrustResult allowTrustResult; case ACCOUNT_MERGE: AccountMergeResult accountMergeResult; case INFLATION: InflationResult inflationResult; case MANAGE_DATA: ManageDataResult manageDataResult; case BUMP_SEQUENCE: BumpSequenceResult bumpSeqResult; case MANAGE_BUY_OFFER: ManageBuyOfferResult manageBuyOfferResult; case PATH_PAYMENT_STRICT_SEND: PathPaymentStrictSendResult pathPaymentStrictSendResult; case CREATE_CLAIMABLE_BALANCE: CreateClaimableBalanceResult createClaimableBalanceResult; case CLAIM_CLAIMABLE_BALANCE: ClaimClaimableBalanceResult claimClaimableBalanceResult; case BEGIN_SPONSORING_FUTURE_RESERVES: BeginSponsoringFutureReservesResult beginSponsoringFutureReservesResult; case END_SPONSORING_FUTURE_RESERVES: EndSponsoringFutureReservesResult endSponsoringFutureReservesResult; case REVOKE_SPONSORSHIP: RevokeSponsorshipResult revokeSponsorshipResult; case CLAWBACK: ClawbackResult clawbackResult; case CLAWBACK_CLAIMABLE_BALANCE: ClawbackClaimableBalanceResult clawbackClaimableBalanceResult; case SET_TRUST_LINE_FLAGS: SetTrustLineFlagsResult setTrustLineFlagsResult; case LIQUIDITY_POOL_DEPOSIT: LiquidityPoolDepositResult liquidityPoolDepositResult; case LIQUIDITY_POOL_WITHDRAW: LiquidityPoolWithdrawResult liquidityPoolWithdrawResult; case INVOKE_HOST_FUNCTION: InvokeHostFunctionResult invokeHostFunctionResult; case EXTEND_FOOTPRINT_TTL: ExtendFootprintTTLResult extendFootprintTTLResult; case RESTORE_FOOTPRINT: RestoreFootprintResult restoreFootprintResult; } tr; case opBAD_AUTH: case opNO_ACCOUNT: case opNOT_SUPPORTED: case opTOO_MANY_SUBENTRIES: case opEXCEEDED_WORK_LIMIT: case opTOO_MANY_SPONSORING: void; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "op_bad_auth",
            "op_no_account",
            "op_not_supported",
            "op_too_many_subentries",
            "op_exceeded_work_limit",
            "op_too_many_sponsoring"
          ]
        },
        {
          "type": "object",
          "required": [
            "op_inner"
          ],
          "properties": {
            "op_inner": {
              "$ref": "#/definitions/OperationResultTr"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "OperationResultTr": {
      "description": "OperationResultTr is an XDR NestedUnion defines as:\n\n```text union switch (OperationType type) { case CREATE_ACCOUNT: CreateAccountResult createAccountResult; case PAYMENT: PaymentResult paymentResult; case PATH_PAYMENT_STRICT_RECEIVE: PathPaymentStrictReceiveResult pathPaymentStrictReceiveResult; case MANAGE_SELL_OFFER: ManageSellOfferResult manageSellOfferResult; case CREATE_PASSIVE_SELL_OFFER: ManageSellOfferResult createPassiveSellOfferResult; case SET_OPTIONS: SetOptionsResult setOptionsResult; case CHANGE_TRUST: ChangeTrustResult changeTrustResult; case ALLOW_TRUST: AllowTrustResult allowTrustResult; case ACCOUNT_MERGE: AccountMergeResult accountMergeResult; case INFLATION: InflationResult inflationResult; case MANAGE_DATA: ManageDataResult manageDataResult; case BUMP_SEQUENCE: BumpSequenceResult bumpSeqResult; case MANAGE_BUY_OFFER: ManageBuyOfferResult manageBuyOfferResult; case PATH_PAYMENT_STRICT_SEND: PathPaymentStrictSendResult pathPaymentStrictSendResult; case CREATE_CLAIMABLE_BALANCE: CreateClaimableBalanceResult createClaimableBalanceResult; case CLAIM_CLAIMABLE_BALANCE: ClaimClaimableBalanceResult claimClaimableBalanceResult; case BEGIN_SPONSORING_FUTURE_RESERVES: BeginSponsoringFutureReservesResult beginSponsoringFutureReservesResult; case END_SPONSORING_FUTURE_RESERVES: EndSponsoringFutureReservesResult endSponsoringFutureReservesResult; case REVOKE_SPONSORSHIP: RevokeSponsorshipResult revokeSponsorshipResult; case CLAWBACK: ClawbackResult clawbackResult; case CLAWBACK_CLAIMABLE_BALANCE: ClawbackClaimableBalanceResult clawbackClaimableBalanceResult; case SET_TRUST_LINE_FLAGS: SetTrustLineFlagsResult setTrustLineFlagsResult; case LIQUIDITY_POOL_DEPOSIT: LiquidityPoolDepositResult liquidityPoolDepositResult; case LIQUIDITY_POOL_WITHDRAW: LiquidityPoolWithdrawResult liquidityPoolWithdrawResult; case INVOKE_HOST_FUNCTION: InvokeHostFunctionResult invokeHostFunctionResult; case EXTEND_FOOTPRINT_TTL: ExtendFootprintTTLResult extendFootprintTTLResult; case RESTORE_FOOTPRINT: RestoreFootprintResult restoreFootprintResult; } ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "create_account"
          ],
          "properties": {
            "create_account": {
              "$ref": "#/definitions/CreateAccountResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "payment"
          ],
          "properties": {
            "payment": {
              "$ref": "#/definitions/PaymentResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "path_payment_strict_receive"
          ],
          "properties": {
            "path_payment_strict_receive": {
              "$ref": "#/definitions/PathPaymentStrictReceiveResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "manage_sell_offer"
          ],
          "properties": {
            "manage_sell_offer": {
              "$ref": "#/definitions/ManageSellOfferResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "create_passive_sell_offer"
          ],
          "properties": {
            "create_passive_sell_offer": {
              "$ref": "#/definitions/ManageSellOfferResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "set_options"
          ],
          "properties": {
            "set_options": {
              "$ref": "#/definitions/SetOptionsResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "change_trust"
          ],
          "properties": {
            "change_trust": {
              "$ref": "#/definitions/ChangeTrustResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "allow_trust"
          ],
          "properties": {
            "allow_trust": {
              "$ref": "#/definitions/AllowTrustResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "account_merge"
          ],
          "properties": {
            "account_merge": {
              "$ref": "#/definitions/AccountMergeResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "inflation"
          ],
          "properties": {
            "inflation": {
              "$ref": "#/definitions/InflationResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "manage_data"
          ],
          "properties": {
            "manage_data": {
              "$ref": "#/definitions/ManageDataResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "bump_sequence"
          ],
          "properties": {
            "bump_sequence": {
              "$ref": "#/definitions/BumpSequenceResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "manage_buy_offer"
          ],
          "properties": {
            "manage_buy_offer": {
              "$ref": "#/definitions/ManageBuyOfferResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "path_payment_strict_send"
          ],
          "properties": {
            "path_payment_strict_send": {
              "$ref": "#/definitions/PathPaymentStrictSendResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "create_claimable_balance"
          ],
          "properties": {
            "create_claimable_balance": {
              "$ref": "#/definitions/CreateClaimableBalanceResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "claim_claimable_balance"
          ],
          "properties": {
            "claim_claimable_balance": {
              "$ref": "#/definitions/ClaimClaimableBalanceResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "begin_sponsoring_future_reserves"
          ],
          "properties": {
            "begin_sponsoring_future_reserves": {
              "$ref": "#/definitions/BeginSponsoringFutureReservesResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "end_sponsoring_future_reserves"
          ],
          "properties": {
            "end_sponsoring_future_reserves": {
              "$ref": "#/definitions/EndSponsoringFutureReservesResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "revoke_sponsorship"
          ],
          "properties": {
            "revoke_sponsorship": {
              "$ref": "#/definitions/RevokeSponsorshipResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "clawback"
          ],
          "properties": {
            "clawback": {
              "$ref": "#/definitions/ClawbackResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "clawback_claimable_balance"
          ],
          "properties": {
            "clawback_claimable_balance": {
              "$ref": "#/definitions/ClawbackClaimableBalanceResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "set_trust_line_flags"
          ],
          "properties": {
            "set_trust_line_flags": {
              "$ref": "#/definitions/SetTrustLineFlagsResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "liquidity_pool_deposit"
          ],
          "properties": {
            "liquidity_pool_deposit": {
              "$ref": "#/definitions/LiquidityPoolDepositResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "liquidity_pool_withdraw"
          ],
          "properties": {
            "liquidity_pool_withdraw": {
              "$ref": "#/definitions/LiquidityPoolWithdrawResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "invoke_host_function"
          ],
          "properties": {
            "invoke_host_function": {
              "$ref": "#/definitions/InvokeHostFunctionResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "extend_footprint_ttl"
          ],
          "properties": {
            "extend_footprint_ttl": {
              "$ref": "#/definitions/ExtendFootprintTtlResult"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "restore_footprint"
          ],
          "properties": {
            "restore_footprint": {
              "$ref": "#/definitions/RestoreFootprintResult"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "PathPaymentStrictReceiveOp": {
      "description": "PathPaymentStrictReceiveOp is an XDR Struct defines as:\n\n```text struct PathPaymentStrictReceiveOp { Asset sendAsset; // asset we pay with int64 sendMax;   // the maximum amount of sendAsset to // send (excluding fees). // The operation will fail if can't be met\n\nMuxedAccount destination; // recipient of the payment Asset destAsset;          // what they end up with int64 destAmount;         // amount they end up with\n\nAsset path<5>; // additional hops it must go through to get there }; ```",
      "type": "object",
      "required": [
        "dest_amount",
        "dest_asset",
        "destination",
        "path",
        "send_asset",
        "send_max"
      ],
      "properties": {
        "dest_amount": {
          "type": "integer",
          "format": "int64"
        },
        "dest_asset": {
          "$ref": "#/definitions/Asset"
        },
        "destination": {
          "$ref": "#/definitions/MuxedAccount"
        },
        "path": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Asset"
          },
          "maxItems": 5
        },
        "send_asset": {
          "$ref": "#/definitions/Asset"
        },
        "send_max": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "PathPaymentStrictReceiveResult": {
      "description": "PathPaymentStrictReceiveResult is an XDR Union defines as:\n\n```text union PathPaymentStrictReceiveResult switch ( PathPaymentStrictReceiveResultCode code) { case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS: struct { ClaimAtom offers<>; SimplePaymentResult last; } success; case PATH_PAYMENT_STRICT_RECEIVE_MALFORMED: case PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED: case PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST: case PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED: case PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION: case PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST: case PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED: case PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL: void; case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER: Asset noIssuer; // the asset that caused the error case PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS: case PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF: case PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX: void; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "malformed",
            "underfunded",
            "src_no_trust",
            "src_not_authorized",
            "no_destination",
            "no_trust",
            "not_authorized",
            "line_full",
            "too_few_offers",
            "offer_cross_self",
            "over_sendmax"
          ]
        },
        {
          "type": "object",
          "required": [
            "success"
          ],
          "properties": {
            "success": {
              "$ref": "#/definitions/PathPaymentStrictReceiveResultSuccess"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "no_issuer"
          ],
          "properties": {
            "no_issuer": {
              "$ref": "#/definitions/Asset"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "PathPaymentStrictReceiveResultSuccess": {
      "description": "PathPaymentStrictReceiveResultSuccess is an XDR NestedStruct defines as:\n\n```text struct { ClaimAtom offers<>; SimplePaymentResult last; } ```",
      "type": "object",
      "required": [
        "last",
        "offers"
      ],
      "properties": {
        "last": {
          "$ref": "#/definitions/SimplePaymentResult"
        },
        "offers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ClaimAtom"
          },
          "maxItems": 4294967295
        }
      }
    },
    "PathPaymentStrictSendOp": {
      "description": "PathPaymentStrictSendOp is an XDR Struct defines as:\n\n```text struct PathPaymentStrictSendOp { Asset sendAsset;  // asset we pay with int64 sendAmount; // amount of sendAsset to send (excluding fees)\n\nMuxedAccount destination; // recipient of the payment Asset destAsset;          // what they end up with int64 destMin;            // the minimum amount of dest asset to // be received // The operation will fail if it can't be met\n\nAsset path<5>; // additional hops it must go through to get there }; ```",
      "type": "object",
      "required": [
        "dest_asset",
        "dest_min",
        "destination",
        "path",
        "send_amount",
        "send_asset"
      ],
      "properties": {
        "dest_asset": {
          "$ref": "#/definitions/Asset"
        },
        "dest_min": {
          "type": "integer",
          "format": "int64"
        },
        "destination": {
          "$ref": "#/definitions/MuxedAccount"
        },
        "path": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Asset"
          },
          "maxItems": 5
        },
        "send_amount": {
          "type": "integer",
          "format": "int64"
        },
        "send_asset": {
          "$ref": "#/definitions/Asset"
        }
      }
    },
    "PathPaymentStrictSendResult": {
      "description": "PathPaymentStrictSendResult is an XDR Union defines as:\n\n```text union PathPaymentStrictSendResult switch (PathPaymentStrictSendResultCode code) { case PATH_PAYMENT_STRICT_SEND_SUCCESS: struct { ClaimAtom offers<>; SimplePaymentResult last; } success; case PATH_PAYMENT_STRICT_SEND_MALFORMED: case PATH_PAYMENT_STRICT_SEND_UNDERFUNDED: case PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST: case PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED: case PATH_PAYMENT_STRICT_SEND_NO_DESTINATION: case PATH_PAYMENT_STRICT_SEND_NO_TRUST: case PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED: case PATH_PAYMENT_STRICT_SEND_LINE_FULL: void; case PATH_PAYMENT_STRICT_SEND_NO_ISSUER: Asset noIssuer; // the asset that caused the error case PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS: case PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF: case PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN: void; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "malformed",
            "underfunded",
            "src_no_trust",
            "src_not_authorized",
            "no_destination",
            "no_trust",
            "not_authorized",
            "line_full",
            "too_few_offers",
            "offer_cross_self",
            "under_destmin"
          ]
        },
        {
          "type": "object",
          "required": [
            "success"
          ],
          "properties": {
            "success": {
              "$ref": "#/definitions/PathPaymentStrictSendResultSuccess"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "no_issuer"
          ],
          "properties": {
            "no_issuer": {
              "$ref": "#/definitions/Asset"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "PathPaymentStrictSendResultSuccess": {
      "description": "PathPaymentStrictSendResultSuccess is an XDR NestedStruct defines as:\n\n```text struct { ClaimAtom offers<>; SimplePaymentResult last; } ```",
      "type": "object",
      "required": [
        "last",
        "offers"
      ],
      "properties": {
        "last": {
          "$ref": "#/definitions/SimplePaymentResult"
        },
        "offers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ClaimAtom"
          },
          "maxItems": 4294967295
        }
      }
    },
    "PaymentOp": {
      "description": "PaymentOp is an XDR Struct defines as:\n\n```text struct PaymentOp { MuxedAccount destination; // recipient of the payment Asset asset;              // what they end up with int64 amount;             // amount they end up with }; ```",
      "type": "object",
      "required": [
        "amount",
        "asset",
        "destination"
      ],
      "properties": {
        "amount": {
          "type": "integer",
          "format": "int64"
        },
        "asset": {
          "$ref": "#/definitions/Asset"
        },
        "destination": {
          "$ref": "#/definitions/MuxedAccount"
        }
      }
    },
    "PaymentResult": {
      "description": "PaymentResult is an XDR Union defines as:\n\n```text union PaymentResult switch (PaymentResultCode code) { case PAYMENT_SUCCESS: void; case PAYMENT_MALFORMED: case PAYMENT_UNDERFUNDED: case PAYMENT_SRC_NO_TRUST: case PAYMENT_SRC_NOT_AUTHORIZED: case PAYMENT_NO_DESTINATION: case PAYMENT_NO_TRUST: case PAYMENT_NOT_AUTHORIZED: case PAYMENT_LINE_FULL: case PAYMENT_NO_ISSUER: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "malformed",
        "underfunded",
        "src_no_trust",
        "src_not_authorized",
        "no_destination",
        "no_trust",
        "not_authorized",
        "line_full",
        "no_issuer"
      ]
    },
    "PoolId": {
      "type": "string"
    },
    "Preconditions": {
      "description": "Preconditions is an XDR Union defines as:\n\n```text union Preconditions switch (PreconditionType type) { case PRECOND_NONE: void; case PRECOND_TIME: TimeBounds timeBounds; case PRECOND_V2: PreconditionsV2 v2; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "none"
          ]
        },
        {
          "type": "object",
          "required": [
            "time"
          ],
          "properties": {
            "time": {
              "$ref": "#/definitions/TimeBounds"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "v2"
          ],
          "properties": {
            "v2": {
              "$ref": "#/definitions/PreconditionsV2"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "PreconditionsV2": {
      "description": "PreconditionsV2 is an XDR Struct defines as:\n\n```text struct PreconditionsV2 { TimeBounds* timeBounds;\n\n// Transaction only valid for ledger numbers n such that // minLedger <= n < maxLedger (if maxLedger == 0, then // only minLedger is checked) LedgerBounds* ledgerBounds;\n\n// If NULL, only valid when sourceAccount's sequence number // is seqNum - 1.  Otherwise, valid when sourceAccount's // sequence number n satisfies minSeqNum <= n < tx.seqNum. // Note that after execution the account's sequence number // is always raised to tx.seqNum, and a transaction is not // valid if tx.seqNum is too high to ensure replay protection. SequenceNumber* minSeqNum;\n\n// For the transaction to be valid, the current ledger time must // be at least minSeqAge greater than sourceAccount's seqTime. Duration minSeqAge;\n\n// For the transaction to be valid, the current ledger number // must be at least minSeqLedgerGap greater than sourceAccount's // seqLedger. uint32 minSeqLedgerGap;\n\n// For the transaction to be valid, there must be a signature // corresponding to every Signer in this array, even if the // signature is not otherwise required by the sourceAccount or // operations. SignerKey extraSigners<2>; }; ```",
      "type": "object",
      "required": [
        "extra_signers",
        "min_seq_age",
        "min_seq_ledger_gap"
      ],
      "properties": {
        "extra_signers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SignerKey"
          },
          "maxItems": 2
        },
        "ledger_bounds": {
          "anyOf": [
            {
              "$ref": "#/definitions/LedgerBounds"
            },
            {
              "type": "null"
            }
          ]
        },
        "min_seq_age": {
          "$ref": "#/definitions/Duration"
        },
        "min_seq_ledger_gap": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "min_seq_num": {
          "anyOf": [
            {
              "$ref": "#/definitions/SequenceNumber"
            },
            {
              "type": "null"
            }
          ]
        },
        "time_bounds": {
          "anyOf": [
            {
              "$ref": "#/definitions/TimeBounds"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Price": {
      "description": "Price is an XDR Struct defines as:\n\n```text struct Price { int32 n; // numerator int32 d; // denominator }; ```",
      "type": "object",
      "required": [
        "d",
        "n"
      ],
      "properties": {
        "d": {
          "type": "integer",
          "format": "int32"
        },
        "n": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "RestoreFootprintOp": {
      "description": "RestoreFootprintOp is an XDR Struct defines as:\n\n```text struct RestoreFootprintOp { ExtensionPoint ext; }; ```",
      "type": "object",
      "required": [
        "ext"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        }
      }
    },
    "RestoreFootprintResult": {
      "description": "RestoreFootprintResult is an XDR Union defines as:\n\n```text union RestoreFootprintResult switch (RestoreFootprintResultCode code) { case RESTORE_FOOTPRINT_SUCCESS: void; case RESTORE_FOOTPRINT_MALFORMED: case RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED: case RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "malformed",
        "resource_limit_exceeded",
        "insufficient_refundable_fee"
      ]
    },
    "RevokeSponsorshipOp": {
      "description": "RevokeSponsorshipOp is an XDR Union defines as:\n\n```text union RevokeSponsorshipOp switch (RevokeSponsorshipType type) { case REVOKE_SPONSORSHIP_LEDGER_ENTRY: LedgerKey ledgerKey; case REVOKE_SPONSORSHIP_SIGNER: struct { AccountID accountID; SignerKey signerKey; } signer; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "ledger_entry"
          ],
          "properties": {
            "ledger_entry": {
              "$ref": "#/definitions/LedgerKey"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "signer"
          ],
          "properties": {
            "signer": {
              "$ref": "#/definitions/RevokeSponsorshipOpSigner"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "RevokeSponsorshipOpSigner": {
      "description": "RevokeSponsorshipOpSigner is an XDR NestedStruct defines as:\n\n```text struct { AccountID accountID; SignerKey signerKey; } ```",
      "type": "object",
      "required": [
        "account_id",
        "signer_key"
      ],
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        },
        "signer_key": {
          "$ref": "#/definitions/SignerKey"
        }
      }
    },
    "RevokeSponsorshipResult": {
      "description": "RevokeSponsorshipResult is an XDR Union defines as:\n\n```text union RevokeSponsorshipResult switch (RevokeSponsorshipResultCode code) { case REVOKE_SPONSORSHIP_SUCCESS: void; case REVOKE_SPONSORSHIP_DOES_NOT_EXIST: case REVOKE_SPONSORSHIP_NOT_SPONSOR: case REVOKE_SPONSORSHIP_LOW_RESERVE: case REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE: case REVOKE_SPONSORSHIP_MALFORMED: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "does_not_exist",
        "not_sponsor",
        "low_reserve",
        "only_transferable",
        "malformed"
      ]
    },
    "ScAddress": {
      "type": "string"
    },
    "ScBytes": {
      "description": "ScBytes is an XDR Typedef defines as:\n\n```text typedef opaque SCBytes<>; ```",
      "type": "string",
      "contentEncoding": "hex",
      "contentMediaType": "application/binary"
    },
    "ScContractInstance": {
      "description": "ScContractInstance is an XDR Struct defines as:\n\n```text struct SCContractInstance { ContractExecutable executable; SCMap* storage; }; ```",
      "type": "object",
      "required": [
        "executable"
      ],
      "properties": {
        "executable": {
          "$ref": "#/definitions/ContractExecutable"
        },
        "storage": {
          "anyOf": [
            {
              "$ref": "#/definitions/ScMap"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "ScError": {
      "description": "ScError is an XDR Union defines as:\n\n```text union SCError switch (SCErrorType type) { case SCE_CONTRACT: uint32 contractCode; case SCE_WASM_VM: case SCE_CONTEXT: case SCE_STORAGE: case SCE_OBJECT: case SCE_CRYPTO: case SCE_EVENTS: case SCE_BUDGET: case SCE_VALUE: case SCE_AUTH: SCErrorCode code; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "contract"
          ],
          "properties": {
            "contract": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "wasm_vm"
          ],
          "properties": {
            "wasm_vm": {
              "$ref": "#/definitions/ScErrorCode"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "context"
          ],
          "properties": {
            "context": {
              "$ref": "#/definitions/ScErrorCode"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "storage"
          ],
          "properties": {
            "storage": {
              "$ref": "#/definitions/ScErrorCode"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "object"
          ],
          "properties": {
            "object": {
              "$ref": "#/definitions/ScErrorCode"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "crypto"
          ],
          "properties": {
            "crypto": {
              "$ref": "#/definitions/ScErrorCode"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "events"
          ],
          "properties": {
            "events": {
              "$ref": "#/definitions/ScErrorCode"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "budget"
          ],
          "properties": {
            "budget": {
              "$ref": "#/definitions/ScErrorCode"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "value"
          ],
          "properties": {
            "value": {
              "$ref": "#/definitions/ScErrorCode"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "auth"
          ],
          "properties": {
            "auth": {
              "$ref": "#/definitions/ScErrorCode"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ScErrorCode": {
      "description": "ScErrorCode is an XDR Enum defines as:\n\n```text enum SCErrorCode { SCEC_ARITH_DOMAIN = 0,      // Some arithmetic was undefined (overflow, divide-by-zero). SCEC_INDEX_BOUNDS = 1,      // Something was indexed beyond its bounds. SCEC_INVALID_INPUT = 2,     // User provided some otherwise-bad data. SCEC_MISSING_VALUE = 3,     // Some value was required but not provided. SCEC_EXISTING_VALUE = 4,    // Some value was provided where not allowed. SCEC_EXCEEDED_LIMIT = 5,    // Some arbitrary limit -- gas or otherwise -- was hit. SCEC_INVALID_ACTION = 6,    // Data was valid but action requested was not. SCEC_INTERNAL_ERROR = 7,    // The host detected an error in its own logic. SCEC_UNEXPECTED_TYPE = 8,   // Some type wasn't as expected. SCEC_UNEXPECTED_SIZE = 9    // Something's size wasn't as expected. }; ```",
      "type": "string",
      "enum": [
        "arith_domain",
        "index_bounds",
        "invalid_input",
        "missing_value",
        "existing_value",
        "exceeded_limit",
        "invalid_action",
        "internal_error",
        "unexpected_type",
        "unexpected_size"
      ]
    },
    "ScMap": {
      "description": "ScMap is an XDR Typedef defines as:\n\n```text typedef SCMapEntry SCMap<>; ```",
      "type": "array",
      "items": {
        "$ref": "#/definitions/ScMapEntry"
      },
      "maxItems": 4294967295
    },
    "ScMapEntry": {
      "description": "ScMapEntry is an XDR Struct defines as:\n\n```text struct SCMapEntry { SCVal key; SCVal val; }; ```",
      "type": "object",
      "required": [
        "key",
        "val"
      ],
      "properties": {
        "key": {
          "$ref": "#/definitions/ScVal"
        },
        "val": {
          "$ref": "#/definitions/ScVal"
        }
      }
    },
    "ScNonceKey": {
      "description": "ScNonceKey is an XDR Struct defines as:\n\n```text struct SCNonceKey { int64 nonce; }; ```",
      "type": "object",
      "required": [
        "nonce"
      ],
      "properties": {
        "nonce": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "ScString": {
      "description": "ScString is an XDR Typedef defines as:\n\n```text typedef string SCString<>; ```",
      "$ref": "#/definitions/StringM<4294967295>"
    },
    "ScSymbol": {
      "description": "ScSymbol is an XDR Typedef defines as:\n\n```text typedef string SCSymbol<SCSYMBOL_LIMIT>; ```",
      "$ref": "#/definitions/StringM<32>"
    },
    "ScVal": {
      "description": "ScVal is an XDR Union defines as:\n\n```text union SCVal switch (SCValType type) {\n\ncase SCV_BOOL: bool b; case SCV_VOID: void; case SCV_ERROR: SCError error;\n\ncase SCV_U32: uint32 u32; case SCV_I32: int32 i32;\n\ncase SCV_U64: uint64 u64; case SCV_I64: int64 i64; case SCV_TIMEPOINT: TimePoint timepoint; case SCV_DURATION: Duration duration;\n\ncase SCV_U128: UInt128Parts u128; case SCV_I128: Int128Parts i128;\n\ncase SCV_U256: UInt256Parts u256; case SCV_I256: Int256Parts i256;\n\ncase SCV_BYTES: SCBytes bytes; case SCV_STRING: SCString str; case SCV_SYMBOL: SCSymbol sym;\n\n// Vec and Map are recursive so need to live // behind an option, due to xdrpp limitations. case SCV_VEC: SCVec *vec; case SCV_MAP: SCMap *map;\n\ncase SCV_ADDRESS: SCAddress address;\n\n// Special SCVals reserved for system-constructed contract-data // ledger keys, not generally usable elsewhere. case SCV_CONTRACT_INSTANCE: SCContractInstance instance; case SCV_LEDGER_KEY_CONTRACT_INSTANCE: void; case SCV_LEDGER_KEY_NONCE: SCNonceKey nonce_key; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "void",
            "ledger_key_contract_instance"
          ]
        },
        {
          "type": "object",
          "required": [
            "bool"
          ],
          "properties": {
            "bool": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "error"
          ],
          "properties": {
            "error": {
              "$ref": "#/definitions/ScError"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "u32"
          ],
          "properties": {
            "u32": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "i32"
          ],
          "properties": {
            "i32": {
              "type": "integer",
              "format": "int32"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "u64"
          ],
          "properties": {
            "u64": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "i64"
          ],
          "properties": {
            "i64": {
              "type": "integer",
              "format": "int64"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "timepoint"
          ],
          "properties": {
            "timepoint": {
              "$ref": "#/definitions/TimePoint"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "duration"
          ],
          "properties": {
            "duration": {
              "$ref": "#/definitions/Duration"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "u128"
          ],
          "properties": {
            "u128": {
              "$ref": "#/definitions/UInt128Parts"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "i128"
          ],
          "properties": {
            "i128": {
              "$ref": "#/definitions/Int128Parts"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "u256"
          ],
          "properties": {
            "u256": {
              "$ref": "#/definitions/UInt256Parts"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "i256"
          ],
          "properties": {
            "i256": {
              "$ref": "#/definitions/Int256Parts"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "bytes"
          ],
          "properties": {
            "bytes": {
              "$ref": "#/definitions/ScBytes"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "string"
          ],
          "properties": {
            "string": {
              "$ref": "#/definitions/ScString"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "symbol"
          ],
          "properties": {
            "symbol": {
              "$ref": "#/definitions/ScSymbol"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "vec"
          ],
          "properties": {
            "vec": {
              "anyOf": [
                {
                  "$ref": "#/definitions/ScVec"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "map"
          ],
          "properties": {
            "map": {
              "anyOf": [
                {
                  "$ref": "#/definitions/ScMap"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "address"
          ],
          "properties": {
            "address": {
              "$ref": "#/definitions/ScAddress"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "contract_instance"
          ],
          "properties": {
            "contract_instance": {
              "$ref": "#/definitions/ScContractInstance"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "ledger_key_nonce"
          ],
          "properties": {
            "ledger_key_nonce": {
              "$ref": "#/definitions/ScNonceKey"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ScVec": {
      "description": "ScVec is an XDR Typedef defines as:\n\n```text typedef SCVal SCVec<>; ```",
      "type": "array",
      "items": {
        "$ref": "#/definitions/ScVal"
      },
      "maxItems": 4294967295
    },
    "ScpBallot": {
      "description": "ScpBallot is an XDR Struct defines as:\n\n```text struct SCPBallot { uint32 counter; // n Value value;    // x }; ```",
      "type": "object",
      "required": [
        "counter",
        "value"
      ],
      "properties": {
        "counter": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "value": {
          "$ref": "#/definitions/Value"
        }
      }
    },
    "ScpEnvelope": {
      "description": "ScpEnvelope is an XDR Struct defines as:\n\n```text struct SCPEnvelope { SCPStatement statement; Signature signature; }; ```",
      "type": "object",
      "required": [
        "signature",
        "statement"
      ],
      "properties": {
        "signature": {
          "$ref": "#/definitions/Signature"
        },
        "statement": {
          "$ref": "#/definitions/ScpStatement"
        }
      }
    },
    "ScpHistoryEntry": {
      "description": "ScpHistoryEntry is an XDR Union defines as:\n\n```text union SCPHistoryEntry switch (int v) { case 0: SCPHistoryEntryV0 v0; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "v0"
          ],
          "properties": {
            "v0": {
              "$ref": "#/definitions/ScpHistoryEntryV0"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ScpHistoryEntryV0": {
      "description": "ScpHistoryEntryV0 is an XDR Struct defines as:\n\n```text struct SCPHistoryEntryV0 { SCPQuorumSet quorumSets<>; // additional quorum sets used by ledgerMessages LedgerSCPMessages ledgerMessages; }; ```",
      "type": "object",
      "required": [
        "ledger_messages",
        "quorum_sets"
      ],
      "properties": {
        "ledger_messages": {
          "$ref": "#/definitions/LedgerScpMessages"
        },
        "quorum_sets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScpQuorumSet"
          },
          "maxItems": 4294967295
        }
      }
    },
    "ScpNomination": {
      "description": "ScpNomination is an XDR Struct defines as:\n\n```text struct SCPNomination { Hash quorumSetHash; // D Value votes<>;      // X Value accepted<>;   // Y }; ```",
      "type": "object",
      "required": [
        "accepted",
        "quorum_set_hash",
        "votes"
      ],
      "properties": {
        "accepted": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Value"
          },
          "maxItems": 4294967295
        },
        "quorum_set_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "votes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Value"
          },
          "maxItems": 4294967295
        }
      }
    },
    "ScpQuorumSet": {
      "description": "ScpQuorumSet is an XDR Struct defines as:\n\n```text struct SCPQuorumSet { uint32 threshold; NodeID validators<>; SCPQuorumSet innerSets<>; }; ```",
      "type": "object",
      "required": [
        "inner_sets",
        "threshold",
        "validators"
      ],
      "properties": {
        "inner_sets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScpQuorumSet"
          },
          "maxItems": 4294967295
        },
        "threshold": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "validators": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NodeId"
          },
          "maxItems": 4294967295
        }
      }
    },
    "ScpStatement": {
      "description": "ScpStatement is an XDR Struct defines as:\n\n```text struct SCPStatement { NodeID nodeID;    // v uint64 slotIndex; // i\n\nunion switch (SCPStatementType type) { case SCP_ST_PREPARE: struct { Hash quorumSetHash;       // D SCPBallot ballot;         // b SCPBallot* prepared;      // p SCPBallot* preparedPrime; // p' uint32 nC;                // c.n uint32 nH;                // h.n } prepare; case SCP_ST_CONFIRM: struct { SCPBallot ballot;   // b uint32 nPrepared;   // p.n uint32 nCommit;     // c.n uint32 nH;          // h.n Hash quorumSetHash; // D } confirm; case SCP_ST_EXTERNALIZE: struct { SCPBallot commit;         // c uint32 nH;                // h.n Hash commitQuorumSetHash; // D used before EXTERNALIZE } externalize; case SCP_ST_NOMINATE: SCPNomination nominate; } pledges; }; ```",
      "type": "object",
      "required": [
        "node_id",
        "pledges",
        "slot_index"
      ],
      "properties": {
        "node_id": {
          "$ref": "#/definitions/NodeId"
        },
        "pledges": {
          "$ref": "#/definitions/ScpStatementPledges"
        },
        "slot_index": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "ScpStatementConfirm": {
      "description": "ScpStatementConfirm is an XDR NestedStruct defines as:\n\n```text struct { SCPBallot ballot;   // b uint32 nPrepared;   // p.n uint32 nCommit;     // c.n uint32 nH;          // h.n Hash quorumSetHash; // D } ```",
      "type": "object",
      "required": [
        "ballot",
        "n_commit",
        "n_h",
        "n_prepared",
        "quorum_set_hash"
      ],
      "properties": {
        "ballot": {
          "$ref": "#/definitions/ScpBallot"
        },
        "n_commit": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_h": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_prepared": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "quorum_set_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        }
      }
    },
    "ScpStatementExternalize": {
      "description": "ScpStatementExternalize is an XDR NestedStruct defines as:\n\n```text struct { SCPBallot commit;         // c uint32 nH;                // h.n Hash commitQuorumSetHash; // D used before EXTERNALIZE } ```",
      "type": "object",
      "required": [
        "commit",
        "commit_quorum_set_hash",
        "n_h"
      ],
      "properties": {
        "commit": {
          "$ref": "#/definitions/ScpBallot"
        },
        "commit_quorum_set_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "n_h": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "ScpStatementPledges": {
      "description": "ScpStatementPledges is an XDR NestedUnion defines as:\n\n```text union switch (SCPStatementType type) { case SCP_ST_PREPARE: struct { Hash quorumSetHash;       // D SCPBallot ballot;         // b SCPBallot* prepared;      // p SCPBallot* preparedPrime; // p' uint32 nC;                // c.n uint32 nH;                // h.n } prepare; case SCP_ST_CONFIRM: struct { SCPBallot ballot;   // b uint32 nPrepared;   // p.n uint32 nCommit;     // c.n uint32 nH;          // h.n Hash quorumSetHash; // D } confirm; case SCP_ST_EXTERNALIZE: struct { SCPBallot commit;         // c uint32 nH;                // h.n Hash commitQuorumSetHash; // D used before EXTERNALIZE } externalize; case SCP_ST_NOMINATE: SCPNomination nominate; } ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "prepare"
          ],
          "properties": {
            "prepare": {
              "$ref": "#/definitions/ScpStatementPrepare"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "confirm"
          ],
          "properties": {
            "confirm": {
              "$ref": "#/definitions/ScpStatementConfirm"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "externalize"
          ],
          "properties": {
            "externalize": {
              "$ref": "#/definitions/ScpStatementExternalize"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "nominate"
          ],
          "properties": {
            "nominate": {
              "$ref": "#/definitions/ScpNomination"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ScpStatementPrepare": {
      "description": "ScpStatementPrepare is an XDR NestedStruct defines as:\n\n```text struct { Hash quorumSetHash;       // D SCPBallot ballot;         // b SCPBallot* prepared;      // p SCPBallot* preparedPrime; // p' uint32 nC;                // c.n uint32 nH;                // h.n } ```",
      "type": "object",
      "required": [
        "ballot",
        "n_c",
        "n_h",
        "quorum_set_hash"
      ],
      "properties": {
        "ballot": {
          "$ref": "#/definitions/ScpBallot"
        },
        "n_c": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "n_h": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "prepared": {
          "anyOf": [
            {
              "$ref": "#/definitions/ScpBallot"
            },
            {
              "type": "null"
            }
          ]
        },
        "prepared_prime": {
          "anyOf": [
            {
              "$ref": "#/definitions/ScpBallot"
            },
            {
              "type": "null"
            }
          ]
        },
        "quorum_set_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        }
      }
    },
    "SequenceNumber": {
      "description": "SequenceNumber is an XDR Typedef defines as:\n\n```text typedef int64 SequenceNumber; ```",
      "type": "integer",
      "format": "int64"
    },
    "SetOptionsOp": {
      "description": "SetOptionsOp is an XDR Struct defines as:\n\n```text struct SetOptionsOp { AccountID* inflationDest; // sets the inflation destination\n\nuint32* clearFlags; // which flags to clear uint32* setFlags;   // which flags to set\n\n// account threshold manipulation uint32* masterWeight; // weight of the master account uint32* lowThreshold; uint32* medThreshold; uint32* highThreshold;\n\nstring32* homeDomain; // sets the home domain\n\n// Add, update or remove a signer for the account // signer is deleted if the weight is 0 Signer* signer; }; ```",
      "type": "object",
      "properties": {
        "clear_flags": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "high_threshold": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "home_domain": {
          "anyOf": [
            {
              "$ref": "#/definitions/String32"
            },
            {
              "type": "null"
            }
          ]
        },
        "inflation_dest": {
          "anyOf": [
            {
              "$ref": "#/definitions/AccountId"
            },
            {
              "type": "null"
            }
          ]
        },
        "low_threshold": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "master_weight": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "med_threshold": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "set_flags": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "signer": {
          "anyOf": [
            {
              "$ref": "#/definitions/Signer"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "SetOptionsResult": {
      "description": "SetOptionsResult is an XDR Union defines as:\n\n```text union SetOptionsResult switch (SetOptionsResultCode code) { case SET_OPTIONS_SUCCESS: void; case SET_OPTIONS_LOW_RESERVE: case SET_OPTIONS_TOO_MANY_SIGNERS: case SET_OPTIONS_BAD_FLAGS: case SET_OPTIONS_INVALID_INFLATION: case SET_OPTIONS_CANT_CHANGE: case SET_OPTIONS_UNKNOWN_FLAG: case SET_OPTIONS_THRESHOLD_OUT_OF_RANGE: case SET_OPTIONS_BAD_SIGNER: case SET_OPTIONS_INVALID_HOME_DOMAIN: case SET_OPTIONS_AUTH_REVOCABLE_REQUIRED: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "low_reserve",
        "too_many_signers",
        "bad_flags",
        "invalid_inflation",
        "cant_change",
        "unknown_flag",
        "threshold_out_of_range",
        "bad_signer",
        "invalid_home_domain",
        "auth_revocable_required"
      ]
    },
    "SetTrustLineFlagsOp": {
      "description": "SetTrustLineFlagsOp is an XDR Struct defines as:\n\n```text struct SetTrustLineFlagsOp { AccountID trustor; Asset asset;\n\nuint32 clearFlags; // which flags to clear uint32 setFlags;   // which flags to set }; ```",
      "type": "object",
      "required": [
        "asset",
        "clear_flags",
        "set_flags",
        "trustor"
      ],
      "properties": {
        "asset": {
          "$ref": "#/definitions/Asset"
        },
        "clear_flags": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "set_flags": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "trustor": {
          "$ref": "#/definitions/AccountId"
        }
      }
    },
    "SetTrustLineFlagsResult": {
      "description": "SetTrustLineFlagsResult is an XDR Union defines as:\n\n```text union SetTrustLineFlagsResult switch (SetTrustLineFlagsResultCode code) { case SET_TRUST_LINE_FLAGS_SUCCESS: void; case SET_TRUST_LINE_FLAGS_MALFORMED: case SET_TRUST_LINE_FLAGS_NO_TRUST_LINE: case SET_TRUST_LINE_FLAGS_CANT_REVOKE: case SET_TRUST_LINE_FLAGS_INVALID_STATE: case SET_TRUST_LINE_FLAGS_LOW_RESERVE: void; }; ```",
      "type": "string",
      "enum": [
        "success",
        "malformed",
        "no_trust_line",
        "cant_revoke",
        "invalid_state",
        "low_reserve"
      ]
    },
    "Signature": {
      "description": "Signature is an XDR Typedef defines as:\n\n```text typedef opaque Signature<64>; ```",
      "type": "string",
      "maxLength": 128,
      "contentEncoding": "hex",
      "contentMediaType": "application/binary"
    },
    "Signer": {
      "description": "Signer is an XDR Struct defines as:\n\n```text struct Signer { SignerKey key; uint32 weight; // really only need 1 byte }; ```",
      "type": "object",
      "required": [
        "key",
        "weight"
      ],
      "properties": {
        "key": {
          "$ref": "#/definitions/SignerKey"
        },
        "weight": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "SignerKey": {
      "type": "string"
    },
    "SimplePaymentResult": {
      "description": "SimplePaymentResult is an XDR Struct defines as:\n\n```text struct SimplePaymentResult { AccountID destination; Asset asset; int64 amount; }; ```",
      "type": "object",
      "required": [
        "amount",
        "asset",
        "destination"
      ],
      "properties": {
        "amount": {
          "type": "integer",
          "format": "int64"
        },
        "asset": {
          "$ref": "#/definitions/Asset"
        },
        "destination": {
          "$ref": "#/definitions/AccountId"
        }
      }
    },
    "SorobanAddressCredentials": {
      "description": "SorobanAddressCredentials is an XDR Struct defines as:\n\n```text struct SorobanAddressCredentials { SCAddress address; int64 nonce; uint32 signatureExpirationLedger; SCVal signature; }; ```",
      "type": "object",
      "required": [
        "address",
        "nonce",
        "signature",
        "signature_expiration_ledger"
      ],
      "properties": {
        "address": {
          "$ref": "#/definitions/ScAddress"
        },
        "nonce": {
          "type": "integer",
          "format": "int64"
        },
        "signature": {
          "$ref": "#/definitions/ScVal"
        },
        "signature_expiration_ledger": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "SorobanAuthorizationEntry": {
      "description": "SorobanAuthorizationEntry is an XDR Struct defines as:\n\n```text struct SorobanAuthorizationEntry { SorobanCredentials credentials; SorobanAuthorizedInvocation rootInvocation; }; ```",
      "type": "object",
      "required": [
        "credentials",
        "root_invocation"
      ],
      "properties": {
        "credentials": {
          "$ref": "#/definitions/SorobanCredentials"
        },
        "root_invocation": {
          "$ref": "#/definitions/SorobanAuthorizedInvocation"
        }
      }
    },
    "SorobanAuthorizedFunction": {
      "description": "SorobanAuthorizedFunction is an XDR Union defines as:\n\n```text union SorobanAuthorizedFunction switch (SorobanAuthorizedFunctionType type) { case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN: InvokeContractArgs contractFn; // This variant of auth payload for creating new contract instances // doesn't allow specifying the constructor arguments, creating contracts // with constructors that take arguments is only possible by authorizing // `SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_V2_HOST_FN` // (protocol 22+). case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN: CreateContractArgs createContractHostFn; // This variant of auth payload for creating new contract instances // is only accepted in and after protocol 22. It allows authorizing the // contract constructor arguments. case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_V2_HOST_FN: CreateContractArgsV2 createContractV2HostFn; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "contract_fn"
          ],
          "properties": {
            "contract_fn": {
              "$ref": "#/definitions/InvokeContractArgs"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "create_contract_host_fn"
          ],
          "properties": {
            "create_contract_host_fn": {
              "$ref": "#/definitions/CreateContractArgs"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "create_contract_v2_host_fn"
          ],
          "properties": {
            "create_contract_v2_host_fn": {
              "$ref": "#/definitions/CreateContractArgsV2"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "SorobanAuthorizedInvocation": {
      "description": "SorobanAuthorizedInvocation is an XDR Struct defines as:\n\n```text struct SorobanAuthorizedInvocation { SorobanAuthorizedFunction function; SorobanAuthorizedInvocation subInvocations<>; }; ```",
      "type": "object",
      "required": [
        "function",
        "sub_invocations"
      ],
      "properties": {
        "function": {
          "$ref": "#/definitions/SorobanAuthorizedFunction"
        },
        "sub_invocations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SorobanAuthorizedInvocation"
          },
          "maxItems": 4294967295
        }
      }
    },
    "SorobanCredentials": {
      "description": "SorobanCredentials is an XDR Union defines as:\n\n```text union SorobanCredentials switch (SorobanCredentialsType type) { case SOROBAN_CREDENTIALS_SOURCE_ACCOUNT: void; case SOROBAN_CREDENTIALS_ADDRESS: SorobanAddressCredentials address; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "source_account"
          ]
        },
        {
          "type": "object",
          "required": [
            "address"
          ],
          "properties": {
            "address": {
              "$ref": "#/definitions/SorobanAddressCredentials"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "SorobanResources": {
      "description": "SorobanResources is an XDR Struct defines as:\n\n```text struct SorobanResources { // The ledger footprint of the transaction. LedgerFootprint footprint; // The maximum number of instructions this transaction can use uint32 instructions;\n\n// The maximum number of bytes this transaction can read from disk backed entries uint32 diskReadBytes; // The maximum number of bytes this transaction can write to ledger uint32 writeBytes; }; ```",
      "type": "object",
      "required": [
        "disk_read_bytes",
        "footprint",
        "instructions",
        "write_bytes"
      ],
      "properties": {
        "disk_read_bytes": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "footprint": {
          "$ref": "#/definitions/LedgerFootprint"
        },
        "instructions": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "write_bytes": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "SorobanResourcesExtV0": {
      "description": "SorobanResourcesExtV0 is an XDR Struct defines as:\n\n```text struct SorobanResourcesExtV0 { // Vector of indices representing what Soroban // entries in the footprint are archived, based on the // order of keys provided in the readWrite footprint. uint32 archivedSorobanEntries<>; }; ```",
      "type": "object",
      "required": [
        "archived_soroban_entries"
      ],
      "properties": {
        "archived_soroban_entries": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "maxItems": 4294967295
        }
      }
    },
    "SorobanTransactionData": {
      "description": "SorobanTransactionData is an XDR Struct defines as:\n\n```text struct SorobanTransactionData { union switch (int v) { case 0: void; case 1: SorobanResourcesExtV0 resourceExt; } ext; SorobanResources resources; // Amount of the transaction `fee` allocated to the Soroban resource fees. // The fraction of `resourceFee` corresponding to `resources` specified // above is *not* refundable (i.e. fees for instructions, ledger I/O), as // well as fees for the transaction size. // The remaining part of the fee is refundable and the charged value is // based on the actual consumption of refundable resources (events, ledger // rent bumps). // The `inclusionFee` used for prioritization of the transaction is defined // as `tx.fee - resourceFee`. int64 resourceFee; }; ```",
      "type": "object",
      "required": [
        "ext",
        "resource_fee",
        "resources"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/SorobanTransactionDataExt"
        },
        "resource_fee": {
          "type": "integer",
          "format": "int64"
        },
        "resources": {
          "$ref": "#/definitions/SorobanResources"
        }
      }
    },
    "SorobanTransactionDataExt": {
      "description": "SorobanTransactionDataExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; case 1: SorobanResourcesExtV0 resourceExt; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v1"
          ],
          "properties": {
            "v1": {
              "$ref": "#/definitions/SorobanResourcesExtV0"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "SorobanTransactionMeta": {
      "description": "SorobanTransactionMeta is an XDR Struct defines as:\n\n```text struct SorobanTransactionMeta { SorobanTransactionMetaExt ext;\n\nContractEvent events<>;             // custom events populated by the // contracts themselves. SCVal returnValue;                  // return value of the host fn invocation\n\n// Diagnostics events that are not hashed. // This will contain all contract and diagnostic events. Even ones // that were emitted in a failed contract call. DiagnosticEvent diagnosticEvents<>; }; ```",
      "type": "object",
      "required": [
        "diagnostic_events",
        "events",
        "ext",
        "return_value"
      ],
      "properties": {
        "diagnostic_events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DiagnosticEvent"
          },
          "maxItems": 4294967295
        },
        "events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ContractEvent"
          },
          "maxItems": 4294967295
        },
        "ext": {
          "$ref": "#/definitions/SorobanTransactionMetaExt"
        },
        "return_value": {
          "$ref": "#/definitions/ScVal"
        }
      }
    },
    "SorobanTransactionMetaExt": {
      "description": "SorobanTransactionMetaExt is an XDR Union defines as:\n\n```text union SorobanTransactionMetaExt switch (int v) { case 0: void; case 1: SorobanTransactionMetaExtV1 v1; }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v1"
          ],
          "properties": {
            "v1": {
              "$ref": "#/definitions/SorobanTransactionMetaExtV1"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "SorobanTransactionMetaExtV1": {
      "description": "SorobanTransactionMetaExtV1 is an XDR Struct defines as:\n\n```text struct SorobanTransactionMetaExtV1 { ExtensionPoint ext;\n\n// The following are the components of the overall Soroban resource fee // charged for the transaction. // The following relation holds: // `resourceFeeCharged = totalNonRefundableResourceFeeCharged + totalRefundableResourceFeeCharged` // where `resourceFeeCharged` is the overall fee charged for the // transaction. Also, `resourceFeeCharged` <= `sorobanData.resourceFee` // i.e.we never charge more than the declared resource fee. // The inclusion fee for charged the Soroban transaction can be found using // the following equation: // `result.feeCharged = resourceFeeCharged + inclusionFeeCharged`.\n\n// Total amount (in stroops) that has been charged for non-refundable // Soroban resources. // Non-refundable resources are charged based on the usage declared in // the transaction envelope (such as `instructions`, `readBytes` etc.) and // is charged regardless of the success of the transaction. int64 totalNonRefundableResourceFeeCharged; // Total amount (in stroops) that has been charged for refundable // Soroban resource fees. // Currently this comprises the rent fee (`rentFeeCharged`) and the // fee for the events and return value. // Refundable resources are charged based on the actual resources usage. // Since currently refundable resources are only used for the successful // transactions, this will be `0` for failed transactions. int64 totalRefundableResourceFeeCharged; // Amount (in stroops) that has been charged for rent. // This is a part of `totalNonRefundableResourceFeeCharged`. int64 rentFeeCharged; }; ```",
      "type": "object",
      "required": [
        "ext",
        "rent_fee_charged",
        "total_non_refundable_resource_fee_charged",
        "total_refundable_resource_fee_charged"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        },
        "rent_fee_charged": {
          "type": "integer",
          "format": "int64"
        },
        "total_non_refundable_resource_fee_charged": {
          "type": "integer",
          "format": "int64"
        },
        "total_refundable_resource_fee_charged": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "SorobanTransactionMetaV2": {
      "description": "SorobanTransactionMetaV2 is an XDR Struct defines as:\n\n```text struct SorobanTransactionMetaV2 { SorobanTransactionMetaExt ext;\n\nSCVal* returnValue; }; ```",
      "type": "object",
      "required": [
        "ext"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/SorobanTransactionMetaExt"
        },
        "return_value": {
          "anyOf": [
            {
              "$ref": "#/definitions/ScVal"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "SponsorshipDescriptor": {
      "description": "SponsorshipDescriptor is an XDR Typedef defines as:\n\n```text typedef AccountID* SponsorshipDescriptor; ```",
      "anyOf": [
        {
          "$ref": "#/definitions/AccountId"
        },
        {
          "type": "null"
        }
      ]
    },
    "StateArchivalSettings": {
      "description": "StateArchivalSettings is an XDR Struct defines as:\n\n```text struct StateArchivalSettings { uint32 maxEntryTTL; uint32 minTemporaryTTL; uint32 minPersistentTTL;\n\n// rent_fee = wfee_rate_average / rent_rate_denominator_for_type int64 persistentRentRateDenominator; int64 tempRentRateDenominator;\n\n// max number of entries that emit archival meta in a single ledger uint32 maxEntriesToArchive;\n\n// Number of snapshots to use when calculating average live Soroban State size uint32 liveSorobanStateSizeWindowSampleSize;\n\n// How often to sample the live Soroban State size for the average, in ledgers uint32 liveSorobanStateSizeWindowSamplePeriod;\n\n// Maximum number of bytes that we scan for eviction per ledger uint32 evictionScanSize;\n\n// Lowest BucketList level to be scanned to evict entries uint32 startingEvictionScanLevel; }; ```",
      "type": "object",
      "required": [
        "eviction_scan_size",
        "live_soroban_state_size_window_sample_period",
        "live_soroban_state_size_window_sample_size",
        "max_entries_to_archive",
        "max_entry_ttl",
        "min_persistent_ttl",
        "min_temporary_ttl",
        "persistent_rent_rate_denominator",
        "starting_eviction_scan_level",
        "temp_rent_rate_denominator"
      ],
      "properties": {
        "eviction_scan_size": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "live_soroban_state_size_window_sample_period": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "live_soroban_state_size_window_sample_size": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "max_entries_to_archive": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "max_entry_ttl": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "min_persistent_ttl": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "min_temporary_ttl": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "persistent_rent_rate_denominator": {
          "type": "integer",
          "format": "int64"
        },
        "starting_eviction_scan_level": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "temp_rent_rate_denominator": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "StellarValue": {
      "description": "StellarValue is an XDR Struct defines as:\n\n```text struct StellarValue { Hash txSetHash;      // transaction set to apply to previous ledger TimePoint closeTime; // network close time\n\n// upgrades to apply to the previous ledger (usually empty) // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop // unknown steps during consensus if needed. // see notes below on 'LedgerUpgrade' for more detail // max size is dictated by number of upgrade types (+ room for future) UpgradeType upgrades<6>;\n\n// reserved for future use union switch (StellarValueType v) { case STELLAR_VALUE_BASIC: void; case STELLAR_VALUE_SIGNED: LedgerCloseValueSignature lcValueSignature; } ext; }; ```",
      "type": "object",
      "required": [
        "close_time",
        "ext",
        "tx_set_hash",
        "upgrades"
      ],
      "properties": {
        "close_time": {
          "$ref": "#/definitions/TimePoint"
        },
        "ext": {
          "$ref": "#/definitions/StellarValueExt"
        },
        "tx_set_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "upgrades": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UpgradeType"
          },
          "maxItems": 6
        }
      }
    },
    "StellarValueExt": {
      "description": "StellarValueExt is an XDR NestedUnion defines as:\n\n```text union switch (StellarValueType v) { case STELLAR_VALUE_BASIC: void; case STELLAR_VALUE_SIGNED: LedgerCloseValueSignature lcValueSignature; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "basic"
          ]
        },
        {
          "type": "object",
          "required": [
            "signed"
          ],
          "properties": {
            "signed": {
              "$ref": "#/definitions/LedgerCloseValueSignature"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "String32": {
      "description": "String32 is an XDR Typedef defines as:\n\n```text typedef string string32<32>; ```",
      "$ref": "#/definitions/StringM<32>"
    },
    "String64": {
      "description": "String64 is an XDR Typedef defines as:\n\n```text typedef string string64<64>; ```",
      "$ref": "#/definitions/StringM<64>"
    },
    "StringM<28>": {
      "type": "string",
      "maxLength": 28
    },
    "StringM<32>": {
      "type": "string",
      "maxLength": 32
    },
    "StringM<4294967295>": {
      "type": "string",
      "maxLength": 4294967295
    },
    "StringM<64>": {
      "type": "string",
      "maxLength": 64
    },
    "TimeBounds": {
      "description": "TimeBounds is an XDR Struct defines as:\n\n```text struct TimeBounds { TimePoint minTime; TimePoint maxTime; // 0 here means no maxTime }; ```",
      "type": "object",
      "required": [
        "max_time",
        "min_time"
      ],
      "properties": {
        "max_time": {
          "$ref": "#/definitions/TimePoint"
        },
        "min_time": {
          "$ref": "#/definitions/TimePoint"
        }
      }
    },
    "TimePoint": {
      "description": "TimePoint is an XDR Typedef defines as:\n\n```text typedef uint64 TimePoint; ```",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "Transaction": {
      "description": "Transaction is an XDR Struct defines as:\n\n```text struct Transaction { // account used to run the transaction MuxedAccount sourceAccount;\n\n// the fee the sourceAccount will pay uint32 fee;\n\n// sequence number to consume in the account SequenceNumber seqNum;\n\n// validity conditions Preconditions cond;\n\nMemo memo;\n\nOperation operations<MAX_OPS_PER_TX>;\n\nunion switch (int v) { case 0: void; case 1: SorobanTransactionData sorobanData; } ext; }; ```",
      "type": "object",
      "required": [
        "cond",
        "ext",
        "fee",
        "memo",
        "operations",
        "seq_num",
        "source_account"
      ],
      "properties": {
        "cond": {
          "$ref": "#/definitions/Preconditions"
        },
        "ext": {
          "$ref": "#/definitions/TransactionExt"
        },
        "fee": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "memo": {
          "$ref": "#/definitions/Memo"
        },
        "operations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Operation"
          },
          "maxItems": 100
        },
        "seq_num": {
          "$ref": "#/definitions/SequenceNumber"
        },
        "source_account": {
          "$ref": "#/definitions/MuxedAccount"
        }
      }
    },
    "TransactionEnvelope": {
      "description": "TransactionEnvelope is an XDR Union defines as:\n\n```text union TransactionEnvelope switch (EnvelopeType type) { case ENVELOPE_TYPE_TX_V0: TransactionV0Envelope v0; case ENVELOPE_TYPE_TX: TransactionV1Envelope v1; case ENVELOPE_TYPE_TX_FEE_BUMP: FeeBumpTransactionEnvelope feeBump; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "tx_v0"
          ],
          "properties": {
            "tx_v0": {
              "$ref": "#/definitions/TransactionV0Envelope"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "tx"
          ],
          "properties": {
            "tx": {
              "$ref": "#/definitions/TransactionV1Envelope"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "tx_fee_bump"
          ],
          "properties": {
            "tx_fee_bump": {
              "$ref": "#/definitions/FeeBumpTransactionEnvelope"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "TransactionEvent": {
      "description": "TransactionEvent is an XDR Struct defines as:\n\n```text struct TransactionEvent { TransactionEventStage stage;  // Stage at which an event has occurred. ContractEvent event;  // The contract event that has occurred. }; ```",
      "type": "object",
      "required": [
        "event",
        "stage"
      ],
      "properties": {
        "event": {
          "$ref": "#/definitions/ContractEvent"
        },
        "stage": {
          "$ref": "#/definitions/TransactionEventStage"
        }
      }
    },
    "TransactionEventStage": {
      "description": "TransactionEventStage is an XDR Enum defines as:\n\n```text enum TransactionEventStage { // The event has happened before any one of the transactions has its // operations applied. TRANSACTION_EVENT_STAGE_BEFORE_ALL_TXS = 0, // The event has happened immediately after operations of the transaction // have been applied. TRANSACTION_EVENT_STAGE_AFTER_TX = 1, // The event has happened after every transaction had its operations // applied. TRANSACTION_EVENT_STAGE_AFTER_ALL_TXS = 2 }; ```",
      "type": "string",
      "enum": [
        "before_all_txs",
        "after_tx",
        "after_all_txs"
      ]
    },
    "TransactionExt": {
      "description": "TransactionExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; case 1: SorobanTransactionData sorobanData; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v1"
          ],
          "properties": {
            "v1": {
              "$ref": "#/definitions/SorobanTransactionData"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "TransactionMeta": {
      "description": "TransactionMeta is an XDR Union defines as:\n\n```text union TransactionMeta switch (int v) { case 0: OperationMeta operations<>; case 1: TransactionMetaV1 v1; case 2: TransactionMetaV2 v2; case 3: TransactionMetaV3 v3; case 4: TransactionMetaV4 v4; }; ```",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "v0"
          ],
          "properties": {
            "v0": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/OperationMeta"
              },
              "maxItems": 4294967295
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "v1"
          ],
          "properties": {
            "v1": {
              "$ref": "#/definitions/TransactionMetaV1"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "v2"
          ],
          "properties": {
            "v2": {
              "$ref": "#/definitions/TransactionMetaV2"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "v3"
          ],
          "properties": {
            "v3": {
              "$ref": "#/definitions/TransactionMetaV3"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "v4"
          ],
          "properties": {
            "v4": {
              "$ref": "#/definitions/TransactionMetaV4"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "TransactionMetaV1": {
      "description": "TransactionMetaV1 is an XDR Struct defines as:\n\n```text struct TransactionMetaV1 { LedgerEntryChanges txChanges; // tx level changes if any OperationMeta operations<>;   // meta for each operation }; ```",
      "type": "object",
      "required": [
        "operations",
        "tx_changes"
      ],
      "properties": {
        "operations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OperationMeta"
          },
          "maxItems": 4294967295
        },
        "tx_changes": {
          "$ref": "#/definitions/LedgerEntryChanges"
        }
      }
    },
    "TransactionMetaV2": {
      "description": "TransactionMetaV2 is an XDR Struct defines as:\n\n```text struct TransactionMetaV2 { LedgerEntryChanges txChangesBefore; // tx level changes before operations // are applied if any OperationMeta operations<>;         // meta for each operation LedgerEntryChanges txChangesAfter;  // tx level changes after operations are // applied if any }; ```",
      "type": "object",
      "required": [
        "operations",
        "tx_changes_after",
        "tx_changes_before"
      ],
      "properties": {
        "operations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OperationMeta"
          },
          "maxItems": 4294967295
        },
        "tx_changes_after": {
          "$ref": "#/definitions/LedgerEntryChanges"
        },
        "tx_changes_before": {
          "$ref": "#/definitions/LedgerEntryChanges"
        }
      }
    },
    "TransactionMetaV3": {
      "description": "TransactionMetaV3 is an XDR Struct defines as:\n\n```text struct TransactionMetaV3 { ExtensionPoint ext;\n\nLedgerEntryChanges txChangesBefore;  // tx level changes before operations // are applied if any OperationMeta operations<>;          // meta for each operation LedgerEntryChanges txChangesAfter;   // tx level changes after operations are // applied if any SorobanTransactionMeta* sorobanMeta; // Soroban-specific meta (only for // Soroban transactions). }; ```",
      "type": "object",
      "required": [
        "ext",
        "operations",
        "tx_changes_after",
        "tx_changes_before"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        },
        "operations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OperationMeta"
          },
          "maxItems": 4294967295
        },
        "soroban_meta": {
          "anyOf": [
            {
              "$ref": "#/definitions/SorobanTransactionMeta"
            },
            {
              "type": "null"
            }
          ]
        },
        "tx_changes_after": {
          "$ref": "#/definitions/LedgerEntryChanges"
        },
        "tx_changes_before": {
          "$ref": "#/definitions/LedgerEntryChanges"
        }
      }
    },
    "TransactionMetaV4": {
      "description": "TransactionMetaV4 is an XDR Struct defines as:\n\n```text struct TransactionMetaV4 { ExtensionPoint ext;\n\nLedgerEntryChanges txChangesBefore;  // tx level changes before operations // are applied if any OperationMetaV2 operations<>;        // meta for each operation LedgerEntryChanges txChangesAfter;   // tx level changes after operations are // applied if any SorobanTransactionMetaV2* sorobanMeta; // Soroban-specific meta (only for // Soroban transactions).\n\nTransactionEvent events<>; // Used for transaction-level events (like fee payment) DiagnosticEvent diagnosticEvents<>; // Used for all diagnostic information }; ```",
      "type": "object",
      "required": [
        "diagnostic_events",
        "events",
        "ext",
        "operations",
        "tx_changes_after",
        "tx_changes_before"
      ],
      "properties": {
        "diagnostic_events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DiagnosticEvent"
          },
          "maxItems": 4294967295
        },
        "events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TransactionEvent"
          },
          "maxItems": 4294967295
        },
        "ext": {
          "$ref": "#/definitions/ExtensionPoint"
        },
        "operations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OperationMetaV2"
          },
          "maxItems": 4294967295
        },
        "soroban_meta": {
          "anyOf": [
            {
              "$ref": "#/definitions/SorobanTransactionMetaV2"
            },
            {
              "type": "null"
            }
          ]
        },
        "tx_changes_after": {
          "$ref": "#/definitions/LedgerEntryChanges"
        },
        "tx_changes_before": {
          "$ref": "#/definitions/LedgerEntryChanges"
        }
      }
    },
    "TransactionResult": {
      "description": "TransactionResult is an XDR Struct defines as:\n\n```text struct TransactionResult { int64 feeCharged; // actual fee charged for the transaction\n\nunion switch (TransactionResultCode code) { case txFEE_BUMP_INNER_SUCCESS: case txFEE_BUMP_INNER_FAILED: InnerTransactionResultPair innerResultPair; case txSUCCESS: case txFAILED: OperationResult results<>; case txTOO_EARLY: case txTOO_LATE: case txMISSING_OPERATION: case txBAD_SEQ: case txBAD_AUTH: case txINSUFFICIENT_BALANCE: case txNO_ACCOUNT: case txINSUFFICIENT_FEE: case txBAD_AUTH_EXTRA: case txINTERNAL_ERROR: case txNOT_SUPPORTED: // case txFEE_BUMP_INNER_FAILED: handled above case txBAD_SPONSORSHIP: case txBAD_MIN_SEQ_AGE_OR_GAP: case txMALFORMED: case txSOROBAN_INVALID: void; } result;\n\n// reserved for future use union switch (int v) { case 0: void; } ext; }; ```",
      "type": "object",
      "required": [
        "ext",
        "fee_charged",
        "result"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/TransactionResultExt"
        },
        "fee_charged": {
          "type": "integer",
          "format": "int64"
        },
        "result": {
          "$ref": "#/definitions/TransactionResultResult"
        }
      }
    },
    "TransactionResultExt": {
      "description": "TransactionResultExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; } ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "TransactionResultMeta": {
      "description": "TransactionResultMeta is an XDR Struct defines as:\n\n```text struct TransactionResultMeta { TransactionResultPair result; LedgerEntryChanges feeProcessing; TransactionMeta txApplyProcessing; }; ```",
      "type": "object",
      "required": [
        "fee_processing",
        "result",
        "tx_apply_processing"
      ],
      "properties": {
        "fee_processing": {
          "$ref": "#/definitions/LedgerEntryChanges"
        },
        "result": {
          "$ref": "#/definitions/TransactionResultPair"
        },
        "tx_apply_processing": {
          "$ref": "#/definitions/TransactionMeta"
        }
      }
    },
    "TransactionResultPair": {
      "description": "TransactionResultPair is an XDR Struct defines as:\n\n```text struct TransactionResultPair { Hash transactionHash; TransactionResult result; // result for the transaction }; ```",
      "type": "object",
      "required": [
        "result",
        "transaction_hash"
      ],
      "properties": {
        "result": {
          "$ref": "#/definitions/TransactionResult"
        },
        "transaction_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        }
      }
    },
    "TransactionResultResult": {
      "description": "TransactionResultResult is an XDR NestedUnion defines as:\n\n```text union switch (TransactionResultCode code) { case txFEE_BUMP_INNER_SUCCESS: case txFEE_BUMP_INNER_FAILED: InnerTransactionResultPair innerResultPair; case txSUCCESS: case txFAILED: OperationResult results<>; case txTOO_EARLY: case txTOO_LATE: case txMISSING_OPERATION: case txBAD_SEQ: case txBAD_AUTH: case txINSUFFICIENT_BALANCE: case txNO_ACCOUNT: case txINSUFFICIENT_FEE: case txBAD_AUTH_EXTRA: case txINTERNAL_ERROR: case txNOT_SUPPORTED: // case txFEE_BUMP_INNER_FAILED: handled above case txBAD_SPONSORSHIP: case txBAD_MIN_SEQ_AGE_OR_GAP: case txMALFORMED: case txSOROBAN_INVALID: void; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "tx_too_early",
            "tx_too_late",
            "tx_missing_operation",
            "tx_bad_seq",
            "tx_bad_auth",
            "tx_insufficient_balance",
            "tx_no_account",
            "tx_insufficient_fee",
            "tx_bad_auth_extra",
            "tx_internal_error",
            "tx_not_supported",
            "tx_bad_sponsorship",
            "tx_bad_min_seq_age_or_gap",
            "tx_malformed",
            "tx_soroban_invalid"
          ]
        },
        {
          "type": "object",
          "required": [
            "tx_fee_bump_inner_success"
          ],
          "properties": {
            "tx_fee_bump_inner_success": {
              "$ref": "#/definitions/InnerTransactionResultPair"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "tx_fee_bump_inner_failed"
          ],
          "properties": {
            "tx_fee_bump_inner_failed": {
              "$ref": "#/definitions/InnerTransactionResultPair"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "tx_success"
          ],
          "properties": {
            "tx_success": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/OperationResult"
              },
              "maxItems": 4294967295
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "tx_failed"
          ],
          "properties": {
            "tx_failed": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/OperationResult"
              },
              "maxItems": 4294967295
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "TransactionSet": {
      "description": "TransactionSet is an XDR Struct defines as:\n\n```text struct TransactionSet { Hash previousLedgerHash; TransactionEnvelope txs<>; }; ```",
      "type": "object",
      "required": [
        "previous_ledger_hash",
        "txs"
      ],
      "properties": {
        "previous_ledger_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "txs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TransactionEnvelope"
          },
          "maxItems": 4294967295
        }
      }
    },
    "TransactionV0": {
      "description": "TransactionV0 is an XDR Struct defines as:\n\n```text struct TransactionV0 { uint256 sourceAccountEd25519; uint32 fee; SequenceNumber seqNum; TimeBounds* timeBounds; Memo memo; Operation operations<MAX_OPS_PER_TX>; union switch (int v) { case 0: void; } ext; }; ```",
      "type": "object",
      "required": [
        "ext",
        "fee",
        "memo",
        "operations",
        "seq_num",
        "source_account_ed25519"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/TransactionV0Ext"
        },
        "fee": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "memo": {
          "$ref": "#/definitions/Memo"
        },
        "operations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Operation"
          },
          "maxItems": 100
        },
        "seq_num": {
          "$ref": "#/definitions/SequenceNumber"
        },
        "source_account_ed25519": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "time_bounds": {
          "anyOf": [
            {
              "$ref": "#/definitions/TimeBounds"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "TransactionV0Envelope": {
      "description": "TransactionV0Envelope is an XDR Struct defines as:\n\n```text struct TransactionV0Envelope { TransactionV0 tx; /* Each decorated signature is a signature over the SHA256 hash of * a TransactionSignaturePayload */ DecoratedSignature signatures<20>; }; ```",
      "type": "object",
      "required": [
        "signatures",
        "tx"
      ],
      "properties": {
        "signatures": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DecoratedSignature"
          },
          "maxItems": 20
        },
        "tx": {
          "$ref": "#/definitions/TransactionV0"
        }
      }
    },
    "TransactionV0Ext": {
      "description": "TransactionV0Ext is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; } ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "TransactionV1Envelope": {
      "description": "TransactionV1Envelope is an XDR Struct defines as:\n\n```text struct TransactionV1Envelope { Transaction tx; /* Each decorated signature is a signature over the SHA256 hash of * a TransactionSignaturePayload */ DecoratedSignature signatures<20>; }; ```",
      "type": "object",
      "required": [
        "signatures",
        "tx"
      ],
      "properties": {
        "signatures": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DecoratedSignature"
          },
          "maxItems": 20
        },
        "tx": {
          "$ref": "#/definitions/Transaction"
        }
      }
    },
    "TrustLineAsset": {
      "description": "TrustLineAsset is an XDR Union defines as:\n\n```text union TrustLineAsset switch (AssetType type) { case ASSET_TYPE_NATIVE: // Not credit void;\n\ncase ASSET_TYPE_CREDIT_ALPHANUM4: AlphaNum4 alphaNum4;\n\ncase ASSET_TYPE_CREDIT_ALPHANUM12: AlphaNum12 alphaNum12;\n\ncase ASSET_TYPE_POOL_SHARE: PoolID liquidityPoolID;\n\n// add other asset types here in the future }; ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "native"
          ]
        },
        {
          "type": "object",
          "required": [
            "credit_alphanum4"
          ],
          "properties": {
            "credit_alphanum4": {
              "$ref": "#/definitions/AlphaNum4"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "credit_alphanum12"
          ],
          "properties": {
            "credit_alphanum12": {
              "$ref": "#/definitions/AlphaNum12"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "pool_share"
          ],
          "properties": {
            "pool_share": {
              "$ref": "#/definitions/PoolId"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "TrustLineEntry": {
      "description": "TrustLineEntry is an XDR Struct defines as:\n\n```text struct TrustLineEntry { AccountID accountID;  // account this trustline belongs to TrustLineAsset asset; // type of asset (with issuer) int64 balance;        // how much of this asset the user has. // Asset defines the unit for this;\n\nint64 limit;  // balance cannot be above this uint32 flags; // see TrustLineFlags\n\n// reserved for future use union switch (int v) { case 0: void; case 1: struct { Liabilities liabilities;\n\nunion switch (int v) { case 0: void; case 2: TrustLineEntryExtensionV2 v2; } ext; } v1; } ext; }; ```",
      "type": "object",
      "required": [
        "account_id",
        "asset",
        "balance",
        "ext",
        "flags",
        "limit"
      ],
      "properties": {
        "account_id": {
          "$ref": "#/definitions/AccountId"
        },
        "asset": {
          "$ref": "#/definitions/TrustLineAsset"
        },
        "balance": {
          "type": "integer",
          "format": "int64"
        },
        "ext": {
          "$ref": "#/definitions/TrustLineEntryExt"
        },
        "flags": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "limit": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "TrustLineEntryExt": {
      "description": "TrustLineEntryExt is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; case 1: struct { Liabilities liabilities;\n\nunion switch (int v) { case 0: void; case 2: TrustLineEntryExtensionV2 v2; } ext; } v1; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v1"
          ],
          "properties": {
            "v1": {
              "$ref": "#/definitions/TrustLineEntryV1"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "TrustLineEntryExtensionV2": {
      "description": "TrustLineEntryExtensionV2 is an XDR Struct defines as:\n\n```text struct TrustLineEntryExtensionV2 { int32 liquidityPoolUseCount;\n\nunion switch (int v) { case 0: void; } ext; }; ```",
      "type": "object",
      "required": [
        "ext",
        "liquidity_pool_use_count"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/TrustLineEntryExtensionV2Ext"
        },
        "liquidity_pool_use_count": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "TrustLineEntryExtensionV2Ext": {
      "description": "TrustLineEntryExtensionV2Ext is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; } ```",
      "type": "string",
      "enum": [
        "v0"
      ]
    },
    "TrustLineEntryV1": {
      "description": "TrustLineEntryV1 is an XDR NestedStruct defines as:\n\n```text struct { Liabilities liabilities;\n\nunion switch (int v) { case 0: void; case 2: TrustLineEntryExtensionV2 v2; } ext; } ```",
      "type": "object",
      "required": [
        "ext",
        "liabilities"
      ],
      "properties": {
        "ext": {
          "$ref": "#/definitions/TrustLineEntryV1Ext"
        },
        "liabilities": {
          "$ref": "#/definitions/Liabilities"
        }
      }
    },
    "TrustLineEntryV1Ext": {
      "description": "TrustLineEntryV1Ext is an XDR NestedUnion defines as:\n\n```text union switch (int v) { case 0: void; case 2: TrustLineEntryExtensionV2 v2; } ```",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "v0"
          ]
        },
        {
          "type": "object",
          "required": [
            "v2"
          ],
          "properties": {
            "v2": {
              "$ref": "#/definitions/TrustLineEntryExtensionV2"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "TtlEntry": {
      "description": "TtlEntry is an XDR Struct defines as:\n\n```text struct TTLEntry { // Hash of the LedgerKey that is associated with this TTLEntry Hash keyHash; uint32 liveUntilLedgerSeq; }; ```",
      "type": "object",
      "required": [
        "key_hash",
        "live_until_ledger_seq"
      ],
      "properties": {
        "key_hash": {
          "type": "string",
          "maxLength": 64,
          "minLength": 64,
          "contentEncoding": "hex",
          "contentMediaType": "application/binary"
        },
        "live_until_ledger_seq": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "UInt128Parts": {
      "description": "UInt128Parts is an XDR Struct defines as:\n\n```text struct UInt128Parts { uint64 hi; uint64 lo; }; ```",
      "type": "object",
      "required": [
        "hi",
        "lo"
      ],
      "properties": {
        "hi": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "lo": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "UInt256Parts": {
      "description": "UInt256Parts is an XDR Struct defines as:\n\n```text struct UInt256Parts { uint64 hi_hi; uint64 hi_lo; uint64 lo_hi; uint64 lo_lo; }; ```",
      "type": "object",
      "required": [
        "hi_hi",
        "hi_lo",
        "lo_hi",
        "lo_lo"
      ],
      "properties": {
        "hi_hi": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "hi_lo": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "lo_hi": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "lo_lo": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "UpgradeEntryMeta": {
      "description": "UpgradeEntryMeta is an XDR Struct defines as:\n\n```text struct UpgradeEntryMeta { LedgerUpgrade upgrade; LedgerEntryChanges changes; }; ```",
      "type": "object",
      "required": [
        "changes",
        "upgrade"
      ],
      "properties": {
        "changes": {
          "$ref": "#/definitions/LedgerEntryChanges"
        },
        "upgrade": {
          "$ref": "#/definitions/LedgerUpgrade"
        }
      }
    },
    "UpgradeType": {
      "description": "UpgradeType is an XDR Typedef defines as:\n\n```text typedef opaque UpgradeType<128>; ```",
      "type": "string",
      "maxLength": 256,
      "contentEncoding": "hex",
      "contentMediaType": "application/binary"
    },
    "Value": {
      "description": "Value is an XDR Typedef defines as:\n\n```text typedef opaque Value<>; ```",
      "type": "string",
      "contentEncoding": "hex",
      "contentMediaType": "application/binary"
    }
  }
}